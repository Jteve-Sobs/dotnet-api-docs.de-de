<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2ca10b7aefa232ce0aefa8a54a8677a253349c54" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36409156" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a character encoding.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Kodieren werden Unicode-Zeichen in eine Bytefolge transformiert. Im Gegensatz dazu ist die Decodierung transformiert eine codierte Bytefolge in einen Satz von Unicode-Zeichen. Informationen zu Unicode-Transformation Format (UTFs) und andere von unterstützten Codierungen <xref:System.Text.Encoding>, finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Beachten Sie, dass <xref:System.Text.Encoding> für Unicode-Zeichen anstelle von beliebigen Binärdaten, z. B. Bytearrays ausgeführt werden soll. Wenn beliebige Binärdaten in Text codiert werden müssen, verwenden Sie ein Protokoll wie Uuencode, die durch Methoden, wie z. B. implementiert wird <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 .NET Framework bietet die folgenden Implementierungen der <xref:System.Text.Encoding> Klasse, um die aktuellen Unicode-Codierungen und andere Codierungen unterstützen:  
  
-   <xref:System.Text.ASCIIEncoding> Unicode-Zeichen codiert als einzelne 7-Bit-ASCII-Zeichen. Diese Codierung unterstützt nur Zeichenwerte zwischen U + 0000 und U + 007F. Codepage 20127. Auch verfügbar durch die <xref:System.Text.Encoding.ASCII%2A> Eigenschaft.  
  
-   <xref:System.Text.UTF7Encoding> Unicode-Zeichen, die unter Verwendung der UTF-7-Codierung codiert. Diese Codierung unterstützt alle Unicode-Zeichenwerte. Codepage 65000. Auch verfügbar durch die <xref:System.Text.Encoding.UTF7%2A> Eigenschaft.  
  
-   <xref:System.Text.UTF8Encoding> Unicode-Zeichen, die unter Verwendung der UTF-8-Codierung codiert. Diese Codierung unterstützt alle Unicode-Zeichenwerte. Codepage 65001. Auch verfügbar durch die <xref:System.Text.Encoding.UTF8%2A> Eigenschaft.  
  
-   <xref:System.Text.UnicodeEncoding> Unicode-Zeichen, die unter Verwendung der UTF-16-Codierung codiert. Sowohl little endian und big-endian-Byte-Aufträge werden unterstützt. Auch verfügbar durch die <xref:System.Text.Encoding.Unicode%2A> Eigenschaft und die <xref:System.Text.Encoding.BigEndianUnicode%2A> Eigenschaft.  
  
-   <xref:System.Text.UTF32Encoding> Unicode-Zeichen, die unter Verwendung der UTF-32-Codierung codiert. Sowohl little Endian (Codepage 12000) und big-Endian (Codepage 12001) werden Aufträge unterstützt. Auch verfügbar durch die <xref:System.Text.Encoding.UTF32%2A> Eigenschaft.  
  
 Die <xref:System.Text.Encoding> Klasse dient in erster Linie zum Konvertieren zwischen verschiedenen Codierungen und Unicode. Einer der abgeleiteten Klassen von Unicode-ist häufig die richtige Wahl für Ihre app.  
  
 Verwenden der <xref:System.Text.Encoding.GetEncoding%2A> Methode, um andere Codierungen abzurufen, und rufen Sie die <xref:System.Text.Encoding.GetEncodings%2A> Methode, um eine Liste aller Codierungen abzurufen.  
  
 Die folgende Tabelle enthält die von .NET Framework unterstützten Codierungen. Jede Codierung Codepagenummer und die Werte von der Codierung aufgeführt <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> und <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> Eigenschaften. Ein Sternchen in der letzten Spalte gibt an, dass die Codepage von .NET Framework, unabhängig von der zugrunde liegenden Plattform systemintern unterstützt wird. Beachten Sie, dass Code, dessen Seiten <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> Eigenschaft einem internationalen Standard entspricht nicht unbedingt vollständig mit dieses Standards entsprechen.  
  
|Codepage|name|Angezeigter Name|.NET Framework-Unterstützung|  
|---------------|----------|------------------|----------------------------|  
|37|IBM037|IBM-EBCDIC (USA, Kanada)||  
|437|IBM437|OEM-USA||  
|500|IBM500|IBM-EBCDIC (International)||  
|708|ASMO-708|Arabisch (ASMO 708)||  
|720|DOS-720|Arabisch (DOS)||  
|737|ibm737|Griechisch (DOS)||  
|775|ibm775|Baltisch (DOS)||  
|850|ibm850|Westeuropäisch (DOS)||  
|852|ibm852|Mitteleuropäisch (DOS)||  
|855|IBM855|OEM-Kyrillisch||  
|857|ibm857|Türkisch (DOS)||  
|858|IBM00858|OEM Multilingual Lateinisch I||  
|860|IBM860|Portugiesisch (DOS)||  
|861|ibm861|Isländisch (DOS)||  
|862|DOS-862|Hebräisch (DOS)||  
|863|IBM863|Französisch (Kanada) (DOS)||  
|864|IBM864|Arabisch (864)||  
|865|IBM865|Nordisch (DOS)||  
|866|cp866|Kyrillisch (DOS)||  
|869|ibm869|Griechisch, Modern (DOS)||  
|870|IBM870|IBM-EBCDIC (Multilingual Lateinisch-2)||  
|874|windows-874|Thailändisch (Windows)||  
|875|cp875|IBM-EBCDIC (Griechisch, Modern)||  
|932|"Shift_jis"|Japanisch (Shift-JIS)||  
|936|gb2312|Chinesisch vereinfacht (GB2312)|✓|  
|949|ks_c_5601-1987|Koreanisch||  
|950|Big5|Chinesisch traditionell (Big5)||  
|1026|IBM1026|IBM-EBCDIC (Türkisch Latein-5)||  
|1047|IBM01047|IBM-Latin-1||  
|1140|IBM01140|IBM-EBCDIC (US-Kanada Euro)||  
|1141|IBM01141|IBM-EBCDIC (Deutschland-Euro)||  
|1142|IBM01142|IBM-EBCDIC (Dänemark-Norwegen-Euro)||  
|1143|IBM01143|IBM-EBCDIC (Finnland Schweden Euro)||  
|1144|IBM01144|IBM-EBCDIC (Italien-Euro)||  
|1145|IBM01145|IBM-EBCDIC (Spanien-Euro)||  
|1146|IBM01146|IBM-EBCDIC (Großbritannien-Euro)||  
|1147|IBM01147|IBM-EBCDIC (Frankreich-Euro)||  
|1148|IBM01148|IBM-EBCDIC (International Euro)||  
|1149|IBM01149|IBM-EBCDIC (Isländisch-Euro)||  
|1200|UTF-16|Unicode|✓|  
|1201|unicodeFFFE|Unicode (Big Endian)|✓|  
|1250|windows-1250|Mitteleuropäisch (Windows)||  
|1251|windows-1251|Kyrillisch (Windows)||  
|1252|Windows-1252|Westeuropäisch (Windows)|✓|  
|1253|windows-1253|Griechisch (Windows)||  
|1254|windows-1254|Türkisch (Windows)||  
|1255|windows-1255|Hebräisch (Windows)||  
|1256|windows-1256|Arabisch (Windows)||  
|1257|windows-1257|Baltisch (Windows)||  
|1258|windows-1258|Vietnamesisch (Windows)||  
|1361|Johab|Niederländisch (Standard)||  
|10000|Macintosh|Westeuropäisch (Mac)||  
|10001|X-Mac-Japanisch|Japanisch (Mac)||  
|10002|X-Mac-Chinesisch (traditionell)|Chinesisch (traditionell) (Mac)||  
|10003|X-Mac-Koreanisch|Koreanisch (Mac)|✓|  
|10004|X-Mac-Arabisch|Arabisch (Mac)||  
|10005|X-Mac-Hebräisch|Hebräisch (Mac)||  
|10006|X-Mac-Griechisch|Griechisch (Mac)||  
|10007|X-Mac-Kyrillisch|Kyrillisch (Mac)||  
|10008|X-Mac-chinesesimp|Chinesisch vereinfacht (Mac)|✓|  
|10010|X-Mac-Rumänisch|Rumänisch (Mac)||  
|10017|X-Mac-Ukrainisch|Ukrainisch (Mac)||  
|10021|X-Mac-thai|Thailändisch (Mac)||  
|10029|X-Mac-ce|Mitteleuropäisch (Mac)||  
|10079|X-Mac-Isländisch|Isländisch (Mac)||  
|10081|X-Mac-Türkisch|Türkisch (Mac)||  
|10082|X-Mac-Kroatisch|Kroatisch (Mac)||  
|12000|UTF-32|Unicode (UTF-32)|✓|  
|12001|UTF-32BE|Unicode (UTF-32 Big-Endian)|✓|  
|20000|X-Chinesisch-CNS|Chinesisch traditionell (CNS)||  
|20001|x-cp20001|TCA Taiwan||  
|20002|X-Chinesisch-Eten|Chinesisch traditionell (Eten)||  
|20003|x-cp20003|IBM5550 Taiwan||  
|20004|x-cp20004|Er durch Drücken Taiwan||  
|20005|x-cp20005|Wang Taiwan||  
|20105|x-IA5|Westeuropäisch (IA5)||  
|20106|x-IA5-German|Deutsch (IA5)||  
|20107|X-IA5-Schwedisch|Schwedisch (IA5)||  
|20108|X-IA5-Norwegian|Norwegisch (IA5)||  
|20127|us-ascii|US-ASCII|✓|  
|20261|x-cp20261|T.61||  
|20269|x-cp20269|ISO-6937||  
|20273|IBM273|IBM-EBCDIC (Deutschland)||  
|20277|IBM277|IBM-EBCDIC (Dänemark-Norwegen)||  
|20278|IBM278|IBM-EBCDIC (Finnland Schweden)||  
|20280|IBM280|IBM-EBCDIC (Italien)||  
|20284|IBM284|IBM-EBCDIC (Spanien)||  
|20285|IBM285|IBM-EBCDIC (GROSSBRITANNIEN)||  
|20290|IBM290|IBM-EBCDIC (japanische Katakana)||  
|20297|IBM297|IBM-EBCDIC (Frankreich)||  
|20420|IBM420|IBM-EBCDIC (Arabisch)||  
|20423|IBM423|IBM-EBCDIC (Griechisch)||  
|20424|IBM424|IBM-EBCDIC (Hebräisch)||  
|20833|X-EBCDIC-KoreanExtended|IBM-EBCDIC (erweitertes Koreanisch)||  
|20838|IBM-Thai|IBM-EBCDIC (Thai)||  
|20866|KOI8-r|Kyrillisch (KOI8-R)||  
|20871|IBM871|IBM-EBCDIC (Isländisch)||  
|20880|IBM880|IBM-EBCDIC (Kyrillisch, Russisch)||  
|20905|IBM905|IBM-EBCDIC (Türkisch)||  
|20924|IBM00924|IBM-Latin-1||  
|20932|EUC-JP|Japanisch (JIS 0208-1990 und 0212-1990)||  
|20936|x-cp20936|Chinesisch vereinfacht (GB2312-80)|✓|  
|20949|x-cp20949|Koreanisch Wansung|✓|  
|21025|cp1025|IBM-EBCDIC (Kyrillisch, Serbisch-Bulgarisch)||  
|21866|KOI8-u|Kyrillisch (KOI8-U)||  
|28591|iso-8859-1|Westeuropäisch (ISO)|✓|  
|28592|iso-8859-2|Mitteleuropäisch (ISO)||  
|28593|iso-8859-3|Lateinisch 3 (ISO)||  
|28594|iso-8859-4|Baltisch (ISO)||  
|28595|iso-8859-5|Kyrillisch (ISO)||  
|28596|iso-8859-6|Arabisch (ISO)||  
|28597|iso-8859-7|Griechisch (ISO)||  
|28598|iso-8859-8|Hebräisch (ISO-Visual)|✓|  
|28599|iso-8859-9|Türkisch (ISO)||  
|28603|iso-8859-13|Estnisch (ISO)||  
|28605|iso-8859-15|Lateinisch 9 (ISO)||  
|29001|X-Europa|Europa||  
|38598|iso-8859-8-i|Hebräisch (ISO-logisch)|✓|  
|50220|ISO-2022-jp|Japanisch (JIS)|✓|  
|50221|csISO2022JP|Japanisch (JIS-1 Byte Kana erlaubt)|✓|  
|50222|ISO-2022-jp|Japanisch (JIS erlaubt 1 Byte Kana - SO / SI)|✓|  
|50225|ISO-2022-kr|Koreanisch (ISO)|✓|  
|50227|x-cp50227|Chinesisch vereinfacht (ISO-2022)|✓|  
|51932|EUC-jp|Japanisch (EUC)|✓|  
|51936|EUC CN|Chinesisch vereinfacht (EUC)|✓|  
|51949|EUC-kr|Koreanisch (EUC)|✓|  
|52936|Hz-gb-2312|Chinesisch vereinfacht (HZ)|✓|  
|54936|GB18030|Chinesisch vereinfacht (GB18030)|✓|  
|57002|X-Iscii – de|ISCII Devanagari|✓|  
|57003|X Iscii werden|ISCII Bengalisch|✓|  
|57004|x-iscii-ta|ISCII Tamil|✓|  
|57005|X-Iscii-te|ISCII Telugu|✓|  
|57006|X Iscii als|ISCII Assamisch|✓|  
|57007|oder für die x iscii|ISCII Oriya|✓|  
|57008|X-Iscii-ka|ISCII Kannada|✓|  
|57009|X-Iscii-ma|ISCII Malayalam|✓|  
|57010|X-Iscii-gu|ISCII Gujarati|✓|  
|57011|X-Iscii-pa|ISCII Punjabi|✓|  
|65000|UTF-7|Unicode (UTF-7)|✓|  
|65001|UTF-8|Unicode (UTF-8)|✓|  
  
 Im folgenden Beispiel wird die <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> und <xref:System.Text.Encoding.GetEncoding%28System.String%29> Methoden zum Abrufen der Griechisch (Windows) code Codierung. Vergleicht die <xref:System.Text.Encoding> Ruft die Methode, um anzugeben, dass sie gleich sind, und klicken Sie dann Maps zeigt den Unicode-Codepunkt und den entsprechenden Codepagewert für jedes Zeichen des griechischen Alphabets zurückgegebenen Objekte.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die UTF-16 und UTF-32-Encoder können die big-endian-Bytereihenfolge (höchstwertigen Byte erste) oder die little-endian-Bytereihenfolge (am wenigsten signifikanten Byte zuerst). Beispielsweise folgt dem lateinischen Großbuchstaben (U + 0041) als serialisiert wird (hexadezimal):  
  
-   UTF-16 big endian-Bytereihenfolge: 00 41  
  
-   UTF-16 little-endian-Bytereihenfolge: 41 00  
  
-   UTF-32 big-endian-Bytereihenfolge: 00 00 00 41  
  
-   UTF-32 little-endian-Bytereihenfolge: 41 00 00 00  
  
 Es ist im Allgemeinen effizienter zum Speichern von Unicode-Zeichen, die mit systemeigenen Bytereihenfolge. Beispielsweise ist es besser, die little-endian-Bytereihenfolge auf little-endian Plattformtypen, beispielsweise Intel Computer verwenden.  
  
 Die <xref:System.Text.Encoding.GetPreamble%2A> Methode ruft ein Array von Bytes, die die Bytereihenfolgemarke (BOM) enthält. Wenn dieses Bytearray in einen codierten Stream vorangestellt ist, leichter den Decoder das Codierungsformat zu identifizieren.  
  
 Weitere Informationen zu Bytereihenfolge und Byte Order Mark, finden Sie im Unicode-Standard an die [Unicode-Homepage](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Beachten Sie, dass die Codierungsklassen Fehler zulassen:  
  
-   Ändern Sie im Hintergrund in ein "?" Zeichen.  
  
-   Verwenden Sie ein Zeichen "best fit".  
  
-   Ändern Sie auf ein anwendungsspezifisches Verhalten mithilfe von der <xref:System.Text.EncoderFallback> und <xref:System.Text.DecoderFallback> Klassen mit dem U + FFFD Unicode-Ersatzzeichen.  
  
 Sie sollten eine Ausnahme bei jedem Data Stream-Fehler auslösen. Eine Anwendung wird mit einem "Throwonerror"-Flag bei Bedarf oder verwendet den <xref:System.Text.EncoderExceptionFallback> und <xref:System.Text.DecoderExceptionFallback> Klassen. Beste Übereinstimmung Fallback wird häufig nicht empfohlen, kann dazu führen, dass Daten verloren gehen oder Verwechslungen und befindet sich langsamer als Ersatz für einfache Zeichen. Für ANSI-Codierung ist die am besten geeignete Verhalten die Standardeinstellung.  
  
   
  
## Examples  
 Das folgende Beispiel konvertiert eine Zeichenfolge aus einer Codierung in eine andere.  
  
> [!NOTE]
>  Das Bytearray [] ist der einzige Typ in diesem Beispiel, das die codierten Daten enthält. Die .NET Char und String-Typen sind selbst Unicode, sodass der <xref:System.Text.Encoding.GetChars%2A> Aufruf decodiert die Daten wieder in Unicode.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen überschreiben dieses Konstruktors.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">The code page identifier of the preferred encoding.  -or-  0, to use the default encoding.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen überschreiben dieses Konstruktors.  
  
 Aufrufe an diesen Konstruktor von einer abgeleiteten Klasse erstellen ein <xref:System.Text.Encoding> -Objekt, das Fallback mit ähnlichen Zeichen für Codierung und Decodierung Vorgänge verwendet. Sowohl die <xref:System.Text.Encoding.DecoderFallback%2A> und <xref:System.Text.Encoding.EncoderFallback%2A> Eigenschaften sind schreibgeschützt und kann nicht geändert werden. Um die Fallbackstrategie zu steuern, für eine Klasse abgeleitet <xref:System.Text.Encoding>, rufen Sie die <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> Konstruktor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> is less than zero.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">The encoding code page identifier.</param>
        <param name="encoderFallback">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</param>
        <param name="decoderFallback">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ist `protected`; abgeleitete Klassen überschreiben.  
  
 Rufen Sie diesen Konstruktor, von einer abgeleiteten Klasse zum Codieren und Decodieren von Strategien beim Fallback zu steuern. Die <xref:System.Text.Encoding> Klassenkonstruktoren nur-Lese Codierung Objekte erstellen, die nicht zulassen, Encoder oder DecoderFallback festgelegt werden, nachdem das Objekt erstellt wurde.  
  
 Wenn entweder `encoderFallback` oder `decoderFallback` ist null, Fallback mit ähnlichen Zeichen als die entsprechenden Fallbackstrategie verwendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> is less than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the ASCII (7-bit) character set.</summary>
        <value>Eine Codierung für den ASCII-Zeichensatz (7 Bits).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASCII-Zeichen sind auf die ersten 128 Unicode-Zeichen von U + 0000 bis U + 007F beschränkt.  
  
 Wenn Sie auswählen, die ASCII-Codierung für Ihre app, beachten Sie Folgendes ein:  
  
-   Der ASCII-Codierung eignet sich in der Regel für die Protokolle, die ASCII erfordern.  
  
-   Wenn Sie die 8-Bit-Codierung (die manchmal fälschlicherweise als "ASCII" bezeichnet) erforderlich ist, die UTF-8-Codierung wird empfohlen gegenüber der ASCII-Codierung. Klicken Sie für die Zeichen 0-7F. die Ergebnisse sind identisch, aber vermeidet Datenverluste Verwendung von UTF-8 ermöglicht die Darstellung der alle Unicode-Zeichen dargestellt werden kann. Beachten Sie, dass die ASCII-Codierung hat einen 8-bit-Mehrdeutigkeit, mit denen böswillige verwenden kann, kann aber UTF-8-Codierung Mehrdeutigkeit in Bezug auf das 8. Bit entfernt.  
  
-   Vor .NET Framework, Version 2.0 darf die .NET Framework spoofing durch ignorieren des 8. Bits. Ab .NET Framework 2.0, ausweichen nicht-ASCII-Codepunkte während der Decodierung.  
  
 Die <xref:System.Text.ASCIIEncoding> von dieser Eigenschaft zurückgegebene Objekt möglicherweise nicht das entsprechende Verhalten für Ihre app. Es verwendet einen Ersatzfallback ersetzt jede Zeichenfolge, die nicht codiert werden kann, und jedes Byte, die nicht decodiert werden können mit einem Fragezeichen ("?") Zeichen. Rufen Sie stattdessen die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> -Methode instanziieren ein <xref:System.Text.ASCIIEncoding> Objekt, dessen Fallback handelt es sich um, eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Wirkung der ASCII-Codierung für Zeichen, die außerhalb des ASCII-Bereichs liegen.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the UTF-16 format that uses the big endian byte order.</summary>
        <value>Ein Codierungsobjekt für das UTF-16-Format, das die Big-Endian-Bytereihenfolge verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.UnicodeEncoding> von dieser Eigenschaft zurückgegebene Objekt möglicherweise nicht das entsprechende Verhalten für Ihre app. Es verwendet einen Ersatzfallback ersetzt jede Zeichenfolge, die nicht codiert werden kann, und jedes Byte, die nicht decodiert werden können mit einem Fragezeichen ("?") Zeichen. Rufen Sie stattdessen die <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor zum Instanziieren einer big-Endian <xref:System.Text.UnicodeEncoding> Objekt, dessen Fallback handelt es sich um, eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 Das zurückgegebene <xref:System.Text.UnicodeEncoding> Objekt hat <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, und <xref:System.Text.Encoding.WebName%2A> Eigenschaften, die den Namen "UnicodeFFFE" ergeben. Obwohl die UTF-16 big-endian-Byte-reihenfolgemarkierung hexadezimale FEFF ist, wurde die UnicodeFFFE"Name" gewählt, weil Byte Order Mark als hexadezimale FFFE auf little-endian-Windows-Computer angezeigt wird.  
  
   
  
## Examples  
 Das folgende Beispiel liest eine Textdatei mit einer UTF-16-Codierung, die unter Verwendung der big-endian-Bytereihenfolge.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.</summary>
        <value>Ein Name der aktuellen <see cref="T:System.Text.Encoding" />-Klasse, die mit den Body-Tags des E-Mail-Agenten verwendet werden kann.  – oder – eine leere Zeichenfolge (""), wenn die aktuelle <see cref="T:System.Text.Encoding" /> kann nicht verwendet werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Codierung für den Namen eines Body haben möchten, sollten Sie aufrufen <xref:System.Text.Encoding.GetEncoding%2A> mit der <xref:System.Text.Encoding.BodyName%2A> Eigenschaft. Häufig Ruft die Methode mit einer abweichenden Codierung aus der Test Codierung, die im Aufruf erbracht ab. Im Allgemeinen müssen nur e-Mail-Anwendungen zum Abrufen, diese Codierung; Die meisten anderen Anwendungen, die eine Codierung wird beschrieben, müssen die zu verwendende seine <xref:System.Text.Encoding.WebName%2A>.  
  
 In einigen Fällen den Wert der <xref:System.Text.Encoding.BodyName%2A> Eigenschaft entspricht der internationalen Standard, die Codierung definiert. Dies bedeutet nicht, dass die Implementierung vollständig mit dieses Standards erfüllt.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft die verschiedenen Namen für jede Codierung ab und zeigt die Codierungen mit ein oder mehrere Namen, die von unterscheiden <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Es zeigt <xref:System.Text.Encoding.EncodingName%2A> jedoch nicht dafür verglichen.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, creates a shallow copy of the current <see cref="T:System.Text.Encoding" /> object.</summary>
        <returns>A copy of the current <see cref="T:System.Text.Encoding" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Klon beschreibbar ist auch dann, wenn die ursprüngliche <xref:System.Text.Encoding> Objekt ist schreibgeschützt. Aus diesem Grund können die Eigenschaften des Klons geändert werden.  
  
 Eine flache Kopie eines Objekts ist eine Kopie des Objekts nur. Wenn das Objekt Verweise auf andere Objekte enthält, erstellt die flache Kopie keine Kopien der Objekte verwiesen wird. Er bezieht sich stattdessen auf die ursprünglichen Objekte. Im Gegensatz dazu erstellt eine tiefe Kopie eines Objekts eine Kopie des Objekts und eine Kopie aller Elemente auf die dieses Objekt direkt oder indirekt verweist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets the code page identifier of the current <see cref="T:System.Text.Encoding" />.</summary>
        <value>Der Codepagebezeichner der aktuellen <see cref="T:System.Text.Encoding" />-Klasse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel ruft die verschiedenen Namen für jede Codierung ab und zeigt die Codierungen mit ein oder mehrere Namen, die von unterscheiden <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Es zeigt <xref:System.Text.Encoding.EncodingName%2A> jedoch nicht dafür verglichen.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts a byte array from one encoding to another.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">The encoding format of <c>bytes</c>.</param>
        <param name="dstEncoding">The target encoding format.</param>
        <param name="bytes">The bytes to convert.</param>
        <summary>Converts an entire byte array from one encoding to another.</summary>
        <returns>An array of type <see cref="T:System.Byte" /> containing the results of converting <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel konvertiert eine Unicode-codierte Zeichenfolge in eine ASCII-codierte Zeichenfolge. Da das ASCII-Codieren von Objekts zurückgegebene der <xref:System.Text.Encoding.ASCII%2A> Eigenschaft verwendet einen Ersatzfallback und das Zeichen Pi ist nicht Teil des ASCII-Zeichensatz, das Pi-Zeichen wird durch ein Fragezeichen ersetzt, wie die Ausgabe des Beispiels zeigt.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> is <see langword="null" />.  -or-  <paramref name="dstEncoding" /> is <see langword="null" />.  -or-  <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">The encoding of the source array, <c>bytes</c>.</param>
        <param name="dstEncoding">The encoding of the output array.</param>
        <param name="bytes">The array of bytes to convert.</param>
        <param name="index">The index of the first element of <c>bytes</c> to convert.</param>
        <param name="count">The number of bytes to convert.</param>
        <summary>Converts a range of bytes in a byte array from one encoding to another.</summary>
        <returns>An array of type <see cref="T:System.Byte" /> containing the result of converting a range of bytes in <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> is <see langword="null" />.  -or-  <paramref name="dstEncoding" /> is <see langword="null" />.  -or-  <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> and <paramref name="count" /> do not specify a valid range in the byte array.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Text.DecoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</summary>
        <value>Das Decoderfallbackobjekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.DecoderFallback> -Objekt stellt einen Fehlerhandler, der aufgerufen wird, wenn eine codierte Bytefolge in Zeichen decodiert werden kann. Eines der folgenden Handlertypen wird unterstützt:  
  
-   Einen ähnlichen fallback-Handler, der Bytes, die nicht decodiert werden können, durch ein geeigneter Ersatz-Zeichen ersetzt.  
  
-   Ein Ersatzfallback-Handler, der Bytes, die nicht decodiert werden können nicht mit einem beliebigen Ersatzzeichen ersetzt. .NET Framework enthält eine Ersetzung fallback-Handler <xref:System.Text.DecoderFallback>, ersetzt die standardmäßig Bytes, die nicht decodiert werden können, mit einem Fragezeichen ("?") Zeichen.  
  
-   Eine Ausnahme fallback-Handler, der eine Ausnahme auslöst, wenn Bytes nicht decodiert werden können. .NET Framework enthält eine Ausnahme fallback-Handler <xref:System.Text.DecoderExceptionFallback>, wodurch eine <xref:System.Text.DecoderFallbackException> Wenn Bytes nicht decodiert werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value in a set operation is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the default encoding for this .NET implementation.</summary>
        <value>Der Standardwert für diese Implementierung .NET Codierung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Unterschiedliche Computer können unterschiedliche Codierungen verwenden, als die Standardeinstellung, und die standardcodierung auf einem einzelnen Computer ändern kann. Bei Verwendung der <xref:System.Text.Encoding.Default%2A> Codierung zur Codierung und Decodierung von Daten zwischen Computern Streaming- oder zu unterschiedlichen Zeiten auf dem gleichen Computer abgerufen, es möglicherweise übersetzt diese Daten nicht ordnungsgemäß. Darüber hinaus zurückgegebenes die Codierung der <xref:System.Text.Encoding.Default%2A> Eigenschaft verwendet Fallback mit ähnlichen Zeichen, die von der Codepage unterstützt nicht unterstützte Zeichen zuzuordnen. Aus diesen Gründen wird die Verwendung der standardcodierung nicht empfohlen. Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, verwenden Sie eine Unicode-Codierung, z. B. <xref:System.Text.UTF8Encoding> oder <xref:System.Text.UnicodeEncoding>. Ein Protokoll auf höherer Ebene können Sie sicherstellen, dass das gleiche Format verwendet wird, zum Codieren und decodieren.  

### <a name="the-default-property-in-the-net-framework"></a>Die Standardeigenschaft in .NET Framework

In .NET Framework auf dem Windows-Desktop den <xref:System.Text.Encoding.Default%2A> Eigenschaft immer ruft aktive Codepage des Systems ab und erstellt eine <xref:System.Text.Encoding> Objekt, das es entspricht. Die aktive Codepage möglicherweise eine ANSI-Codepage enthält die ASCII-Zeichensatz zusammen mit zusätzlichen Zeichen, die variieren nach Codepage. Da alle <xref:System.Text.Encoding.Default%2A> Codierungen, die basierend auf ANSI-Codepages Daten verloren gehen, sollten Sie die <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> stattdessen Codierung. UTF-8 häufig U + 00 mit U + 7F. Bereich identisch ist, aber Sie können Zeichen außerhalb des ASCII-ohne Verlust codieren.

## <a name="the-default-property-on-net-core"></a>Die Standardeigenschaft für .NET Core

Auf .NET Core die <xref:System.Text.Encoding.Default%2A> -Eigenschaft gibt immer die <xref:System.Text.UTF8Encoding>. Auf alle Betriebssysteme (Windows, Linux und Max OS X) auf die Anwendungen mit .NET Core ausgeführt wird UTF-8 unterstützt.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Text.EncoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</summary>
        <value>Das Encoderfallbackobjekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.EncoderFallback> -Objekt stellt einen Fehlerhandler, der aufgerufen wird, wenn ein Zeichen in eine codierte Bytefolge konvertiert werden kann. Eines der folgenden Handlertypen wird unterstützt:  
  
-   Einen ähnlichen fallback-Handler, der Zeichen, die nicht codiert werden können, durch ein geeigneter Ersatz-Zeichen ersetzt.  
  
-   Ein Ersatzfallback-Handler, der Zeichen, die nicht codiert werden können mit einem beliebigen Ersatzzeichen ersetzt. .NET Framework enthält eine Ersetzung fallback-Handler <xref:System.Text.EncoderFallback>, die standardmäßig ersetzt Zeichen, die nicht codiert werden können, mit einem Fragezeichen ("?") Zeichen.  
  
-   Eine Ausnahme fallback-Handler, der eine Ausnahme auslöst, wenn Zeichen nicht codiert werden können. .NET Framework enthält eine Ausnahme fallback-Handler <xref:System.Text.EncoderExceptionFallback>, wodurch eine <xref:System.Text.EncoderFallbackException> Wenn Zeichen nicht decodiert werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value in a set operation is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets the human-readable description of the current encoding.</summary>
        <value>Die Klartextbeschreibung der aktuellen <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoding.EncodingName%2A> Eigenschaft zur Anzeige vorgesehen ist. Beim Ermitteln eines Namens, der übergeben werden kann die <xref:System.Text.Encoding.GetEncoding%2A> -Methode, mit der <xref:System.Text.Encoding.WebName%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft die verschiedenen Namen für jede Codierung ab und zeigt die Codierungen mit ein oder mehrere Namen, die von unterscheiden <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Es zeigt <xref:System.Text.Encoding.EncodingName%2A> jedoch nicht dafür verglichen.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The <see cref="T:System.Object" /> to compare with the current instance.</param>
        <summary>Determines whether the specified <see cref="T:System.Object" /> is equal to the current instance.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.Encoding" /> and is equal to the current instance; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei Instanzen von <xref:System.Text.Encoding> werden als gleich betrachtet, wenn sie dieselbe Codepage entsprechen und ihre `EncoderFallback` und `DecoderFallback` -Objekte gleich sind. Insbesondere abgeleiteten Codepages, die alle eine Codepage 0 und deren Zugriffe sind normalerweise `null` (`Nothing` in Visual Basic .NET).). Daher werden sie alle anderen gleich angesehen. Ein Vorteil ist, die bei der <xref:System.Text.Encoding.Equals%2A> wird verwendet, um eine Hashtabelle aufzufüllen, alle Codierungen gleich stammen und fallen in der gleichen Tabelle Hash Slot.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft zwei Instanzen der gleichen Codierung (eine nach der Codepage) und ein anderes anhand des Namens ab und überprüft deren Gleichheit.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the characters to encode.</param>
        <summary>When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.</summary>
        <returns>The number of bytes produced by encoding all the characters in the specified character array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> rufen Sie zum Speichern der resultierenden Bytes der <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird.  
  
-   Wenn Ihre app Zeichenfolgeneingaben behandelt, sollte, verwenden Sie die Zeichenfolge Versionen der <xref:System.Text.Encoding.GetBytes%2A> Methode.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten Sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The string containing the set of characters to encode.</param>
        <summary>When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> rufen Sie zum Speichern der resultierenden Bytes der <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird.  
  
-   Wenn Ihre app Zeichenfolgeneingaben, die Version der Zeichenfolge behandelt <xref:System.Text.Encoding.GetBytes%2A> wird empfohlen.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A pointer to the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> erfordert zum Speichern der resultierenden Bytes, rufen Sie die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Überlegungen zur Verwendung dieser Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird.  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, sollten Sie die Version der Zeichenfolge verwenden die <xref:System.Text.Encoding.GetBytes%2A> Methode.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%2A> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="index">The index of the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> rufen Sie zum Speichern der resultierenden Bytes der <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird.  
  
-   Wenn Ihre app Zeichenfolgeneingaben, die Version der Zeichenfolge behandelt <xref:System.Text.Encoding.GetBytes%2A> wird empfohlen.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um drei Zeichen aus einem Zeichenarray von zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>When overridden in a derived class, encodes a set of characters into a sequence of bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the characters to encode.</param>
        <summary>When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.</summary>
        <returns>A byte array containing the results of encoding the specified set of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Ersatzzeichenpaare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> merkt sich dieses hohe Ersatzzeichen, damit es mit ein niedriges Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding> wird nicht in der Lage, den Status verwalten, damit das Zeichen zu sendende der <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, sollten Sie die Version der Zeichenfolge Aufrufen der <xref:System.Text.Encoding.GetBytes%2A> Methode.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The string containing the characters to encode.</param>
        <summary>When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.</summary>
        <returns>A byte array containing the results of encoding the specified set of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Ersatzzeichenpaare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> merkt sich dieses hohe Ersatzzeichen, damit es mit ein niedriges Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding> wird nicht in der Lage, den Status verwalten, damit das Zeichen zu sendende der <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, verwenden Sie die Version der Zeichenfolge <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="index">The index of the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.</summary>
        <returns>A byte array containing the results of encoding the specified set of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Ersatzzeichenpaare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> merkt sich dieses hohe Ersatzzeichen, damit es mit ein niedriges Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding> wird nicht in der Lage, den Status verwalten, damit das Zeichen zu sendende der <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, verwenden Sie die Version der Zeichenfolge <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um drei Zeichen aus einem Zeichenarray von zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A pointer to the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">A pointer to the location at which to start writing the resulting sequence of bytes.</param>
        <param name="byteCount">The maximum number of bytes to write.</param>
        <summary>When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</summary>
        <returns>The actual number of bytes written at the location indicated by the <paramref name="bytes" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> erfordert zum Speichern der resultierenden Bytes, rufen Sie die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> Objekt von der bereitgestellten <xref:System.Text.Encoding.GetDecoder%2A> oder <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Ersatzzeichenpaare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> merkt sich dieses hohe Ersatzzeichen, damit es mit ein niedriges Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding> wird nicht in der Lage, den Status verwalten, damit das Zeichen zu sendende der <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, verwenden Sie die Version der Zeichenfolge <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.  -or-  <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> is less than the resulting number of bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="charIndex">The index of the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
        <param name="byteIndex">The index at which to start writing the resulting sequence of bytes.</param>
        <summary>When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.</summary>
        <returns>The actual number of bytes written into <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes rufen Sie die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Ersatzzeichenpaare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> merkt sich dieses hohe Ersatzzeichen, damit es mit ein niedriges Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding> wird nicht in der Lage, den Status verwalten, damit das Zeichen zu sendende der <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, verwenden Sie die Version der Zeichenfolge <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um drei Zeichen aus einem Zeichenarray von zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.  -or-  <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.  -or-  <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.  -or-  <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">The string containing the set of characters to encode.</param>
        <param name="charIndex">The index of the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
        <param name="byteIndex">The index at which to start writing the resulting sequence of bytes.</param>
        <summary>When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.</summary>
        <returns>The actual number of bytes written into <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes rufen Sie die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.Encoding.GetBytes%2A> -Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app möglicherweise viele Eingabezeichen in eine Codepage codieren und die Zeichen mit mehreren aufrufen müssen verarbeitet werden müssen. In diesem Fall müssen Sie wahrscheinlich den Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird beibehalten der <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Ersatzzeichenpaare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> merkt sich dieses hohe Ersatzzeichen, damit es mit ein niedriges Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding> wird nicht in der Lage, den Status verwalten, damit das Zeichen zu sendende der <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, verwenden Sie die Version der Zeichenfolge <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Die Unicode-Zeichen Puffer Version <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren aufrufen, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Bytearrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.  -or-  <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.  -or-  <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.  -or-  <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <summary>When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> zum Speichern der resultierenden Zeichen verwenden Sie die <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> Methode. Um die maximale Arraygröße zu berechnen, verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> Methode. Die <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und die <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> Methode führt die tatsächlichen Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihrer app müssen möglicherweise mehrere Eingabe Bytes aus einer Codepage zu decodieren und die Bytes mit mehreren Aufrufen verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen aufrufen.  
  
-   Wenn Ihre app Zeichenfolgenausgaben verarbeitet, sollten Sie verwenden die <xref:System.Text.Encoding.GetString%2A> Methode. Da diese Methode muss Zeichenfolgenlänge überprüfen und einen Puffer zuzuordnen, ist es etwas langsamer, aber die resultierende <xref:System.String> zu bevorzugen ist.  
  
-   Der Byteversion von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, unterstützt die Ausgabe von Zeichen Puffer ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert und klicken Sie dann die Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetChars%2A> erfordert zum Speichern der resultierenden Zeichen, verwenden Sie die <xref:System.Text.Encoding.GetCharCount%2A> Methode. Zum Berechnen der maximalen Arraygröße verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.Encoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die tatsächlichen Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihrer app müssen möglicherweise mehrere Eingabe Bytes aus einer Codepage zu decodieren und die Bytes mit mehreren Aufrufen verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen aufrufen.  
  
-   Wenn Ihre app Zeichenfolgenausgaben verarbeitet, es wird empfohlen, verwenden Sie die <xref:System.Text.Encoding.GetString%2A> Methode. Da diese Methode muss Zeichenfolgenlänge überprüfen und einen Puffer zuzuordnen, ist es etwas langsamer, aber die resultierende <xref:System.String> zu bevorzugen ist.  
  
-   Der Byteversion von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, unterstützt die Ausgabe von Zeichen Puffer ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen verwenden Sie die <xref:System.Text.Encoding.GetCharCount%2A> Methode. Zum Berechnen der maximalen Arraygröße verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.Encoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die tatsächlichen Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihrer app müssen möglicherweise mehrere Eingabe Bytes aus einer Codepage zu decodieren und die Bytes mit mehreren Aufrufen verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen aufrufen.  
  
-   Wenn Ihre app Zeichenfolgenausgaben verarbeitet, es wird empfohlen, verwenden Sie die <xref:System.Text.Encoding.GetString%2A> Methode. Da diese Methode muss Zeichenfolgenlänge überprüfen und einen Puffer zuzuordnen, ist es etwas langsamer, aber die resultierende <xref:System.String> zu bevorzugen ist.  
  
-   Der Byteversion von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, unterstützt die Ausgabe von Zeichen Puffer ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Das folgende Beispiel konvertiert eine Zeichenfolge aus einer Codierung in eine andere.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert und anschließend einen Bereich von Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>When overridden in a derived class, decodes a sequence of bytes into a set of characters.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <summary>When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.</summary>
        <returns>A character array containing the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft die Zeichen aus einer Eingabebytefolge ab. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> da <xref:System.Text.Encoding> erwartet diskrete Konvertierungen während <xref:System.Text.Decoder> für mehrere Durchläufe für genau einen Eingabedatenstrom dient.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 **Hinweis** diese Methode dient zum Verarbeiten von Unicode-Zeichen, nicht auf beliebigen Binärdaten, z. B. Bytearrays. Wenn Sie beliebige Binärdaten in Text codiert werden müssen, verwenden Sie ein Protokoll wie Uuencode, die durch Methoden, wie z. B. implementiert wird <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die tatsächlichen Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihrer app müssen möglicherweise mehrere Eingabe Bytes aus einer Codepage zu decodieren und die Bytes mit mehreren Aufrufen verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen aufrufen, da Bytefolgen unterbrochen werden können, wenn in Batches verarbeitet. (Z. B. Teil einer ISO-2022 Umschaltsequenz unter Umständen eine <xref:System.Text.Encoding.GetChars%2A> aufrufen und den Vorgang fortzusetzen, am Anfang der nächsten <xref:System.Text.Encoding.GetChars%2A> aufrufen. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft den Fallback für diese unvollständigen Sequenzen jedoch <xref:System.Text.Decoder> merkt sich diese Sequenzen für den nächsten Aufruf.)  
  
-   Wenn Ihre app Zeichenfolgenausgaben verarbeitet, es wird empfohlen, verwenden Sie die <xref:System.Text.Encoding.GetString%2A> Methode. Da diese Methode muss Zeichenfolgenlänge überprüfen und einen Puffer zuzuordnen, ist es etwas langsamer, aber die resultierende <xref:System.String> zu bevorzugen ist.  
  
-   Der Byteversion von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, unterstützt die Ausgabe von Zeichen Puffer ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert und klicken Sie dann die Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.</summary>
        <returns>A character array containing the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft die Zeichen aus einer Eingabebytefolge ab. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> da <xref:System.Text.Encoding> erwartet diskrete Konvertierungen während <xref:System.Text.Decoder> für mehrere Durchläufe für genau einen Eingabedatenstrom dient.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 **Hinweis** diese Methode dient zum Verarbeiten von Unicode-Zeichen, nicht auf beliebigen Binärdaten, z. B. Bytearrays. Wenn Sie beliebige Binärdaten in Text codiert werden müssen, verwenden Sie ein Protokoll wie Uuencode, die durch Methoden, wie z. B. implementiert wird <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die tatsächlichen Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihrer app müssen möglicherweise mehrere Eingabe Bytes aus einer Codepage zu decodieren und die Bytes mit mehreren Aufrufen verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen aufrufen, da Bytefolgen unterbrochen werden können, wenn in Batches verarbeitet. (Z. B. Teil einer ISO-2022 Umschaltsequenz unter Umständen eine <xref:System.Text.Encoding.GetChars%2A> aufrufen und den Vorgang fortzusetzen, am Anfang der nächsten <xref:System.Text.Encoding.GetChars%2A> aufrufen. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft den Fallback für diese unvollständigen Sequenzen jedoch <xref:System.Text.Decoder> merkt sich diese Sequenzen für den nächsten Aufruf.)  
  
-   Wenn Ihre app Zeichenfolgenausgaben verarbeitet, es wird empfohlen, verwenden Sie die <xref:System.Text.Encoding.GetString%2A> Methode. Da diese Methode muss Zeichenfolgenlänge überprüfen und einen Puffer zuzuordnen, ist es etwas langsamer, aber die resultierende <xref:System.String> zu bevorzugen ist.  
  
-   Der Byteversion von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, unterstützt die Ausgabe von Zeichen Puffer ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert und anschließend einen Bereich von Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to the first byte to decode.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <param name="chars">A pointer to the location at which to start writing the resulting set of characters.</param>
        <param name="charCount">The maximum number of characters to write.</param>
        <summary>When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</summary>
        <returns>The actual number of characters written at the location indicated by the <paramref name="chars" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetChars%2A> erfordert zum Speichern der resultierenden Zeichen, verwenden Sie die <xref:System.Text.Encoding.GetCharCount%2A> Methode. Zum Berechnen der maximalen Arraygröße verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.Encoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft die Zeichen aus einer Eingabebytefolge ab. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> da <xref:System.Text.Encoding> erwartet diskrete Konvertierungen während <xref:System.Text.Decoder> für mehrere Durchläufe für genau einen Eingabedatenstrom dient.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> Objekt von der bereitgestellten <xref:System.Text.Encoding.GetDecoder%2A> oder <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 **Hinweis** diese Methode dient zum Verarbeiten von Unicode-Zeichen, nicht auf beliebigen Binärdaten, z. B. Bytearrays. Wenn Sie beliebige Binärdaten in Text codiert werden müssen, verwenden Sie ein Protokoll wie Uuencode, die durch Methoden, wie z. B. implementiert wird <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die tatsächlichen Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihrer app müssen möglicherweise mehrere Eingabe Bytes aus einer Codepage zu decodieren und die Bytes mit mehreren Aufrufen verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen aufrufen, da Bytefolgen unterbrochen werden können, wenn in Batches verarbeitet. (Z. B. Teil einer ISO-2022 Umschaltsequenz unter Umständen eine <xref:System.Text.Encoding.GetChars%2A> aufrufen und den Vorgang fortzusetzen, am Anfang der nächsten <xref:System.Text.Encoding.GetChars%2A> aufrufen. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft den Fallback für diese unvollständigen Sequenzen jedoch <xref:System.Text.Decoder> merkt sich diese Sequenzen für den nächsten Aufruf.)  
  
-   Wenn Ihre app Zeichenfolgenausgaben, behandelt die <xref:System.Text.Encoding.GetString%2A> Methode wird empfohlen. Da diese Methode muss Zeichenfolgenlänge überprüfen und einen Puffer zuzuordnen, ist es etwas langsamer, aber die resultierende <xref:System.String> zu bevorzugen ist.  
  
-   Der Byteversion von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, unterstützt die Ausgabe von Zeichen Puffer ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.  -or-  <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> is less than the resulting number of characters.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="byteIndex">The index of the first byte to decode.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <param name="chars">The character array to contain the resulting set of characters.</param>
        <param name="charIndex">The index at which to start writing the resulting set of characters.</param>
        <summary>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.</summary>
        <returns>The actual number of characters written into <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen verwenden Sie die <xref:System.Text.Encoding.GetCharCount%2A> Methode. Zum Berechnen der maximalen Arraygröße verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.Encoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > ruft Zeichen aus einer Eingabebytefolge ab. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> da <xref:System.Text.Encoding> erwartet diskrete Konvertierungen während <xref:System.Text.Decoder> dient für mehrere Durchläufe für genau einen Eingabedatenstrom.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 **Hinweis** diese Methode dient zum Verarbeiten von Unicode-Zeichen, nicht auf beliebigen Binärdaten, z. B. Bytearrays. Wenn Sie beliebige Binärdaten in Text codiert werden müssen, verwenden Sie ein Protokoll wie Uuencode, die durch Methoden, wie z. B. implementiert wird <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die tatsächlichen Decodierung aus. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihrer app müssen möglicherweise mehrere Eingabe Bytes aus einer Codepage zu decodieren und die Bytes mit mehreren Aufrufen verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen aufrufen, da Bytefolgen unterbrochen werden können, wenn in Batches verarbeitet. (Z. B. Teil einer ISO-2022 Umschaltsequenz unter Umständen eine [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > aufrufen und den Vorgang fortzusetzen, am Anfang der nächsten [\], Int32, Int32, Char\<Xref : System.Text.Encoding.GetChars%2A > aufrufen. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > Fallback für diese unvollständigen Sequenzen ruft aber <xref:System.Text.Decoder> merkt sich diese Sequenzen für den nächsten Aufruf.)  
  
-   Wenn Ihre app Zeichenfolgenausgaben, behandelt die <xref:System.Text.Encoding.GetString%2A> Methode wird empfohlen. Da diese Methode muss Zeichenfolgenlänge überprüfen und einen Puffer zuzuordnen, ist es etwas langsamer, aber die resultierende <xref:System.String> zu bevorzugen ist.  
  
-   Der Byteversion von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Bedenken Sie, allerdings, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten sie den Ausgabepuffer wiederverwenden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, unterstützt die Ausgabe von Zeichen Puffer ist die beste Wahl.  
  
-   Erwägen Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Streams, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Das folgende Beispiel konvertiert eine Zeichenfolge aus einer Codierung in eine andere.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert und anschließend einen Bereich von Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.  -or-  <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.  -or-  <paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.  -or-  <paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.</summary>
        <returns>A <see cref="T:System.Text.Decoder" /> that converts an encoded sequence of bytes into a sequence of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> konvertiert sequenzielle Blöcke von Bytes in sequenzielle Blöcke von Zeichen ähnlich wie die <xref:System.Text.Encoding.GetChars%2A> Methode dieser Klasse. Allerdings eine <xref:System.Text.Decoder> Zustandsinformationen zwischen aufrufen, damit es ordnungsgemäß decodiert Bytefolgen an, die Blöcke umfassen verwaltet. Die <xref:System.Text.Decoder> behält nachfolgende Bytes am Ende der Datenblöcke und die nachfolgenden Bytes im nächste Decodierungsvorgang verwendet. Aus diesem Grund <xref:System.Text.Encoding.GetDecoder%2A> und <xref:System.Text.Encoding.GetEncoder%2A> eignen sich für die netzwerkübertragung und Dateivorgänge, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die Standardimplementierung gibt ein <see cref="T:System.Text.Decoder" /> aufruft, die die <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> und <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> Methoden des aktuellen <see cref="T:System.Text.Encoding" />. Muss, überschreiben Sie diese Methode zum Zurückgeben einer <see cref="T:System.Text.Decoder" /> , verwaltet den Zustand zwischen aufrufen.</para>
        </block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> that converts a sequence of Unicode characters into an encoded sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> konvertiert sequenzielle Blöcke von Zeichen in sequenzielle Blöcke von Bytes auf ähnliche Weise die <xref:System.Text.Encoding.GetBytes%2A> Methode dieser Klasse. Allerdings eine <xref:System.Text.Encoder> Zustandsinformationen zwischen aufrufen, damit korrekt Zeichensequenzen codiert werden, die Blöcke umfassen verwaltet. Die <xref:System.Text.Encoder> auch beibehalten, nachfolgende Zeichen am Ende der Datenblöcke und das nachfolgenden Zeichen in der nächsten Codierungsvorgang verwendet. Z. B. ein Datenblock möglicherweise eine hohe Ersatzzeichen ohne Entsprechung enden, und die übereinstimmende niedrige Ersatzzeichen ist möglicherweise in den nächsten Datenblock. Aus diesem Grund <xref:System.Text.Encoding.GetDecoder%2A> und <xref:System.Text.Encoding.GetEncoder%2A> eignen sich für die netzwerkübertragung und Dateivorgänge, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die Standardimplementierung gibt ein <see cref="T:System.Text.Encoder" /> aufruft, die die <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> und <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> Methoden des aktuellen <see cref="T:System.Text.Encoding" />. Muss, überschreiben Sie diese Methode zum Zurückgeben einer <see cref="T:System.Text.Encoder" /> , verwaltet den Zustand zwischen aufrufen.</para>
        </block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns an encoding for the specified code page.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">The code page identifier of the preferred encoding. Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.  -or-  0 (zero), to use the default encoding.</param>
        <summary>Returns the encoding associated with the specified code page identifier.</summary>
        <returns>The encoding that is associated with the specified code page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das fallback-Handler hängt von den Codierungstyp des `codepage`. Wenn `codepage` ist ein Code Seiten- oder Doppelbyte-Zeichensatz (DBCS)-Codierung, die ein ähnlichen fallback-Handler wird verwendet. Andernfalls wird ein Ersatz-fallback-Handler verwendet. Diese fallback-Handler können nicht für Ihre app geeignet sein. Das fallback-Handler verwendet, die von der Codierung gemäß Angabe `codepage`, Sie erreichen die <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> überladen.  
  
 Die <xref:System.Text.Encoding.GetEncoding%2A> Methode abhängig von der zugrunde liegenden Plattform unterstützt die meisten Codepages. .NET Framework unterstützt systemintern jedoch einige Codierungen. Eine Liste der Codepages, finden Sie unter der <xref:System.Text.Encoding> klassenthema. Alternativ können Sie rufen die <xref:System.Text.Encoding.GetEncodings%2A> ein Array der abzurufenden Methode <xref:System.Text.EncodingInfo> Objekte, die Informationen über alle Codierungen enthält.  
  
 Zusätzlich zu den Codierungen, die systemintern auf einer bestimmten Plattform-Version von .NET Framework unterstützt werden die <xref:System.Text.Encoding.GetEncoding%2A> Methodenrückgabe alle zusätzlichen Codierungen, bei denen durch die Registrierung zur Verfügung gestellt werden ein <xref:System.Text.EncodingProvider> Objekt. Die gleiche Codierung registriert wurde, indem Sie mehrere <xref:System.Text.EncodingProvider> Objekte, die diese Methode gibt das letzte Lesezeichen registriert.  

Sie können auch angeben, der Wert 0 für die `codepage` Argument. Das genaue Verhalten hängt von, ob alle Codierungen verfügbar durch die Registrierung vorgenommen wurden ein <xref:System.Text.EncodingProvider> Objekt:

- Einen oder mehrere Codierung Anbieter registriert wurden, wird die Codierung des letzten registrierten Anbieters, der sich entschieden hat, wenn Codierung liefern kann die <xref:System.Text.Encoding.GetEncoding%2A> -Methode übergeben ein `codepage` Argument von 0.     

- Auf .NET Framework, wenn keine Codierung Anbieter wurde registriert, wenn die <xref:System.Text.CodePagesEncodingProvider> der registrierten codierungsanbieter ist oder wenn keine Codierung registrierten Anbieter kümmert sich um eine `codepage` Wert 0, gibt es aktiven Codepage des Betriebssystems. Um die aktive Codepage in Windows-Systemen zu bestimmen, rufen Sie die Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Funktion von .NET Framework auf dem Windows-Desktop.

- Auf .NET Core, wenn kein codierungsanbieter wurde registriert, oder wenn keine Codierung registrierten Anbieter kümmert sich um eine `codepage` Wert von 0 (null) gibt die <xref:System.Text.UTF8Encoding>.
  
> [!NOTE]
>  Einige nicht unterstützte Codepages Ursache ein <xref:System.ArgumentException> ausgelöst wird, während andere auslösen, eine <xref:System.NotSupportedException>. Daher Ihren Code muss catch alle Ausnahmen, die im Abschnitt für Ausnahmen angegeben.  
  
> [!NOTE]
>  Die ANSI-Codepages können auf verschiedenen Computern unterschiedlich sein und können auf einem einzelnen Computer, die führende zur Beschädigung von Daten ändern. Aus diesem Grund ist die aktive Codepage ANSI-Codepage, codieren und Decodieren von Daten mithilfe der Standardcodepage zurückgegebenes `Encoding.GetEncoding(0)` wird nicht empfohlen. Die meisten konsistent zu erzielen sollten Sie verwenden, eine Unicode-Codierung, z. B. UTF-8 (Codepage 65001) oder UTF-16, anstelle einer bestimmten Codepage.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Gibt eine zwischengespeicherte Instanz mit Standardeinstellungen zurück. Sie sollten die Konstruktoren der abgeleiteten Klassen zum Abrufen einer Instanz mit unterschiedlichen Einstellungen verwenden. Z. B. die <xref:System.Text.UTF32Encoding> Klasse bietet einen Konstruktor, der Sie die fehlererkennung aktivieren kann.  

   
  
## Examples  
 Im folgenden Beispiel ruft zwei Instanzen der gleichen Codierung (eine nach Codepage) und ein anderes nach Namen ab und überprüft deren Gleichheit.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> is less than zero or greater than 65535.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> is not supported by the underlying platform.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> is not supported by the underlying platform.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The code page name of the preferred encoding. Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid. Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</param>
        <summary>Returns the encoding associated with the specified code page name.</summary>
        <returns>The encoding  associated with the specified code page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das fallback-Handler hängt von den Codierungstyp des `name`. Wenn `name` ist ein Code Seiten- oder Doppelbyte-Zeichensatz (DBCS)-Codierung, die ein ähnlichen fallback-Handler wird verwendet. Andernfalls wird ein Ersatz-fallback-Handler verwendet. Diese fallback-Handler können nicht für Ihre app geeignet sein. Das fallback-Handler verwendet, die von der Codierung gemäß Angabe `name`, Sie erreichen die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> überladen.  
  
 Die <xref:System.Text.Encoding.GetEncoding%2A> Methode abhängig von der zugrunde liegenden Plattform unterstützt die meisten Codepages. .NET Framework unterstützt systemintern jedoch einige Codierungen. Eine Liste der Codepages, finden Sie unter der <xref:System.Text.Encoding> klassenthema. Alternativ können Sie rufen die <xref:System.Text.Encoding.GetEncodings%2A> ein Array der abzurufenden Methode <xref:System.Text.EncodingInfo> Objekte, die Informationen über alle Codierungen enthält. 
  
 Zusätzlich zu den Codierungen, die systemintern auf einer bestimmten Plattform-Version von .NET Framework unterstützt werden die <xref:System.Text.Encoding.GetEncoding%2A> Methodenrückgabe alle zusätzlichen Codierungen, bei denen durch die Registrierung zur Verfügung gestellt werden ein <xref:System.Text.EncodingProvider> Objekt. Die gleiche Codierung registriert wurde, indem Sie mehrere <xref:System.Text.EncodingProvider> Objekte, die diese Methode gibt das letzte Lesezeichen registriert.  
   
> [!NOTE]
>  Die ANSI-Codepages können auf verschiedenen Computern unterschiedlich sein, oder für einen einzelnen Computer, die führende zur Beschädigung von Daten geändert werden können. Die meisten konsistent zu erzielen sollten Sie Unicode, z. B. UTF-8 (Codepage 65001) oder UTF-16, anstelle einer bestimmten Codepage verwenden.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> Gibt eine zwischengespeicherte Instanz mit Standardeinstellungen zurück. Sie sollten die Konstruktoren der abgeleiteten Klassen zum Abrufen einer Instanz mit unterschiedlichen Einstellungen verwenden. Z. B. die <xref:System.Text.UTF32Encoding> Klasse bietet einen Konstruktor, der Sie die fehlererkennung aktivieren kann.  
  
## Examples  
 Im folgenden Beispiel ruft zwei Instanzen der gleichen Codierung (eine nach Codepage) und ein anderes nach Namen ab und überprüft deren Gleichheit.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is not a valid code page name.  -or-  The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">The code page identifier of the preferred encoding. Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.  -or-  0 (zero), to use the default encoding.</param>
        <param name="encoderFallback">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</param>
        <param name="decoderFallback">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</param>
        <summary>Returns the encoding associated with the specified code page identifier. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</summary>
        <returns>The encoding that is associated with the specified code page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Einige nicht unterstützte Codepages dazu führen, dass die Ausnahme <xref:System.ArgumentException> ausgelöst wird, während andere auslösen, <xref:System.NotSupportedException>. Daher Ihren Code muss catch alle Ausnahmen, die im Abschnitt für Ausnahmen angegeben.  
  
 Die <xref:System.Text.Encoding.GetEncoding%2A> Methode abhängig von der zugrunde liegenden Plattform unterstützt die meisten Codepages. .NET Framework unterstützt systemintern jedoch einige Codierungen. Eine Liste der Codepages, finden Sie unter der <xref:System.Text.Encoding> klassenthema. Sie erreichen die <xref:System.Text.Encoding.GetEncodings%2A> Methode im vollständigen .NET Framework auf dem Windows-Desktop um eine Liste aller Codierungen abzurufen.   
  
 Zusätzlich zu den Codierungen, die systemintern auf einer bestimmten Plattform-Version von .NET Framework unterstützt werden die <xref:System.Text.Encoding.GetEncoding%2A> Methodenrückgabe alle zusätzlichen Codierungen, bei denen durch die Registrierung zur Verfügung gestellt werden ein <xref:System.Text.EncodingProvider> Objekt.  Die gleiche Codierung registriert wurde, indem Sie mehrere <xref:System.Text.EncodingProvider> Objekte, die diese Methode gibt das letzte Lesezeichen registriert.  

Sie können auch angeben, der Wert 0 für die `codepage` Argument. Das genaue Verhalten hängt von, ob alle Codierungen verfügbar durch die Registrierung vorgenommen wurden ein <xref:System.Text.EncodingProvider> Objekt:

- Einen oder mehrere Codierung Anbieter registriert wurden, wird die Codierung des letzten registrierten Anbieters, der sich entschieden hat, wenn Codierung liefern kann die <xref:System.Text.Encoding.GetEncoding%2A> -Methode übergeben ein `codepage` Argument von 0.     

- Auf .NET Framework, wenn keine Codierung Anbieter wurde registriert, wenn die <xref:System.Text.CodePagesEncodingProvider> ist der registrierte codierungsanbieter oder wenn keine Codierung registrierten Anbieter kümmert sich um eine `codepage` Wert 0, gibt es zurück, die aktiven Codepage.

- Auf .NET Core, wenn kein codierungsanbieter wurde registriert, oder wenn keine Codierung registrierten Anbieter kümmert sich um eine `codepage` Wert von 0 (null) gibt die <xref:System.Text.UTF8Encoding> Codierung.

> [!NOTE]
>  Die ANSI-Codepages können auf verschiedenen Computern unterschiedlich sein und können auf einem einzelnen Computer, die führende zur Beschädigung von Daten ändern. Aus diesem Grund ist die aktive Codepage ANSI-Codepage, codieren und Decodieren von Daten mithilfe der Standardcodepage zurückgegebenes `Encoding.GetEncoding(0)` wird nicht empfohlen. Die meisten konsistent zu erzielen sollten Sie Unicode, z. B. UTF-8 (Codepage 65001) oder UTF-16, anstelle einer bestimmten Codepage verwenden. 
  
 Zum Abrufen der aktiven Codepage zugeordnete Codierung, können Sie entweder einen Wert 0 für angeben der `codepage` Argument oder, wenn Ihr Code auf das vollständige .NET Framework auf dem Windows-Desktop ausgeführt wird, Abrufen des Werts der <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> Eigenschaft. Um die aktuelle aktive Codepage zu bestimmen, rufen Sie die Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Funktion von .NET Framework auf dem Windows-Desktop.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Gibt eine zwischengespeicherte Instanz mit Standardeinstellungen zurück. Sie sollten die Konstruktoren der abgeleiteten Klassen zum Abrufen einer Instanz mit unterschiedlichen Einstellungen verwenden. Z. B. die <xref:System.Text.UTF32Encoding> Klasse bietet einen Konstruktor, der Sie die fehlererkennung aktivieren kann.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> Methode.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> is less than zero or greater than 65535.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> is not supported by the underlying platform.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> is not supported by the underlying platform.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">The code page name of the preferred encoding. Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid. Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</param>
        <param name="encoderFallback">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</param>
        <param name="decoderFallback">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</param>
        <summary>Returns the encoding associated with the specified code page name. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</summary>
        <returns>The encoding that is associated with the specified code page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoding.GetEncoding%2A> Methode abhängig von der zugrunde liegenden Plattform unterstützt die meisten Codepages. .NET Framework unterstützt systemintern jedoch einige Codierungen.  
  
 Zusätzlich zu den Codierungen, die systemintern auf einer bestimmten Plattform-Version von .NET Framework unterstützt werden die <xref:System.Text.Encoding.GetEncoding%2A> Methodenrückgabe alle zusätzlichen Codierungen, bei denen durch die Registrierung zur Verfügung gestellt werden ein <xref:System.Text.EncodingProvider> Objekt. Die gleiche Codierung registriert wurde, indem Sie mehrere <xref:System.Text.EncodingProvider> Objekte, die diese Methode gibt das letzte Lesezeichen registriert. 
  
> [!NOTE]
>  Die ANSI-Codepages können auf verschiedenen Computern unterschiedlich sein und können auf einem einzelnen Computer, die führende zur Beschädigung von Daten ändern. Die meisten konsistent zu erzielen sollten Sie verwenden, eine Unicode-Codierung, z. B. UTF-8 (Codepage 65001) oder UTF-16, anstelle einer bestimmten Codepage.  
  
 Eine Liste der Codepages, finden Sie unter der <xref:System.Text.Encoding> klassenthema. Sie erreichen die <xref:System.Text.Encoding.GetEncodings%2A> Methode auf das vollständige .NET Framework auf dem Windows-Desktop um eine Liste aller Codierungen abzurufen.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Gibt eine zwischengespeicherte Instanz mit Standardeinstellungen zurück. Sie sollten die Konstruktoren der abgeleiteten Klassen zum Abrufen einer Instanz mit unterschiedlichen Einstellungen verwenden. Z. B. die <xref:System.Text.UTF32Encoding> Klasse bietet einen Konstruktor, der Sie die fehlererkennung aktivieren kann.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> Methode.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is not a valid code page name.  -or-  The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an array that contains all encodings.</summary>
        <returns>An array that contains all encodings.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt eine Liste der unterstützten Codierungen, die eindeutig durch die Codepage unterschieden. Eine Tabelle mit den unterstützten Codierungen, finden Sie unter der <xref:System.Text.Encoding> klassenthema.  
  
> [!NOTE]
>  Die Liste der unterstützten Codierungen zurückgegebenes der <xref:System.Text.Encoding.GetEncodings%2A> Methode schließt zusätzliche Codierung zur Verfügung gestellt, von einer nicht <xref:System.Text.EncodingProvider> Implementierungen, die durch Aufrufe von registriert wurden die <xref:System.Text.Encoding.RegisterProvider%2A> Methode.  
  
 Codierungen 50220 und 50222 sind beide verknüpft sind, mit dem Namen "Iso-2022-jp", aber nicht identisch sind. Codierung 50220 konvertiert halber Breite Katakana-Zeichen in Katakana-Zeichen mit voller Breite, wohingegen Codierung 50222 verwendet eine Sequenz UMSCHALT-in/UMSCHALT-Out halbbreiten Katakana-Zeichen zu codieren. Der Anzeigename für Codierung 50222 ist "Japanisch (JIS-1 Byte Kana erlaubt - SO / SI)" zur Unterscheidung von Codierung 50220, mit dem Anzeigenamen "Japanisch (JIS)" nennen.  
  
 Wenn Sie die Codierung Name "Iso-2022-jp", die .NET Framework gibt Codierung 50220 anfordern. Allerdings hängt die Codierung, die für Ihre app geeignet ist der bevorzugten Behandlung der Katakana-Zeichen halber Breite.  
  
 Verwenden Sie zum Abrufen einer bestimmten Codierung der <xref:System.Text.Encoding.GetEncoding%2A> Methode.  
  
 <xref:System.Text.Encoding.GetEncodings%2A> wird in einigen Fällen verwendet werden, um Benutzer mit einer Liste von Codierungen in eine Datei vorlegen **speichern als** (Dialogfeld). Viele nicht-Unicode-Codierungen sind jedoch entweder unvollständig und übersetzen: zu viele Zeichen "?", oder weisen Sie etwas andere Verhalten auf verschiedenen Plattformen. Erwägen Sie UTF-8 oder UTF-16 als Standard.  
  
   
  
## Examples  
 Im folgende Beispiel werden die Werte der booleschen Eigenschaften jeder Codierung überprüft.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for the current instance.</summary>
        <returns>The hash code for the current instance.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">The number of characters to encode.</param>
        <summary>When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.</summary>
        <returns>The maximum number of bytes produced by encoding the specified number of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `charCount` Parameter gibt die Anzahl der tatsächlich an <xref:System.Char> Objekte, die Unicode-Zeichen zu codieren, darstellen, da .NET Framework intern UTF-16-Unicode-Zeichen verwendet. Daher können die meisten Unicode-Zeichen dargestellt werden, von einem <xref:System.Char> -Objekt, aber ein Unicode-Zeichen, die durch ein Ersatzzeichenpaar, z. B. dargestellt wird, müssen Sie zwei <xref:System.Char> Objekte.  
  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes verwenden Sie die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Zum Berechnen der maximalen Arraygröße verwenden Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> Ruft die Anzahl Worst-Case, einschließlich ungünstigsten Fall für das derzeit ausgewählte ab <xref:System.Text.EncoderFallback>. Wenn ein Fallback mit einer potenziell großen Zeichenfolge ausgewählt wird <xref:System.Text.Encoding.GetMaxByteCount%2A> große Werte, insbesondere in Fällen, in denen die schlimmsten Fall für die Codierung umfasst Moduswechsel für jedes Zeichen, abgerufen. Dies kann z. B. ISO-2022-JP haben. Weitere Informationen finden Sie im Blogeintrag "[mit Encoding.GetMaxByteCount() und Encoding.GetMaxCharCount() Neuigkeiten?](http://go.microsoft.com/fwlink/?LinkId=153702)" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 In den meisten Fällen ruft diese Methode geeignete Werte für kleine Zeichenfolgen ab. Für große Zeichenfolgen müssen Sie möglicherweise entscheiden sehr große Puffer und Erfassen von Fehlern in dem seltenen Fall, wenn ein günstiger Puffer zu klein ist. Sie sollten auch einen anderen Ansatz erwägen <xref:System.Text.Encoding.GetByteCount%2A> oder <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 Bei Verwendung <xref:System.Text.Encoding.GetMaxByteCount%2A>, sollten Sie den Ausgabepuffer basierend auf der maximalen Größe des Eingabepuffers zuweisen. Wenn der Ausgabepuffer Größe eingeschränkt ist, können die <xref:System.Text.Encoding.Convert%2A> Methode.  
  
 Beachten Sie, dass <xref:System.Text.Encoding.GetMaxByteCount%2A> potenzielle übrig gebliebene Surrogate aus einer vorherigen betrachtet. Aufgrund der Decoder Ruft die Übergabe des Werts 1 an die Methode für ein Einzelbyte-Codierung, z. B. ASCII 2 ab. Verwenden Sie die <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> Eigenschaft, wenn diese Informationen erforderlich ist.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` ist nicht unbedingt der gleiche Wert wie `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> is less than zero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Alle <see cref="T:System.Text.Encoding" /> Implementierungen müssen sicherstellen, dass keine Ausnahmen durch Pufferüberlauf auftritt, wenn Puffer anhand der Ergebnisse von dieser Methode Berechnungen deren Größe geändert werden.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.</summary>
        <returns>The maximum number of characters produced by decoding the specified number of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen verwenden Sie die <xref:System.Text.Encoding.GetCharCount%2A> Methode. Zum Berechnen der maximalen Arraygröße verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.Encoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> Ruft die Anzahl Worst-Case, einschließlich ungünstigsten Fall für das derzeit ausgewählte ab <xref:System.Text.DecoderFallback>. Wenn ein Fallback mit einer potenziell großen Zeichenfolge ausgewählt wird <xref:System.Text.Encoding.GetMaxCharCount%2A> große Werte abgerufen.  
  
 In den meisten Fällen ruft diese Methode geeignete Zahlen für kleine Zeichenfolgen ab. Für große Zeichenfolgen müssen Sie möglicherweise entscheiden sehr große Puffer und Erfassen von Fehlern in dem seltenen Fall, dass ein günstiger Puffer zu klein ist. Sie sollten auch einen anderen Ansatz erwägen <xref:System.Text.Encoding.GetCharCount%2A> oder <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> hat keinen Bezug zu <xref:System.Text.Encoding.GetBytes%2A>. Wenn Sie eine ähnliche Funktion für die Verwendung mit benötigt <xref:System.Text.Encoding.GetBytes%2A>, verwenden Sie <xref:System.Text.Encoding.GetMaxByteCount%2A>.  
  
 Bei Verwendung <xref:System.Text.Encoding.GetMaxCharCount%2A>, sollten Sie den Ausgabepuffer basierend auf der maximalen Größe des Eingabepuffers zuweisen. Wenn der Ausgabepuffer Größe eingeschränkt ist, können die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode.  
  
 Beachten Sie, dass <xref:System.Text.Encoding.GetMaxCharCount%2A> berücksichtigt den ungünstigsten Fall für übrig gebliebene Bytes aus einem vorherigen Encoder-Vorgang. Die Übergabe des Werts 0 an diese Methode bei den meisten Codepages hingegen Werte größer als oder gleich 1 abgerufen.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` ist nicht unbedingt der gleiche Wert wie `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert und klicken Sie dann die Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> is less than zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Alle <see cref="T:System.Text.Encoding" /> Implementierungen müssen sicherstellen, dass keine Ausnahmen durch Pufferüberlauf auftritt, wenn Puffer anhand der Ergebnisse von dieser Methode Berechnungen deren Größe geändert werden.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.</summary>
        <returns>A byte array containing a sequence of bytes that specifies the encoding used.  -or-  A byte array of length zero, if a preamble is not required.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Optional können die <xref:System.Text.Encoding> Objekt stellt keine Präambel, die ein Array von Bytes, die die Abfolge von Bytes, die aufgrund des Codierungsvorgangs vorangestellt werden kann. Die Präambel eine Bytereihenfolge-Marke (in Unicode-Codepunkt U + FEFF) enthält, leichter den Decoder die Bytereihenfolge und die Transformationsformat oder im UTF zu bestimmen.  
  
 Die Unicode-bytereihenfolgemarkierung (BOM) ist (im Hexadezimalformat) wie folgt serialisiert:  
  
-   UTF-8: EF BB BF  
  
-   UTF-16 big endian-Bytereihenfolge: FF FE  
  
-   UTF-16 little-endian-Bytereihenfolge: FF FE  
  
-   UTF-32 big-endian-Bytereihenfolge: 00 00 FE FF  
  
-   UTF-32 little-endian-Bytereihenfolge: FF FE 00 00  
  
 Sollten Sie die BOM verwenden, da es bietet eine nahezu bestimmte Identifikation des eine Codierung für Dateien, die andernfalls verloren Verweis auf die <xref:System.Text.Encoding> Objekts an, z. B. nicht gekennzeichnet oder falsch gekennzeichnet Webdaten oder zufällige Dateien gespeichert, wenn ein Unternehmen hat keine haben Sie internationale Sicherheitsrisiken oder andere Daten. Häufig Benutzerprobleme können vermieden werden, wenn Daten einheitlich und ordnungsgemäß konfiguriert, vorzugsweise in UTF-8 oder UTF-16 gekennzeichnet ist.  
  
 Für die Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant. Es kann jedoch verwendet werden, zu einem Server, den richtigen encoding-Header zu senden. Alternativ können sie als ein Fallback verwendet werden, für den Fall, dass die Codierung verloren gegangen ist.  
  
 Es gibt einige Nachteile mit einer BOM. Zu wissen, wie die Datenbankfelder zu beschränken, die eine BOM verwenden kann z. B. schwierig sein. Die Verkettung von Dateien, problematisch sein kann auch, beispielsweise beim Zusammenführen von Dateien in einem solchen eine Möglichkeit, die ein unnötige Zeichen in der Mitte Daten annehmen kann. Trotz der einige Nachteile wird jedoch dringend die Verwendung einer Stückliste empfohlen.  
  
 Weitere Informationen zu Bytereihenfolge und Byte Order Mark, finden Sie im Unicode-Standard an die [Unicode-Homepage](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie die codierten Bytes mit einer Präambel voranstellen. Die meisten Codierungen bieten jedoch keine Präambel. Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie mit einer Unicode-Codierung, d. h. <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, oder <xref:System.Text.UTF32Encoding>, mit einer Präambel.  
  
   
  
## Examples  
 Im folgende Beispiel werden die Bytereihenfolge der Codierung auf Grundlage der Präambel bestimmt.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>When overridden in a derived class, decodes a sequence of bytes into a string.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <summary>When overridden in a derived class, decodes all the bytes in the specified byte array into a string.</summary>
        <returns>A string that contains the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> zurückgegebenes Objekt die <xref:System.Text.Encoding.GetDecoder%2A> eine Deri-Methode Verschieben von-Klasse.  
  
 Finden Sie im Abschnitt "Hinweise" der <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Verweis Themas beschriebenen Techniken und Überlegungen zu decodieren.  
  
 Beachten Sie, dass das genaue Verhalten der <xref:System.Text.Encoding.GetString%2A> Methode für einen bestimmten <xref:System.Text.Encoding> Implementierung hängt von der Fallbackstrategie definiert für diesen <xref:System.Text.Encoding> Objekt. Weitere Informationen finden Sie im Abschnitt "Auswählen einer Fallbackstrategie" die [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) Thema.  
  
   
  
## Examples  
 Das folgende Beispiel liest eine UTF-8-codierte Zeichenfolge aus einer Binärdatei, dargestellt durch eine <xref:System.IO.FileStream> Objekt. Für Dateien, die kleiner als 2.048 Bytes sind, liest er den Inhalt der gesamten Datei in ein Bytearray und ruft die <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> Methode, um die Decodierung durchzuführen. Es liest für größere Dateien 2.048 Bytes zu einem Zeitpunkt in ein Bytearray, ruft der <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um zu bestimmen, wie viele Zeichen im Array enthalten sind, und ruft dann die <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um die Decodierung durchzuführen.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 Das Beispiel verwendet den folgenden Text, der in eine UTF-8-codierte Datei, die mit dem Namen Utf8Example.txt gespeichert werden soll.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The byte array contains invalid Unicode code points.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to a byte array.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string.</summary>
        <returns>A string that contains the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoding.GetString%2A> -Methode entwickelt, um die Leistung zu optimieren, wenn Sie einen systemeigenen Zeiger auf ein Bytearray verfügen. Statt verwalteten Bytearrays erstellen und anschließend decodiert können Sie stattdessen diese Methode aufrufen, ohne alle zwischenobjekte erstellen zu müssen.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> zurückgegebenes Objekt die <xref:System.Text.Encoding.GetDecoder%2A> eine Deri-Methode Verschieben von-Klasse.  
  
 Finden Sie im Abschnitt "Hinweise" der <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Verweis Themas beschriebenen Techniken und Überlegungen zu decodieren.  
  
 Beachten Sie, dass das genaue Verhalten der <xref:System.Text.Encoding.GetString%2A> Methode für einen bestimmten <xref:System.Text.Encoding> Implementierung hängt von der Fallbackstrategie definiert für diesen <xref:System.Text.Encoding> Objekt. Weitere Informationen finden Sie im Abschnitt "Auswählen einer Fallbackstrategie" die [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md) Thema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is a null pointer.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> is less than zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A   fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for a complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.</summary>
        <returns>A string that contains the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen der <xref:System.Text.Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Finden Sie im Abschnitt "Hinweise" der <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Verweis Themas beschriebenen Techniken und Überlegungen zu decodieren.  
  
   
  
## Examples  
 Das folgende Beispiel liest eine UTF-8-codierte Zeichenfolge aus einer Binärdatei, die durch dargestellt wird ein <xref:System.IO.FileStream> Objekt. Für Dateien, die kleiner als 2.048 Bytes sind, liest er den Inhalt der gesamten Datei in ein Bytearray und ruft die <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Methode, um die Decodierung durchzuführen. Es liest für größere Dateien 2.048 Bytes zu einem Zeitpunkt in ein Bytearray, ruft der <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um zu bestimmen, wie viele Zeichen im Array enthalten sind, und ruft dann die <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um die Decodierung durchzuführen.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 Das Beispiel verwendet den folgenden Text, der in eine UTF-8-codierte Datei, die mit dem Namen Utf8Example.txt gespeichert werden soll.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The byte array contains invalid Unicode code points.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.</summary>
        <value>Ein Name für die aktuelle <see cref="T:System.Text.Encoding" />, die für die Header-Tags des E-Mail-Agenten verwendet werden kann.  – oder – eine leere Zeichenfolge (""), wenn die aktuelle <see cref="T:System.Text.Encoding" /> kann nicht verwendet werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie benötigen eine Codierung für einen Headernamen an, Sie sollten Aufrufen der <xref:System.Text.Encoding.GetEncoding%2A> Methode mit der <xref:System.Text.Encoding.HeaderName%2A> Eigenschaft. Häufig Ruft die Methode mit einer abweichenden Codierung aus der Test Codierung, die im Aufruf erbracht ab. Im Allgemeinen müssen nur e-Mail-Anwendungen diese Codierung abgerufen.  
  
 In einigen Fällen den Wert der <xref:System.Text.Encoding.BodyName%2A> Eigenschaft entspricht der internationalen Standard, die Codierung definiert. Dies bedeutet nicht, dass die Implementierung vollständig mit dieses Standards erfüllt.  
  
 Beachten Sie, dass <xref:System.Text.Encoding.WebName%2A> gibt den Namen zu verwenden, um die Beschreibung einer Codierung zurück. Die <xref:System.Text.Encoding.HeaderName%2A> Eigenschaft definiert eine andere Codierung, die besser für eine e-Mail-Anwendung, z. B. möglicherweise. Verwendung der Eigenschaft zum Definieren der Codierung wird jedoch nicht empfohlen.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft die verschiedenen Namen für jede Codierung ab und zeigt die Codierungen mit ein oder mehrere Namen, die von unterscheiden <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Es zeigt <xref:System.Text.Encoding.EncodingName%2A> jedoch nicht dafür verglichen.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a value indicating whether the current encoding is always normalized.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a value indicating whether the current encoding is always normalized, using the default normalization form.</summary>
        <returns>
          <see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> is always normalized; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardformular für die Normalisierung wird <xref:System.Text.NormalizationForm.FormC>, die vollständigen kanonischen Zerlegung, gefolgt von der Austausch von Sequenzen mit ihren primären aus Komponenten zusammengesetzt, nach Möglichkeit verwendet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">One of the <see cref="T:System.Text.NormalizationForm" /> values.</param>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.</summary>
        <returns>
          <see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> object is always normalized using the specified <see cref="T:System.Text.NormalizationForm" /> value; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardformular für die Normalisierung wird <xref:System.Text.NormalizationForm.FormC>, die vollständigen kanonischen Zerlegung, gefolgt von der Austausch von Sequenzen mit ihren primären aus Komponenten zusammengesetzt, nach Möglichkeit verwendet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> von Browserclients verwendet werden kann, um Inhalt anzuzeigen, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel werden die Werte der booleschen Eigenschaften jeder Codierung überprüft.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> von Browserclients verwendet werden kann, um Inhalt zu speichern, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel werden die Werte der booleschen Eigenschaften jeder Codierung überprüft.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> von Mail- und Newsclients verwendet werden kann, um Inhalt anzuzeigen, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel werden die Werte der booleschen Eigenschaften jeder Codierung überprüft.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> von Mail- und Newsclients verwendet werden kann, um Inhalt zu speichern, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel werden die Werte der booleschen Eigenschaften jeder Codierung überprüft.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding is read-only.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> schreibgeschützt ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> Einzelbyte-Codepunkte verwendet, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für ein Einzelbyte-Codierung, z. B. <xref:System.Text.ASCIIEncoding>, ruft diese Eigenschaft `true`.  
  
> [!CAUTION]
>  Sie sollten darauf achten in Leistungsumfang von Ihrer Anwendung mit dem Wert für <xref:System.Text.Encoding.IsSingleByte%2A>. Eine Annahme, wie eine Codierung fortfährt, möglicherweise trotzdem falsch. Windows-1252 hat beispielsweise den Wert `true` für <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, aber Encoding.GetMaxByteCount (1) gibt 2 zurück. Dies ist, da die Methode potenzielle übrig gebliebene Surrogate aus einer vorherigen betrachtet.  
  
   
  
## Examples  
 Im folgende Beispiel werden die Werte der booleschen Eigenschaften jeder Codierung überprüft.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">A subclass of <see cref="T:System.Text.EncodingProvider" /> that provides access to additional character encodings.</param>
        <summary>Registers an encoding provider.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoding.RegisterProvider%2A> Methode ermöglicht Ihnen die Registrierung einer Klasse abgeleitet <xref:System.Text.EncodingProvider> , macht auf einer Plattform verfügbaren Codierungen Zeichen, die nicht anderweitig unterstützt werden. Sobald die codierungsanbieter registriert wurde, können die Codierungen, die er unterstützt abgerufen werden, durch das Aufrufen einer <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> überladen. Wenn es mehrere Codierung Anbieter sind, die <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> Methode versucht, zum Abrufen einer angegebenen Codierung aus jeder Anbieter, beginnend mit dem zuletzt registriert.

Registrieren einen codierungsanbieter mithilfe der <xref:System.Text.Encoding.RegisterProvider%2A> Methode ändert auch das Verhalten von der [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) und [EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) Methoden, die beim Übergeben eines Arguments der `0`:

- Wenn der registrierte Anbieter ist der <xref:System.Text.CodePagesEncodingProvider>, die Methode gibt die Codierung, die der Codepage des Systems active entspricht, wenn auf dem Windows-Betriebssystem ausgeführt wird.

- Eine benutzerdefinierte codierungsanbieter kann auswählen, welche Codierung beim Zurückgeben einer von beiden <xref:System.Text.Encoding.GetEncoding%2A> Überladungen der Methode wird ein Argument übergeben `0`. Der Anbieter nach Wunsch kann nicht zurückgegeben wird, eine Codierung durch die Verwendung der <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> -Methodenrückgabe `null`. 
  
 [!INCLUDE[net_v46](~/includes/net-v46-md.md)] enthält ein codierungsanbieter, <xref:System.Text.CodePagesEncodingProvider>, stellt die Codierungen, die im vollständigen .NET Framework vorhanden sind, jedoch sind nicht verfügbar in [!INCLUDE[net_v46](~/includes/net-v46-md.md)]. Standardmäßig [!INCLUDE[net_v46](~/includes/net-v46-md.md)] unterstützt nur die Unicode-Codierungen, die ASCII- und die Codepage 28591 entscheiden.  
  
 Wenn die gleiche Anbieter für die Codierung, in mehreren Aufrufen verwendet wird der <xref:System.Text.Encoding.RegisterProvider%2A> -Methode, nur der erste Methodenaufruf registriert den Anbieter. Nachfolgende Aufrufe werden ignoriert.  
  
 Wenn die <xref:System.Text.Encoding.RegisterProvider%2A> Methode wird aufgerufen, um mehrere Anbieter zu registrieren, die gleiche Codierung behandelt, der zuletzt registrierte Anbieter wird für alle Codierungs- und Decodierungsvorgängen verwendet. Zuvor registrierten Anbietern werden ignoriert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the UTF-16 format using the little endian byte order.</summary>
        <value>Eine Codierung für das UTF-16-Format mit Little-Endian-Bytereihenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informationen über die Codierungen, die von .NET Framework und eine Erläuterung der Unicode-Zeichen um zu verwendende Codierung unterstützt werden, finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Die <xref:System.Text.UnicodeEncoding> von dieser Eigenschaft zurückgegebene Objekt möglicherweise nicht das entsprechende Verhalten für Ihre app. Es verwendet einen Ersatzfallback ersetzt jede Zeichenfolge, die nicht codiert werden kann, und jedes Byte, die nicht decodiert werden können mit einem Fragezeichen ("?") Zeichen. Rufen Sie stattdessen die <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor zum Instanziieren einer little-Endian <xref:System.Text.UnicodeEncoding> Objekt, dessen Fallback handelt es sich um, eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the UTF-32 format using the little endian byte order.</summary>
        <value>Ein Codierungsobjekt für das UTF-32-Format mit Little-Endian-Bytereihenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.UTF32Encoding> von dieser Eigenschaft zurückgegebene Objekt möglicherweise nicht das entsprechende Verhalten für Ihre app. Ersatzfallback verwendet, um das Unicode-ERSATZZEICHEN (U + FFFE) ersetzt jede Zeichenfolge, die nicht codiert werden kann, und jedes Byte, die nicht decodiert werden können. Rufen Sie stattdessen die <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor zum Instanziieren einer <xref:System.Text.UTF32Encoding> Objekt, dessen Fallback handelt es sich um, eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Eine Erläuterung der little-endian-Bytereihenfolge, finden Sie unter der <xref:System.Text.Encoding> klassenthema.  
  
 Informationen über die Codierungen, die von .NET Framework und eine Erläuterung der Unicode-Zeichen um zu verwendende Codierung unterstützt werden, finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the UTF-7 format.</summary>
        <value>Eine Codierung für das UTF-7-Format.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 UTF-7-Codierung wird hauptsächlich in Umgebungen verwendet, die in der Vergangenheit, um 7 Bits, z. B. NNTP und einige e-Mail-Anwendungen eingeschränkt wurden. Aufgrund von Verbindungsproblemen mit Stabilität und Sicherheit sollten Sie nicht verwenden UTF7 Codierung in 8-Bit-Umgebungen, in dem UTF-8-Codierung anstelle kann verwendet werden.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the UTF-8 format.</summary>
        <value>Eine Codierung für das UTF-8-Format.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt ein <xref:System.Text.UTF8Encoding> Objekt, das Unicode (UTF-16-codierte) Zeichen in eine Folge von ein bis vier Bytes pro Zeichen codiert und, die ein UTF-8-codierte Bytearray in Unicode (UTF-16-codierte) Zeichen decodiert. Informationen zu zeichencodierungen, die von .NET Framework und eine Erläuterung der Unicode-Zeichen um zu verwendende Codierung unterstützt werden, finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Die <xref:System.Text.UTF8Encoding> von dieser Eigenschaft zurückgegebene Objekt möglicherweise nicht das entsprechende Verhalten für Ihre app.  
  
-   Es gibt eine <xref:System.Text.UTF8Encoding> Objekt, das eine Unicode-bytereihenfolgemarkierung (BOM) bereitstellt. Rufen Sie eine Überladung der zum Instanziieren einer UTF8-Codierung, die eine BOM nicht bereitstellt, die <xref:System.Text.UTF8Encoding.%23ctor%2A> Konstruktor.  
  
-   Gibt eine <xref:System.Text.UTF8Encoding> -Objekt, das verwendet einen Ersatzfallback ersetzt jede Zeichenfolge, die nicht codiert werden kann, und jedes Byte, die nicht decodiert werden können mit einem Fragezeichen ("?") Zeichen. Rufen Sie stattdessen die <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor zum Instanziieren einer <xref:System.Text.UTF8Encoding> Objekt, dessen Fallback handelt es sich um, eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>, wie das folgende Beispiel veranschaulicht.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 Das folgende Beispiel definiert ein Array, das die folgenden Zeichen besteht aus:  
  
-   KLEINES LATEINISCHES Z (U + 007A)  
  
-   KLEINE LATEINISCHE BUCHSTABEN EIN (U + 0061 IST)  
  
-   KOMBINIEREN VON BREVIS (U + 0306)  
  
-   KLEINES LATEINISCHES AE MIT AKUT (U + 01FD)  
  
-   GRIECHISCH BUCHSTABE BETA (U + 03B2)  
  
-   Ein Ersatzzeichenpaar (U + D800 U + DD54), die griechischen ACROPHONIC ATTIC ein TAUSENDERTRENNZEICHEN STATERS (U + 10154) bildet.  
  
 Es zeigt die UTF-16-Codeeinheiten jedes Zeichens und bestimmt die Anzahl der Bytes, die von einem UTF-8-Encoder zum Codieren der Zeichen erforderlich. Klicken Sie dann codiert die Zeichen, und die resultierenden UTF-8-codierten Bytes angezeigt.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.</summary>
        <value>Der IANA-Name für die aktuelle <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoding.WebName%2A> Eigenschaft ist identisch mit der <xref:System.Text.EncodingInfo.Name%2A> Eigenschaft.  
  
 Beachten Sie, dass <xref:System.Text.Encoding.WebName%2A> gibt einen IANA registrierten Namen für die Codierung zurück. Wenn der Wert der Name der Standard ist, kann die Implementierung der Codierung nicht vollständig dieses Standards entsprechen. Die <xref:System.Text.Encoding.HeaderName%2A> Eigenschaft definiert eine andere Codierung, die für e-Mail-Kopfzeilen besser geeignet sein könnte. Allerdings sollten die meisten apps verwenden <xref:System.Text.Encoding.WebName%2A> stattdessen.  
  
 Weitere Informationen zur IANA finden Sie unter [www.iana.org](https://www.iana.org/).  
  
 Die <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> ist identisch mit der <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> zurückgegebenes <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. Manche der Webnamen sind Duplikate; Siehe die Hinweise für <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> für Weitere Informationen.  
  
   
  
## Examples  
 Das folgende Beispiel schließt den <xref:System.Text.Encoding.WebName%2A> in einem HTML-Header.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 Im folgenden Beispiel ruft die verschiedenen Namen für jede Codierung ab und zeigt die Codierungen mit ein oder mehrere Namen, die von unterscheiden <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Es zeigt <xref:System.Text.Encoding.EncodingName%2A> jedoch nicht dafür verglichen.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.</summary>
        <value>Die Codepage des Betriebssystems Windows, die der aktuellen <see cref="T:System.Text.Encoding" /> am ehesten entspricht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird für die Kompatibilität mit Windows unterstützt mehrere Sprachen (MLang) APIs, z. B. zur Ermittlung von Schriftartfamilien. Für die Globalisierung wird die Verwendung eines Unicode-Codierungen stattdessen empfohlen. Es wird außerdem empfohlen, verwenden Sie <xref:System.Text.Encoding.WebName%2A> anstelle von <xref:System.Text.Encoding.WindowsCodePage%2A> um die Codepage zu identifizieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, die Windows-Codepage, die jeder Codierung am ehesten entspricht.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>