<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fbaa756388725dd57b042a6b27c2dd7fd8c3aec1" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75118775" /></Metadata><TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="1959a-101">Stellt eine Zeichencodierung dar.</span><span class="sxs-lookup"><span data-stu-id="1959a-101">Represents a character encoding.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-102">Beim Kodieren werden Unicode-Zeichen in eine Bytefolge transformiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-102">Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</span></span> <span data-ttu-id="1959a-103">Im Gegensatz dazu ist das Decodieren der Prozess der Transformation einer Sequenz codierter Bytes in eine Gruppe von Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-103">In contrast, decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</span></span> <span data-ttu-id="1959a-104">Informationen zu den Unicode-Transformations Formaten (UTFs) und anderen Codierungen, die von <xref:System.Text.Encoding>unterstützt werden, finden Sie unter [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="1959a-104">For information about the Unicode Transformation Formats (UTFs) and other encodings supported by <xref:System.Text.Encoding>, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>

 <span data-ttu-id="1959a-105">Beachten Sie, dass <xref:System.Text.Encoding> für die Verwendung von Unicode-Zeichen anstelle von willkürlichen Binärdaten (z. b. Byte Arrays) vorgesehen ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-105">Note that <xref:System.Text.Encoding> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="1959a-106">Wenn Sie beliebige Binärdaten in Text codieren müssen, sollten Sie ein Protokoll wie z. b. UUEncode verwenden, das von Methoden wie z. b. <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-106">If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="1959a-107">.Net bietet die folgenden Implementierungen der <xref:System.Text.Encoding>-Klasse, um aktuelle Unicode-Codierungen und andere Codierungen zu unterstützen:</span><span class="sxs-lookup"><span data-stu-id="1959a-107">.NET provides the following implementations of the <xref:System.Text.Encoding> class to support current Unicode encodings and other encodings:</span></span>

-   <span data-ttu-id="1959a-108"><xref:System.Text.ASCIIEncoding> Unicode-Zeichen als einzelne 7-Bit-ASCII-Zeichen codiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-108"><xref:System.Text.ASCIIEncoding> encodes Unicode characters as single 7-bit ASCII characters.</span></span> <span data-ttu-id="1959a-109">Diese Codierung unterstützt nur Zeichen Werte zwischen U + 0000 und u + 007F.</span><span class="sxs-lookup"><span data-stu-id="1959a-109">This encoding only supports character values between U+0000 and U+007F.</span></span> <span data-ttu-id="1959a-110">Codepage 20127.</span><span class="sxs-lookup"><span data-stu-id="1959a-110">Code page 20127.</span></span> <span data-ttu-id="1959a-111">Auch über die <xref:System.Text.Encoding.ASCII%2A>-Eigenschaft verfügbar.</span><span class="sxs-lookup"><span data-stu-id="1959a-111">Also available through the <xref:System.Text.Encoding.ASCII%2A> property.</span></span>

-   <span data-ttu-id="1959a-112"><xref:System.Text.UTF7Encoding> Unicode-Zeichen mithilfe der UTF-7-Codierung codiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-112"><xref:System.Text.UTF7Encoding> encodes Unicode characters using the UTF-7 encoding.</span></span> <span data-ttu-id="1959a-113">Diese Codierung unterstützt alle Unicode-Zeichen Werte.</span><span class="sxs-lookup"><span data-stu-id="1959a-113">This encoding supports all Unicode character values.</span></span> <span data-ttu-id="1959a-114">Codepage 65000.</span><span class="sxs-lookup"><span data-stu-id="1959a-114">Code page 65000.</span></span> <span data-ttu-id="1959a-115">Auch über die <xref:System.Text.Encoding.UTF7%2A>-Eigenschaft verfügbar.</span><span class="sxs-lookup"><span data-stu-id="1959a-115">Also available through the <xref:System.Text.Encoding.UTF7%2A> property.</span></span>

-   <span data-ttu-id="1959a-116"><xref:System.Text.UTF8Encoding> Unicode-Zeichen mithilfe der UTF-8-Codierung codiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-116"><xref:System.Text.UTF8Encoding> encodes Unicode characters using the UTF-8 encoding.</span></span> <span data-ttu-id="1959a-117">Diese Codierung unterstützt alle Unicode-Zeichen Werte.</span><span class="sxs-lookup"><span data-stu-id="1959a-117">This encoding supports all Unicode character values.</span></span> <span data-ttu-id="1959a-118">Codepage 65001.</span><span class="sxs-lookup"><span data-stu-id="1959a-118">Code page 65001.</span></span> <span data-ttu-id="1959a-119">Auch über die <xref:System.Text.Encoding.UTF8%2A>-Eigenschaft verfügbar.</span><span class="sxs-lookup"><span data-stu-id="1959a-119">Also available through the <xref:System.Text.Encoding.UTF8%2A> property.</span></span>

-   <span data-ttu-id="1959a-120"><xref:System.Text.UnicodeEncoding> Unicode-Zeichen mithilfe der UTF-16-Codierung codiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-120"><xref:System.Text.UnicodeEncoding> encodes Unicode characters using the UTF-16 encoding.</span></span> <span data-ttu-id="1959a-121">Sowohl Little-Endian-als auch Big-Endian-Byte Bestellungen werden unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-121">Both little endian and big endian byte orders are supported.</span></span> <span data-ttu-id="1959a-122">Auch über die <xref:System.Text.Encoding.Unicode%2A>-Eigenschaft und die <xref:System.Text.Encoding.BigEndianUnicode%2A>-Eigenschaft verfügbar.</span><span class="sxs-lookup"><span data-stu-id="1959a-122">Also available through the <xref:System.Text.Encoding.Unicode%2A> property and the <xref:System.Text.Encoding.BigEndianUnicode%2A> property.</span></span>

-   <span data-ttu-id="1959a-123"><xref:System.Text.UTF32Encoding> codiert Unicode-Zeichen mithilfe der UTF-32-Codierung.</span><span class="sxs-lookup"><span data-stu-id="1959a-123"><xref:System.Text.UTF32Encoding> encodes Unicode characters using the UTF-32 encoding.</span></span> <span data-ttu-id="1959a-124">Es werden sowohl kleine Endian-(Codepage 12000) als auch Big Endian-Byte Bestellungen (Codepage 12001) unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-124">Both little endian (code page 12000) and big endian (code page 12001) byte orders are supported.</span></span> <span data-ttu-id="1959a-125">Auch über die <xref:System.Text.Encoding.UTF32%2A>-Eigenschaft verfügbar.</span><span class="sxs-lookup"><span data-stu-id="1959a-125">Also available through the <xref:System.Text.Encoding.UTF32%2A> property.</span></span>

 <span data-ttu-id="1959a-126">Die <xref:System.Text.Encoding>-Klasse ist hauptsächlich für die Konvertierung zwischen verschiedenen Codierungen und Unicode vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="1959a-126">The <xref:System.Text.Encoding> class is primarily intended to convert between different encodings and Unicode.</span></span> <span data-ttu-id="1959a-127">Häufig ist eine der abgeleiteten Unicode-Klassen die richtige Wahl für Ihre APP.</span><span class="sxs-lookup"><span data-stu-id="1959a-127">Often one of the derived Unicode classes is the correct choice for your app.</span></span>

 <span data-ttu-id="1959a-128">Verwenden Sie die <xref:System.Text.Encoding.GetEncoding%2A>-Methode, um andere Codierungen abzurufen, und rufen Sie die <xref:System.Text.Encoding.GetEncodings%2A>-Methode auf, um eine Liste aller Codierungen abzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-128">Use the <xref:System.Text.Encoding.GetEncoding%2A> method to obtain other encodings, and call the <xref:System.Text.Encoding.GetEncodings%2A> method to get a list of all encodings.</span></span>

 <span data-ttu-id="1959a-129">In der folgenden Tabelle sind die Codierungen aufgelistet, die von .NET Framework und .net Core unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-129">The following table lists the encodings supported by .NET Framework and .NET Core.</span></span> <span data-ttu-id="1959a-130">Sie listet die Code Page Nummer jeder Codierung und die Werte der <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>-und <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> Eigenschaften der Codierung auf.</span><span class="sxs-lookup"><span data-stu-id="1959a-130">It lists each encoding's code page number and the values of the encoding's <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> and <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="1959a-131">Ein Häkchen in den Spalten **.NET Framework Support** und **.net Core-Unterstützung** gibt an, dass die Codepage unabhängig von der zugrunde liegenden Plattform nativ von der .NET-Implementierung unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-131">A check mark in the **.NET Framework support** and **.NET Core support** columns indicates that the code page is natively supported by that .NET implementation, regardless of the underlying platform.</span></span> <span data-ttu-id="1959a-132">Für .NET Framework hängt die Verfügbarkeit anderer Codierungen, die in der Tabelle aufgelistet sind, vom Betriebssystem ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-132">For .NET Framework, the availability of other encodings listed in the table depends on the operating system.</span></span> <span data-ttu-id="1959a-133">Für .net Core sind andere Codierungen verfügbar, indem die <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType>-Klasse oder die Ableitung von der <xref:System.Text.EncodingProvider?displayProperty=nameWithType>-Klasse verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-133">For .NET Core, other encodings are available by using the <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> class or by deriving from the <xref:System.Text.EncodingProvider?displayProperty=nameWithType> class.</span></span>

> [!NOTE]
> <span data-ttu-id="1959a-134">Codepages, deren <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>-Eigenschaft einem internationalen Standard entspricht, entsprechen nicht notwendigerweise vollständig dem Standard.</span><span class="sxs-lookup"><span data-stu-id="1959a-134">Code pages whose <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> property corresponds to an international standard do not necessarily comply in full with that standard.</span></span>

|<span data-ttu-id="1959a-135">Codepage</span><span class="sxs-lookup"><span data-stu-id="1959a-135">Code page</span></span>|<span data-ttu-id="1959a-136">Name</span><span class="sxs-lookup"><span data-stu-id="1959a-136">Name</span></span>|<span data-ttu-id="1959a-137">Anzeigename</span><span class="sxs-lookup"><span data-stu-id="1959a-137">Display name</span></span>|<span data-ttu-id="1959a-138">.NET Framework Unterstützung</span><span class="sxs-lookup"><span data-stu-id="1959a-138">.NET Framework support</span></span>| <span data-ttu-id="1959a-139">.NET Core-Unterstützung</span><span class="sxs-lookup"><span data-stu-id="1959a-139">.NET Core support</span></span> |
|---------|----|------------|----------------------|-------------------|
|<span data-ttu-id="1959a-140">37</span><span class="sxs-lookup"><span data-stu-id="1959a-140">37</span></span>|<span data-ttu-id="1959a-141">IBM037</span><span class="sxs-lookup"><span data-stu-id="1959a-141">IBM037</span></span>|<span data-ttu-id="1959a-142">IBM EBCDIC (USA-Kanada)</span><span class="sxs-lookup"><span data-stu-id="1959a-142">IBM EBCDIC (US-Canada)</span></span>|||
|<span data-ttu-id="1959a-143">437</span><span class="sxs-lookup"><span data-stu-id="1959a-143">437</span></span>|<span data-ttu-id="1959a-144">IBM437</span><span class="sxs-lookup"><span data-stu-id="1959a-144">IBM437</span></span>|<span data-ttu-id="1959a-145">OEM-USA</span><span class="sxs-lookup"><span data-stu-id="1959a-145">OEM United States</span></span>|||
|<span data-ttu-id="1959a-146">500</span><span class="sxs-lookup"><span data-stu-id="1959a-146">500</span></span>|<span data-ttu-id="1959a-147">IBM500</span><span class="sxs-lookup"><span data-stu-id="1959a-147">IBM500</span></span>|<span data-ttu-id="1959a-148">IBM EBCDIC (International)</span><span class="sxs-lookup"><span data-stu-id="1959a-148">IBM EBCDIC (International)</span></span>|||
|<span data-ttu-id="1959a-149">708</span><span class="sxs-lookup"><span data-stu-id="1959a-149">708</span></span>|<span data-ttu-id="1959a-150">ASMO-708</span><span class="sxs-lookup"><span data-stu-id="1959a-150">ASMO-708</span></span>|<span data-ttu-id="1959a-151">Arabisch (ASMO 708)</span><span class="sxs-lookup"><span data-stu-id="1959a-151">Arabic (ASMO 708)</span></span>|||
|<span data-ttu-id="1959a-152">720</span><span class="sxs-lookup"><span data-stu-id="1959a-152">720</span></span>|<span data-ttu-id="1959a-153">DOS-720</span><span class="sxs-lookup"><span data-stu-id="1959a-153">DOS-720</span></span>|<span data-ttu-id="1959a-154">Arabisch (DOS)</span><span class="sxs-lookup"><span data-stu-id="1959a-154">Arabic (DOS)</span></span>|||
|<span data-ttu-id="1959a-155">737</span><span class="sxs-lookup"><span data-stu-id="1959a-155">737</span></span>|<span data-ttu-id="1959a-156">ibm737</span><span class="sxs-lookup"><span data-stu-id="1959a-156">ibm737</span></span>|<span data-ttu-id="1959a-157">Griechisch (DOS)</span><span class="sxs-lookup"><span data-stu-id="1959a-157">Greek (DOS)</span></span>|||
|<span data-ttu-id="1959a-158">775</span><span class="sxs-lookup"><span data-stu-id="1959a-158">775</span></span>|<span data-ttu-id="1959a-159">ibm775</span><span class="sxs-lookup"><span data-stu-id="1959a-159">ibm775</span></span>|<span data-ttu-id="1959a-160">Baltisch (DOS)</span><span class="sxs-lookup"><span data-stu-id="1959a-160">Baltic (DOS)</span></span>|||
|<span data-ttu-id="1959a-161">850</span><span class="sxs-lookup"><span data-stu-id="1959a-161">850</span></span>|<span data-ttu-id="1959a-162">ibm850</span><span class="sxs-lookup"><span data-stu-id="1959a-162">ibm850</span></span>|<span data-ttu-id="1959a-163">Westeuropäisch (DOS)</span><span class="sxs-lookup"><span data-stu-id="1959a-163">Western European (DOS)</span></span>|||
|<span data-ttu-id="1959a-164">852</span><span class="sxs-lookup"><span data-stu-id="1959a-164">852</span></span>|<span data-ttu-id="1959a-165">ibm852</span><span class="sxs-lookup"><span data-stu-id="1959a-165">ibm852</span></span>|<span data-ttu-id="1959a-166">Mitteleuropäisch (DOS)</span><span class="sxs-lookup"><span data-stu-id="1959a-166">Central European (DOS)</span></span>|||
|<span data-ttu-id="1959a-167">855</span><span class="sxs-lookup"><span data-stu-id="1959a-167">855</span></span>|<span data-ttu-id="1959a-168">IBM855</span><span class="sxs-lookup"><span data-stu-id="1959a-168">IBM855</span></span>|<span data-ttu-id="1959a-169">OEM-Kyrillisch</span><span class="sxs-lookup"><span data-stu-id="1959a-169">OEM Cyrillic</span></span>|||
|<span data-ttu-id="1959a-170">857</span><span class="sxs-lookup"><span data-stu-id="1959a-170">857</span></span>|<span data-ttu-id="1959a-171">ibm857</span><span class="sxs-lookup"><span data-stu-id="1959a-171">ibm857</span></span>|<span data-ttu-id="1959a-172">Türkisch (DOS)</span><span class="sxs-lookup"><span data-stu-id="1959a-172">Turkish (DOS)</span></span>|||
|<span data-ttu-id="1959a-173">858</span><span class="sxs-lookup"><span data-stu-id="1959a-173">858</span></span>|<span data-ttu-id="1959a-174">IBM00858</span><span class="sxs-lookup"><span data-stu-id="1959a-174">IBM00858</span></span>|<span data-ttu-id="1959a-175">OEM-mehrsprachige lateinische I</span><span class="sxs-lookup"><span data-stu-id="1959a-175">OEM Multilingual Latin I</span></span>|||
|<span data-ttu-id="1959a-176">860</span><span class="sxs-lookup"><span data-stu-id="1959a-176">860</span></span>|<span data-ttu-id="1959a-177">IBM860</span><span class="sxs-lookup"><span data-stu-id="1959a-177">IBM860</span></span>|<span data-ttu-id="1959a-178">Portugiesisch (DOS)</span><span class="sxs-lookup"><span data-stu-id="1959a-178">Portuguese (DOS)</span></span>|||
|<span data-ttu-id="1959a-179">861</span><span class="sxs-lookup"><span data-stu-id="1959a-179">861</span></span>|<span data-ttu-id="1959a-180">ibm861</span><span class="sxs-lookup"><span data-stu-id="1959a-180">ibm861</span></span>|<span data-ttu-id="1959a-181">Isländisch (DOS)</span><span class="sxs-lookup"><span data-stu-id="1959a-181">Icelandic (DOS)</span></span>|||
|<span data-ttu-id="1959a-182">862</span><span class="sxs-lookup"><span data-stu-id="1959a-182">862</span></span>|<span data-ttu-id="1959a-183">DOS-862</span><span class="sxs-lookup"><span data-stu-id="1959a-183">DOS-862</span></span>|<span data-ttu-id="1959a-184">Hebräisch (DOS)</span><span class="sxs-lookup"><span data-stu-id="1959a-184">Hebrew (DOS)</span></span>|||
|<span data-ttu-id="1959a-185">863</span><span class="sxs-lookup"><span data-stu-id="1959a-185">863</span></span>|<span data-ttu-id="1959a-186">IBM863</span><span class="sxs-lookup"><span data-stu-id="1959a-186">IBM863</span></span>|<span data-ttu-id="1959a-187">Französisch (Kanada)</span><span class="sxs-lookup"><span data-stu-id="1959a-187">French Canadian (DOS)</span></span>|||
|<span data-ttu-id="1959a-188">864</span><span class="sxs-lookup"><span data-stu-id="1959a-188">864</span></span>|<span data-ttu-id="1959a-189">IBM864</span><span class="sxs-lookup"><span data-stu-id="1959a-189">IBM864</span></span>|<span data-ttu-id="1959a-190">Arabisch (864)</span><span class="sxs-lookup"><span data-stu-id="1959a-190">Arabic (864)</span></span>|||
|<span data-ttu-id="1959a-191">865</span><span class="sxs-lookup"><span data-stu-id="1959a-191">865</span></span>|<span data-ttu-id="1959a-192">IBM865</span><span class="sxs-lookup"><span data-stu-id="1959a-192">IBM865</span></span>|<span data-ttu-id="1959a-193">Nordisch (DOS)</span><span class="sxs-lookup"><span data-stu-id="1959a-193">Nordic (DOS)</span></span>|||
|<span data-ttu-id="1959a-194">866</span><span class="sxs-lookup"><span data-stu-id="1959a-194">866</span></span>|<span data-ttu-id="1959a-195">cp866</span><span class="sxs-lookup"><span data-stu-id="1959a-195">cp866</span></span>|<span data-ttu-id="1959a-196">Kyrillisch (DOS)</span><span class="sxs-lookup"><span data-stu-id="1959a-196">Cyrillic (DOS)</span></span>|||
|<span data-ttu-id="1959a-197">869</span><span class="sxs-lookup"><span data-stu-id="1959a-197">869</span></span>|<span data-ttu-id="1959a-198">ibm869</span><span class="sxs-lookup"><span data-stu-id="1959a-198">ibm869</span></span>|<span data-ttu-id="1959a-199">Griechisch, modern (DOS)</span><span class="sxs-lookup"><span data-stu-id="1959a-199">Greek, Modern (DOS)</span></span>|||
|<span data-ttu-id="1959a-200">870</span><span class="sxs-lookup"><span data-stu-id="1959a-200">870</span></span>|<span data-ttu-id="1959a-201">IBM870</span><span class="sxs-lookup"><span data-stu-id="1959a-201">IBM870</span></span>|<span data-ttu-id="1959a-202">IBM EBCDIC (mehrsprachige lateinische-2)</span><span class="sxs-lookup"><span data-stu-id="1959a-202">IBM EBCDIC (Multilingual Latin-2)</span></span>|||
|<span data-ttu-id="1959a-203">874</span><span class="sxs-lookup"><span data-stu-id="1959a-203">874</span></span>|<span data-ttu-id="1959a-204">windows-874</span><span class="sxs-lookup"><span data-stu-id="1959a-204">windows-874</span></span>|<span data-ttu-id="1959a-205">Thailändisch (Windows)</span><span class="sxs-lookup"><span data-stu-id="1959a-205">Thai (Windows)</span></span>|||
|<span data-ttu-id="1959a-206">875</span><span class="sxs-lookup"><span data-stu-id="1959a-206">875</span></span>|<span data-ttu-id="1959a-207">cp875</span><span class="sxs-lookup"><span data-stu-id="1959a-207">cp875</span></span>|<span data-ttu-id="1959a-208">IBM EBCDIC (griechisch modern)</span><span class="sxs-lookup"><span data-stu-id="1959a-208">IBM EBCDIC (Greek Modern)</span></span>|||
|<span data-ttu-id="1959a-209">932</span><span class="sxs-lookup"><span data-stu-id="1959a-209">932</span></span>|<span data-ttu-id="1959a-210">shift_jis</span><span class="sxs-lookup"><span data-stu-id="1959a-210">shift_jis</span></span>|<span data-ttu-id="1959a-211">Japanisch (Shift-JIS)</span><span class="sxs-lookup"><span data-stu-id="1959a-211">Japanese (Shift-JIS)</span></span>|||
|<span data-ttu-id="1959a-212">936</span><span class="sxs-lookup"><span data-stu-id="1959a-212">936</span></span>|<span data-ttu-id="1959a-213">gb2312</span><span class="sxs-lookup"><span data-stu-id="1959a-213">gb2312</span></span>|<span data-ttu-id="1959a-214">Chinesisch vereinfacht (GB2312)</span><span class="sxs-lookup"><span data-stu-id="1959a-214">Chinese Simplified (GB2312)</span></span>|<span data-ttu-id="1959a-215">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-215">✓</span></span>||
|<span data-ttu-id="1959a-216">949</span><span class="sxs-lookup"><span data-stu-id="1959a-216">949</span></span>|<span data-ttu-id="1959a-217">ks_c_5601-1987</span><span class="sxs-lookup"><span data-stu-id="1959a-217">ks_c_5601-1987</span></span>|<span data-ttu-id="1959a-218">Koreanisch</span><span class="sxs-lookup"><span data-stu-id="1959a-218">Korean</span></span>|||
|<span data-ttu-id="1959a-219">950</span><span class="sxs-lookup"><span data-stu-id="1959a-219">950</span></span>|<span data-ttu-id="1959a-220">Big5</span><span class="sxs-lookup"><span data-stu-id="1959a-220">big5</span></span>|<span data-ttu-id="1959a-221">Chinesisch traditionell (Big5)</span><span class="sxs-lookup"><span data-stu-id="1959a-221">Chinese Traditional (Big5)</span></span>|||
|<span data-ttu-id="1959a-222">1026</span><span class="sxs-lookup"><span data-stu-id="1959a-222">1026</span></span>|<span data-ttu-id="1959a-223">IBM1026</span><span class="sxs-lookup"><span data-stu-id="1959a-223">IBM1026</span></span>|<span data-ttu-id="1959a-224">IBM EBCDIC (Türkisch (lateinisch-5)</span><span class="sxs-lookup"><span data-stu-id="1959a-224">IBM EBCDIC (Turkish Latin-5)</span></span>|||
|<span data-ttu-id="1959a-225">1047</span><span class="sxs-lookup"><span data-stu-id="1959a-225">1047</span></span>|<span data-ttu-id="1959a-226">IBM01047</span><span class="sxs-lookup"><span data-stu-id="1959a-226">IBM01047</span></span>|<span data-ttu-id="1959a-227">IBM Latin-1</span><span class="sxs-lookup"><span data-stu-id="1959a-227">IBM Latin-1</span></span>|||
|<span data-ttu-id="1959a-228">1140</span><span class="sxs-lookup"><span data-stu-id="1959a-228">1140</span></span>|<span data-ttu-id="1959a-229">IBM01140</span><span class="sxs-lookup"><span data-stu-id="1959a-229">IBM01140</span></span>|<span data-ttu-id="1959a-230">IBM EBCDIC (USA-Kanada-Euro)</span><span class="sxs-lookup"><span data-stu-id="1959a-230">IBM EBCDIC (US-Canada-Euro)</span></span>|||
|<span data-ttu-id="1959a-231">1141</span><span class="sxs-lookup"><span data-stu-id="1959a-231">1141</span></span>|<span data-ttu-id="1959a-232">IBM01141</span><span class="sxs-lookup"><span data-stu-id="1959a-232">IBM01141</span></span>|<span data-ttu-id="1959a-233">IBM EBCDIC (Deutschland-Euro)</span><span class="sxs-lookup"><span data-stu-id="1959a-233">IBM EBCDIC (Germany-Euro)</span></span>|||
|<span data-ttu-id="1959a-234">1142</span><span class="sxs-lookup"><span data-stu-id="1959a-234">1142</span></span>|<span data-ttu-id="1959a-235">IBM01142</span><span class="sxs-lookup"><span data-stu-id="1959a-235">IBM01142</span></span>|<span data-ttu-id="1959a-236">IBM EBCDIC (Dänemark-Norwegen-Euro)</span><span class="sxs-lookup"><span data-stu-id="1959a-236">IBM EBCDIC (Denmark-Norway-Euro)</span></span>|||
|<span data-ttu-id="1959a-237">1143</span><span class="sxs-lookup"><span data-stu-id="1959a-237">1143</span></span>|<span data-ttu-id="1959a-238">IBM01143</span><span class="sxs-lookup"><span data-stu-id="1959a-238">IBM01143</span></span>|<span data-ttu-id="1959a-239">IBM EBCDIC (Finnland-Schweden-Euro)</span><span class="sxs-lookup"><span data-stu-id="1959a-239">IBM EBCDIC (Finland-Sweden-Euro)</span></span>|||
|<span data-ttu-id="1959a-240">1144</span><span class="sxs-lookup"><span data-stu-id="1959a-240">1144</span></span>|<span data-ttu-id="1959a-241">IBM01144</span><span class="sxs-lookup"><span data-stu-id="1959a-241">IBM01144</span></span>|<span data-ttu-id="1959a-242">IBM EBCDIC (Italien-Euro)</span><span class="sxs-lookup"><span data-stu-id="1959a-242">IBM EBCDIC (Italy-Euro)</span></span>|||
|<span data-ttu-id="1959a-243">1145</span><span class="sxs-lookup"><span data-stu-id="1959a-243">1145</span></span>|<span data-ttu-id="1959a-244">IBM01145</span><span class="sxs-lookup"><span data-stu-id="1959a-244">IBM01145</span></span>|<span data-ttu-id="1959a-245">IBM EBCDIC (Spanien-Euro)</span><span class="sxs-lookup"><span data-stu-id="1959a-245">IBM EBCDIC (Spain-Euro)</span></span>|||
|<span data-ttu-id="1959a-246">1146</span><span class="sxs-lookup"><span data-stu-id="1959a-246">1146</span></span>|<span data-ttu-id="1959a-247">IBM01146</span><span class="sxs-lookup"><span data-stu-id="1959a-247">IBM01146</span></span>|<span data-ttu-id="1959a-248">IBM EBCDIC (UK-Euro)</span><span class="sxs-lookup"><span data-stu-id="1959a-248">IBM EBCDIC (UK-Euro)</span></span>|||
|<span data-ttu-id="1959a-249">1147</span><span class="sxs-lookup"><span data-stu-id="1959a-249">1147</span></span>|<span data-ttu-id="1959a-250">IBM01147</span><span class="sxs-lookup"><span data-stu-id="1959a-250">IBM01147</span></span>|<span data-ttu-id="1959a-251">IBM EBCDIC (Frankreich-Euro)</span><span class="sxs-lookup"><span data-stu-id="1959a-251">IBM EBCDIC (France-Euro)</span></span>|||
|<span data-ttu-id="1959a-252">1148</span><span class="sxs-lookup"><span data-stu-id="1959a-252">1148</span></span>|<span data-ttu-id="1959a-253">IBM01148</span><span class="sxs-lookup"><span data-stu-id="1959a-253">IBM01148</span></span>|<span data-ttu-id="1959a-254">IBM EBCDIC (International-Euro)</span><span class="sxs-lookup"><span data-stu-id="1959a-254">IBM EBCDIC (International-Euro)</span></span>|||
|<span data-ttu-id="1959a-255">1149</span><span class="sxs-lookup"><span data-stu-id="1959a-255">1149</span></span>|<span data-ttu-id="1959a-256">IBM01149</span><span class="sxs-lookup"><span data-stu-id="1959a-256">IBM01149</span></span>|<span data-ttu-id="1959a-257">IBM EBCDIC (Isländisch-Euro)</span><span class="sxs-lookup"><span data-stu-id="1959a-257">IBM EBCDIC (Icelandic-Euro)</span></span>|||
|<span data-ttu-id="1959a-258">1200</span><span class="sxs-lookup"><span data-stu-id="1959a-258">1200</span></span>|<span data-ttu-id="1959a-259">UTF-16</span><span class="sxs-lookup"><span data-stu-id="1959a-259">utf-16</span></span>|<span data-ttu-id="1959a-260">Unicode</span><span class="sxs-lookup"><span data-stu-id="1959a-260">Unicode</span></span>|<span data-ttu-id="1959a-261">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-261">✓</span></span>|<span data-ttu-id="1959a-262">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-262">✓</span></span>|
|<span data-ttu-id="1959a-263">1201</span><span class="sxs-lookup"><span data-stu-id="1959a-263">1201</span></span>|<span data-ttu-id="1959a-264">unicodeFFFE</span><span class="sxs-lookup"><span data-stu-id="1959a-264">unicodeFFFE</span></span>|<span data-ttu-id="1959a-265">Unicode (Big-tedian)</span><span class="sxs-lookup"><span data-stu-id="1959a-265">Unicode (Big endian)</span></span>|<span data-ttu-id="1959a-266">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-266">✓</span></span>|<span data-ttu-id="1959a-267">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-267">✓</span></span>|
|<span data-ttu-id="1959a-268">1250</span><span class="sxs-lookup"><span data-stu-id="1959a-268">1250</span></span>|<span data-ttu-id="1959a-269">windows-1250</span><span class="sxs-lookup"><span data-stu-id="1959a-269">windows-1250</span></span>|<span data-ttu-id="1959a-270">Mitteleuropäisch (Windows)</span><span class="sxs-lookup"><span data-stu-id="1959a-270">Central European (Windows)</span></span>|||
|<span data-ttu-id="1959a-271">1251</span><span class="sxs-lookup"><span data-stu-id="1959a-271">1251</span></span>|<span data-ttu-id="1959a-272">windows-1251</span><span class="sxs-lookup"><span data-stu-id="1959a-272">windows-1251</span></span>|<span data-ttu-id="1959a-273">Kyrillisch (Windows)</span><span class="sxs-lookup"><span data-stu-id="1959a-273">Cyrillic (Windows)</span></span>|||
|<span data-ttu-id="1959a-274">1252</span><span class="sxs-lookup"><span data-stu-id="1959a-274">1252</span></span>|<span data-ttu-id="1959a-275">Windows-1252</span><span class="sxs-lookup"><span data-stu-id="1959a-275">Windows-1252</span></span>|<span data-ttu-id="1959a-276">Westeuropäisch (Windows)</span><span class="sxs-lookup"><span data-stu-id="1959a-276">Western European (Windows)</span></span>|<span data-ttu-id="1959a-277">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-277">✓</span></span>||
|<span data-ttu-id="1959a-278">1253</span><span class="sxs-lookup"><span data-stu-id="1959a-278">1253</span></span>|<span data-ttu-id="1959a-279">windows-1253</span><span class="sxs-lookup"><span data-stu-id="1959a-279">windows-1253</span></span>|<span data-ttu-id="1959a-280">Griechisch (Windows)</span><span class="sxs-lookup"><span data-stu-id="1959a-280">Greek (Windows)</span></span>|||
|<span data-ttu-id="1959a-281">1254</span><span class="sxs-lookup"><span data-stu-id="1959a-281">1254</span></span>|<span data-ttu-id="1959a-282">windows-1254</span><span class="sxs-lookup"><span data-stu-id="1959a-282">windows-1254</span></span>|<span data-ttu-id="1959a-283">Türkisch (Windows)</span><span class="sxs-lookup"><span data-stu-id="1959a-283">Turkish (Windows)</span></span>|||
|<span data-ttu-id="1959a-284">1255</span><span class="sxs-lookup"><span data-stu-id="1959a-284">1255</span></span>|<span data-ttu-id="1959a-285">windows-1255</span><span class="sxs-lookup"><span data-stu-id="1959a-285">windows-1255</span></span>|<span data-ttu-id="1959a-286">Hebräisch (Windows)</span><span class="sxs-lookup"><span data-stu-id="1959a-286">Hebrew (Windows)</span></span>|||
|<span data-ttu-id="1959a-287">1256</span><span class="sxs-lookup"><span data-stu-id="1959a-287">1256</span></span>|<span data-ttu-id="1959a-288">windows-1256</span><span class="sxs-lookup"><span data-stu-id="1959a-288">windows-1256</span></span>|<span data-ttu-id="1959a-289">Arabisch (Windows)</span><span class="sxs-lookup"><span data-stu-id="1959a-289">Arabic (Windows)</span></span>|||
|<span data-ttu-id="1959a-290">1257</span><span class="sxs-lookup"><span data-stu-id="1959a-290">1257</span></span>|<span data-ttu-id="1959a-291">windows-1257</span><span class="sxs-lookup"><span data-stu-id="1959a-291">windows-1257</span></span>|<span data-ttu-id="1959a-292">Baltisch (Windows)</span><span class="sxs-lookup"><span data-stu-id="1959a-292">Baltic (Windows)</span></span>|||
|<span data-ttu-id="1959a-293">1258</span><span class="sxs-lookup"><span data-stu-id="1959a-293">1258</span></span>|<span data-ttu-id="1959a-294">windows-1258</span><span class="sxs-lookup"><span data-stu-id="1959a-294">windows-1258</span></span>|<span data-ttu-id="1959a-295">Vietnamesisch (Windows)</span><span class="sxs-lookup"><span data-stu-id="1959a-295">Vietnamese (Windows)</span></span>|||
|<span data-ttu-id="1959a-296">1361</span><span class="sxs-lookup"><span data-stu-id="1959a-296">1361</span></span>|<span data-ttu-id="1959a-297">Johab</span><span class="sxs-lookup"><span data-stu-id="1959a-297">Johab</span></span>|<span data-ttu-id="1959a-298">Koreanisch (Johab)</span><span class="sxs-lookup"><span data-stu-id="1959a-298">Korean (Johab)</span></span>|||
|<span data-ttu-id="1959a-299">10.000</span><span class="sxs-lookup"><span data-stu-id="1959a-299">10000</span></span>|<span data-ttu-id="1959a-300">Macintosh</span><span class="sxs-lookup"><span data-stu-id="1959a-300">macintosh</span></span>|<span data-ttu-id="1959a-301">Westeuropäisch (Mac)</span><span class="sxs-lookup"><span data-stu-id="1959a-301">Western European (Mac)</span></span>|||
|<span data-ttu-id="1959a-302">10001</span><span class="sxs-lookup"><span data-stu-id="1959a-302">10001</span></span>|<span data-ttu-id="1959a-303">x-Mac-Japanisch</span><span class="sxs-lookup"><span data-stu-id="1959a-303">x-mac-japanese</span></span>|<span data-ttu-id="1959a-304">Japanisch (Mac)</span><span class="sxs-lookup"><span data-stu-id="1959a-304">Japanese (Mac)</span></span>|||
|<span data-ttu-id="1959a-305">10002</span><span class="sxs-lookup"><span data-stu-id="1959a-305">10002</span></span>|<span data-ttu-id="1959a-306">x-mac-chinesetrad</span><span class="sxs-lookup"><span data-stu-id="1959a-306">x-mac-chinesetrad</span></span>|<span data-ttu-id="1959a-307">Chinesisch (traditionell) (Mac)</span><span class="sxs-lookup"><span data-stu-id="1959a-307">Chinese Traditional (Mac)</span></span>|||
|<span data-ttu-id="1959a-308">10003</span><span class="sxs-lookup"><span data-stu-id="1959a-308">10003</span></span>|<span data-ttu-id="1959a-309">x-Mac-Koreanisch</span><span class="sxs-lookup"><span data-stu-id="1959a-309">x-mac-korean</span></span>|<span data-ttu-id="1959a-310">Koreanisch (Mac)</span><span class="sxs-lookup"><span data-stu-id="1959a-310">Korean (Mac)</span></span>|<span data-ttu-id="1959a-311">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-311">✓</span></span>||
|<span data-ttu-id="1959a-312">10004</span><span class="sxs-lookup"><span data-stu-id="1959a-312">10004</span></span>|<span data-ttu-id="1959a-313">x-Mac-Arabisch</span><span class="sxs-lookup"><span data-stu-id="1959a-313">x-mac-arabic</span></span>|<span data-ttu-id="1959a-314">Arabisch (Mac)</span><span class="sxs-lookup"><span data-stu-id="1959a-314">Arabic (Mac)</span></span>|||
|<span data-ttu-id="1959a-315">10005</span><span class="sxs-lookup"><span data-stu-id="1959a-315">10005</span></span>|<span data-ttu-id="1959a-316">x-Mac-Hebräisch</span><span class="sxs-lookup"><span data-stu-id="1959a-316">x-mac-hebrew</span></span>|<span data-ttu-id="1959a-317">Hebräisch (Mac)</span><span class="sxs-lookup"><span data-stu-id="1959a-317">Hebrew (Mac)</span></span>|||
|<span data-ttu-id="1959a-318">10006</span><span class="sxs-lookup"><span data-stu-id="1959a-318">10006</span></span>|<span data-ttu-id="1959a-319">x-Mac-Griechisch</span><span class="sxs-lookup"><span data-stu-id="1959a-319">x-mac-greek</span></span>|<span data-ttu-id="1959a-320">Griechisch (Mac)</span><span class="sxs-lookup"><span data-stu-id="1959a-320">Greek (Mac)</span></span>|||
|<span data-ttu-id="1959a-321">10007</span><span class="sxs-lookup"><span data-stu-id="1959a-321">10007</span></span>|<span data-ttu-id="1959a-322">x-Mac-Kyrillisch</span><span class="sxs-lookup"><span data-stu-id="1959a-322">x-mac-cyrillic</span></span>|<span data-ttu-id="1959a-323">Kyrillisch (Mac)</span><span class="sxs-lookup"><span data-stu-id="1959a-323">Cyrillic (Mac)</span></span>|||
|<span data-ttu-id="1959a-324">10008</span><span class="sxs-lookup"><span data-stu-id="1959a-324">10008</span></span>|<span data-ttu-id="1959a-325">x-Mac-chinesesimp</span><span class="sxs-lookup"><span data-stu-id="1959a-325">x-mac-chinesesimp</span></span>|<span data-ttu-id="1959a-326">Chinesisch vereinfacht (Mac)</span><span class="sxs-lookup"><span data-stu-id="1959a-326">Chinese Simplified (Mac)</span></span>|<span data-ttu-id="1959a-327">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-327">✓</span></span>||
|<span data-ttu-id="1959a-328">10010</span><span class="sxs-lookup"><span data-stu-id="1959a-328">10010</span></span>|<span data-ttu-id="1959a-329">x-Mac-Rumänisch</span><span class="sxs-lookup"><span data-stu-id="1959a-329">x-mac-romanian</span></span>|<span data-ttu-id="1959a-330">Rumänisch (Mac)</span><span class="sxs-lookup"><span data-stu-id="1959a-330">Romanian (Mac)</span></span>|||
|<span data-ttu-id="1959a-331">10017</span><span class="sxs-lookup"><span data-stu-id="1959a-331">10017</span></span>|<span data-ttu-id="1959a-332">x-Mac-Ukrainisch</span><span class="sxs-lookup"><span data-stu-id="1959a-332">x-mac-ukrainian</span></span>|<span data-ttu-id="1959a-333">Ukrainisch (Mac)</span><span class="sxs-lookup"><span data-stu-id="1959a-333">Ukrainian (Mac)</span></span>|||
|<span data-ttu-id="1959a-334">10021</span><span class="sxs-lookup"><span data-stu-id="1959a-334">10021</span></span>|<span data-ttu-id="1959a-335">x-Mac-Thai</span><span class="sxs-lookup"><span data-stu-id="1959a-335">x-mac-thai</span></span>|<span data-ttu-id="1959a-336">Thailändisch (Mac)</span><span class="sxs-lookup"><span data-stu-id="1959a-336">Thai (Mac)</span></span>|||
|<span data-ttu-id="1959a-337">10029</span><span class="sxs-lookup"><span data-stu-id="1959a-337">10029</span></span>|<span data-ttu-id="1959a-338">x-Mac-CE</span><span class="sxs-lookup"><span data-stu-id="1959a-338">x-mac-ce</span></span>|<span data-ttu-id="1959a-339">Mitteleuropäisch (Mac)</span><span class="sxs-lookup"><span data-stu-id="1959a-339">Central European (Mac)</span></span>|||
|<span data-ttu-id="1959a-340">10079</span><span class="sxs-lookup"><span data-stu-id="1959a-340">10079</span></span>|<span data-ttu-id="1959a-341">x-Mac-Isländisch</span><span class="sxs-lookup"><span data-stu-id="1959a-341">x-mac-icelandic</span></span>|<span data-ttu-id="1959a-342">Isländisch (Mac)</span><span class="sxs-lookup"><span data-stu-id="1959a-342">Icelandic (Mac)</span></span>|||
|<span data-ttu-id="1959a-343">10081</span><span class="sxs-lookup"><span data-stu-id="1959a-343">10081</span></span>|<span data-ttu-id="1959a-344">x-Mac-Türkisch</span><span class="sxs-lookup"><span data-stu-id="1959a-344">x-mac-turkish</span></span>|<span data-ttu-id="1959a-345">Türkisch (Mac)</span><span class="sxs-lookup"><span data-stu-id="1959a-345">Turkish (Mac)</span></span>|||
|<span data-ttu-id="1959a-346">10082</span><span class="sxs-lookup"><span data-stu-id="1959a-346">10082</span></span>|<span data-ttu-id="1959a-347">x-Mac-Kroatisch</span><span class="sxs-lookup"><span data-stu-id="1959a-347">x-mac-croatian</span></span>|<span data-ttu-id="1959a-348">Kroatisch (Mac)</span><span class="sxs-lookup"><span data-stu-id="1959a-348">Croatian (Mac)</span></span>|||
|<span data-ttu-id="1959a-349">12000</span><span class="sxs-lookup"><span data-stu-id="1959a-349">12000</span></span>|<span data-ttu-id="1959a-350">UTF-32</span><span class="sxs-lookup"><span data-stu-id="1959a-350">utf-32</span></span>|<span data-ttu-id="1959a-351">Unicode (UTF-32)</span><span class="sxs-lookup"><span data-stu-id="1959a-351">Unicode (UTF-32)</span></span>|<span data-ttu-id="1959a-352">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-352">✓</span></span>|<span data-ttu-id="1959a-353">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-353">✓</span></span>|
|<span data-ttu-id="1959a-354">12001</span><span class="sxs-lookup"><span data-stu-id="1959a-354">12001</span></span>|<span data-ttu-id="1959a-355">UTF-32be</span><span class="sxs-lookup"><span data-stu-id="1959a-355">utf-32BE</span></span>|<span data-ttu-id="1959a-356">Unicode (UTF-32 Big-d)</span><span class="sxs-lookup"><span data-stu-id="1959a-356">Unicode (UTF-32 Big endian)</span></span>|<span data-ttu-id="1959a-357">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-357">✓</span></span>|<span data-ttu-id="1959a-358">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-358">✓</span></span>|
|<span data-ttu-id="1959a-359">20.000</span><span class="sxs-lookup"><span data-stu-id="1959a-359">20000</span></span>|<span data-ttu-id="1959a-360">x-Chinesisch-CNS</span><span class="sxs-lookup"><span data-stu-id="1959a-360">x-Chinese-CNS</span></span>|<span data-ttu-id="1959a-361">Chinesisch (traditionell) (CNS)</span><span class="sxs-lookup"><span data-stu-id="1959a-361">Chinese Traditional (CNS)</span></span>|||
|<span data-ttu-id="1959a-362">20001</span><span class="sxs-lookup"><span data-stu-id="1959a-362">20001</span></span>|<span data-ttu-id="1959a-363">x-cp20001</span><span class="sxs-lookup"><span data-stu-id="1959a-363">x-cp20001</span></span>|<span data-ttu-id="1959a-364">TCA-Taiwan</span><span class="sxs-lookup"><span data-stu-id="1959a-364">TCA Taiwan</span></span>|||
|<span data-ttu-id="1959a-365">20002</span><span class="sxs-lookup"><span data-stu-id="1959a-365">20002</span></span>|<span data-ttu-id="1959a-366">x-Chinesisch-eTEN</span><span class="sxs-lookup"><span data-stu-id="1959a-366">x-Chinese-Eten</span></span>|<span data-ttu-id="1959a-367">Chinesisch (traditionell) (eTEN)</span><span class="sxs-lookup"><span data-stu-id="1959a-367">Chinese Traditional (Eten)</span></span>|||
|<span data-ttu-id="1959a-368">20003</span><span class="sxs-lookup"><span data-stu-id="1959a-368">20003</span></span>|<span data-ttu-id="1959a-369">x-cp20003</span><span class="sxs-lookup"><span data-stu-id="1959a-369">x-cp20003</span></span>|<span data-ttu-id="1959a-370">IBM5550 Taiwan</span><span class="sxs-lookup"><span data-stu-id="1959a-370">IBM5550 Taiwan</span></span>|||
|<span data-ttu-id="1959a-371">20004</span><span class="sxs-lookup"><span data-stu-id="1959a-371">20004</span></span>|<span data-ttu-id="1959a-372">x-cp20004</span><span class="sxs-lookup"><span data-stu-id="1959a-372">x-cp20004</span></span>|<span data-ttu-id="1959a-373">Teletext-Taiwan</span><span class="sxs-lookup"><span data-stu-id="1959a-373">TeleText Taiwan</span></span>|||
|<span data-ttu-id="1959a-374">20005</span><span class="sxs-lookup"><span data-stu-id="1959a-374">20005</span></span>|<span data-ttu-id="1959a-375">x-cp20005</span><span class="sxs-lookup"><span data-stu-id="1959a-375">x-cp20005</span></span>|<span data-ttu-id="1959a-376">Wang Taiwan</span><span class="sxs-lookup"><span data-stu-id="1959a-376">Wang Taiwan</span></span>|||
|<span data-ttu-id="1959a-377">20105</span><span class="sxs-lookup"><span data-stu-id="1959a-377">20105</span></span>|<span data-ttu-id="1959a-378">x-IA5</span><span class="sxs-lookup"><span data-stu-id="1959a-378">x-IA5</span></span>|<span data-ttu-id="1959a-379">Westeuropäisch (IA5)</span><span class="sxs-lookup"><span data-stu-id="1959a-379">Western European (IA5)</span></span>|||
|<span data-ttu-id="1959a-380">20106</span><span class="sxs-lookup"><span data-stu-id="1959a-380">20106</span></span>|<span data-ttu-id="1959a-381">x-IA5-German</span><span class="sxs-lookup"><span data-stu-id="1959a-381">x-IA5-German</span></span>|<span data-ttu-id="1959a-382">Deutsch (IA5)</span><span class="sxs-lookup"><span data-stu-id="1959a-382">German (IA5)</span></span>|||
|<span data-ttu-id="1959a-383">20107</span><span class="sxs-lookup"><span data-stu-id="1959a-383">20107</span></span>|<span data-ttu-id="1959a-384">x-IA5-Schwedisch</span><span class="sxs-lookup"><span data-stu-id="1959a-384">x-IA5-Swedish</span></span>|<span data-ttu-id="1959a-385">Schwedisch (IA5)</span><span class="sxs-lookup"><span data-stu-id="1959a-385">Swedish (IA5)</span></span>|||
|<span data-ttu-id="1959a-386">20108</span><span class="sxs-lookup"><span data-stu-id="1959a-386">20108</span></span>|<span data-ttu-id="1959a-387">x-IA5-Norwegisch</span><span class="sxs-lookup"><span data-stu-id="1959a-387">x-IA5-Norwegian</span></span>|<span data-ttu-id="1959a-388">Norwegisch (IA5)</span><span class="sxs-lookup"><span data-stu-id="1959a-388">Norwegian (IA5)</span></span>|||
|<span data-ttu-id="1959a-389">20127</span><span class="sxs-lookup"><span data-stu-id="1959a-389">20127</span></span>|<span data-ttu-id="1959a-390">us-ascii</span><span class="sxs-lookup"><span data-stu-id="1959a-390">us-ascii</span></span>|<span data-ttu-id="1959a-391">US-ASCII</span><span class="sxs-lookup"><span data-stu-id="1959a-391">US-ASCII</span></span>|<span data-ttu-id="1959a-392">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-392">✓</span></span>|<span data-ttu-id="1959a-393">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-393">✓</span></span>|
|<span data-ttu-id="1959a-394">20261</span><span class="sxs-lookup"><span data-stu-id="1959a-394">20261</span></span>|<span data-ttu-id="1959a-395">x-cp20261</span><span class="sxs-lookup"><span data-stu-id="1959a-395">x-cp20261</span></span>|<span data-ttu-id="1959a-396">T. 61</span><span class="sxs-lookup"><span data-stu-id="1959a-396">T.61</span></span>|||
|<span data-ttu-id="1959a-397">20269</span><span class="sxs-lookup"><span data-stu-id="1959a-397">20269</span></span>|<span data-ttu-id="1959a-398">x-cp20269</span><span class="sxs-lookup"><span data-stu-id="1959a-398">x-cp20269</span></span>|<span data-ttu-id="1959a-399">ISO-6937</span><span class="sxs-lookup"><span data-stu-id="1959a-399">ISO-6937</span></span>|||
|<span data-ttu-id="1959a-400">20273</span><span class="sxs-lookup"><span data-stu-id="1959a-400">20273</span></span>|<span data-ttu-id="1959a-401">IBM273</span><span class="sxs-lookup"><span data-stu-id="1959a-401">IBM273</span></span>|<span data-ttu-id="1959a-402">IBM EBCDIC (Deutschland)</span><span class="sxs-lookup"><span data-stu-id="1959a-402">IBM EBCDIC (Germany)</span></span>|||
|<span data-ttu-id="1959a-403">20277</span><span class="sxs-lookup"><span data-stu-id="1959a-403">20277</span></span>|<span data-ttu-id="1959a-404">IBM277</span><span class="sxs-lookup"><span data-stu-id="1959a-404">IBM277</span></span>|<span data-ttu-id="1959a-405">IBM EBCDIC (Dänemark-Norwegen)</span><span class="sxs-lookup"><span data-stu-id="1959a-405">IBM EBCDIC (Denmark-Norway)</span></span>|||
|<span data-ttu-id="1959a-406">20278</span><span class="sxs-lookup"><span data-stu-id="1959a-406">20278</span></span>|<span data-ttu-id="1959a-407">IBM278</span><span class="sxs-lookup"><span data-stu-id="1959a-407">IBM278</span></span>|<span data-ttu-id="1959a-408">IBM EBCDIC (Finnland-Schweden)</span><span class="sxs-lookup"><span data-stu-id="1959a-408">IBM EBCDIC (Finland-Sweden)</span></span>|||
|<span data-ttu-id="1959a-409">20280</span><span class="sxs-lookup"><span data-stu-id="1959a-409">20280</span></span>|<span data-ttu-id="1959a-410">IBM280</span><span class="sxs-lookup"><span data-stu-id="1959a-410">IBM280</span></span>|<span data-ttu-id="1959a-411">IBM EBCDIC (Italien)</span><span class="sxs-lookup"><span data-stu-id="1959a-411">IBM EBCDIC (Italy)</span></span>|||
|<span data-ttu-id="1959a-412">20284</span><span class="sxs-lookup"><span data-stu-id="1959a-412">20284</span></span>|<span data-ttu-id="1959a-413">IBM284</span><span class="sxs-lookup"><span data-stu-id="1959a-413">IBM284</span></span>|<span data-ttu-id="1959a-414">IBM EBCDIC (Spanien)</span><span class="sxs-lookup"><span data-stu-id="1959a-414">IBM EBCDIC (Spain)</span></span>|||
|<span data-ttu-id="1959a-415">20285</span><span class="sxs-lookup"><span data-stu-id="1959a-415">20285</span></span>|<span data-ttu-id="1959a-416">IBM285</span><span class="sxs-lookup"><span data-stu-id="1959a-416">IBM285</span></span>|<span data-ttu-id="1959a-417">IBM EBCDIC (Vereinigtes Königreich)</span><span class="sxs-lookup"><span data-stu-id="1959a-417">IBM EBCDIC (UK)</span></span>|||
|<span data-ttu-id="1959a-418">20290</span><span class="sxs-lookup"><span data-stu-id="1959a-418">20290</span></span>|<span data-ttu-id="1959a-419">IBM290</span><span class="sxs-lookup"><span data-stu-id="1959a-419">IBM290</span></span>|<span data-ttu-id="1959a-420">IBM EBCDIC (Japanisch Katakana)</span><span class="sxs-lookup"><span data-stu-id="1959a-420">IBM EBCDIC (Japanese katakana)</span></span>|||
|<span data-ttu-id="1959a-421">20297</span><span class="sxs-lookup"><span data-stu-id="1959a-421">20297</span></span>|<span data-ttu-id="1959a-422">IBM297</span><span class="sxs-lookup"><span data-stu-id="1959a-422">IBM297</span></span>|<span data-ttu-id="1959a-423">IBM EBCDIC (Frankreich)</span><span class="sxs-lookup"><span data-stu-id="1959a-423">IBM EBCDIC (France)</span></span>|||
|<span data-ttu-id="1959a-424">20420</span><span class="sxs-lookup"><span data-stu-id="1959a-424">20420</span></span>|<span data-ttu-id="1959a-425">IBM420</span><span class="sxs-lookup"><span data-stu-id="1959a-425">IBM420</span></span>|<span data-ttu-id="1959a-426">IBM EBCDIC (Arabisch)</span><span class="sxs-lookup"><span data-stu-id="1959a-426">IBM EBCDIC (Arabic)</span></span>|||
|<span data-ttu-id="1959a-427">20423</span><span class="sxs-lookup"><span data-stu-id="1959a-427">20423</span></span>|<span data-ttu-id="1959a-428">IBM423</span><span class="sxs-lookup"><span data-stu-id="1959a-428">IBM423</span></span>|<span data-ttu-id="1959a-429">IBM EBCDIC (Griechisch)</span><span class="sxs-lookup"><span data-stu-id="1959a-429">IBM EBCDIC (Greek)</span></span>|||
|<span data-ttu-id="1959a-430">20424</span><span class="sxs-lookup"><span data-stu-id="1959a-430">20424</span></span>|<span data-ttu-id="1959a-431">IBM424</span><span class="sxs-lookup"><span data-stu-id="1959a-431">IBM424</span></span>|<span data-ttu-id="1959a-432">IBM EBCDIC (Hebräisch)</span><span class="sxs-lookup"><span data-stu-id="1959a-432">IBM EBCDIC (Hebrew)</span></span>|||
|<span data-ttu-id="1959a-433">20833</span><span class="sxs-lookup"><span data-stu-id="1959a-433">20833</span></span>|<span data-ttu-id="1959a-434">x-EBCDIC-koreanextended</span><span class="sxs-lookup"><span data-stu-id="1959a-434">x-EBCDIC-KoreanExtended</span></span>|<span data-ttu-id="1959a-435">IBM EBCDIC (Koreanisch erweitert)</span><span class="sxs-lookup"><span data-stu-id="1959a-435">IBM EBCDIC (Korean Extended)</span></span>|||
|<span data-ttu-id="1959a-436">20838</span><span class="sxs-lookup"><span data-stu-id="1959a-436">20838</span></span>|<span data-ttu-id="1959a-437">IBM-Thai</span><span class="sxs-lookup"><span data-stu-id="1959a-437">IBM-Thai</span></span>|<span data-ttu-id="1959a-438">IBM EBCDIC (Thailändisch)</span><span class="sxs-lookup"><span data-stu-id="1959a-438">IBM EBCDIC (Thai)</span></span>|||
|<span data-ttu-id="1959a-439">20866</span><span class="sxs-lookup"><span data-stu-id="1959a-439">20866</span></span>|<span data-ttu-id="1959a-440">koi8-r</span><span class="sxs-lookup"><span data-stu-id="1959a-440">koi8-r</span></span>|<span data-ttu-id="1959a-441">Kyrillisch (KOI8-R)</span><span class="sxs-lookup"><span data-stu-id="1959a-441">Cyrillic (KOI8-R)</span></span>|||
|<span data-ttu-id="1959a-442">20871</span><span class="sxs-lookup"><span data-stu-id="1959a-442">20871</span></span>|<span data-ttu-id="1959a-443">IBM871</span><span class="sxs-lookup"><span data-stu-id="1959a-443">IBM871</span></span>|<span data-ttu-id="1959a-444">IBM EBCDIC (Isländisch)</span><span class="sxs-lookup"><span data-stu-id="1959a-444">IBM EBCDIC (Icelandic)</span></span>|||
|<span data-ttu-id="1959a-445">20880</span><span class="sxs-lookup"><span data-stu-id="1959a-445">20880</span></span>|<span data-ttu-id="1959a-446">IBM880</span><span class="sxs-lookup"><span data-stu-id="1959a-446">IBM880</span></span>|<span data-ttu-id="1959a-447">IBM EBCDIC (Kyrillisch Russisch)</span><span class="sxs-lookup"><span data-stu-id="1959a-447">IBM EBCDIC (Cyrillic Russian)</span></span>|||
|<span data-ttu-id="1959a-448">20905</span><span class="sxs-lookup"><span data-stu-id="1959a-448">20905</span></span>|<span data-ttu-id="1959a-449">IBM905</span><span class="sxs-lookup"><span data-stu-id="1959a-449">IBM905</span></span>|<span data-ttu-id="1959a-450">IBM EBCDIC (Türkisch)</span><span class="sxs-lookup"><span data-stu-id="1959a-450">IBM EBCDIC (Turkish)</span></span>|||
|<span data-ttu-id="1959a-451">20924</span><span class="sxs-lookup"><span data-stu-id="1959a-451">20924</span></span>|<span data-ttu-id="1959a-452">IBM00924</span><span class="sxs-lookup"><span data-stu-id="1959a-452">IBM00924</span></span>|<span data-ttu-id="1959a-453">IBM Latin-1</span><span class="sxs-lookup"><span data-stu-id="1959a-453">IBM Latin-1</span></span>|||
|<span data-ttu-id="1959a-454">20932</span><span class="sxs-lookup"><span data-stu-id="1959a-454">20932</span></span>|<span data-ttu-id="1959a-455">EUC-JP</span><span class="sxs-lookup"><span data-stu-id="1959a-455">EUC-JP</span></span>|<span data-ttu-id="1959a-456">Japanisch (JIS 0208-1990 und 0212-1990)</span><span class="sxs-lookup"><span data-stu-id="1959a-456">Japanese (JIS 0208-1990 and 0212-1990)</span></span>|||
|<span data-ttu-id="1959a-457">20936</span><span class="sxs-lookup"><span data-stu-id="1959a-457">20936</span></span>|<span data-ttu-id="1959a-458">x-cp20936</span><span class="sxs-lookup"><span data-stu-id="1959a-458">x-cp20936</span></span>|<span data-ttu-id="1959a-459">Chinesisch vereinfacht (GB2312-80)</span><span class="sxs-lookup"><span data-stu-id="1959a-459">Chinese Simplified (GB2312-80)</span></span>|<span data-ttu-id="1959a-460">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-460">✓</span></span>||
|<span data-ttu-id="1959a-461">20949</span><span class="sxs-lookup"><span data-stu-id="1959a-461">20949</span></span>|<span data-ttu-id="1959a-462">x-cp20949</span><span class="sxs-lookup"><span data-stu-id="1959a-462">x-cp20949</span></span>|<span data-ttu-id="1959a-463">Koreanisch Wansung</span><span class="sxs-lookup"><span data-stu-id="1959a-463">Korean Wansung</span></span>|<span data-ttu-id="1959a-464">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-464">✓</span></span>||
|<span data-ttu-id="1959a-465">21025</span><span class="sxs-lookup"><span data-stu-id="1959a-465">21025</span></span>|<span data-ttu-id="1959a-466">cp1025</span><span class="sxs-lookup"><span data-stu-id="1959a-466">cp1025</span></span>|<span data-ttu-id="1959a-467">IBM EBCDIC (Kyrillisch Serbisch-Bulgarisch)</span><span class="sxs-lookup"><span data-stu-id="1959a-467">IBM EBCDIC (Cyrillic Serbian-Bulgarian)</span></span>|||
|<span data-ttu-id="1959a-468">21866</span><span class="sxs-lookup"><span data-stu-id="1959a-468">21866</span></span>|<span data-ttu-id="1959a-469">KOI8-u</span><span class="sxs-lookup"><span data-stu-id="1959a-469">koi8-u</span></span>|<span data-ttu-id="1959a-470">Kyrillisch (KOI8-U)</span><span class="sxs-lookup"><span data-stu-id="1959a-470">Cyrillic (KOI8-U)</span></span>|||
|<span data-ttu-id="1959a-471">28591</span><span class="sxs-lookup"><span data-stu-id="1959a-471">28591</span></span>|<span data-ttu-id="1959a-472">iso-8859-1</span><span class="sxs-lookup"><span data-stu-id="1959a-472">iso-8859-1</span></span>|<span data-ttu-id="1959a-473">Westeuropäisch (ISO)</span><span class="sxs-lookup"><span data-stu-id="1959a-473">Western European (ISO)</span></span>|<span data-ttu-id="1959a-474">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-474">✓</span></span>|<span data-ttu-id="1959a-475">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-475">✓</span></span>|
|<span data-ttu-id="1959a-476">28592</span><span class="sxs-lookup"><span data-stu-id="1959a-476">28592</span></span>|<span data-ttu-id="1959a-477">iso-8859-2</span><span class="sxs-lookup"><span data-stu-id="1959a-477">iso-8859-2</span></span>|<span data-ttu-id="1959a-478">Mitteleuropäisch (ISO)</span><span class="sxs-lookup"><span data-stu-id="1959a-478">Central European (ISO)</span></span>|||
|<span data-ttu-id="1959a-479">28593</span><span class="sxs-lookup"><span data-stu-id="1959a-479">28593</span></span>|<span data-ttu-id="1959a-480">iso-8859-3</span><span class="sxs-lookup"><span data-stu-id="1959a-480">iso-8859-3</span></span>|<span data-ttu-id="1959a-481">Lateinisch 3 (ISO)</span><span class="sxs-lookup"><span data-stu-id="1959a-481">Latin 3 (ISO)</span></span>|||
|<span data-ttu-id="1959a-482">28594</span><span class="sxs-lookup"><span data-stu-id="1959a-482">28594</span></span>|<span data-ttu-id="1959a-483">iso-8859-4</span><span class="sxs-lookup"><span data-stu-id="1959a-483">iso-8859-4</span></span>|<span data-ttu-id="1959a-484">Baltisch (ISO)</span><span class="sxs-lookup"><span data-stu-id="1959a-484">Baltic (ISO)</span></span>|||
|<span data-ttu-id="1959a-485">28595</span><span class="sxs-lookup"><span data-stu-id="1959a-485">28595</span></span>|<span data-ttu-id="1959a-486">iso-8859-5</span><span class="sxs-lookup"><span data-stu-id="1959a-486">iso-8859-5</span></span>|<span data-ttu-id="1959a-487">Kyrillisch (ISO)</span><span class="sxs-lookup"><span data-stu-id="1959a-487">Cyrillic (ISO)</span></span>|||
|<span data-ttu-id="1959a-488">28596</span><span class="sxs-lookup"><span data-stu-id="1959a-488">28596</span></span>|<span data-ttu-id="1959a-489">iso-8859-6</span><span class="sxs-lookup"><span data-stu-id="1959a-489">iso-8859-6</span></span>|<span data-ttu-id="1959a-490">Arabisch (ISO)</span><span class="sxs-lookup"><span data-stu-id="1959a-490">Arabic (ISO)</span></span>|||
|<span data-ttu-id="1959a-491">28597</span><span class="sxs-lookup"><span data-stu-id="1959a-491">28597</span></span>|<span data-ttu-id="1959a-492">iso-8859-7</span><span class="sxs-lookup"><span data-stu-id="1959a-492">iso-8859-7</span></span>|<span data-ttu-id="1959a-493">Griechisch (ISO)</span><span class="sxs-lookup"><span data-stu-id="1959a-493">Greek (ISO)</span></span>|||
|<span data-ttu-id="1959a-494">28598</span><span class="sxs-lookup"><span data-stu-id="1959a-494">28598</span></span>|<span data-ttu-id="1959a-495">iso-8859-8</span><span class="sxs-lookup"><span data-stu-id="1959a-495">iso-8859-8</span></span>|<span data-ttu-id="1959a-496">Hebräisch (ISO-Visual)</span><span class="sxs-lookup"><span data-stu-id="1959a-496">Hebrew (ISO-Visual)</span></span>|<span data-ttu-id="1959a-497">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-497">✓</span></span>||
|<span data-ttu-id="1959a-498">28599</span><span class="sxs-lookup"><span data-stu-id="1959a-498">28599</span></span>|<span data-ttu-id="1959a-499">iso-8859-9</span><span class="sxs-lookup"><span data-stu-id="1959a-499">iso-8859-9</span></span>|<span data-ttu-id="1959a-500">Türkisch (ISO)</span><span class="sxs-lookup"><span data-stu-id="1959a-500">Turkish (ISO)</span></span>|||
|<span data-ttu-id="1959a-501">28603</span><span class="sxs-lookup"><span data-stu-id="1959a-501">28603</span></span>|<span data-ttu-id="1959a-502">iso-8859-13</span><span class="sxs-lookup"><span data-stu-id="1959a-502">iso-8859-13</span></span>|<span data-ttu-id="1959a-503">Estonian (ISO)</span><span class="sxs-lookup"><span data-stu-id="1959a-503">Estonian (ISO)</span></span>|||
|<span data-ttu-id="1959a-504">28605</span><span class="sxs-lookup"><span data-stu-id="1959a-504">28605</span></span>|<span data-ttu-id="1959a-505">iso-8859-15</span><span class="sxs-lookup"><span data-stu-id="1959a-505">iso-8859-15</span></span>|<span data-ttu-id="1959a-506">Lateinisch 9 (ISO)</span><span class="sxs-lookup"><span data-stu-id="1959a-506">Latin 9 (ISO)</span></span>|||
|<span data-ttu-id="1959a-507">29001</span><span class="sxs-lookup"><span data-stu-id="1959a-507">29001</span></span>|<span data-ttu-id="1959a-508">x-Europa</span><span class="sxs-lookup"><span data-stu-id="1959a-508">x-Europa</span></span>|<span data-ttu-id="1959a-509">'</span><span class="sxs-lookup"><span data-stu-id="1959a-509">Europa</span></span>|||
|<span data-ttu-id="1959a-510">38598</span><span class="sxs-lookup"><span data-stu-id="1959a-510">38598</span></span>|<span data-ttu-id="1959a-511">iso-8859-8-i</span><span class="sxs-lookup"><span data-stu-id="1959a-511">iso-8859-8-i</span></span>|<span data-ttu-id="1959a-512">Hebräisch (ISO-logisch)</span><span class="sxs-lookup"><span data-stu-id="1959a-512">Hebrew (ISO-Logical)</span></span>|<span data-ttu-id="1959a-513">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-513">✓</span></span>||
|<span data-ttu-id="1959a-514">50220</span><span class="sxs-lookup"><span data-stu-id="1959a-514">50220</span></span>|<span data-ttu-id="1959a-515">ISO-2022-JP</span><span class="sxs-lookup"><span data-stu-id="1959a-515">iso-2022-jp</span></span>|<span data-ttu-id="1959a-516">Japanisch (JIS)</span><span class="sxs-lookup"><span data-stu-id="1959a-516">Japanese (JIS)</span></span>|<span data-ttu-id="1959a-517">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-517">✓</span></span>||
|<span data-ttu-id="1959a-518">50221</span><span class="sxs-lookup"><span data-stu-id="1959a-518">50221</span></span>|<span data-ttu-id="1959a-519">csISO2022JP</span><span class="sxs-lookup"><span data-stu-id="1959a-519">csISO2022JP</span></span>|<span data-ttu-id="1959a-520">Japanisch (JIS-1-Byte-Kana zulassen)</span><span class="sxs-lookup"><span data-stu-id="1959a-520">Japanese (JIS-Allow 1 byte Kana)</span></span>|<span data-ttu-id="1959a-521">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-521">✓</span></span>||
|<span data-ttu-id="1959a-522">50222</span><span class="sxs-lookup"><span data-stu-id="1959a-522">50222</span></span>|<span data-ttu-id="1959a-523">ISO-2022-JP</span><span class="sxs-lookup"><span data-stu-id="1959a-523">iso-2022-jp</span></span>|<span data-ttu-id="1959a-524">Japanisch (JIS-1 Byte Kana-so/SI)</span><span class="sxs-lookup"><span data-stu-id="1959a-524">Japanese (JIS-Allow 1 byte Kana - SO/SI)</span></span>|<span data-ttu-id="1959a-525">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-525">✓</span></span>||
|<span data-ttu-id="1959a-526">50225</span><span class="sxs-lookup"><span data-stu-id="1959a-526">50225</span></span>|<span data-ttu-id="1959a-527">ISO-2022-KR</span><span class="sxs-lookup"><span data-stu-id="1959a-527">iso-2022-kr</span></span>|<span data-ttu-id="1959a-528">Koreanisch (ISO)</span><span class="sxs-lookup"><span data-stu-id="1959a-528">Korean (ISO)</span></span>|<span data-ttu-id="1959a-529">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-529">✓</span></span>||
|<span data-ttu-id="1959a-530">50227</span><span class="sxs-lookup"><span data-stu-id="1959a-530">50227</span></span>|<span data-ttu-id="1959a-531">x-cp50227</span><span class="sxs-lookup"><span data-stu-id="1959a-531">x-cp50227</span></span>|<span data-ttu-id="1959a-532">Chinesisch vereinfacht (ISO-2022)</span><span class="sxs-lookup"><span data-stu-id="1959a-532">Chinese Simplified (ISO-2022)</span></span>|<span data-ttu-id="1959a-533">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-533">✓</span></span>||
|<span data-ttu-id="1959a-534">51932</span><span class="sxs-lookup"><span data-stu-id="1959a-534">51932</span></span>|<span data-ttu-id="1959a-535">EUC-JP</span><span class="sxs-lookup"><span data-stu-id="1959a-535">euc-jp</span></span>|<span data-ttu-id="1959a-536">Japanisch (EUC)</span><span class="sxs-lookup"><span data-stu-id="1959a-536">Japanese (EUC)</span></span>|<span data-ttu-id="1959a-537">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-537">✓</span></span>||
|<span data-ttu-id="1959a-538">51936</span><span class="sxs-lookup"><span data-stu-id="1959a-538">51936</span></span>|<span data-ttu-id="1959a-539">EUC-CN</span><span class="sxs-lookup"><span data-stu-id="1959a-539">EUC-CN</span></span>|<span data-ttu-id="1959a-540">Chinesisch (vereinfacht) (EUC)</span><span class="sxs-lookup"><span data-stu-id="1959a-540">Chinese Simplified (EUC)</span></span>|<span data-ttu-id="1959a-541">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-541">✓</span></span>||
|<span data-ttu-id="1959a-542">51949</span><span class="sxs-lookup"><span data-stu-id="1959a-542">51949</span></span>|<span data-ttu-id="1959a-543">EUC-KR</span><span class="sxs-lookup"><span data-stu-id="1959a-543">euc-kr</span></span>|<span data-ttu-id="1959a-544">Koreanisch (EUC)</span><span class="sxs-lookup"><span data-stu-id="1959a-544">Korean (EUC)</span></span>|<span data-ttu-id="1959a-545">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-545">✓</span></span>||
|<span data-ttu-id="1959a-546">52936</span><span class="sxs-lookup"><span data-stu-id="1959a-546">52936</span></span>|<span data-ttu-id="1959a-547">hz-gb-2312</span><span class="sxs-lookup"><span data-stu-id="1959a-547">hz-gb-2312</span></span>|<span data-ttu-id="1959a-548">Chinesisch (vereinfacht) (Hz)</span><span class="sxs-lookup"><span data-stu-id="1959a-548">Chinese Simplified (HZ)</span></span>|<span data-ttu-id="1959a-549">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-549">✓</span></span>||
|<span data-ttu-id="1959a-550">54936</span><span class="sxs-lookup"><span data-stu-id="1959a-550">54936</span></span>|<span data-ttu-id="1959a-551">GB18030</span><span class="sxs-lookup"><span data-stu-id="1959a-551">GB18030</span></span>|<span data-ttu-id="1959a-552">Chinesisch vereinfacht (GB18030)</span><span class="sxs-lookup"><span data-stu-id="1959a-552">Chinese Simplified (GB18030)</span></span>|<span data-ttu-id="1959a-553">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-553">✓</span></span>||
|<span data-ttu-id="1959a-554">57002</span><span class="sxs-lookup"><span data-stu-id="1959a-554">57002</span></span>|<span data-ttu-id="1959a-555">x-ISCII-de</span><span class="sxs-lookup"><span data-stu-id="1959a-555">x-iscii-de</span></span>|<span data-ttu-id="1959a-556">ISCII-Geräte Abteilung</span><span class="sxs-lookup"><span data-stu-id="1959a-556">ISCII Devanagari</span></span>|<span data-ttu-id="1959a-557">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-557">✓</span></span>||
|<span data-ttu-id="1959a-558">57003</span><span class="sxs-lookup"><span data-stu-id="1959a-558">57003</span></span>|<span data-ttu-id="1959a-559">x-ISCII-be</span><span class="sxs-lookup"><span data-stu-id="1959a-559">x-iscii-be</span></span>|<span data-ttu-id="1959a-560">ISCII Bengalisch</span><span class="sxs-lookup"><span data-stu-id="1959a-560">ISCII Bengali</span></span>|<span data-ttu-id="1959a-561">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-561">✓</span></span>||
|<span data-ttu-id="1959a-562">57004</span><span class="sxs-lookup"><span data-stu-id="1959a-562">57004</span></span>|<span data-ttu-id="1959a-563">x-iscii-ta</span><span class="sxs-lookup"><span data-stu-id="1959a-563">x-iscii-ta</span></span>|<span data-ttu-id="1959a-564">ISCII Tamil</span><span class="sxs-lookup"><span data-stu-id="1959a-564">ISCII Tamil</span></span>|<span data-ttu-id="1959a-565">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-565">✓</span></span>||
|<span data-ttu-id="1959a-566">57005</span><span class="sxs-lookup"><span data-stu-id="1959a-566">57005</span></span>|<span data-ttu-id="1959a-567">x-ISCII-te</span><span class="sxs-lookup"><span data-stu-id="1959a-567">x-iscii-te</span></span>|<span data-ttu-id="1959a-568">ISCII Telugu</span><span class="sxs-lookup"><span data-stu-id="1959a-568">ISCII Telugu</span></span>|<span data-ttu-id="1959a-569">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-569">✓</span></span>||
|<span data-ttu-id="1959a-570">57006</span><span class="sxs-lookup"><span data-stu-id="1959a-570">57006</span></span>|<span data-ttu-id="1959a-571">x-ISCII-as</span><span class="sxs-lookup"><span data-stu-id="1959a-571">x-iscii-as</span></span>|<span data-ttu-id="1959a-572">ISCII-Assamese</span><span class="sxs-lookup"><span data-stu-id="1959a-572">ISCII Assamese</span></span>|<span data-ttu-id="1959a-573">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-573">✓</span></span>||
|<span data-ttu-id="1959a-574">57007</span><span class="sxs-lookup"><span data-stu-id="1959a-574">57007</span></span>|<span data-ttu-id="1959a-575">x-ISCII-or</span><span class="sxs-lookup"><span data-stu-id="1959a-575">x-iscii-or</span></span>|<span data-ttu-id="1959a-576">ISCII Oriya</span><span class="sxs-lookup"><span data-stu-id="1959a-576">ISCII Oriya</span></span>|<span data-ttu-id="1959a-577">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-577">✓</span></span>||
|<span data-ttu-id="1959a-578">57008</span><span class="sxs-lookup"><span data-stu-id="1959a-578">57008</span></span>|<span data-ttu-id="1959a-579">x-ISCII-Ka</span><span class="sxs-lookup"><span data-stu-id="1959a-579">x-iscii-ka</span></span>|<span data-ttu-id="1959a-580">ISCII Kannada</span><span class="sxs-lookup"><span data-stu-id="1959a-580">ISCII Kannada</span></span>|<span data-ttu-id="1959a-581">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-581">✓</span></span>||
|<span data-ttu-id="1959a-582">57009</span><span class="sxs-lookup"><span data-stu-id="1959a-582">57009</span></span>|<span data-ttu-id="1959a-583">x-ISCII-MA</span><span class="sxs-lookup"><span data-stu-id="1959a-583">x-iscii-ma</span></span>|<span data-ttu-id="1959a-584">ISCII Malayalam</span><span class="sxs-lookup"><span data-stu-id="1959a-584">ISCII Malayalam</span></span>|<span data-ttu-id="1959a-585">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-585">✓</span></span>||
|<span data-ttu-id="1959a-586">57010</span><span class="sxs-lookup"><span data-stu-id="1959a-586">57010</span></span>|<span data-ttu-id="1959a-587">x-iscii-gu</span><span class="sxs-lookup"><span data-stu-id="1959a-587">x-iscii-gu</span></span>|<span data-ttu-id="1959a-588">ISCII Gujarati</span><span class="sxs-lookup"><span data-stu-id="1959a-588">ISCII Gujarati</span></span>|<span data-ttu-id="1959a-589">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-589">✓</span></span>||
|<span data-ttu-id="1959a-590">57011</span><span class="sxs-lookup"><span data-stu-id="1959a-590">57011</span></span>|<span data-ttu-id="1959a-591">x-iscii-pa</span><span class="sxs-lookup"><span data-stu-id="1959a-591">x-iscii-pa</span></span>|<span data-ttu-id="1959a-592">ISCII Punjabi</span><span class="sxs-lookup"><span data-stu-id="1959a-592">ISCII Punjabi</span></span>|<span data-ttu-id="1959a-593">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-593">✓</span></span>||
|<span data-ttu-id="1959a-594">65000</span><span class="sxs-lookup"><span data-stu-id="1959a-594">65000</span></span>|<span data-ttu-id="1959a-595">UTF-7</span><span class="sxs-lookup"><span data-stu-id="1959a-595">utf-7</span></span>|<span data-ttu-id="1959a-596">Unicode (UTF-7)</span><span class="sxs-lookup"><span data-stu-id="1959a-596">Unicode (UTF-7)</span></span>|<span data-ttu-id="1959a-597">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-597">✓</span></span>|<span data-ttu-id="1959a-598">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-598">✓</span></span>|
|<span data-ttu-id="1959a-599">65001</span><span class="sxs-lookup"><span data-stu-id="1959a-599">65001</span></span>|<span data-ttu-id="1959a-600">utf-8</span><span class="sxs-lookup"><span data-stu-id="1959a-600">utf-8</span></span>|<span data-ttu-id="1959a-601">Unicode (UTF-8)</span><span class="sxs-lookup"><span data-stu-id="1959a-601">Unicode (UTF-8)</span></span>|<span data-ttu-id="1959a-602">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-602">✓</span></span>|<span data-ttu-id="1959a-603">✓</span><span class="sxs-lookup"><span data-stu-id="1959a-603">✓</span></span>|

 <span data-ttu-id="1959a-604">Im folgenden Beispiel werden die Methoden <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> und <xref:System.Text.Encoding.GetEncoding%28System.String%29> aufgerufen, um die Windows-Codepage-Codierung (Windows) zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="1959a-604">The following example calls the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> and <xref:System.Text.Encoding.GetEncoding%28System.String%29> methods to get the Greek (Windows) code page encoding.</span></span> <span data-ttu-id="1959a-605">Er vergleicht die <xref:System.Text.Encoding> von den Methoden Aufrufen zurückgegebenen Objekte, um anzuzeigen, dass Sie gleich sind. Anschließend zeigt Maps den Unicode-Codepunkt und den entsprechenden Codepage-Wert für jedes Zeichen im griechischen Alphabet an.</span><span class="sxs-lookup"><span data-stu-id="1959a-605">It compares the <xref:System.Text.Encoding> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet.</span></span>

 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]

 <span data-ttu-id="1959a-606">Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> verwenden, die von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode bzw. der <xref:System.Text.Encoding.GetEncoder%2A>-Methode der abgeleiteten Klasse bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-606">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1959a-607">Der UTF-16-und der UTF-32-Encoder können die Big-Endian-Byte Reihenfolge (signifikanteste Byte zuerst) oder die kleine Endian-Byte Reihenfolge (das am wenigsten signifikante Byte zuerst) verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-607">The UTF-16 and the UTF-32 encoders can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first).</span></span> <span data-ttu-id="1959a-608">Beispielsweise wird der lateinische Großbuchstabe A (U + 0041) wie folgt serialisiert (in Hexadezimal):</span><span class="sxs-lookup"><span data-stu-id="1959a-608">For example, the Latin Capital Letter A (U+0041) is serialized as follows (in hexadecimal):</span></span>

-   <span data-ttu-id="1959a-609">UTF-16 Big-Endian-Byte Reihenfolge: 00 41</span><span class="sxs-lookup"><span data-stu-id="1959a-609">UTF-16 big endian byte order: 00 41</span></span>

-   <span data-ttu-id="1959a-610">UTF-16 Little-Endian-Byte Reihenfolge: 41 00</span><span class="sxs-lookup"><span data-stu-id="1959a-610">UTF-16 little endian byte order: 41 00</span></span>

-   <span data-ttu-id="1959a-611">UTF-32 Big Endian-Byte Reihenfolge: 00 00 00 41</span><span class="sxs-lookup"><span data-stu-id="1959a-611">UTF-32 big endian byte order: 00 00 00 41</span></span>

-   <span data-ttu-id="1959a-612">UTF-32 Little-Endian-Byte Reihenfolge: 41 00 00 00</span><span class="sxs-lookup"><span data-stu-id="1959a-612">UTF-32 little endian byte order: 41 00 00 00</span></span>

 <span data-ttu-id="1959a-613">Es ist in der Regel effizienter, Unicode-Zeichen mithilfe der systemeigenen Byte Reihenfolge zu speichern.</span><span class="sxs-lookup"><span data-stu-id="1959a-613">It is generally more efficient to store Unicode characters using the native byte order.</span></span> <span data-ttu-id="1959a-614">Beispielsweise ist es besser, die Little-Endian-Byte Reihenfolge auf kleinen Endian-Plattformen wie z. b. Intel-Computern zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-614">For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.</span></span>

 <span data-ttu-id="1959a-615">Die <xref:System.Text.Encoding.GetPreamble%2A>-Methode ruft ein Bytearray ab, das die Byte Reihenfolge-Marke (BOM) enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-615">The <xref:System.Text.Encoding.GetPreamble%2A> method retrieves an array of bytes that includes the byte order mark (BOM).</span></span> <span data-ttu-id="1959a-616">Wenn dieses Bytearray einem codierten Stream vorangestellt wird, hilft es dem Decoder, das verwendete Codierungsformat zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="1959a-616">If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.</span></span>

 <span data-ttu-id="1959a-617">Weitere Informationen zur Byte Reihenfolge und zur Byte Reihenfolge-Markierung finden Sie im Unicode-Standard auf der [Unicode-Homepage](https://go.microsoft.com/fwlink/?LinkId=37123).</span><span class="sxs-lookup"><span data-stu-id="1959a-617">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](https://go.microsoft.com/fwlink/?LinkId=37123).</span></span>

 <span data-ttu-id="1959a-618">Beachten Sie, dass die Codierungs Klassen Fehler zulassen:</span><span class="sxs-lookup"><span data-stu-id="1959a-618">Note that the encoding classes allow errors to:</span></span>

-   <span data-ttu-id="1959a-619">Wechseln Sie im Hintergrund zu einem "?"-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-619">Silently change to a "?" character.</span></span>

-   <span data-ttu-id="1959a-620">Verwenden Sie ein Zeichen mit der optimalen Anpassung.</span><span class="sxs-lookup"><span data-stu-id="1959a-620">Use a "best fit" character.</span></span>

-   <span data-ttu-id="1959a-621">Wechseln Sie zu einem anwendungsspezifischen Verhalten, indem Sie die Klassen <xref:System.Text.EncoderFallback> und <xref:System.Text.DecoderFallback> mit dem Unicode-Ersatz Zeichen "U + FFFD" verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-621">Change to an application-specific behavior through use of the <xref:System.Text.EncoderFallback> and <xref:System.Text.DecoderFallback> classes with the U+FFFD Unicode replacement character.</span></span>

 <span data-ttu-id="1959a-622">Sie sollten für jeden Datenstrom Fehler eine Ausnahme auslösen.</span><span class="sxs-lookup"><span data-stu-id="1959a-622">You should throw an exception on any data stream error.</span></span> <span data-ttu-id="1959a-623">Eine APP verwendet entweder das Flag "throwOnError", falls zutreffend, oder verwendet die Klassen "<xref:System.Text.EncoderExceptionFallback>" und "<xref:System.Text.DecoderExceptionFallback>".</span><span class="sxs-lookup"><span data-stu-id="1959a-623">An app either uses a "throwonerror" flag when applicable or uses the <xref:System.Text.EncoderExceptionFallback> and <xref:System.Text.DecoderExceptionFallback> classes.</span></span> <span data-ttu-id="1959a-624">Der Fall Back am besten geeignet ist oft nicht empfehlenswert, da dies zu Datenverlusten oder Verwirrung führen kann und langsamer als einfache Zeichen Ersetzungen ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-624">Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements.</span></span> <span data-ttu-id="1959a-625">Bei ANSI-Codierungen ist das beste Verhalten der Standardeinstellung.</span><span class="sxs-lookup"><span data-stu-id="1959a-625">For ANSI encodings, the best fit behavior is the default.</span></span>



## Examples
 <span data-ttu-id="1959a-626">Im folgenden Beispiel wird eine Zeichenfolge von einer Codierung in eine andere konvertiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-626">The following example converts a string from one encoding to another.</span></span>

> [!NOTE]
>  <span data-ttu-id="1959a-627">Das Byte []-Array ist der einzige Typ in diesem Beispiel, der die codierten Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-627">The byte[] array is the only type in this example that contains the encoded data.</span></span> <span data-ttu-id="1959a-628">Die .NET-Typen "char" und "String" sind selbst Unicode, sodass der <xref:System.Text.Encoding.GetChars%2A>-Rückruf die Daten zurück in Unicode decodiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-628">The .NET Char and String types are themselves Unicode, so the <xref:System.Text.Encoding.GetChars%2A> call decodes the data back to Unicode.</span></span>

 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]

 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1959a-629">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1959a-629">Understanding Encodings</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1959a-630">Initialisiert eine neue Instanz der <see cref="T:System.Text.Encoding" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1959a-630">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1959a-631">Initialisiert eine neue Instanz der <see cref="T:System.Text.Encoding" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1959a-631">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-632">Abgeleitete Klassen überschreiben diesen Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="1959a-632">Derived classes override this constructor.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage"><span data-ttu-id="1959a-633">Der Codepagebezeichner der bevorzugten Codierung.</span><span class="sxs-lookup"><span data-stu-id="1959a-633">The code page identifier of the preferred encoding.</span></span>

 <span data-ttu-id="1959a-634">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-634">-or-</span></span>

 <span data-ttu-id="1959a-635">0, um die Standardcodierung zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-635">0, to use the default encoding.</span></span></param>
        <summary><span data-ttu-id="1959a-636">Initialisiert eine neue Instanz der <see cref="T:System.Text.Encoding" />-Klasse, die der angegebenen Codepage entspricht.</span><span class="sxs-lookup"><span data-stu-id="1959a-636">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-637">Abgeleitete Klassen überschreiben diesen Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="1959a-637">Derived classes override this constructor.</span></span>

 <span data-ttu-id="1959a-638">Aufrufe dieses Konstruktors aus einer abgeleiteten Klasse erstellen ein <xref:System.Text.Encoding> Objekt, das einen Fall Back mit dem besten Wert für Codierungs-und Decodierungs Vorgänge verwendet.</span><span class="sxs-lookup"><span data-stu-id="1959a-638">Calls to this constructor from a derived class create an <xref:System.Text.Encoding> object that uses best-fit fallback for both encoding and decoding operations.</span></span> <span data-ttu-id="1959a-639">Die Eigenschaften "<xref:System.Text.Encoding.DecoderFallback%2A>" und "<xref:System.Text.Encoding.EncoderFallback%2A>" sind schreibgeschützt und können nicht geändert werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-639">Both the <xref:System.Text.Encoding.DecoderFallback%2A> and <xref:System.Text.Encoding.EncoderFallback%2A> properties are read-only and cannot be modified.</span></span> <span data-ttu-id="1959a-640">Um die Fall Back Strategie für eine Klasse zu steuern, die von <xref:System.Text.Encoding>abgeleitet ist, müssen Sie den <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>-Konstruktor aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-640">To control the fallback strategy for a class derived from <xref:System.Text.Encoding>, call the <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> constructor.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-641"><paramref name="codePage" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="1959a-641"><paramref name="codePage" /> is less than zero.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage"><span data-ttu-id="1959a-642">Der Bezeichner der Codierungs-Codepage.</span><span class="sxs-lookup"><span data-stu-id="1959a-642">The encoding code page identifier.</span></span></param>
        <param name="encoderFallback"><span data-ttu-id="1959a-643">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn ein Zeichen nicht mit der aktuellen Codierung codiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-643">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span></span></param>
        <param name="decoderFallback"><span data-ttu-id="1959a-644">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn eine Bytefolge nicht mit der aktuellen Codierung decodiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-644">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span></span></param>
        <summary><span data-ttu-id="1959a-645">Initialisiert eine neue Instanz der <see cref="T:System.Text.Encoding" />-Klasse, die der angegebenen Codepage entspricht, mit den angegebenen Fallbackstrategien für Codierer und Decodierer.</span><span class="sxs-lookup"><span data-stu-id="1959a-645">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-646">Dieser Konstruktor ist `protected`. abgeleitete Klassen überschreiben Sie.</span><span class="sxs-lookup"><span data-stu-id="1959a-646">This constructor is `protected`; derived classes override it.</span></span>

 <span data-ttu-id="1959a-647">Dieser Konstruktor wird von einer abgeleiteten Klasse aufgerufen, um die Fall Back Codierungs-und Decodierungs Strategien zu steuern.</span><span class="sxs-lookup"><span data-stu-id="1959a-647">You call this constructor from a derived class to control the fallback encoding and decoding strategies.</span></span> <span data-ttu-id="1959a-648">Mit den <xref:System.Text.Encoding> Klassenkonstruktoren werden schreibgeschützte Codierungs Objekte erstellt, die die Festlegung des Encoders oder Decoderfallbacks nach der Erstellung des Objekts nicht zulassen.</span><span class="sxs-lookup"><span data-stu-id="1959a-648">The <xref:System.Text.Encoding> class constructors create read-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created.</span></span>

 <span data-ttu-id="1959a-649">Wenn entweder `encoderFallback` oder `decoderFallback` den Wert NULL hat, wird der Fall Back mit der besten Anpassung als entsprechende Fall Back Strategie verwendet.</span><span class="sxs-lookup"><span data-stu-id="1959a-649">If either `encoderFallback` or `decoderFallback` is null, best-fit fallback is used as the corresponding fallback strategy.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-650"><paramref name="codePage" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="1959a-650"><paramref name="codePage" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-651">Ruft eine Codierung für den ASCII-Zeichensatz (7-Bit) ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-651">Gets an encoding for the ASCII (7-bit) character set.</span></span></summary>
        <value><span data-ttu-id="1959a-652">Eine Codierung für den ASCII-Zeichensatz (7 Bits).</span><span class="sxs-lookup"><span data-stu-id="1959a-652">An  encoding for the ASCII (7-bit) character set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-653">ASCII-Zeichen sind auf die niedrigsten 128 Unicode-Zeichen (von U + 0000 bis U + 007F) beschränkt.</span><span class="sxs-lookup"><span data-stu-id="1959a-653">ASCII characters are limited to the lowest 128 Unicode characters, from U+0000 to U+007F.</span></span>

 <span data-ttu-id="1959a-654">Wenn Sie die ASCII-Codierung für Ihre App auswählen, sollten Sie Folgendes beachten:</span><span class="sxs-lookup"><span data-stu-id="1959a-654">When selecting the ASCII encoding for your app, consider the following:</span></span>

-   <span data-ttu-id="1959a-655">Die ASCII-Codierung ist in der Regel für Protokolle geeignet, für die ASCII erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-655">The ASCII encoding is usually appropriate for protocols that require ASCII.</span></span>

-   <span data-ttu-id="1959a-656">Wenn Sie eine 8-Bit-Codierung benötigen (was manchmal fälschlicherweise als "ASCII" bezeichnet wird), wird die UTF-8-Codierung über die ASCII-Codierung empfohlen.</span><span class="sxs-lookup"><span data-stu-id="1959a-656">If you requires 8-bit encoding (which is sometimes incorrectly referred to as "ASCII"), the UTF-8 encoding is recommended over the ASCII encoding.</span></span> <span data-ttu-id="1959a-657">Für die Zeichen 0-7f sind die Ergebnisse identisch, aber die Verwendung von UTF-8 vermeidet den Datenverlust, indem die Darstellung aller Unicode-Zeichen, die darstellbar sind, zugelassen wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-657">For the characters 0-7F, the results are identical, but use of UTF-8 avoids data loss by allowing representation of all Unicode characters that are representable.</span></span> <span data-ttu-id="1959a-658">Beachten Sie, dass die ASCII-Codierung eine 8-Bit-Mehrdeutigkeit aufweist, die böswillige Verwendungsmöglichkeiten zulässt, aber die UTF-8-Codierung entfernt Mehrdeutigkeiten über das 8. Bit.</span><span class="sxs-lookup"><span data-stu-id="1959a-658">Note that the ASCII encoding has an 8th bit ambiguity that can allow malicious use, but the UTF-8 encoding removes ambiguity about the 8th bit.</span></span>

-   <span data-ttu-id="1959a-659">Vor der .NET Framework Version 2,0 ermöglichte das .NET Framework Spoofing, indem das 8. Bit ignoriert wurde.</span><span class="sxs-lookup"><span data-stu-id="1959a-659">Prior to the .NET Framework version 2.0, the .NET Framework allowed spoofing by ignoring the 8th bit.</span></span> <span data-ttu-id="1959a-660">Beginnend mit dem .NET Framework 2,0 werden nicht-ASCII-Code Punkte während der Decodierung zurückgegriffen.</span><span class="sxs-lookup"><span data-stu-id="1959a-660">Beginning with the .NET Framework 2.0, non-ASCII code points fall back during decoding.</span></span>

 <span data-ttu-id="1959a-661">Das <xref:System.Text.ASCIIEncoding> Objekt, das von dieser Eigenschaft zurückgegeben wird, verfügt möglicherweise nicht über das entsprechende Verhalten für Ihre APP.</span><span class="sxs-lookup"><span data-stu-id="1959a-661">The <xref:System.Text.ASCIIEncoding> object that is returned by this property might not have the appropriate behavior for your app.</span></span> <span data-ttu-id="1959a-662">Er verwendet einen Ersatz Fall Back, um jede Zeichenfolge zu ersetzen, die nicht codiert werden kann, und jedes Byte, das nicht mit einem Fragezeichen ("?") decodiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-662">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="1959a-663">Stattdessen können Sie die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>-Methode aufzurufen, um ein <xref:System.Text.ASCIIEncoding> Objekt zu instanziieren, dessen Fall Back entweder eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>ist, wie im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="1959a-663">Instead, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> method to instantiate an <xref:System.Text.ASCIIEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>

 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]



## Examples
 <span data-ttu-id="1959a-664">Im folgenden Beispiel werden die Auswirkungen der ASCII-Codierung auf Zeichen, die sich außerhalb des ASCII-Bereichs befinden, veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="1959a-664">The following example demonstrates the effect of the ASCII encoding on characters that are outside the ASCII range.</span></span>

 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1959a-665">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1959a-665">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-666">Ruft eine Codierung für das UTF-16-Format mit Big-Endian-Bytereihenfolge ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-666">Gets an encoding for the UTF-16 format that uses the big endian byte order.</span></span></summary>
        <value><span data-ttu-id="1959a-667">Ein Codierungsobjekt für das UTF-16-Format, das die Big-Endian-Bytereihenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="1959a-667">An encoding object for the UTF-16 format that uses the big endian byte order.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-668">Das <xref:System.Text.UnicodeEncoding> Objekt, das von dieser Eigenschaft zurückgegeben wird, verfügt möglicherweise nicht über das entsprechende Verhalten für Ihre APP.</span><span class="sxs-lookup"><span data-stu-id="1959a-668">The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="1959a-669">Er verwendet einen Ersatz Fall Back, um jede Zeichenfolge zu ersetzen, die nicht codiert werden kann, und jedes Byte, das nicht mit einem Fragezeichen ("?") decodiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-669">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="1959a-670">Stattdessen können Sie den <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>-Konstruktor aufzurufen, um ein Big-Endian-<xref:System.Text.UnicodeEncoding> Objekt zu instanziieren, dessen Fall Back entweder eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>ist, wie im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="1959a-670">Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a big endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>

 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]

 <span data-ttu-id="1959a-671">Das zurückgegebene <xref:System.Text.UnicodeEncoding>-Objekt verfügt über die Eigenschaften <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>und <xref:System.Text.Encoding.WebName%2A>, die den Namen "unicodeFFFE" ergeben.</span><span class="sxs-lookup"><span data-stu-id="1959a-671">The returned <xref:System.Text.UnicodeEncoding> object has <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, and <xref:System.Text.Encoding.WebName%2A> properties, which yield the name "unicodeFFFE".</span></span> <span data-ttu-id="1959a-672">Obwohl die UTF-16 Big Endian-Byte Reihenfolge Markierung das hexadezimale FEFF ist, wurde der Name "unicodeFFFE" ausgewählt, da die Byte Reihenfolge-Markierung auf kleinen Endian-Windows-Computern als hexadezimale FFFE angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-672">Although the UTF-16 big endian byte order mark is hexadecimal FEFF, the name "unicodeFFFE" was chosen because the byte order mark appears as hexadecimal FFFE on little endian Windows computers.</span></span>



## Examples
 <span data-ttu-id="1959a-673">Im folgenden Beispiel wird eine Textdatei mit einer UTF-16-Codierung mithilfe der Big-Endian-Byte Reihenfolge gelesen.</span><span class="sxs-lookup"><span data-stu-id="1959a-673">The following example reads a text file with a UTF-16 encoding using the big endian byte order.</span></span>

 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]

 <span data-ttu-id="1959a-674">Im folgenden Beispiel wird die Anzahl der Bytes bestimmt, die zum Codieren eines Zeichen Arrays erforderlich sind, die Zeichen codiert und die resultierenden Bytes angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-674">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1959a-675">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1959a-675">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-676">Beim Überschreiben in einer abgeleiteten Klasse wird ein Name für die aktuelle Codierung abgerufen, die mit den Body-Tags des E-Mail-Agenten verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-676">When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.</span></span></summary>
        <value><span data-ttu-id="1959a-677">Ein Name der aktuellen <see cref="T:System.Text.Encoding" />-Klasse, die mit den Body-Tags des E-Mail-Agenten verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-677">A name for the current <see cref="T:System.Text.Encoding" /> that can be used with mail agent body tags.</span></span>

<span data-ttu-id="1959a-678">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-678">-or-</span></span>

<span data-ttu-id="1959a-679">Eine leere Zeichenfolge (""), wenn das aktuelle <see cref="T:System.Text.Encoding" /> nicht verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-679">An empty string (""), if the current <see cref="T:System.Text.Encoding" /> cannot be used.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-680">Wenn Sie eine Codierung für einen Textkörper Namen benötigen, sollten Sie <xref:System.Text.Encoding.GetEncoding%2A> mit der <xref:System.Text.Encoding.BodyName%2A>-Eigenschaft abrufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-680">If you need an encoding for a body name, you should call <xref:System.Text.Encoding.GetEncoding%2A> with the <xref:System.Text.Encoding.BodyName%2A> property.</span></span> <span data-ttu-id="1959a-681">Häufig wird von der-Methode eine andere Codierung von der im-Befehl bereitgestellten Test Codierung abgerufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-681">Often the method retrieves a different encoding from the test encoding furnished in the call.</span></span> <span data-ttu-id="1959a-682">Im Allgemeinen müssen nur e-Mail-Anwendungen eine solche Codierung abrufen. die meisten anderen Anwendungen, die eine Codierung beschreiben müssen, sollten ihre <xref:System.Text.Encoding.WebName%2A>verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-682">Generally only email applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <xref:System.Text.Encoding.WebName%2A>.</span></span>

 <span data-ttu-id="1959a-683">In einigen Fällen entspricht der Wert der <xref:System.Text.Encoding.BodyName%2A>-Eigenschaft dem internationalen Standard, der diese Codierung definiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-683">In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding.</span></span> <span data-ttu-id="1959a-684">Dies bedeutet nicht, dass die Implementierung vollständig mit diesem Standard übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="1959a-684">This doesn't mean that the implementation complies in full with that standard.</span></span>



## Examples
 <span data-ttu-id="1959a-685">Im folgenden Beispiel werden die anderen Namen für die einzelnen Codierungen abgerufen und die Codierungen mit einem oder mehreren Namen angezeigt, die sich von <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="1959a-685">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1959a-686">Es wird <xref:System.Text.Encoding.EncodingName%2A> angezeigt, aber nicht mit diesem verglichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-686">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1959a-687">Erstellt beim Überschreiben in einer abgeleiteten Klasse eine flache Kopie des aktuellen <see cref="T:System.Text.Encoding" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="1959a-687">When overridden in a derived class, creates a shallow copy of the current <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <returns><span data-ttu-id="1959a-688">Eine Kopie des aktuellen <see cref="T:System.Text.Encoding" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="1959a-688">A copy of the current <see cref="T:System.Text.Encoding" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-689">Der Klon ist beschreibbar, auch wenn das ursprüngliche <xref:System.Text.Encoding>-Objekt schreibgeschützt ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-689">The clone is writable even if the original <xref:System.Text.Encoding> object is read-only.</span></span> <span data-ttu-id="1959a-690">Daher können die Eigenschaften des geklonten geändert werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-690">Therefore, the properties of the clone can be modified.</span></span>

 <span data-ttu-id="1959a-691">Eine flache Kopie eines-Objekts ist nur eine Kopie des-Objekts.</span><span class="sxs-lookup"><span data-stu-id="1959a-691">A shallow copy of an object is a copy of the object only.</span></span> <span data-ttu-id="1959a-692">Wenn das Objekt Verweise auf andere Objekte enthält, erstellt die flache Kopie keine Kopien der referenzierten Objekte.</span><span class="sxs-lookup"><span data-stu-id="1959a-692">If the object contains references to other objects, the shallow copy does not create copies of the referred objects.</span></span> <span data-ttu-id="1959a-693">Stattdessen verweist es auf die ursprünglichen Objekte.</span><span class="sxs-lookup"><span data-stu-id="1959a-693">It refers to the original objects instead.</span></span> <span data-ttu-id="1959a-694">Im Gegensatz dazu erstellt eine tiefe Kopie eines Objekts eine Kopie des Objekts und eine Kopie aller Elemente, die direkt oder indirekt von diesem Objekt referenziert werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-694">In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-695">Ruft den Codepagebezeichner der aktuellen <see cref="T:System.Text.Encoding" />-Klasse beim Überschreiben in einer abgeleiteten Klasse ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-695">When overridden in a derived class, gets the code page identifier of the current <see cref="T:System.Text.Encoding" />.</span></span></summary>
        <value><span data-ttu-id="1959a-696">Der Codepagebezeichner der aktuellen <see cref="T:System.Text.Encoding" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1959a-696">The code page identifier of the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="1959a-697">Im folgenden Beispiel werden die anderen Namen für die einzelnen Codierungen abgerufen und die Codierungen mit einem oder mehreren Namen angezeigt, die sich von <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="1959a-697">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1959a-698">Es wird <xref:System.Text.Encoding.EncodingName%2A> angezeigt, aber nicht mit diesem verglichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-698">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1959a-699">Konvertiert ein Bytearray aus einer Codierung in eine andere.</span><span class="sxs-lookup"><span data-stu-id="1959a-699">Converts a byte array from one encoding to another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding"><span data-ttu-id="1959a-700">Das Codierungsformat von <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-700">The encoding format of <paramref name="bytes" />.</span></span></param>
        <param name="dstEncoding"><span data-ttu-id="1959a-701">Das Zielcodierungsformat.</span><span class="sxs-lookup"><span data-stu-id="1959a-701">The target encoding format.</span></span></param>
        <param name="bytes"><span data-ttu-id="1959a-702">Die zu konvertierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-702">The bytes to convert.</span></span></param>
        <summary><span data-ttu-id="1959a-703">Konvertiert ein vollständiges Bytearray aus einer Codierung in eine andere.</span><span class="sxs-lookup"><span data-stu-id="1959a-703">Converts an entire byte array from one encoding to another.</span></span></summary>
        <returns><span data-ttu-id="1959a-704">Ein Array vom Typ <see cref="T:System.Byte" />, das die Ergebnisse der Konvertierung in <paramref name="bytes" /> von <paramref name="srcEncoding" /> in <paramref name="dstEncoding" /> enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-704">An array of type <see cref="T:System.Byte" /> containing the results of converting <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="1959a-705">Im folgenden Beispiel wird eine Unicode-codierte Zeichenfolge in eine ASCII-codierte Zeichenfolge konvertiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-705">The following example converts a Unicode-encoded string to an ASCII-encoded string.</span></span> <span data-ttu-id="1959a-706">Da das von der <xref:System.Text.Encoding.ASCII%2A>-Eigenschaft zurückgegebene ASCII-Codierungs Objekt den Ersatz Fall Back verwendet und das Pi-Zeichen nicht Teil des ASCII-Zeichensatzes ist, wird das Pi-Zeichen durch ein Fragezeichen ersetzt, wie die Ausgabe des Beispiels zeigt.</span><span class="sxs-lookup"><span data-stu-id="1959a-706">Because the ASCII encoding object returned by the <xref:System.Text.Encoding.ASCII%2A> property uses replacement fallback and the Pi character is not part of the ASCII character set, the Pi character is replaced with a question mark, as the output from the example shows.</span></span>

 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-707"><paramref name="srcEncoding" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-707"><paramref name="srcEncoding" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1959a-708">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-708">-or-</span></span>

 <span data-ttu-id="1959a-709"><paramref name="dstEncoding" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-709"><paramref name="dstEncoding" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1959a-710">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-710">-or-</span></span>

 <span data-ttu-id="1959a-711"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-711"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1959a-712">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-712">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-713">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-713">-and-</span></span>

 <span data-ttu-id="1959a-714">**srcEncoding.**</span><span class="sxs-lookup"><span data-stu-id="1959a-714">**srcEncoding.**</span></span> <span data-ttu-id="1959a-715">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-715"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1959a-716">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-716">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-717">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-717">-and-</span></span>

 <span data-ttu-id="1959a-718">**dstEncoding.**</span><span class="sxs-lookup"><span data-stu-id="1959a-718">**dstEncoding.**</span></span> <span data-ttu-id="1959a-719">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-719"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding"><span data-ttu-id="1959a-720">Die Codierung des Quellarrays, <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-720">The encoding of the source array, <paramref name="bytes" />.</span></span></param>
        <param name="dstEncoding"><span data-ttu-id="1959a-721">Die Codierung des Ausgabearrays.</span><span class="sxs-lookup"><span data-stu-id="1959a-721">The encoding of the output array.</span></span></param>
        <param name="bytes"><span data-ttu-id="1959a-722">Das zu konvertierende Bytearray.</span><span class="sxs-lookup"><span data-stu-id="1959a-722">The array of bytes to convert.</span></span></param>
        <param name="index"><span data-ttu-id="1959a-723">Der Index des ersten zu konvertierenden Elements von <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-723">The index of the first element of <paramref name="bytes" /> to convert.</span></span></param>
        <param name="count"><span data-ttu-id="1959a-724">Die Anzahl der zu konvertierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-724">The number of bytes to convert.</span></span></param>
        <summary><span data-ttu-id="1959a-725">Konvertiert einen Bereich von Bytes in einem Bytearray aus einer Codierung in eine andere.</span><span class="sxs-lookup"><span data-stu-id="1959a-725">Converts a range of bytes in a byte array from one encoding to another.</span></span></summary>
        <returns><span data-ttu-id="1959a-726">Ein Array vom Typ <see cref="T:System.Byte" />, das das Ergebnis der Konvertierung eines Bereichs von Bytes in <paramref name="bytes" /> von <paramref name="srcEncoding" /> in <paramref name="dstEncoding" /> enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-726">An array of type <see cref="T:System.Byte" /> containing the result of converting a range of bytes in <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-727"><paramref name="srcEncoding" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-727"><paramref name="srcEncoding" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1959a-728">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-728">-or-</span></span>

 <span data-ttu-id="1959a-729"><paramref name="dstEncoding" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-729"><paramref name="dstEncoding" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1959a-730">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-730">-or-</span></span>

 <span data-ttu-id="1959a-731"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-731"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-732"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich im Bytearray an.</span><span class="sxs-lookup"><span data-stu-id="1959a-732"><paramref name="index" /> and <paramref name="count" /> do not specify a valid range in the byte array.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1959a-733">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-733">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-734">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-734">-and-</span></span>

 <span data-ttu-id="1959a-735">**srcEncoding.**</span><span class="sxs-lookup"><span data-stu-id="1959a-735">**srcEncoding.**</span></span> <span data-ttu-id="1959a-736">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-736"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1959a-737">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-737">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-738">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-738">-and-</span></span>

 <span data-ttu-id="1959a-739">**dstEncoding.**</span><span class="sxs-lookup"><span data-stu-id="1959a-739">**dstEncoding.**</span></span> <span data-ttu-id="1959a-740">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-740"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DecoderFallback As DecoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback" Usage="System.Text.Encoding.DecoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-741">Ruft das <see cref="T:System.Text.DecoderFallback" />-Objekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-741">Gets or sets the <see cref="T:System.Text.DecoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <value><span data-ttu-id="1959a-742">Das Decoderfallbackobjekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="1959a-742">The decoder fallback object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-743">Das <xref:System.Text.DecoderFallback>-Objekt stellt einen Fehlerhandler dar, der aufgerufen wird, wenn eine codierte Byte Sequenz nicht in ein Zeichen decodiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-743">The <xref:System.Text.DecoderFallback> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character.</span></span> <span data-ttu-id="1959a-744">Jeder der folgenden Handlertypen wird unterstützt:</span><span class="sxs-lookup"><span data-stu-id="1959a-744">Any one of the following handler types is supported:</span></span>

-   <span data-ttu-id="1959a-745">Ein Fall Back-Handler mit der besten Anpassung, der Bytes ersetzt, die nicht mit einem geeigneten Ersatz Zeichen decodiert werden können.</span><span class="sxs-lookup"><span data-stu-id="1959a-745">A best-fit fallback handler, which replaces bytes that cannot be decoded with some suitable replacement character.</span></span>

-   <span data-ttu-id="1959a-746">Ein Ersatz Fall Back Handler, der Bytes ersetzt, die nicht durch ein beliebiges Ersatz Zeichen decodiert werden können.</span><span class="sxs-lookup"><span data-stu-id="1959a-746">A replacement fallback handler, which replaces bytes that cannot be decoded with some arbitrary replacement character.</span></span> <span data-ttu-id="1959a-747">.NET enthält einen Ersatz Fall Back Handler, <xref:System.Text.DecoderFallback>. dieser ersetzt standardmäßig bytes, die nicht decodiert werden können, durch ein Fragezeichen ("?").</span><span class="sxs-lookup"><span data-stu-id="1959a-747">.NET includes one replacement fallback handler, <xref:System.Text.DecoderFallback>, which by default replaces bytes that cannot be decoded with a question mark ("?") character.</span></span>

-   <span data-ttu-id="1959a-748">Ein Ausnahmefall Back Handler, der eine Ausnahme auslöst, wenn Bytes nicht decodiert werden können.</span><span class="sxs-lookup"><span data-stu-id="1959a-748">An exception fallback handler, which throws an exception when bytes cannot be decoded.</span></span> <span data-ttu-id="1959a-749">.NET enthält einen Ausnahmefall Back Handler, <xref:System.Text.DecoderExceptionFallback>, der eine <xref:System.Text.DecoderFallbackException> auslöst, wenn Bytes nicht decodiert werden können.</span><span class="sxs-lookup"><span data-stu-id="1959a-749">.NET includes one exception fallback handler, <xref:System.Text.DecoderExceptionFallback>, which throws a <xref:System.Text.DecoderFallbackException> when bytes cannot be decoded.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-750">Der Wert in einem set-Vorgang ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-750">The value in a set operation is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1959a-751">Ein Wert kann in einem set-Vorgang nicht zugewiesen werden, da das aktuelle <see cref="T:System.Text.Encoding" />-Objekt schreibgeschützt ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-751">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</span></span></exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1959a-752">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1959a-752">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-753">Ruft die Standardcodierung für diese .NET-Implementierung ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-753">Gets the default encoding for this .NET implementation.</span></span></summary>
        <value><span data-ttu-id="1959a-754">Die Standard Codierung für diese .NET-Implementierung.</span><span class="sxs-lookup"><span data-stu-id="1959a-754">The default encoding for this .NET implementation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!WARNING]
>  <span data-ttu-id="1959a-755">Verschiedene Computer können unterschiedliche Codierungen als Standard verwenden, und die Standard Codierung kann sich auf einem einzelnen Computer ändern.</span><span class="sxs-lookup"><span data-stu-id="1959a-755">Different computers can use different encodings as the default, and the default encoding can change on a single computer.</span></span> <span data-ttu-id="1959a-756">Wenn Sie die <xref:System.Text.Encoding.Default%2A> Codierung zum Codieren und Decodieren von Daten verwenden, die zwischen Computern gestreamt werden, oder die zu unterschiedlichen Zeitpunkten auf demselben Computer abgerufen werden, werden diese Daten möglicherweise falsch übersetzt.</span><span class="sxs-lookup"><span data-stu-id="1959a-756">If you use the <xref:System.Text.Encoding.Default%2A> encoding to encode and decode data streamed between computers or retrieved at different times on the same computer, it may translate that data incorrectly.</span></span> <span data-ttu-id="1959a-757">Außerdem verwendet die von der <xref:System.Text.Encoding.Default%2A>-Eigenschaft zurückgegebene Codierung den Fall Back mit der besten Zeichenzahl, um Zeichen, die von der Codepage unterstützt werden, nicht unterstützte Zeichen zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="1959a-757">In addition, the encoding returned by the <xref:System.Text.Encoding.Default%2A> property uses best-fit fallback to map unsupported characters to characters supported by the code page.</span></span> <span data-ttu-id="1959a-758">Aus diesen Gründen wird die Verwendung der Standard Codierung nicht empfohlen.</span><span class="sxs-lookup"><span data-stu-id="1959a-758">For these reasons, using the default encoding is not recommended.</span></span> <span data-ttu-id="1959a-759">Um sicherzustellen, dass codierte Bytes ordnungsgemäß decodiert werden, sollten Sie eine Unicode-Codierung verwenden, wie z. b. <xref:System.Text.UTF8Encoding> oder <xref:System.Text.UnicodeEncoding>.</span><span class="sxs-lookup"><span data-stu-id="1959a-759">To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as <xref:System.Text.UTF8Encoding> or <xref:System.Text.UnicodeEncoding>.</span></span> <span data-ttu-id="1959a-760">Sie können auch ein Protokoll auf höherer Ebene verwenden, um sicherzustellen, dass das gleiche Format zum Codieren und decodieren verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-760">You could also use a higher-level protocol to ensure that the same format is used for encoding and decoding.</span></span>

### <a name="the-default-property-in-the-net-framework"></a><span data-ttu-id="1959a-761">Die Standard Eigenschaft im .NET Framework</span><span class="sxs-lookup"><span data-stu-id="1959a-761">The Default property in the .NET Framework</span></span>

<span data-ttu-id="1959a-762">In der .NET Framework auf dem Windows-Desktop Ruft die <xref:System.Text.Encoding.Default%2A>-Eigenschaft immer die aktive Codepage des Systems ab und erstellt ein <xref:System.Text.Encoding>-Objekt, das Ihr entspricht.</span><span class="sxs-lookup"><span data-stu-id="1959a-762">In the .NET Framework on the Windows desktop, the <xref:System.Text.Encoding.Default%2A> property always gets the system's active code page and creates a <xref:System.Text.Encoding> object that corresponds to it.</span></span> <span data-ttu-id="1959a-763">Die aktive Codepage ist möglicherweise eine ANSI-Codepage, die den ASCII-Zeichensatz samt zusätzlichen Zeichen enthält, die von der Codepage abweichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-763">The active code page may be an ANSI code page, which includes the ASCII character set along with additional characters that vary by code page.</span></span> <span data-ttu-id="1959a-764">Da alle <xref:System.Text.Encoding.Default%2A> Codierungen, die auf ANSI-Codepages basieren, Daten verloren gehen, sollten Sie stattdessen die <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> Codierung verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-764">Because all <xref:System.Text.Encoding.Default%2A> encodings based on ANSI code pages lose data, consider using the <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> encoding instead.</span></span> <span data-ttu-id="1959a-765">UTF-8 ist im Bereich von u + 00 bis u + 7F häufig identisch, kann jedoch ohne Verlust Zeichen außerhalb des ASCII-Bereichs codieren.</span><span class="sxs-lookup"><span data-stu-id="1959a-765">UTF-8 is often identical in the U+00 to U+7F range, but can encode characters outside the ASCII range without loss.</span></span>

## <a name="the-default-property-on-net-core"></a><span data-ttu-id="1959a-766">Die Standard Eigenschaft in .net Core</span><span class="sxs-lookup"><span data-stu-id="1959a-766">The Default property on .NET Core</span></span>

<span data-ttu-id="1959a-767">In .net Core gibt die <xref:System.Text.Encoding.Default%2A>-Eigenschaft immer den <xref:System.Text.UTF8Encoding>zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-767">On .NET Core, the <xref:System.Text.Encoding.Default%2A> property always returns the <xref:System.Text.UTF8Encoding>.</span></span> <span data-ttu-id="1959a-768">UTF-8 wird unter allen Betriebssystemen (Windows, Linux und Max OS X) unterstützt, auf denen .net Core-Anwendungen ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-768">UTF-8 is supported on all the operating systems (Windows, Linux, and Max OS X) on which .NET Core applications run.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EncoderFallback As EncoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback" Usage="System.Text.Encoding.EncoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-769">Ruft das <see cref="T:System.Text.EncoderFallback" />-Objekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-769">Gets or sets the <see cref="T:System.Text.EncoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <value><span data-ttu-id="1959a-770">Das Encoderfallbackobjekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="1959a-770">The encoder fallback object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-771">Das <xref:System.Text.EncoderFallback>-Objekt stellt einen Fehlerhandler dar, der aufgerufen wird, wenn ein Zeichen nicht in eine codierte Byte Sequenz konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-771">The <xref:System.Text.EncoderFallback> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence.</span></span> <span data-ttu-id="1959a-772">Jeder der folgenden Handlertypen wird unterstützt:</span><span class="sxs-lookup"><span data-stu-id="1959a-772">Any one of the following handler types is supported:</span></span>

-   <span data-ttu-id="1959a-773">Ein Fall Back-Handler mit der besten Anpassung, der Zeichen ersetzt, die nicht mit einem geeigneten Ersatz Zeichen codiert werden können.</span><span class="sxs-lookup"><span data-stu-id="1959a-773">A best-fit fallback handler, which replaces characters that cannot be encoded with some suitable replacement character.</span></span>

-   <span data-ttu-id="1959a-774">Ein Ersatz Fall Back Handler, durch den Zeichen ersetzt werden, die nicht mit einem beliebigen Ersatz Zeichen codiert werden können.</span><span class="sxs-lookup"><span data-stu-id="1959a-774">A replacement fallback handler, which replaces characters that cannot be encoded with some arbitrary replacement character.</span></span> <span data-ttu-id="1959a-775">.NET enthält einen Ersatz Fall Back Handler, <xref:System.Text.EncoderFallback>. dieser ersetzt standardmäßig Zeichen, die nicht mit einem Fragezeichen ("?") codiert werden können.</span><span class="sxs-lookup"><span data-stu-id="1959a-775">.NET includes one replacement fallback handler, <xref:System.Text.EncoderFallback>, which by default replaces characters that cannot be encoded with a question mark ("?") character.</span></span>

-   <span data-ttu-id="1959a-776">Ein Ausnahmefall Back Handler, der eine Ausnahme auslöst, wenn Zeichen nicht codiert werden können.</span><span class="sxs-lookup"><span data-stu-id="1959a-776">An exception fallback handler, which throws an exception when characters cannot be encoded.</span></span> <span data-ttu-id="1959a-777">.NET enthält einen Ausnahmefall Back Handler, <xref:System.Text.EncoderExceptionFallback>, der eine <xref:System.Text.EncoderFallbackException> auslöst, wenn Zeichen nicht decodiert werden können.</span><span class="sxs-lookup"><span data-stu-id="1959a-777">.NET includes one exception fallback handler, <xref:System.Text.EncoderExceptionFallback>, which throws an <xref:System.Text.EncoderFallbackException> when characters cannot be decoded.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-778">Der Wert in einem set-Vorgang ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-778">The value in a set operation is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1959a-779">Ein Wert kann in einem set-Vorgang nicht zugewiesen werden, da das aktuelle <see cref="T:System.Text.Encoding" />-Objekt schreibgeschützt ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-779">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</span></span></exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1959a-780">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1959a-780">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-781">Beim Überschreiben in einer abgeleiteten Klasse wird die Klartextbeschreibung der aktuellen Codierung abgerufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-781">When overridden in a derived class, gets the human-readable description of the current encoding.</span></span></summary>
        <value><span data-ttu-id="1959a-782">Die Klartextbeschreibung der aktuellen <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-782">The human-readable description of the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-783">Die <xref:System.Text.Encoding.EncodingName%2A>-Eigenschaft ist für die Anzeige bestimmt.</span><span class="sxs-lookup"><span data-stu-id="1959a-783">The <xref:System.Text.Encoding.EncodingName%2A> property is intended for display.</span></span> <span data-ttu-id="1959a-784">Um einen Namen zu suchen, der an die <xref:System.Text.Encoding.GetEncoding%2A>-Methode übermittelt werden kann, verwenden Sie die <xref:System.Text.Encoding.WebName%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="1959a-784">To find a name that can be passed to the <xref:System.Text.Encoding.GetEncoding%2A> method, use the <xref:System.Text.Encoding.WebName%2A> property.</span></span>



## Examples
 <span data-ttu-id="1959a-785">Im folgenden Beispiel werden die anderen Namen für die einzelnen Codierungen abgerufen und die Codierungen mit einem oder mehreren Namen angezeigt, die sich von <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="1959a-785">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1959a-786">Es wird <xref:System.Text.Encoding.EncodingName%2A> angezeigt, aber nicht mit diesem verglichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-786">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="1959a-787">Das <see cref="T:System.Object" />, das mit der aktuellen Instanz verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1959a-787">The <see cref="T:System.Object" /> to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="1959a-788">Bestimmt, ob das angegebene <see cref="T:System.Object" /> und die aktuelle Instanz gleich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-788">Determines whether the specified <see cref="T:System.Object" /> is equal to the current instance.</span></span></summary>
        <returns><span data-ttu-id="1959a-789"><see langword="true" />, wenn <paramref name="value" /> eine Instanz von <see cref="T:System.Text.Encoding" /> und gleich der aktuellen Instanz ist; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-789"><see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.Encoding" /> and is equal to the current instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-790">Zwei Instanzen von <xref:System.Text.Encoding> werden als gleich betrachtet, wenn Sie derselben Codepage entsprechen und ihre `EncoderFallback` und `DecoderFallback` Objekte gleich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-790">Two instances of <xref:System.Text.Encoding> are considered equal if they correspond to the same code page and their `EncoderFallback` and `DecoderFallback` objects are equal.</span></span> <span data-ttu-id="1959a-791">Insbesondere abgeleitete Codepages verfügen jeweils über eine Codepage von 0, und ihre Fallbacks werden normalerweise `null` (`Nothing` in Visual Basic .net).</span><span class="sxs-lookup"><span data-stu-id="1959a-791">In particular, derived code pages all have a code page of 0 and their fallbacks are normally `null` (`Nothing` in Visual Basic .NET).</span></span> <span data-ttu-id="1959a-792">Folglich werden alle einander als gleich betrachtet.</span><span class="sxs-lookup"><span data-stu-id="1959a-792">Thus they are all considered equal to one another.</span></span> <span data-ttu-id="1959a-793">Eine Folge besteht darin, dass bei der Verwendung <xref:System.Text.Encoding.Equals%2A> zum Auffüllen einer Hash Tabelle alle abgeleiteten Codierungen gleich sind und in denselben Hash Tabellen Slot fallen.</span><span class="sxs-lookup"><span data-stu-id="1959a-793">One consequence is that when <xref:System.Text.Encoding.Equals%2A> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot.</span></span>



## Examples
 <span data-ttu-id="1959a-794">Im folgenden Beispiel werden zwei Instanzen derselben Codierung abgerufen (eine nach Codepage und eine andere nach Namen) und ihre Gleichheit überprüft.</span><span class="sxs-lookup"><span data-stu-id="1959a-794">The following example gets two instances of the same encoding (one by codepage and another by name), and checks their equality.</span></span>

 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1959a-795">Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl an Bytes, die beim Codieren der Zeichen erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-795">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1959a-796">Das Zeichenarray mit den zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-796">The character array containing the characters to encode.</span></span></param>
        <summary><span data-ttu-id="1959a-797">Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl an Bytes, die beim Codieren aller Zeichen im angegebenen Zeichenarray erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-797">When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.</span></span></summary>
        <returns><span data-ttu-id="1959a-798">Die Anzahl der Bytes, die durch Codieren aller Zeichen im angegebenen Zeichenarray erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-798">The number of bytes produced by encoding all the characters in the specified character array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-799">Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, können Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-799">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1959a-800">Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-800">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1959a-801">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-801">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-802">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-802">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1959a-803">Die <xref:System.Text.Encoding.GetBytes%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-803">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1959a-804">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-804">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1959a-805">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-805">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-806">Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-806">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1959a-807">In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-807">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="1959a-808">Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Versionen der <xref:System.Text.Encoding.GetBytes%2A>-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-808">If your app handles string inputs, you should use the string versions of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>

-   <span data-ttu-id="1959a-809">Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen.</span><span class="sxs-lookup"><span data-stu-id="1959a-809">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1959a-810">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-810">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-811">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollten Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-811">If your app must convert a large amount of data, you should reuse the output buffer.</span></span> <span data-ttu-id="1959a-812">In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-812">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1959a-813">Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-813">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1959a-814">Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-814">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-815">Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-815">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1959a-816">Im folgenden Beispiel wird die Anzahl der Bytes bestimmt, die zum Codieren eines Zeichen Arrays erforderlich sind, die Zeichen codiert und die resultierenden Bytes angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-816">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-817"><paramref name="chars" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-817"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1959a-818">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-818">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-819">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-819">-and-</span></span>

 <span data-ttu-id="1959a-820">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-820"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1959a-821">Die zu codierende Spanne von Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-821">The span of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1959a-822">Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl an Bytes, die beim Codieren der Zeichen in der angegebenen Zeichenspanne erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-822">When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified character span.</span></span></summary>
        <returns><span data-ttu-id="1959a-823">Die Anzahl von Bytes, die beim Codieren des angegebenen Zeichenbereichs erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-823">The number of bytes produced by encoding the specified character span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-824">Um die genaue spannen Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, können Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-824">To calculate the exact span size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1959a-825">Um die maximale spannen Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-825">To calculate the maximum span size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1959a-826">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-826">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-827">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-827">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1959a-828">Die <xref:System.Text.Encoding.GetBytes%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-828">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1959a-829">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-829">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1959a-830">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-830">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-831">Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-831">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1959a-832">In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-832">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="1959a-833">Wenn Ihre APP die Eingabe von Eingabezeichen verarbeitet, wird die Span-Version von <xref:System.Text.Encoding.GetBytes%2A> empfohlen.</span><span class="sxs-lookup"><span data-stu-id="1959a-833">If your app handles span of characters inputs, the span version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>

-   <span data-ttu-id="1959a-834">Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-834">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1959a-835">Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabe spannen Puffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-835">The conversion method converts as much data as possible, and does throw an exception if the output span buffer is too small.</span></span> <span data-ttu-id="1959a-836">Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-836">For continuous encoding of a stream, this method is often the best choice.</span></span>
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="1959a-837">Die Zeichenfolge mit den zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-837">The string containing the set of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1959a-838">Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Bytes, die beim Codieren der Zeichen in der angegebenen Zeichenfolge erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-838">When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.</span></span></summary>
        <returns><span data-ttu-id="1959a-839">Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-839">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-840">Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, können Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-840">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1959a-841">Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-841">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1959a-842">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-842">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-843">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-843">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1959a-844">Die <xref:System.Text.Encoding.GetBytes%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-844">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1959a-845">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-845">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1959a-846">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-846">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-847">Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-847">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1959a-848">In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-848">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="1959a-849">Wenn Ihre APP Zeichen folgen Eingaben behandelt, wird die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A> empfohlen.</span><span class="sxs-lookup"><span data-stu-id="1959a-849">If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>

-   <span data-ttu-id="1959a-850">Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen.</span><span class="sxs-lookup"><span data-stu-id="1959a-850">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1959a-851">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-851">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-852">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-852">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-853">In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-853">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1959a-854">Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-854">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1959a-855">Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-855">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-856">Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-856">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1959a-857">Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, die Zeichen codiert und die resultierenden Bytes anzeigt.</span><span class="sxs-lookup"><span data-stu-id="1959a-857">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-858"><paramref name="s" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-858"><paramref name="s" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1959a-859">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-859">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-860">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-860">-and-</span></span>

 <span data-ttu-id="1959a-861">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-861"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1959a-862">Ein Zeiger auf das erste zu codierende Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-862">A pointer to the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="1959a-863">Die Anzahl der zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-863">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1959a-864">Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Bytes, die beim Codieren der Zeichen ab dem Zeichenzeiger erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-864">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</span></span></summary>
        <returns><span data-ttu-id="1959a-865">Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-865">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-866">Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes erfordert, sollten Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-866">To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1959a-867">Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-867">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1959a-868">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-868">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-869">Die <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>-Methode führt die eigentliche Codierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-869">The <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> method performs the actual encoding.</span></span> <span data-ttu-id="1959a-870">Die <xref:System.Text.Encoding.GetBytes%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-870">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1959a-871">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-871">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1959a-872">Im folgenden finden Sie einige Überlegungen zur Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-872">The following are some considerations for using these methods:</span></span>

-   <span data-ttu-id="1959a-873">Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-873">Your app may need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1959a-874">In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-874">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="1959a-875">Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version der <xref:System.Text.Encoding.GetBytes%2A>-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-875">If your app handles string inputs, you should use the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>

-   <span data-ttu-id="1959a-876">Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%2A> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen.</span><span class="sxs-lookup"><span data-stu-id="1959a-876">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%2A> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1959a-877">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-877">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-878">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-878">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-879">In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-879">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1959a-880">Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-880">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1959a-881">Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-881">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-882">Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-882">For continuous encoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-883"><paramref name="chars" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-883"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-884"><paramref name="count" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="1959a-884"><paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1959a-885">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-885">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-886">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-886">-and-</span></span>

 <span data-ttu-id="1959a-887">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-887"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="1959a-888">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="1959a-888">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="1959a-889">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-889">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1959a-890">Das Zeichenarray, das die zu codierenden Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-890">The character array containing the set of characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="1959a-891">Der Index des ersten zu codierenden Zeichens.</span><span class="sxs-lookup"><span data-stu-id="1959a-891">The index of the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="1959a-892">Die Anzahl der zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-892">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1959a-893">Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl an Bytes, die beim Codieren der Zeichen aus dem angegebenen Zeichenarray erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-893">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.</span></span></summary>
        <returns><span data-ttu-id="1959a-894">Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-894">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-895">Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, können Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-895">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1959a-896">Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-896">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1959a-897">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-897">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-898">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-898">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1959a-899">Die <xref:System.Text.Encoding.GetBytes%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-899">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1959a-900">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-900">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1959a-901">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-901">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-902">Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-902">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1959a-903">In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-903">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="1959a-904">Wenn Ihre APP Zeichen folgen Eingaben behandelt, wird die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A> empfohlen.</span><span class="sxs-lookup"><span data-stu-id="1959a-904">If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>

-   <span data-ttu-id="1959a-905">Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen.</span><span class="sxs-lookup"><span data-stu-id="1959a-905">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1959a-906">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-906">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-907">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-907">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-908">In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-908">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1959a-909">Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-909">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1959a-910">Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-910">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-911">Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-911">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1959a-912">Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die erforderlich sind, um drei Zeichen aus einem Zeichen Array zu codieren, die Zeichen zu codieren und die resultierenden Bytes anzeigen.</span><span class="sxs-lookup"><span data-stu-id="1959a-912">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-913"><paramref name="chars" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-913"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-914"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="1959a-914"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="1959a-915">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-915">-or-</span></span>

 <span data-ttu-id="1959a-916"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.</span><span class="sxs-lookup"><span data-stu-id="1959a-916"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1959a-917">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-917">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-918">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-918">-and-</span></span>

 <span data-ttu-id="1959a-919">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-919"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="1959a-920">Die Zeichenfolge mit den zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-920">The string containing the set of characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="1959a-921">Der Index des ersten zu codierenden Zeichens.</span><span class="sxs-lookup"><span data-stu-id="1959a-921">The index of the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="1959a-922">Die Anzahl der zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-922">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1959a-923">Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl an Bytes, die beim Codieren der Zeichen aus der angegebenen Zeichenspanne erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-923">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified string.</span></span></summary>
        <returns><span data-ttu-id="1959a-924">Die Anzahl der Bytes, die beim Codieren der Zeichenfolge erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-924">The number of bytes produced by encoding the string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-925">Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, können Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-925">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1959a-926">Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-926">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1959a-927">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-927">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-928">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-928">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1959a-929">Die <xref:System.Text.Encoding.GetBytes%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-929">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1959a-930">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-930">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1959a-931">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-931">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-932">Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-932">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1959a-933">In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-933">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="1959a-934">Wenn Ihre APP Zeichen folgen Eingaben behandelt, wird die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A> empfohlen.</span><span class="sxs-lookup"><span data-stu-id="1959a-934">If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>

-   <span data-ttu-id="1959a-935">Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen.</span><span class="sxs-lookup"><span data-stu-id="1959a-935">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1959a-936">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-936">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-937">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-937">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-938">In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-938">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1959a-939">Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-939">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1959a-940">Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-940">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-941">Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-941">For continuous encoding of a stream, this method is often the best choice.</span></span>


## Examples
 <span data-ttu-id="1959a-942">Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die erforderlich sind, um drei Zeichen aus einem Zeichen Array zu codieren, die Zeichen zu codieren und die resultierenden Bytes anzeigen.</span><span class="sxs-lookup"><span data-stu-id="1959a-942">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1959a-943">Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen in eine Bytefolge codiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-943">When overridden in a derived class, encodes a set of characters into a sequence of bytes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1959a-944">Das Zeichenarray mit den zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-944">The character array containing the characters to encode.</span></span></param>
        <summary><span data-ttu-id="1959a-945">Beim Überschreiben in einer abgeleiteten Klasse werden alle Zeichen im angegebenen Zeichenarray in eine Bytefolge codiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-945">When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="1959a-946">Ein Bytearray mit den Ergebnissen der Codierung der angegebenen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-946">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-947">Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> verwenden, die von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode bzw. der <xref:System.Text.Encoding.GetEncoder%2A>-Methode der abgeleiteten Klasse bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-947">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1959a-948">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-948">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1959a-949">Die <xref:System.Text.Encoding.GetBytes%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-949">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1959a-950">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-950">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1959a-951">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-951">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-952">Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-952">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1959a-953">In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-953">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="1959a-954">(Eine Zeichenfolge, die Ersatz Zeichenpaare enthält, kann z. b. mit einem hohen Ersatz Zeichen enden.</span><span class="sxs-lookup"><span data-stu-id="1959a-954">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="1959a-955">Der <xref:System.Text.Encoder> speichert das hohe Ersatz Zeichen, sodass es zu Beginn eines folgenden Aufrufes mit einem niedrigen Ersatz Zeichen kombiniert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-955">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="1959a-956"><xref:System.Text.Encoding> nicht in der Lage sein, den Zustand beizubehalten, sodass das Zeichen an die <xref:System.Text.EncoderFallback>gesendet wird.)</span><span class="sxs-lookup"><span data-stu-id="1959a-956"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="1959a-957">Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version der <xref:System.Text.Encoding.GetBytes%2A>-Methode abrufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-957">If your app handles string inputs, you should call the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>

-   <span data-ttu-id="1959a-958">Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen.</span><span class="sxs-lookup"><span data-stu-id="1959a-958">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1959a-959">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-959">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-960">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-960">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-961">In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-961">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1959a-962">Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-962">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1959a-963">Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-963">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-964">Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-964">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1959a-965">Im folgenden Beispiel wird die Anzahl der Bytes bestimmt, die zum Codieren eines Zeichen Arrays erforderlich sind, die Zeichen codiert und die resultierenden Bytes angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-965">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-966"><paramref name="chars" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-966"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1959a-967">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-967">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-968">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-968">-and-</span></span>

 <span data-ttu-id="1959a-969">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-969"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="1959a-970">Die Zeichenfolge mit den zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-970">The string containing the characters to encode.</span></span></param>
        <summary><span data-ttu-id="1959a-971">Beim Überschreiben in einer abgeleiteten Klasse werden alle Zeichen in der angegebenen Zeichenfolge in eine Bytefolge codiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-971">When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="1959a-972">Ein Bytearray mit den Ergebnissen der Codierung der angegebenen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-972">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-973">Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> verwenden, die von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode bzw. der <xref:System.Text.Encoding.GetEncoder%2A>-Methode der abgeleiteten Klasse bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-973">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1959a-974">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-974">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1959a-975">Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-975">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1959a-976">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-976">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1959a-977">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-977">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-978">Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-978">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1959a-979">In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-979">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="1959a-980">(Eine Zeichenfolge, die Ersatz Zeichenpaare enthält, kann z. b. mit einem hohen Ersatz Zeichen enden.</span><span class="sxs-lookup"><span data-stu-id="1959a-980">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="1959a-981">Der <xref:System.Text.Encoder> speichert das hohe Ersatz Zeichen, sodass es zu Beginn eines folgenden Aufrufes mit einem niedrigen Ersatz Zeichen kombiniert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-981">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="1959a-982"><xref:System.Text.Encoding> nicht in der Lage sein, den Zustand beizubehalten, sodass das Zeichen an die <xref:System.Text.EncoderFallback>gesendet wird.)</span><span class="sxs-lookup"><span data-stu-id="1959a-982"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="1959a-983">Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A>verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-983">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="1959a-984">Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen.</span><span class="sxs-lookup"><span data-stu-id="1959a-984">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1959a-985">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-985">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-986">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-986">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-987">In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-987">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1959a-988">Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-988">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1959a-989">Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-989">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-990">Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-990">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1959a-991">Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, die Zeichen codiert und die resultierenden Bytes anzeigt.</span><span class="sxs-lookup"><span data-stu-id="1959a-991">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-992"><paramref name="s" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-992"><paramref name="s" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1959a-993">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-993">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-994">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-994">-and-</span></span>

 <span data-ttu-id="1959a-995">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-995"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1959a-996">Die Spanne mit den zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-996">The span containing the set of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="1959a-997">Die Bytespanne, die die codierten Bytes enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="1959a-997">The byte span to hold the encoded bytes.</span></span></param>
        <summary><span data-ttu-id="1959a-998">Codiert beim Überschreiben in einer abgeleiteten Klasse eine Gruppe von Zeichen aus der angegebenen schreibgeschützten Spanne in eine Bytespanne.</span><span class="sxs-lookup"><span data-stu-id="1959a-998">When overridden in a derived class, encodes into a span of bytes a set of characters from the specified read-only span.</span></span></summary>
        <returns><span data-ttu-id="1959a-999">Die Anzahl der codierten Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-999">The number of encoded bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1000">Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> verwenden, die von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode bzw. der <xref:System.Text.Encoding.GetEncoder%2A>-Methode der abgeleiteten Klasse bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1000">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1959a-1001">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-1001">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1959a-1002">Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1002">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1959a-1003">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1003">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1959a-1004">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-1004">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-1005">Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1005">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1959a-1006">In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1006">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="1959a-1007">(Eine Zeichenfolge, die Ersatz Zeichenpaare enthält, kann z. b. mit einem hohen Ersatz Zeichen enden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1007">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="1959a-1008">Der <xref:System.Text.Encoder> speichert das hohe Ersatz Zeichen, sodass es zu Beginn eines folgenden Aufrufes mit einem niedrigen Ersatz Zeichen kombiniert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1008">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="1959a-1009"><xref:System.Text.Encoding> nicht in der Lage sein, den Zustand beizubehalten, sodass das Zeichen an die <xref:System.Text.EncoderFallback>gesendet wird.)</span><span class="sxs-lookup"><span data-stu-id="1959a-1009"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="1959a-1010">Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A>verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1010">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="1959a-1011">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1011">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-1012">In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1012">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1959a-1013">Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1013">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1959a-1014">Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1014">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-1015">Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1015">For continuous encoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1959a-1016">Das Zeichenarray, das die zu codierenden Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1016">The character array containing the set of characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="1959a-1017">Der Index des ersten zu codierenden Zeichens.</span><span class="sxs-lookup"><span data-stu-id="1959a-1017">The index of the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="1959a-1018">Die Anzahl der zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1018">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1959a-1019">Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen im angegebenen Zeichenarray in eine Bytefolge codiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1019">When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="1959a-1020">Ein Bytearray mit den Ergebnissen der Codierung der angegebenen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1020">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1021">Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> verwenden, die von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode bzw. der <xref:System.Text.Encoding.GetEncoder%2A>-Methode der abgeleiteten Klasse bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1021">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1959a-1022">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-1022">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1959a-1023">Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1023">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1959a-1024">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1024">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1959a-1025">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-1025">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-1026">Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1026">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1959a-1027">In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1027">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="1959a-1028">(Eine Zeichenfolge, die Ersatz Zeichenpaare enthält, kann z. b. mit einem hohen Ersatz Zeichen enden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1028">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="1959a-1029">Der <xref:System.Text.Encoder> speichert das hohe Ersatz Zeichen, sodass es zu Beginn eines folgenden Aufrufes mit einem niedrigen Ersatz Zeichen kombiniert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1029">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="1959a-1030"><xref:System.Text.Encoding> nicht in der Lage sein, den Zustand beizubehalten, sodass das Zeichen an die <xref:System.Text.EncoderFallback>gesendet wird.)</span><span class="sxs-lookup"><span data-stu-id="1959a-1030"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="1959a-1031">Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A>verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1031">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="1959a-1032">Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1032">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1959a-1033">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1033">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-1034">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1034">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-1035">In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1035">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1959a-1036">Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1036">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1959a-1037">Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1037">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-1038">Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1038">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1959a-1039">Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die erforderlich sind, um drei Zeichen aus einem Zeichen Array zu codieren, die Zeichen zu codieren und die resultierenden Bytes anzeigen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1039">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-1040"><paramref name="chars" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1040"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-1041"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="1959a-1041"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="1959a-1042">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1042">-or-</span></span>

 <span data-ttu-id="1959a-1043"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.</span><span class="sxs-lookup"><span data-stu-id="1959a-1043"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1959a-1044">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-1044">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-1045">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-1045">-and-</span></span>

 <span data-ttu-id="1959a-1046">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1046"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="1959a-1047">Die Zeichenfolge mit den zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1047">The string containing the characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="1959a-1048">Der Index in der Zeichenfolge, ab dem die Codierung beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="1959a-1048">The index inside the string to start the encoding from.</span></span></param>
        <param name="count"><span data-ttu-id="1959a-1049">Die Anzahl der zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1049">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1959a-1050">Codiert beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die durch <paramref name="count" /> in der angegebenen Zeichenfolge angegeben werden, ab dem angegebenen <paramref name="index" /> in ein Bytearray.</span><span class="sxs-lookup"><span data-stu-id="1959a-1050">When overridden in a derived class, encodes into an array of bytes the number of characters specified by <paramref name="count" /> in the specified string, starting from the specified <paramref name="index" />.</span></span></summary>
        <returns><span data-ttu-id="1959a-1051">Ein Bytearray mit den Ergebnissen der Codierung der angegebenen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1051">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1052">Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> verwenden, die von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode bzw. der <xref:System.Text.Encoding.GetEncoder%2A>-Methode der abgeleiteten Klasse bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1052">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1959a-1053">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-1053">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1959a-1054">Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1054">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1959a-1055">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1055">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1959a-1056">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-1056">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-1057">Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1057">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1959a-1058">In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1058">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="1959a-1059">(Eine Zeichenfolge, die Ersatz Zeichenpaare enthält, kann z. b. mit einem hohen Ersatz Zeichen enden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1059">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="1959a-1060">Der <xref:System.Text.Encoder> speichert das hohe Ersatz Zeichen, sodass es zu Beginn eines folgenden Aufrufes mit einem niedrigen Ersatz Zeichen kombiniert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1060">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="1959a-1061"><xref:System.Text.Encoding> nicht in der Lage sein, den Zustand beizubehalten, sodass das Zeichen an die <xref:System.Text.EncoderFallback>gesendet wird.)</span><span class="sxs-lookup"><span data-stu-id="1959a-1061"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="1959a-1062">Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A>verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1062">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="1959a-1063">Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1063">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1959a-1064">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1064">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-1065">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1065">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-1066">In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1066">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1959a-1067">Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1067">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1959a-1068">Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1068">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-1069">Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1069">For continuous encoding of a stream, this method is often the best choice.</span></span>


## Examples
 <span data-ttu-id="1959a-1070">Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, die Zeichen codiert und die resultierenden Bytes anzeigt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1070">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1959a-1071">Ein Zeiger auf das erste zu codierende Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1071">A pointer to the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="1959a-1072">Die Anzahl der zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1072">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="1959a-1073">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1959a-1073">A pointer to the location at which to start writing the resulting sequence of bytes.</span></span></param>
        <param name="byteCount"><span data-ttu-id="1959a-1074">Die maximal zu schreibende Anzahl von Byte.</span><span class="sxs-lookup"><span data-stu-id="1959a-1074">The maximum number of bytes to write.</span></span></param>
        <summary><span data-ttu-id="1959a-1075">Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen beginnend am angegebenen Zeichenzeiger in eine Bytefolge codiert, die ab Beginn des angegebenen Bytezeigers gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1075">When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</span></span></summary>
        <returns><span data-ttu-id="1959a-1076">Die tatsächliche Anzahl an Bytes, die an der durch den <paramref name="bytes" />-Parameter angegebenen Position geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1076">The actual number of bytes written at the location indicated by the <paramref name="bytes" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1077">Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes erfordert, müssen Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1077">To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1959a-1078">Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1078">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1959a-1079">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1079">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-1080">Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> Objekt von der bereitgestellten <xref:System.Text.Encoding.GetDecoder%2A> oder <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.</span><span class="sxs-lookup"><span data-stu-id="1959a-1080">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1959a-1081">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-1081">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1959a-1082">Die <xref:System.Text.Encoding.GetBytes%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1082">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1959a-1083">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1083">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1959a-1084">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-1084">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-1085">Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1085">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1959a-1086">In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1086">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="1959a-1087">(Eine Zeichenfolge, die Ersatz Zeichenpaare enthält, kann z. b. mit einem hohen Ersatz Zeichen enden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1087">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="1959a-1088">Der <xref:System.Text.Encoder> speichert das hohe Ersatz Zeichen, sodass es zu Beginn eines folgenden Aufrufes mit einem niedrigen Ersatz Zeichen kombiniert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1088">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="1959a-1089"><xref:System.Text.Encoding> nicht in der Lage sein, den Zustand beizubehalten, sodass das Zeichen an die <xref:System.Text.EncoderFallback>gesendet wird.)</span><span class="sxs-lookup"><span data-stu-id="1959a-1089"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="1959a-1090">Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A>verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1090">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="1959a-1091">Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1091">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1959a-1092">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1092">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-1093">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1093">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-1094">In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1094">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1959a-1095">Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1095">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1959a-1096">Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1096">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-1097">Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1097">For continuous encoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-1098"><paramref name="chars" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1098"><paramref name="chars" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1959a-1099">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1099">-or-</span></span>

 <span data-ttu-id="1959a-1100"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1100"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-1101"><paramref name="charCount" /> oder <paramref name="byteCount" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="1959a-1101"><paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1959a-1102"><paramref name="byteCount" /> ist niedriger als die sich ergebende Anzahl von Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-1102"><paramref name="byteCount" /> is less than the resulting number of bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1959a-1103">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-1103">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-1104">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-1104">-and-</span></span>

 <span data-ttu-id="1959a-1105">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1105"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="1959a-1106">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="1959a-1106">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="1959a-1107">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1107">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1959a-1108">Das Zeichenarray, das die zu codierenden Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1108">The character array containing the set of characters to encode.</span></span></param>
        <param name="charIndex"><span data-ttu-id="1959a-1109">Der Index des ersten zu codierenden Zeichens.</span><span class="sxs-lookup"><span data-stu-id="1959a-1109">The index of the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="1959a-1110">Die Anzahl der zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1110">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="1959a-1111">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="1959a-1111">The byte array to contain the resulting sequence of bytes.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="1959a-1112">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1959a-1112">The index at which to start writing the resulting sequence of bytes.</span></span></param>
        <summary><span data-ttu-id="1959a-1113">Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen aus dem angegebenen Zeichenarray in das angegebene Bytearray codiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1113">When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="1959a-1114">Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1114">The actual number of bytes written into <paramref name="bytes" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1115">Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, sollten Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1115">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1959a-1116">Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1116">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1959a-1117">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1117">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-1118">Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> verwenden, die von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode bzw. der <xref:System.Text.Encoding.GetEncoder%2A>-Methode der abgeleiteten Klasse bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1118">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1959a-1119">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-1119">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1959a-1120">Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1120">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1959a-1121">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1121">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1959a-1122">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-1122">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-1123">Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1123">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1959a-1124">In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1124">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="1959a-1125">(Eine Zeichenfolge, die Ersatz Zeichenpaare enthält, kann z. b. mit einem hohen Ersatz Zeichen enden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1125">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="1959a-1126">Der <xref:System.Text.Encoder> speichert das hohe Ersatz Zeichen, sodass es zu Beginn eines folgenden Aufrufes mit einem niedrigen Ersatz Zeichen kombiniert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1126">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="1959a-1127"><xref:System.Text.Encoding> nicht in der Lage sein, den Zustand beizubehalten, sodass das Zeichen an die <xref:System.Text.EncoderFallback>gesendet wird.)</span><span class="sxs-lookup"><span data-stu-id="1959a-1127"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="1959a-1128">Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A>verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1128">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="1959a-1129">Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1129">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1959a-1130">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1130">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-1131">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1131">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-1132">In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1132">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1959a-1133">Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1133">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1959a-1134">Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1134">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-1135">Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1135">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1959a-1136">Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die erforderlich sind, um drei Zeichen aus einem Zeichen Array zu codieren, die Zeichen zu codieren und die resultierenden Bytes anzeigen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1136">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-1137"><paramref name="chars" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1137"><paramref name="chars" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1959a-1138">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1138">-or-</span></span>

 <span data-ttu-id="1959a-1139"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1139"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-1140"><paramref name="charIndex" />, <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="1959a-1140"><paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span></span>

<span data-ttu-id="1959a-1141">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1141">-or-</span></span>

 <span data-ttu-id="1959a-1142"><paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.</span><span class="sxs-lookup"><span data-stu-id="1959a-1142"><paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span></span>

<span data-ttu-id="1959a-1143">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1143">-or-</span></span>

 <span data-ttu-id="1959a-1144"><paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1144"><paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1959a-1145"><paramref name="bytes" /> hat von <paramref name="byteIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1145"><paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1959a-1146">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-1146">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-1147">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-1147">-and-</span></span>

 <span data-ttu-id="1959a-1148">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1148"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="1959a-1149">Die Zeichenfolge mit den zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1149">The string containing the set of characters to encode.</span></span></param>
        <param name="charIndex"><span data-ttu-id="1959a-1150">Der Index des ersten zu codierenden Zeichens.</span><span class="sxs-lookup"><span data-stu-id="1959a-1150">The index of the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="1959a-1151">Die Anzahl der zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1151">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="1959a-1152">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="1959a-1152">The byte array to contain the resulting sequence of bytes.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="1959a-1153">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1959a-1153">The index at which to start writing the resulting sequence of bytes.</span></span></param>
        <summary><span data-ttu-id="1959a-1154">Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen aus der angegebenen Zeichenfolge in das angegebene Bytearray codiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1154">When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="1959a-1155">Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1155">The actual number of bytes written into <paramref name="bytes" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1156">Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, sollten Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1156">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1959a-1157">Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1157">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1959a-1158">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1158">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-1159">Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> verwenden, die von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode bzw. der <xref:System.Text.Encoding.GetEncoder%2A>-Methode der abgeleiteten Klasse bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1159">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1959a-1160">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-1160">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="1959a-1161">Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode, die mehrere Konvertierungen in einem einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1161">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="1959a-1162">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1162">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="1959a-1163">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-1163">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-1164">Möglicherweise muss Ihre APP viele Eingabezeichen in eine Codepage codieren und die Zeichen mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1164">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="1959a-1165">In diesem Fall müssen Sie möglicherweise den Status zwischen den Aufrufen beibehalten und dabei den Zustand berücksichtigen, der vom verwendeten <xref:System.Text.Encoder> Objekt persistent gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1165">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="1959a-1166">(Eine Zeichenfolge, die Ersatz Zeichenpaare enthält, kann z. b. mit einem hohen Ersatz Zeichen enden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1166">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="1959a-1167">Der <xref:System.Text.Encoder> speichert das hohe Ersatz Zeichen, sodass es zu Beginn eines folgenden Aufrufes mit einem niedrigen Ersatz Zeichen kombiniert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1167">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="1959a-1168"><xref:System.Text.Encoding> nicht in der Lage sein, den Zustand beizubehalten, sodass das Zeichen an die <xref:System.Text.EncoderFallback>gesendet wird.)</span><span class="sxs-lookup"><span data-stu-id="1959a-1168"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="1959a-1169">Wenn Ihre APP Zeichen folgen Eingaben behandelt, sollten Sie die Zeichen folgen Version von <xref:System.Text.Encoding.GetBytes%2A>verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1169">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="1959a-1170">Die Unicode-Zeichen Puffer Version von <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren aufrufen, die das <xref:System.Text.Encoder>-Objekt verwenden oder in vorhandene Puffer einfügen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1170">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="1959a-1171">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1171">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-1172">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1172">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-1173">In diesem Fall ist die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte Arrays unterstützt, die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1173">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="1959a-1174">Verwenden Sie die <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1174">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1959a-1175">Die Konvertierungsmethode konvertiert so viele Daten wie möglich, und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1175">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-1176">Bei der kontinuierlichen Codierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1176">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1959a-1177">Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, die Zeichen codiert und die resultierenden Bytes anzeigt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1177">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-1178"><paramref name="s" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1178"><paramref name="s" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1959a-1179">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1179">-or-</span></span>

 <span data-ttu-id="1959a-1180"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1180"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-1181"><paramref name="charIndex" />, <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="1959a-1181"><paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span></span>

<span data-ttu-id="1959a-1182">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1182">-or-</span></span>

 <span data-ttu-id="1959a-1183"><paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.</span><span class="sxs-lookup"><span data-stu-id="1959a-1183"><paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span></span>

<span data-ttu-id="1959a-1184">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1184">-or-</span></span>

 <span data-ttu-id="1959a-1185"><paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1185"><paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1959a-1186"><paramref name="bytes" /> hat von <paramref name="byteIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1186"><paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1959a-1187">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-1187">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-1188">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-1188">-and-</span></span>

 <span data-ttu-id="1959a-1189">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1189"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1959a-1190">Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren einer Bytefolge erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1190">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1959a-1191">Das Bytearray, das die zu decodierende Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1191">The byte array containing the sequence of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1959a-1192">Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren aller Bytes in dem angegebenen Bytearray erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1192">When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="1959a-1193">Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1193">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1194">Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> zum Speichern der resultierenden Zeichen benötigt, sollten Sie die <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1194">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method.</span></span> <span data-ttu-id="1959a-1195">Verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29>-Methode, um die maximale Array Größe zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1195">To calculate the maximum array size, you should use the <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> method.</span></span> <span data-ttu-id="1959a-1196">Die <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1196">The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-1197">Die <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29>-Methode führt die eigentliche Decodierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-1197">The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method determines how many characters result in decoding a sequence of bytes, and the  <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> method performs the actual decoding.</span></span> <span data-ttu-id="1959a-1198">Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1198">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1959a-1199">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1199">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1959a-1200">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-1200">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-1201">Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1201">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1959a-1202">In diesem Fall müssen Sie den Status zwischen den Aufrufen wahrscheinlich beibehalten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1202">In this case, you probably need to maintain state between calls.</span></span>

-   <span data-ttu-id="1959a-1203">Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, sollten Sie die <xref:System.Text.Encoding.GetString%2A>-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1203">If your app handles string outputs, you should use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="1959a-1204">Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1204">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1959a-1205">Die Byte-Version von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren Aufrufen großer Puffer.</span><span class="sxs-lookup"><span data-stu-id="1959a-1205">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="1959a-1206">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1206">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-1207">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1207">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-1208">In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1208">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1959a-1209">Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1209">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1959a-1210">Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1210">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-1211">Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1211">For continuous decoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1959a-1212">Im folgenden Beispiel wird eine Zeichenfolge in ein Bytearray codiert und dann in ein Zeichen Array decodiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1212">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-1213"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1213"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1959a-1214">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-1214">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-1215">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-1215">-and-</span></span>

 <span data-ttu-id="1959a-1216">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1216"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1959a-1217">Eine zu decodierende schreibgeschützte Bytespanne.</span><span class="sxs-lookup"><span data-stu-id="1959a-1217">A read-only byte span to decode.</span></span></param>
        <summary><span data-ttu-id="1959a-1218">Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren der angegebenen schreibgeschützten Bytespanne erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1218">When overridden in a derived class, calculates the number of characters produced by decoding the provided read-only byte span.</span></span></summary>
        <returns><span data-ttu-id="1959a-1219">Die Anzahl von Zeichen, die beim Decodieren der Bytespanne erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1219">The number of characters produced by decoding the byte span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1220">Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen erfordert, sollten Sie die <xref:System.Text.Encoding.GetCharCount%2A>-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1220">To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1959a-1221">Verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode, um die maximale Array Größe zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1221">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1959a-1222">Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1222">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-1223">Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%2A>-Methode führt die eigentliche Decodierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-1223">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="1959a-1224">Die <xref:System.Text.Encoding.GetChars%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1224">The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1959a-1225">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1225">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1959a-1226">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-1226">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-1227">Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1227">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1959a-1228">In diesem Fall müssen Sie den Status zwischen den Aufrufen wahrscheinlich beibehalten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1228">In this case, you probably need to maintain state between calls.</span></span>

-   <span data-ttu-id="1959a-1229">Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, empfiehlt es sich, die <xref:System.Text.Encoding.GetString%2A>-Methode zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1229">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="1959a-1230">Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1230">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1959a-1231">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1231">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-1232">In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1232">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1959a-1233">Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1233">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1959a-1234">Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1234">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-1235">Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1235">For continuous decoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1959a-1236">Ein Zeiger auf das erste zu decodierende Byte.</span><span class="sxs-lookup"><span data-stu-id="1959a-1236">A pointer to the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="1959a-1237">Die Anzahl der zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-1237">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1959a-1238">Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren einer Bytefolge ab dem angegebenen Bytezeiger erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1238">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</span></span></summary>
        <returns><span data-ttu-id="1959a-1239">Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1239">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1240">Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen erfordert, sollten Sie die <xref:System.Text.Encoding.GetCharCount%2A>-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1240">To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1959a-1241">Verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode, um die maximale Array Größe zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1241">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1959a-1242">Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1242">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-1243">Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%2A>-Methode führt die eigentliche Decodierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-1243">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="1959a-1244">Die <xref:System.Text.Encoding.GetChars%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1244">The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1959a-1245">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1245">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1959a-1246">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-1246">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-1247">Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1247">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1959a-1248">In diesem Fall müssen Sie den Status zwischen den Aufrufen wahrscheinlich beibehalten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1248">In this case, you probably need to maintain state between calls.</span></span>

-   <span data-ttu-id="1959a-1249">Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, empfiehlt es sich, die <xref:System.Text.Encoding.GetString%2A>-Methode zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1249">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="1959a-1250">Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1250">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1959a-1251">Die Byte-Version von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren Aufrufen großer Puffer.</span><span class="sxs-lookup"><span data-stu-id="1959a-1251">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="1959a-1252">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1252">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-1253">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1253">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-1254">In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1254">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1959a-1255">Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1255">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1959a-1256">Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1256">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-1257">Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1257">For continuous decoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-1258"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1258"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-1259"><paramref name="count" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="1959a-1259"><paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1959a-1260">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-1260">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-1261">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-1261">-and-</span></span>

 <span data-ttu-id="1959a-1262">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1262"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="1959a-1263">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="1959a-1263">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="1959a-1264">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1264">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1959a-1265">Das Bytearray, das die zu decodierende Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1265">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="1959a-1266">Der Index des ersten zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-1266">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="1959a-1267">Die Anzahl der zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-1267">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1959a-1268">Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren einer Bytefolge aus dem angegebenen Bytearray erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1268">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="1959a-1269">Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1269">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1270">Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, sollten Sie die <xref:System.Text.Encoding.GetCharCount%2A>-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1270">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1959a-1271">Verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode, um die maximale Array Größe zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1271">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1959a-1272">Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1272">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-1273">Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%2A>-Methode führt die eigentliche Decodierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-1273">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="1959a-1274">Die <xref:System.Text.Encoding.GetChars%2A>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1274">The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1959a-1275">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1275">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1959a-1276">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-1276">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-1277">Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1277">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1959a-1278">In diesem Fall müssen Sie den Status zwischen den Aufrufen wahrscheinlich beibehalten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1278">In this case, you probably need to maintain state between calls.</span></span>

-   <span data-ttu-id="1959a-1279">Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, empfiehlt es sich, die <xref:System.Text.Encoding.GetString%2A>-Methode zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1279">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="1959a-1280">Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1280">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1959a-1281">Die Byte-Version von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren Aufrufen großer Puffer.</span><span class="sxs-lookup"><span data-stu-id="1959a-1281">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="1959a-1282">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1282">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-1283">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1283">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-1284">In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1284">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1959a-1285">Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1285">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1959a-1286">Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1286">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-1287">Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1287">For continuous decoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1959a-1288">Im folgenden Beispiel wird eine Zeichenfolge von einer Codierung in eine andere konvertiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1288">The following example converts a string from one encoding to another.</span></span>

 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]

 <span data-ttu-id="1959a-1289">Im folgenden Beispiel wird eine Zeichenfolge in ein Bytearray codiert und dann ein Bereich von Bytes in ein Zeichen Array decodiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1289">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-1290"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1290"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-1291"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="1959a-1291"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="1959a-1292">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1292">-or-</span></span>

 <span data-ttu-id="1959a-1293"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</span><span class="sxs-lookup"><span data-stu-id="1959a-1293"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1959a-1294">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-1294">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-1295">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-1295">-and-</span></span>

 <span data-ttu-id="1959a-1296">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1296"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1959a-1297">Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge in Zeichen decodiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1297">When overridden in a derived class, decodes a sequence of bytes into a set of characters.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1959a-1298">Das Bytearray, das die zu decodierende Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1298">The byte array containing the sequence of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1959a-1299">Beim Überschreiben in einer abgeleiteten Klasse werden alle Bytes im angegebenen Bytearray in Zeichen decodiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1299">When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.</span></span></summary>
        <returns><span data-ttu-id="1959a-1300">Ein Zeichenarray, das die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1300">A character array containing the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1301"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> ruft Zeichen aus einer Eingabe Byte Sequenz ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-1301"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="1959a-1302"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, da <xref:System.Text.Encoding> diskrete Konvertierungen erwartet, während <xref:System.Text.Decoder> für mehrere Durchgänge in einem einzelnen Eingabestream konzipiert ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1302"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1959a-1303">Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> verwenden, die von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode bzw. der <xref:System.Text.Encoding.GetEncoder%2A>-Methode der abgeleiteten Klasse bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1303">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1959a-1304">**Hinweis** Diese Methode ist für die Verwendung von Unicode-Zeichen vorgesehen, nicht für beliebige Binärdaten, wie z. b. Byte Arrays.</span><span class="sxs-lookup"><span data-stu-id="1959a-1304">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="1959a-1305">Wenn Sie beliebige Binärdaten in Text codieren müssen, sollten Sie ein Protokoll wie z. b. UUEncode verwenden, das von Methoden wie z. b. <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1305">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="1959a-1306">Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%2A>-Methode führt die eigentliche Decodierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-1306">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="1959a-1307">Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1307">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1959a-1308">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1308">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1959a-1309">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-1309">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-1310">Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1310">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1959a-1311">In diesem Fall müssen Sie den Status zwischen Aufrufen wahrscheinlich beibehalten, da Byte Sequenzen bei der Verarbeitung in Batches unterbrochen werden können.</span><span class="sxs-lookup"><span data-stu-id="1959a-1311">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="1959a-1312">(Beispielsweise kann ein Teil einer ISO-2022-Verschiebungs Sequenz einen <xref:System.Text.Encoding.GetChars%2A> Aufrufe beenden und zu Beginn des nächsten <xref:System.Text.Encoding.GetChars%2A>-Aufrufes fortsetzen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1312">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="1959a-1313"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft den Fall Back für diese unvollständigen Sequenzen auf, aber <xref:System.Text.Decoder> speichert diese Sequenzen für den nächsten-Befehl.)</span><span class="sxs-lookup"><span data-stu-id="1959a-1313"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>

-   <span data-ttu-id="1959a-1314">Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, empfiehlt es sich, die <xref:System.Text.Encoding.GetString%2A>-Methode zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1314">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="1959a-1315">Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1315">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1959a-1316">Die Byte-Version von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren Aufrufen großer Puffer.</span><span class="sxs-lookup"><span data-stu-id="1959a-1316">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="1959a-1317">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1317">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-1318">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1318">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-1319">In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1319">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1959a-1320">Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1320">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1959a-1321">Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1321">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-1322">Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1322">For continuous decoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1959a-1323">Im folgenden Beispiel wird eine Zeichenfolge in ein Bytearray codiert und dann in ein Zeichen Array decodiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1323">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-1324"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1324"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1959a-1325">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-1325">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-1326">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-1326">-and-</span></span>

 <span data-ttu-id="1959a-1327">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1327"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1959a-1328">Eine schreibgeschützte Spanne, die die zu decodierende Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1328">A read-only span containing the sequence of bytes to decode.</span></span></param>
        <param name="chars"><span data-ttu-id="1959a-1329">Die Zeichenspanne, die die decodierten Bytes empfängt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1329">The character span receiving the decoded bytes.</span></span></param>
        <summary><span data-ttu-id="1959a-1330">Decodiert beim Überschreiben in einer abgeleiteten Klasse alle Bytes in der angegebenen schreibgeschützten Bytespanne in eine Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="1959a-1330">When overridden in a derived class, decodes all the bytes in the specified read-only byte span into a character span.</span></span></summary>
        <returns><span data-ttu-id="1959a-1331">Die Anzahl der decodierten Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-1331">The number of decoded bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1332"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> ruft Zeichen aus einer Eingabe Byte Spanne ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-1332"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte span.</span></span> <span data-ttu-id="1959a-1333"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, da <xref:System.Text.Encoding> diskrete Konvertierungen erwartet, während <xref:System.Text.Decoder> für mehrere Durchgänge in einem einzelnen Eingabestream konzipiert ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1333"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1959a-1334">Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> verwenden, die von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode bzw. der <xref:System.Text.Encoding.GetEncoder%2A>-Methode der abgeleiteten Klasse bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1334">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1959a-1335">Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%2A>-Methode führt die eigentliche Decodierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-1335">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="1959a-1336">Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1336">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1959a-1337">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1337">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1959a-1338">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-1338">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-1339">Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1339">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1959a-1340">In diesem Fall müssen Sie den Status zwischen Aufrufen wahrscheinlich beibehalten, da Byte Sequenzen bei der Verarbeitung in Batches unterbrochen werden können.</span><span class="sxs-lookup"><span data-stu-id="1959a-1340">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="1959a-1341">(Beispielsweise kann ein Teil einer ISO-2022-Verschiebungs Sequenz einen <xref:System.Text.Encoding.GetChars%2A> Aufrufe beenden und zu Beginn des nächsten <xref:System.Text.Encoding.GetChars%2A>-Aufrufes fortsetzen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1341">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="1959a-1342"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft den Fall Back für diese unvollständigen Sequenzen auf, aber <xref:System.Text.Decoder> speichert diese Sequenzen für den nächsten-Befehl.)</span><span class="sxs-lookup"><span data-stu-id="1959a-1342"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>

-   <span data-ttu-id="1959a-1343">Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, empfiehlt es sich, die <xref:System.Text.Encoding.GetString%2A>-Methode zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1343">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="1959a-1344">Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1344">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1959a-1345">Die Byte-Version von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren Aufrufen großer Puffer.</span><span class="sxs-lookup"><span data-stu-id="1959a-1345">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="1959a-1346">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1346">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-1347">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1347">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-1348">In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1348">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1959a-1349">Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1349">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1959a-1350">Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1350">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-1351">Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1351">For continuous decoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1959a-1352">Das Bytearray, das die zu decodierende Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1352">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="1959a-1353">Der Index des ersten zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-1353">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="1959a-1354">Die Anzahl der zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-1354">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1959a-1355">Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge aus dem angegebenen Bytearray in Zeichen decodiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1355">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.</span></span></summary>
        <returns><span data-ttu-id="1959a-1356">Ein Zeichenarray, das die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1356">A character array containing the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1357"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> ruft Zeichen aus einer Eingabe Byte Sequenz ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-1357"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="1959a-1358"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, da <xref:System.Text.Encoding> diskrete Konvertierungen erwartet, während <xref:System.Text.Decoder> für mehrere Durchgänge in einem einzelnen Eingabestream konzipiert ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1358"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1959a-1359">Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> verwenden, die von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode bzw. der <xref:System.Text.Encoding.GetEncoder%2A>-Methode der abgeleiteten Klasse bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1359">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1959a-1360">**Hinweis** Diese Methode ist für die Verwendung von Unicode-Zeichen vorgesehen, nicht für beliebige Binärdaten, wie z. b. Byte Arrays.</span><span class="sxs-lookup"><span data-stu-id="1959a-1360">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="1959a-1361">Wenn Sie beliebige Binärdaten in Text codieren müssen, sollten Sie ein Protokoll wie z. b. UUEncode verwenden, das von Methoden wie z. b. <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1361">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="1959a-1362">Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%2A>-Methode führt die eigentliche Decodierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-1362">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="1959a-1363">Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1363">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1959a-1364">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1364">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1959a-1365">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-1365">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-1366">Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1366">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1959a-1367">In diesem Fall müssen Sie den Status zwischen Aufrufen wahrscheinlich beibehalten, da Byte Sequenzen bei der Verarbeitung in Batches unterbrochen werden können.</span><span class="sxs-lookup"><span data-stu-id="1959a-1367">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="1959a-1368">(Beispielsweise kann ein Teil einer ISO-2022-Verschiebungs Sequenz einen <xref:System.Text.Encoding.GetChars%2A> Aufrufe beenden und zu Beginn des nächsten <xref:System.Text.Encoding.GetChars%2A>-Aufrufes fortsetzen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1368">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="1959a-1369"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft den Fall Back für diese unvollständigen Sequenzen auf, aber <xref:System.Text.Decoder> speichert diese Sequenzen für den nächsten-Befehl.)</span><span class="sxs-lookup"><span data-stu-id="1959a-1369"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>

-   <span data-ttu-id="1959a-1370">Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, empfiehlt es sich, die <xref:System.Text.Encoding.GetString%2A>-Methode zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1370">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="1959a-1371">Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1371">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1959a-1372">Die Byte-Version von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren Aufrufen großer Puffer.</span><span class="sxs-lookup"><span data-stu-id="1959a-1372">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="1959a-1373">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1373">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-1374">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1374">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-1375">In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1375">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1959a-1376">Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1376">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1959a-1377">Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1377">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-1378">Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1378">For continuous decoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1959a-1379">Im folgenden Beispiel wird eine Zeichenfolge in ein Bytearray codiert und dann ein Bereich von Bytes in ein Zeichen Array decodiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1379">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-1380"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1380"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-1381"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="1959a-1381"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="1959a-1382">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1382">-or-</span></span>

 <span data-ttu-id="1959a-1383"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</span><span class="sxs-lookup"><span data-stu-id="1959a-1383"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1959a-1384">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-1384">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-1385">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-1385">-and-</span></span>

 <span data-ttu-id="1959a-1386">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1386"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1959a-1387">Ein Zeiger auf das erste zu decodierende Byte.</span><span class="sxs-lookup"><span data-stu-id="1959a-1387">A pointer to the first byte to decode.</span></span></param>
        <param name="byteCount"><span data-ttu-id="1959a-1388">Die Anzahl der zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-1388">The number of bytes to decode.</span></span></param>
        <param name="chars"><span data-ttu-id="1959a-1389">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1959a-1389">A pointer to the location at which to start writing the resulting set of characters.</span></span></param>
        <param name="charCount"><span data-ttu-id="1959a-1390">Die maximale Anzahl der zu schreibenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1390">The maximum number of characters to write.</span></span></param>
        <summary><span data-ttu-id="1959a-1391">Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge beginnend am angegebenen Bytezeiger in Zeichen decodiert, die ab Beginn des angegebenen Zeichenzeigers gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1391">When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</span></span></summary>
        <returns><span data-ttu-id="1959a-1392">Die tatsächliche Anzahl der Zeichen, die an der durch den <paramref name="chars" />-Parameter angegebenen Position geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1392">The actual number of characters written at the location indicated by the <paramref name="chars" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1393">Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen erfordert, sollten Sie die <xref:System.Text.Encoding.GetCharCount%2A>-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1393">To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1959a-1394">Verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode, um die maximale Array Größe zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1394">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1959a-1395">Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1395">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-1396"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> ruft Zeichen aus einer Eingabe Byte Sequenz ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-1396"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="1959a-1397"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, da <xref:System.Text.Encoding> diskrete Konvertierungen erwartet, während <xref:System.Text.Decoder> für mehrere Durchgänge in einem einzelnen Eingabestream konzipiert ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1397"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1959a-1398">Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> Objekt von der bereitgestellten <xref:System.Text.Encoding.GetDecoder%2A> oder <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.</span><span class="sxs-lookup"><span data-stu-id="1959a-1398">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1959a-1399">**Hinweis** Diese Methode ist für die Verwendung von Unicode-Zeichen vorgesehen, nicht für beliebige Binärdaten, wie z. b. Byte Arrays.</span><span class="sxs-lookup"><span data-stu-id="1959a-1399">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="1959a-1400">Wenn Sie beliebige Binärdaten in Text codieren müssen, sollten Sie ein Protokoll wie z. b. UUEncode verwenden, das von Methoden wie z. b. <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1400">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="1959a-1401">Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%2A>-Methode führt die eigentliche Decodierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-1401">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="1959a-1402">Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1402">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1959a-1403">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1403">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1959a-1404">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-1404">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-1405">Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1405">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1959a-1406">In diesem Fall müssen Sie den Status zwischen Aufrufen wahrscheinlich beibehalten, da Byte Sequenzen bei der Verarbeitung in Batches unterbrochen werden können.</span><span class="sxs-lookup"><span data-stu-id="1959a-1406">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="1959a-1407">(Beispielsweise kann ein Teil einer ISO-2022-Verschiebungs Sequenz einen <xref:System.Text.Encoding.GetChars%2A> Aufrufe beenden und zu Beginn des nächsten <xref:System.Text.Encoding.GetChars%2A>-Aufrufes fortsetzen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1407">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="1959a-1408"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft den Fall Back für diese unvollständigen Sequenzen auf, aber <xref:System.Text.Decoder> speichert diese Sequenzen für den nächsten-Befehl.)</span><span class="sxs-lookup"><span data-stu-id="1959a-1408"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>

-   <span data-ttu-id="1959a-1409">Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, wird die <xref:System.Text.Encoding.GetString%2A>-Methode empfohlen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1409">If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended.</span></span> <span data-ttu-id="1959a-1410">Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1410">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1959a-1411">Die Byte-Version von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren Aufrufen großer Puffer.</span><span class="sxs-lookup"><span data-stu-id="1959a-1411">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="1959a-1412">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1412">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-1413">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1413">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-1414">In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1414">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1959a-1415">Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1415">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1959a-1416">Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1416">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-1417">Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1417">For continuous decoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-1418"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1418"><paramref name="bytes" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1959a-1419">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1419">-or-</span></span>

 <span data-ttu-id="1959a-1420"><paramref name="chars" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1420"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-1421"><paramref name="byteCount" /> oder <paramref name="charCount" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="1959a-1421"><paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1959a-1422"><paramref name="charCount" /> ist niedriger als die sich ergebende Anzahl von Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1422"><paramref name="charCount" /> is less than the resulting number of characters.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1959a-1423">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-1423">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-1424">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-1424">-and-</span></span>

 <span data-ttu-id="1959a-1425">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1425"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="1959a-1426">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="1959a-1426">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="1959a-1427">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1427">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1959a-1428">Das Bytearray, das die zu decodierende Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1428">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="1959a-1429">Der Index des ersten zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-1429">The index of the first byte to decode.</span></span></param>
        <param name="byteCount"><span data-ttu-id="1959a-1430">Die Anzahl der zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-1430">The number of bytes to decode.</span></span></param>
        <param name="chars"><span data-ttu-id="1959a-1431">Das Zeichenarray, das die sich ergebenden Zeichen enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="1959a-1431">The character array to contain the resulting set of characters.</span></span></param>
        <param name="charIndex"><span data-ttu-id="1959a-1432">Der Index, an dem mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1959a-1432">The index at which to start writing the resulting set of characters.</span></span></param>
        <summary><span data-ttu-id="1959a-1433">Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge aus dem angegebenen Bytearray in das angegebene Zeichenarray decodiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1433">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.</span></span></summary>
        <returns><span data-ttu-id="1959a-1434">Die tatsächliche Anzahl der Zeichen, die in <paramref name="chars" /> geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1434">The actual number of characters written into <paramref name="chars" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1435">Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, sollten Sie die <xref:System.Text.Encoding.GetCharCount%2A>-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1435">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1959a-1436">Verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode, um die maximale Array Größe zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1436">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1959a-1437">Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1437">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-1438">[\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 2a? displayproperty = namewithtype > Ruft Zeichen aus einer Eingabe Byte Sequenz ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-1438">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="1959a-1439">[\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 2a? displayproperty = namewithtype > ist anders als <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, weil <xref:System.Text.Encoding> diskrete Konvertierungen erwartet, während <xref:System.Text.Decoder> für mehrere Durchgänge in einem einzelnen Eingabestream konzipiert ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1439">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1959a-1440">Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> verwenden, die von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode bzw. der <xref:System.Text.Encoding.GetEncoder%2A>-Methode der abgeleiteten Klasse bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1440">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1959a-1441">**Hinweis** Diese Methode ist für die Verwendung von Unicode-Zeichen vorgesehen, nicht für beliebige Binärdaten, wie z. b. Byte Arrays.</span><span class="sxs-lookup"><span data-stu-id="1959a-1441">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="1959a-1442">Wenn Sie beliebige Binärdaten in Text codieren müssen, sollten Sie ein Protokoll wie z. b. UUEncode verwenden, das von Methoden wie z. b. <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1442">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="1959a-1443">Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die <xref:System.Text.Encoding.GetChars%2A>-Methode führt die eigentliche Decodierung aus.</span><span class="sxs-lookup"><span data-stu-id="1959a-1443">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="1959a-1444">Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>-Methode erwartet diskrete Konvertierungen, im Gegensatz zur <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode, die mehrere Durchgänge für einen einzelnen Eingabestream verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1444">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="1959a-1445">Es werden mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1445">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="1959a-1446">Im folgenden finden Sie einige Überlegungen zur Programmierung bei der Verwendung dieser Methoden:</span><span class="sxs-lookup"><span data-stu-id="1959a-1446">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="1959a-1447">Möglicherweise muss Ihre APP mehrere Eingabe Bytes von einer Codepage decodieren und die Bytes mithilfe mehrerer Aufrufe verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1447">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="1959a-1448">In diesem Fall müssen Sie den Status zwischen Aufrufen wahrscheinlich beibehalten, da Byte Sequenzen bei der Verarbeitung in Batches unterbrochen werden können.</span><span class="sxs-lookup"><span data-stu-id="1959a-1448">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="1959a-1449">(Beispielsweise kann ein Teil einer ISO-2022-Verschiebungs Sequenz einen [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 2a > aufrufen und fortsetzen zu Beginn des nächsten [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 2a-> Aufrufens.</span><span class="sxs-lookup"><span data-stu-id="1959a-1449">(For example, part of an ISO-2022 shift sequence may end one [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="1959a-1450">[\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 2a? displayproperty = namewithtype > Ruft den Fall Back für diese unvollständigen Sequenzen auf, aber <xref:System.Text.Decoder> speichert diese Sequenzen für den nächsten-Befehl.)</span><span class="sxs-lookup"><span data-stu-id="1959a-1450">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>

-   <span data-ttu-id="1959a-1451">Wenn Ihre APP Zeichen folgen Ausgaben verarbeitet, wird die <xref:System.Text.Encoding.GetString%2A>-Methode empfohlen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1451">If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended.</span></span> <span data-ttu-id="1959a-1452">Da diese Methode die Länge der Zeichenfolge überprüfen und einen Puffer zuordnen muss, ist Sie etwas langsamer, aber der resultierende <xref:System.String> Typ muss bevorzugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1452">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="1959a-1453">Die Byte-Version von <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> ermöglicht einige schnelle Techniken, insbesondere bei mehreren Aufrufen großer Puffer.</span><span class="sxs-lookup"><span data-stu-id="1959a-1453">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="1959a-1454">Beachten Sie jedoch, dass diese Methoden Version manchmal unsicher ist, da Zeiger erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1454">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="1959a-1455">Wenn Ihre APP eine große Datenmenge konvertieren muss, sollte Sie den Ausgabepuffer wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1455">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="1959a-1456">In diesem Fall gilt: die [\], Int32, Int32, char\<Xref: System. Text. Encoding. GetChars% 28system. Byte% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Char% 5B% 5D% 2csystem. Int32% 29 > Version, die Ausgabe Zeichen Puffer unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1456">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="1959a-1457">Verwenden Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1457">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1959a-1458">Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1458">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="1959a-1459">Bei der kontinuierlichen Decodierung eines Streams ist diese Methode oft die beste Wahl.</span><span class="sxs-lookup"><span data-stu-id="1959a-1459">For continuous decoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="1959a-1460">Im folgenden Beispiel wird eine Zeichenfolge von einer Codierung in eine andere konvertiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1460">The following example converts a string from one encoding to another.</span></span>

 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]

 <span data-ttu-id="1959a-1461">Im folgenden Beispiel wird eine Zeichenfolge in ein Bytearray codiert und dann ein Bereich von Bytes in ein Zeichen Array decodiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1461">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-1462"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1462"><paramref name="bytes" /> is <see langword="null" />.</span></span>

<span data-ttu-id="1959a-1463">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1463">-or-</span></span>

 <span data-ttu-id="1959a-1464"><paramref name="chars" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1464"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-1465"><paramref name="byteIndex" />, <paramref name="byteCount" /> oder <paramref name="charIndex" /> ist kleiner als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="1959a-1465"><paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.</span></span>

<span data-ttu-id="1959a-1466">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1466">-or-</span></span>

 <span data-ttu-id="1959a-1467"><paramref name="byteindex" /> und <paramref name="byteCount" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</span><span class="sxs-lookup"><span data-stu-id="1959a-1467"><paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.</span></span>

<span data-ttu-id="1959a-1468">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1468">-or-</span></span>

 <span data-ttu-id="1959a-1469"><paramref name="charIndex" /> ist kein gültiger Index in <paramref name="chars" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1469"><paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1959a-1470"><paramref name="chars" /> hat von <paramref name="charIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Zeichen aufzunehmen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1470"><paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1959a-1471">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-1471">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-1472">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-1472">-and-</span></span>

 <span data-ttu-id="1959a-1473">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1473"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1959a-1474">Beim Überschreiben in einer abgeleiteten Klasse wird ein Decoder abgerufen, der eine codierte Bytefolge in Zeichen konvertiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1474">When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.</span></span></summary>
        <returns><span data-ttu-id="1959a-1475">Eine <see cref="T:System.Text.Decoder" />-Klasse, die eine codierte Bytefolge in eine Folge von Zeichen codiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1475">A <see cref="T:System.Text.Decoder" /> that converts an encoded sequence of bytes into a sequence of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1476">Die <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode konvertiert sequenzielle Blöcke von Bytes in sequenzielle Zeichenblöcke, ähnlich wie bei der <xref:System.Text.Encoding.GetChars%2A>-Methode dieser Klasse.</span><span class="sxs-lookup"><span data-stu-id="1959a-1476">The <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.Encoding.GetChars%2A> method of this class.</span></span> <span data-ttu-id="1959a-1477">Ein <xref:System.Text.Decoder> behält jedoch Zustandsinformationen zwischen Aufrufen bei, damit Byte Sequenzen, die Blöcke spannen, ordnungsgemäß decodiert werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1477">However, a <xref:System.Text.Decoder> maintains state information between calls so it correctly decodes byte sequences that span blocks.</span></span> <span data-ttu-id="1959a-1478">Der <xref:System.Text.Decoder> behält auch nachfolgende Bytes am Ende der Datenblöcke bei und verwendet die nachfolgenden Bytes im nächsten Decodierungs Vorgang.</span><span class="sxs-lookup"><span data-stu-id="1959a-1478">The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</span></span> <span data-ttu-id="1959a-1479">Aus diesem Grund sind <xref:System.Text.Encoding.GetDecoder%2A> und <xref:System.Text.Encoding.GetEncoder%2A> für Netzwerkübertragungs-und Datei Vorgänge nützlich, da diese Vorgänge häufig Datenblöcke anstelle eines gesamten Datenstroms behandeln.</span><span class="sxs-lookup"><span data-stu-id="1959a-1479">Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1959a-1480">Die Standard Implementierung gibt einen <see cref="T:System.Text.Decoder" /> zurück, der die Methoden <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> und <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> der aktuellen <see cref="T:System.Text.Encoding" />aufruft.</span><span class="sxs-lookup"><span data-stu-id="1959a-1480">The default implementation returns a <see cref="T:System.Text.Decoder" /> that calls the <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> and <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> methods of the current <see cref="T:System.Text.Encoding" />.</span></span> <span data-ttu-id="1959a-1481">Sie müssen diese Methode überschreiben, um eine <see cref="T:System.Text.Decoder" /> zurückzugeben, die ihren Zustand zwischen Aufrufen beibehält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1481">You must override this method to return a <see cref="T:System.Text.Decoder" /> that maintains its state between calls.</span></span></para></block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1959a-1482">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1959a-1482">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1959a-1483">Beim Überschreiben in einer abgeleiteten Klasse wird ein Encoder abgerufen, der eine Folge von Unicode-Zeichen in eine codierte Bytefolge konvertiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1483">When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="1959a-1484">Ein <see cref="T:System.Text.Encoder" />, der eine Folge von Unicode-Zeichen in eine codierte Bytefolge konvertiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1484">A <see cref="T:System.Text.Encoder" /> that converts a sequence of Unicode characters into an encoded sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1485">Die <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode konvertiert sequenzielle Blöcke von Zeichen in sequenzielle Block von Bytes, ähnlich wie bei der <xref:System.Text.Encoding.GetBytes%2A>-Methode dieser Klasse.</span><span class="sxs-lookup"><span data-stu-id="1959a-1485">The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.Encoding.GetBytes%2A> method of this class.</span></span> <span data-ttu-id="1959a-1486">Eine <xref:System.Text.Encoder> behält jedoch Zustandsinformationen zwischen Aufrufen bei, sodass Sie Zeichen folgen, die Blöcke spannen, ordnungsgemäß codiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1486">However, a <xref:System.Text.Encoder> maintains state information between calls so it correctly encodes character sequences that span blocks.</span></span> <span data-ttu-id="1959a-1487">Der <xref:System.Text.Encoder> behält auch nachfolgende Zeichen am Ende der Datenblöcke bei und verwendet die nachfolgenden Zeichen im nächsten Codierungs Vorgang.</span><span class="sxs-lookup"><span data-stu-id="1959a-1487">The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</span></span> <span data-ttu-id="1959a-1488">Beispielsweise kann ein Datenblock mit einem nicht übereinstimmenden hohen Ersatz Zeichen enden, und das entsprechende niedrige Ersatz Zeichen kann sich im nächsten Datenblock befinden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1488">For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</span></span> <span data-ttu-id="1959a-1489">Aus diesem Grund sind <xref:System.Text.Encoding.GetDecoder%2A> und <xref:System.Text.Encoding.GetEncoder%2A> für Netzwerkübertragungs-und Datei Vorgänge nützlich, da diese Vorgänge häufig Datenblöcke anstelle eines gesamten Datenstroms behandeln.</span><span class="sxs-lookup"><span data-stu-id="1959a-1489">Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1959a-1490">Die Standard Implementierung gibt einen <see cref="T:System.Text.Encoder" /> zurück, der die Methoden <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> und <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> der aktuellen <see cref="T:System.Text.Encoding" />aufruft.</span><span class="sxs-lookup"><span data-stu-id="1959a-1490">The default implementation returns a <see cref="T:System.Text.Encoder" /> that calls the <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> and <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> methods of the current <see cref="T:System.Text.Encoding" />.</span></span> <span data-ttu-id="1959a-1491">Sie müssen diese Methode überschreiben, um eine <see cref="T:System.Text.Encoder" /> zurückzugeben, die ihren Zustand zwischen Aufrufen beibehält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1491">You must override this method to return a <see cref="T:System.Text.Encoder" /> that maintains its state between calls.</span></span></para></block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1959a-1492">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1959a-1492">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1959a-1493">Gibt eine Codierung für die angegebene Codepage zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-1493">Returns an encoding for the specified code page.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage"><span data-ttu-id="1959a-1494">Der Codepagebezeichner der bevorzugten Codierung.</span><span class="sxs-lookup"><span data-stu-id="1959a-1494">The code page identifier of the preferred encoding.</span></span> <span data-ttu-id="1959a-1495">Mögliche Werte sind in der Codepage-Spalte der Tabelle aufgeführt, die im Thema zur <see cref="T:System.Text.Encoding" />-Klasse angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1495">Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span>

<span data-ttu-id="1959a-1496">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1496">-or-</span></span>

<span data-ttu-id="1959a-1497">0 (null), um die Standardcodierung zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1497">0 (zero), to use the default encoding.</span></span></param>
        <summary><span data-ttu-id="1959a-1498">Gibt die dem angegebenen Codepagebezeichner zugeordnete Codierung zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-1498">Returns the encoding associated with the specified code page identifier.</span></span></summary>
        <returns><span data-ttu-id="1959a-1499">Die Codierung, die der angegebenen Codepage zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1499">The encoding that is associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1500">Der Fall Back Handler hängt vom Codierungstyp `codepage`ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-1500">The fallback handler depends on the encoding type of `codepage`.</span></span> <span data-ttu-id="1959a-1501">Wenn `codepage` eine Codepage oder eine Doppelbyte-Zeichensatz Codierung (DBCS) ist, wird ein Fall Back-Handler mit dem besten Zeichen verwendet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1501">If `codepage` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</span></span> <span data-ttu-id="1959a-1502">Andernfalls wird ein Ersatz Fall Back Handler verwendet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1502">Otherwise, a replacement fallback handler is used.</span></span> <span data-ttu-id="1959a-1503">Diese Fall Back Handler sind für Ihre APP möglicherweise nicht geeignet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1503">These fallback handlers may not be appropriate for your app.</span></span> <span data-ttu-id="1959a-1504">Um den Fall Back Handler anzugeben, der von der durch `codepage`angegebenen Codierung verwendet wird, können Sie die <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>-Überladung aufrufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1504">To specify the fallback handler used by the encoding specified by `codepage`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.</span></span>

 <span data-ttu-id="1959a-1505">In der .NET Framework basiert die <xref:System.Text.Encoding.GetEncoding%2A>-Methode auf der zugrunde liegenden Plattform, um die meisten Codepages zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1505">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="1959a-1506">Allerdings unterstützt die .NET Framework nativ einige Codierungen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1506">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="1959a-1507">Eine Liste der Codepages finden Sie im Thema <xref:System.Text.Encoding>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1959a-1507">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="1959a-1508">In .net Core gibt die <xref:System.Text.Encoding.GetEncoding%2A>-Methode die Codierungen zurück, die von .net Core unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1508">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="1959a-1509">Bei beiden .net-Implementierungen können Sie die <xref:System.Text.Encoding.GetEncodings%2A>-Methode zum Abrufen eines Arrays von <xref:System.Text.EncodingInfo> Objekten, das Informationen zu allen verfügbaren Codierungen enthält, abrufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1509">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span>

 <span data-ttu-id="1959a-1510">Zusätzlich zu den Codierungen, die in .net Core nativ verfügbar sind oder auf einer bestimmten Platt Form Version der .NET Framework intrinsisch unterstützt werden, gibt die <xref:System.Text.Encoding.GetEncoding%2A>-Methode alle zusätzlichen Codierungen zurück, die durch das Registrieren eines <xref:System.Text.EncodingProvider> Objekts verfügbar gemacht werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1510">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="1959a-1511">Wenn dieselbe Codierung von mehreren <xref:System.Text.EncodingProvider> Objekten registriert wurde, gibt diese Methode die zuletzt registrierte zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-1511">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>

<span data-ttu-id="1959a-1512">Sie können auch den Wert 0 für das `codepage` Argument angeben.</span><span class="sxs-lookup"><span data-stu-id="1959a-1512">You can also supply a value of 0 for the `codepage` argument.</span></span> <span data-ttu-id="1959a-1513">Das genaue Verhalten hängt davon ab, ob Codierungen verfügbar gemacht wurden, indem ein <xref:System.Text.EncodingProvider> Objekt registriert wird:</span><span class="sxs-lookup"><span data-stu-id="1959a-1513">Its precise behavior depends on whether any encodings have been made available by registering an <xref:System.Text.EncodingProvider> object:</span></span>

- <span data-ttu-id="1959a-1514">Wenn mindestens ein Codierungs Anbieter registriert wurde, wird die Codierung des letzten registrierten Anbieters zurückgegeben, der eine Codierung zurückgegeben hat, wenn der <xref:System.Text.Encoding.GetEncoding%2A> Methode ein `codepage` Argument 0 (null) überlassen wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1514">If one or more encoding providers have been registered, it returns the encoding of the last registered provider that has chosen to return a encoding when the <xref:System.Text.Encoding.GetEncoding%2A> method is passed a `codepage` argument of 0.</span></span>

- <span data-ttu-id="1959a-1515">Wenn auf dem .NET Framework kein Codierungs Anbieter registriert wurde und die <xref:System.Text.CodePagesEncodingProvider> der registrierte Codierungs Anbieter ist, oder wenn kein registrierter Codierungs Anbieter einen `codepage` Wert von 0 verarbeitet, wird die aktive Codepage des Betriebssystems zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="1959a-1515">On the .NET Framework, if no encoding provider has been registered, if the <xref:System.Text.CodePagesEncodingProvider> is the registered encoding provider, or if no registered encoding provider handles a `codepage` value of 0, it returns the operating system's active code page.</span></span> <span data-ttu-id="1959a-1516">Um die aktive Codepage auf Windows-Systemen zu ermitteln, müssen Sie die Windows [GetACP-](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Funktion aus dem .NET Framework auf dem Windows-Desktop aufrufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1516">To determine the active code page on Windows systems, call the Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the .NET Framework on the Windows desktop.</span></span>

- <span data-ttu-id="1959a-1517">Wenn in .net Core kein Codierungs Anbieter registriert wurde oder wenn kein registrierter Codierungs Anbieter einen `codepage` Wert von 0 verarbeitet, wird der <xref:System.Text.UTF8Encoding>zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="1959a-1517">On .NET Core, if no encoding provider has been registered or if no registered encoding provider handles a `codepage` value of 0, it returns the <xref:System.Text.UTF8Encoding>.</span></span>

> [!NOTE]
>  <span data-ttu-id="1959a-1518">Einige nicht unterstützte Codepages bewirken, dass eine <xref:System.ArgumentException> ausgelöst wird, während andere zu einer <xref:System.NotSupportedException>führen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1518">Some unsupported code pages cause an <xref:System.ArgumentException> to be thrown, whereas others cause a <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="1959a-1519">Der Code muss daher alle Ausnahmen abfangen, die im Abschnitt "Ausnahmen" angegeben sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1519">Therefore, your code must catch all exceptions indicated in the Exceptions section.</span></span>

> [!NOTE]
>  <span data-ttu-id="1959a-1520">Die ANSI-Codepages können sich auf verschiedenen Computern unterscheiden und können auf einem einzelnen Computer geändert werden, was zu Daten Beschädigungen führt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1520">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="1959a-1521">Aus diesem Grund wird, wenn die aktive Codepage eine ANSI-Codepage ist, das Codieren und Decodieren von Daten mithilfe der Standard Codepage, die von `Encoding.GetEncoding(0)` zurückgegeben wird, nicht empfohlen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1521">For this reason, if the active code page is an ANSI code page, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended.</span></span> <span data-ttu-id="1959a-1522">Um möglichst konsistente Ergebnisse zu erzielen, sollten Sie eine Unicode-Codierung, z. b. UTF-8 (Codepage 65001) oder UTF-16, anstelle einer bestimmten Codepage verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1522">For the most consistent results, you should use a Unicode encoding, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>

 <span data-ttu-id="1959a-1523"><xref:System.Text.Encoding.GetEncoding%2A> gibt eine zwischengespeicherte-Instanz mit Standardeinstellungen zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-1523"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="1959a-1524">Verwenden Sie die Konstruktoren abgeleiteter Klassen, um eine Instanz mit unterschiedlichen Einstellungen zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1524">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="1959a-1525">Beispielsweise stellt die <xref:System.Text.UTF32Encoding>-Klasse einen Konstruktor bereit, mit dem Sie die Fehlererkennung aktivieren können.</span><span class="sxs-lookup"><span data-stu-id="1959a-1525">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>



## Examples
 <span data-ttu-id="1959a-1526">Im folgenden Beispiel werden zwei Instanzen derselben Codierung abgerufen (eine nach Codepage und eine andere nach Namen) und ihre Gleichheit überprüft.</span><span class="sxs-lookup"><span data-stu-id="1959a-1526">The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</span></span>

 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-1527"><paramref name="codepage" /> ist kleiner als 0 (null) oder größer als 65535.</span><span class="sxs-lookup"><span data-stu-id="1959a-1527"><paramref name="codepage" /> is less than zero or greater than 65535.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1959a-1528"><paramref name="codepage" /> wird von der zugrunde liegenden Plattform nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1528"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1959a-1529"><paramref name="codepage" /> wird von der zugrunde liegenden Plattform nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1529"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1959a-1530">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1959a-1530">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="1959a-1531">Der Codepagename der bevorzugten Codierung.</span><span class="sxs-lookup"><span data-stu-id="1959a-1531">The code page name of the preferred encoding.</span></span> <span data-ttu-id="1959a-1532">Jeder von der <see cref="P:System.Text.Encoding.WebName" />-Eigenschaft zurückgegebene Wert ist gültig.</span><span class="sxs-lookup"><span data-stu-id="1959a-1532">Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid.</span></span> <span data-ttu-id="1959a-1533">Mögliche Werte sind in der Name-Spalte der Tabelle aufgeführt, die im Thema zur <see cref="T:System.Text.Encoding" />-Klasse angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1533">Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span></param>
        <summary><span data-ttu-id="1959a-1534">Gibt die dem angegebenen Codepagenamen zugeordnete Codierung zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-1534">Returns the encoding associated with the specified code page name.</span></span></summary>
        <returns><span data-ttu-id="1959a-1535">Die der angegebenen Codepage zugeordnete Codierung.</span><span class="sxs-lookup"><span data-stu-id="1959a-1535">The encoding  associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1536">Der Fall Back Handler hängt vom Codierungstyp `name`ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-1536">The fallback handler depends on the encoding type of `name`.</span></span> <span data-ttu-id="1959a-1537">Wenn `name` eine Codepage oder eine Doppelbyte-Zeichensatz Codierung (DBCS) ist, wird ein Fall Back-Handler mit dem besten Zeichen verwendet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1537">If `name` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</span></span> <span data-ttu-id="1959a-1538">Andernfalls wird ein Ersatz Fall Back Handler verwendet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1538">Otherwise, a replacement fallback handler is used.</span></span> <span data-ttu-id="1959a-1539">Diese Fall Back Handler sind für Ihre APP möglicherweise nicht geeignet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1539">These fallback handlers may not be appropriate for your app.</span></span> <span data-ttu-id="1959a-1540">Um den Fall Back Handler anzugeben, der von der durch `name`angegebenen Codierung verwendet wird, können Sie die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>-Überladung aufrufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1540">To specify the fallback handler used by the encoding specified by `name`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.</span></span>

<span data-ttu-id="1959a-1541">In der .NET Framework basiert die <xref:System.Text.Encoding.GetEncoding%2A>-Methode auf der zugrunde liegenden Plattform, um die meisten Codepages zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1541">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="1959a-1542">Allerdings unterstützt die .NET Framework nativ einige Codierungen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1542">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="1959a-1543">Eine Liste der Codepages finden Sie im Thema <xref:System.Text.Encoding>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1959a-1543">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="1959a-1544">In .net Core gibt die <xref:System.Text.Encoding.GetEncoding%2A>-Methode die Codierungen zurück, die von .net Core unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1544">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="1959a-1545">Bei beiden .net-Implementierungen können Sie die <xref:System.Text.Encoding.GetEncodings%2A>-Methode zum Abrufen eines Arrays von <xref:System.Text.EncodingInfo> Objekten, das Informationen zu allen verfügbaren Codierungen enthält, abrufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1545">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span>

 <span data-ttu-id="1959a-1546">Zusätzlich zu den Codierungen, die in .net Core nativ verfügbar sind oder auf einer bestimmten Platt Form Version der .NET Framework intrinsisch unterstützt werden, gibt die <xref:System.Text.Encoding.GetEncoding%2A>-Methode alle zusätzlichen Codierungen zurück, die durch das Registrieren eines <xref:System.Text.EncodingProvider> Objekts verfügbar gemacht werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1546">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="1959a-1547">Wenn dieselbe Codierung von mehreren <xref:System.Text.EncodingProvider> Objekten registriert wurde, gibt diese Methode die zuletzt registrierte zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-1547">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>

> [!NOTE]
>  <span data-ttu-id="1959a-1548">Die ANSI-Codepages können sich auf verschiedenen Computern unterscheiden, oder Sie können für einen einzelnen Computer geändert werden, was zu Daten Beschädigungen führt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1548">The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption.</span></span> <span data-ttu-id="1959a-1549">Um möglichst konsistente Ergebnisse zu erzielen, sollten Sie Unicode verwenden, z. b. UTF-8 (Codepage 65001) oder UTF-16 anstelle einer bestimmten Codepage.</span><span class="sxs-lookup"><span data-stu-id="1959a-1549">For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>


 <span data-ttu-id="1959a-1550"><xref:System.Text.Encoding.GetEncoding%2A> gibt eine zwischengespeicherte-Instanz mit Standardeinstellungen zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-1550"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="1959a-1551">Verwenden Sie die Konstruktoren abgeleiteter Klassen, um eine Instanz mit unterschiedlichen Einstellungen zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1551">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="1959a-1552">Beispielsweise stellt die <xref:System.Text.UTF32Encoding>-Klasse einen Konstruktor bereit, mit dem Sie die Fehlererkennung aktivieren können.</span><span class="sxs-lookup"><span data-stu-id="1959a-1552">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>

## Examples
 <span data-ttu-id="1959a-1553">Im folgenden Beispiel werden zwei Instanzen derselben Codierung abgerufen (eine nach Codepage und eine andere nach Namen) und ihre Gleichheit überprüft.</span><span class="sxs-lookup"><span data-stu-id="1959a-1553">The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</span></span>

 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1959a-1554"><paramref name="name" /> ist kein gültiger Codepagename.</span><span class="sxs-lookup"><span data-stu-id="1959a-1554"><paramref name="name" /> is not a valid code page name.</span></span>

<span data-ttu-id="1959a-1555">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1555">-or-</span></span>

<span data-ttu-id="1959a-1556">Die durch <paramref name="name" /> angegebene Codepage wird von der zugrunde liegenden Plattform nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1556">The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1959a-1557">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1959a-1557">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage"><span data-ttu-id="1959a-1558">Der Codepagebezeichner der bevorzugten Codierung.</span><span class="sxs-lookup"><span data-stu-id="1959a-1558">The code page identifier of the preferred encoding.</span></span> <span data-ttu-id="1959a-1559">Mögliche Werte sind in der Codepage-Spalte der Tabelle aufgeführt, die im Thema zur <see cref="T:System.Text.Encoding" />-Klasse angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1559">Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span>

<span data-ttu-id="1959a-1560">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1560">-or-</span></span>

<span data-ttu-id="1959a-1561">0 (null), um die Standardcodierung zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1561">0 (zero), to use the default encoding.</span></span></param>
        <param name="encoderFallback"><span data-ttu-id="1959a-1562">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn ein Zeichen nicht mit der aktuellen Codierung codiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1562">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span></span></param>
        <param name="decoderFallback"><span data-ttu-id="1959a-1563">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn eine Bytefolge nicht mit der aktuellen Codierung decodiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1563">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span></span></param>
        <summary><span data-ttu-id="1959a-1564">Gibt die dem angegebenen Codepagebezeichner zugeordnete Codierung zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-1564">Returns the encoding associated with the specified code page identifier.</span></span> <span data-ttu-id="1959a-1565">Parameter geben einen Fehlerhandler für Zeichen an, die nicht codiert werden können, und für Bytefolgen, die nicht decodiert werden können.</span><span class="sxs-lookup"><span data-stu-id="1959a-1565">Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</span></span></summary>
        <returns><span data-ttu-id="1959a-1566">Die Codierung, die der angegebenen Codepage zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1566">The encoding that is associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="1959a-1567">Einige nicht unterstützte Codepages bewirken, dass die Ausnahme <xref:System.ArgumentException> ausgelöst wird, während andere zu <xref:System.NotSupportedException>führen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1567">Some unsupported code pages cause the exception <xref:System.ArgumentException> to be thrown, whereas others cause <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="1959a-1568">Der Code muss daher alle Ausnahmen abfangen, die im Abschnitt "Ausnahmen" angegeben sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1568">Therefore, your code must catch all exceptions indicated in the Exceptions section.</span></span>

<span data-ttu-id="1959a-1569">In der .NET Framework basiert die <xref:System.Text.Encoding.GetEncoding%2A>-Methode auf der zugrunde liegenden Plattform, um die meisten Codepages zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1569">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="1959a-1570">Allerdings unterstützt die .NET Framework nativ einige Codierungen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1570">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="1959a-1571">Eine Liste der Codepages finden Sie im Thema <xref:System.Text.Encoding>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1959a-1571">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="1959a-1572">In .net Core gibt die <xref:System.Text.Encoding.GetEncoding%2A>-Methode die Codierungen zurück, die von .net Core unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1572">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="1959a-1573">Bei beiden .net-Implementierungen können Sie die <xref:System.Text.Encoding.GetEncodings%2A>-Methode zum Abrufen eines Arrays von <xref:System.Text.EncodingInfo> Objekten, das Informationen zu allen verfügbaren Codierungen enthält, abrufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1573">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span>

 <span data-ttu-id="1959a-1574">Zusätzlich zu den Codierungen, die in .net Core nativ verfügbar sind oder auf einer bestimmten Platt Form Version der .NET Framework intrinsisch unterstützt werden, gibt die <xref:System.Text.Encoding.GetEncoding%2A>-Methode alle zusätzlichen Codierungen zurück, die durch das Registrieren eines <xref:System.Text.EncodingProvider> Objekts verfügbar gemacht werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1574">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="1959a-1575">Wenn dieselbe Codierung von mehreren <xref:System.Text.EncodingProvider> Objekten registriert wurde, gibt diese Methode die zuletzt registrierte zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-1575">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>

<span data-ttu-id="1959a-1576">Sie können auch den Wert 0 für das `codepage` Argument angeben.</span><span class="sxs-lookup"><span data-stu-id="1959a-1576">You can also supply a value of 0 for the `codepage` argument.</span></span> <span data-ttu-id="1959a-1577">Das genaue Verhalten hängt davon ab, ob Codierungen verfügbar gemacht wurden, indem ein <xref:System.Text.EncodingProvider> Objekt registriert wird:</span><span class="sxs-lookup"><span data-stu-id="1959a-1577">Its precise behavior depends on whether any encodings have been made available by registering an <xref:System.Text.EncodingProvider> object:</span></span>

- <span data-ttu-id="1959a-1578">Wenn mindestens ein Codierungs Anbieter registriert wurde, wird die Codierung des letzten registrierten Anbieters zurückgegeben, der eine Codierung zurückgegeben hat, wenn der <xref:System.Text.Encoding.GetEncoding%2A> Methode ein `codepage` Argument 0 (null) überlassen wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1578">If one or more encoding providers have been registered, it returns the encoding of the last registered provider that has chosen to return a encoding when the <xref:System.Text.Encoding.GetEncoding%2A> method is passed a `codepage` argument of 0.</span></span>

- <span data-ttu-id="1959a-1579">Wenn auf der .NET Framework kein Codierungs Anbieter registriert wurde und der <xref:System.Text.CodePagesEncodingProvider> der registrierte Codierungs Anbieter ist, oder wenn kein registrierter Codierungs Anbieter einen `codepage` Wert von 0 verarbeitet, wird die aktive Codepage zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="1959a-1579">On the .NET Framework, if no encoding provider has been registered, if the <xref:System.Text.CodePagesEncodingProvider> is the registered encoding provider, or if no registered encoding provider handles a `codepage` value of 0, it returns the active code page.</span></span>

- <span data-ttu-id="1959a-1580">Wenn in .net Core kein Codierungs Anbieter registriert wurde oder wenn kein registrierter Codierungs Anbieter einen `codepage` Wert von 0 verarbeitet, wird die <xref:System.Text.UTF8Encoding> Codierung zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="1959a-1580">On .NET Core, if no encoding provider has been registered or if no registered encoding provider handles a `codepage` value of 0, it returns the <xref:System.Text.UTF8Encoding> encoding.</span></span>

> [!NOTE]
>  <span data-ttu-id="1959a-1581">Die ANSI-Codepages können sich auf verschiedenen Computern unterscheiden und können auf einem einzelnen Computer geändert werden, was zu Daten Beschädigungen führt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1581">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="1959a-1582">Aus diesem Grund wird, wenn die aktive Codepage eine ANSI-Codepage ist, das Codieren und Decodieren von Daten mithilfe der Standard Codepage, die von `Encoding.GetEncoding(0)` zurückgegeben wird, nicht empfohlen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1582">For this reason, if the active code page is an ANSI code page, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended.</span></span> <span data-ttu-id="1959a-1583">Um möglichst konsistente Ergebnisse zu erzielen, sollten Sie Unicode verwenden, z. b. UTF-8 (Codepage 65001) oder UTF-16 anstelle einer bestimmten Codepage.</span><span class="sxs-lookup"><span data-stu-id="1959a-1583">For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>

 <span data-ttu-id="1959a-1584">Zum Abrufen der Codierung, die der aktiven Codepage zugeordnet ist, können Sie entweder den Wert 0 für das `codepage` Argument angeben oder, wenn der Code auf der .NET Framework auf dem Windows-Desktop ausgeführt wird, den Wert der <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>-Eigenschaft abrufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1584">To get the encoding associated with the active code page, you can either supply a value of 0 for the `codepage` argument or, if your code is running on the .NET Framework on the Windows desktop, retrieve the value of the <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="1959a-1585">Um die aktuelle aktive Codepage zu ermitteln, müssen Sie die Windows [GetACP-](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Funktion aus dem .NET Framework auf dem Windows-Desktop aufrufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1585">To determine the current active code page, call the Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the .NET Framework on the Windows desktop.</span></span>

 <span data-ttu-id="1959a-1586"><xref:System.Text.Encoding.GetEncoding%2A> gibt eine zwischengespeicherte-Instanz mit Standardeinstellungen zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-1586"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="1959a-1587">Verwenden Sie die Konstruktoren abgeleiteter Klassen, um eine Instanz mit unterschiedlichen Einstellungen zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1587">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="1959a-1588">Beispielsweise stellt die <xref:System.Text.UTF32Encoding>-Klasse einen Konstruktor bereit, mit dem Sie die Fehlererkennung aktivieren können.</span><span class="sxs-lookup"><span data-stu-id="1959a-1588">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>



## Examples
 <span data-ttu-id="1959a-1589">Das folgende Beispiel veranschaulicht die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="1959a-1589">The following example demonstrates the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> method.</span></span>

 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-1590"><paramref name="codepage" /> ist kleiner als 0 (null) oder größer als 65535.</span><span class="sxs-lookup"><span data-stu-id="1959a-1590"><paramref name="codepage" /> is less than zero or greater than 65535.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1959a-1591"><paramref name="codepage" /> wird von der zugrunde liegenden Plattform nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1591"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1959a-1592"><paramref name="codepage" /> wird von der zugrunde liegenden Plattform nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1592"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1959a-1593">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1959a-1593">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="1959a-1594">Der Codepagename der bevorzugten Codierung.</span><span class="sxs-lookup"><span data-stu-id="1959a-1594">The code page name of the preferred encoding.</span></span> <span data-ttu-id="1959a-1595">Jeder von der <see cref="P:System.Text.Encoding.WebName" />-Eigenschaft zurückgegebene Wert ist gültig.</span><span class="sxs-lookup"><span data-stu-id="1959a-1595">Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid.</span></span> <span data-ttu-id="1959a-1596">Mögliche Werte sind in der Name-Spalte der Tabelle aufgeführt, die im Thema zur <see cref="T:System.Text.Encoding" />-Klasse angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1596">Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span></param>
        <param name="encoderFallback"><span data-ttu-id="1959a-1597">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn ein Zeichen nicht mit der aktuellen Codierung codiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1597">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span></span></param>
        <param name="decoderFallback"><span data-ttu-id="1959a-1598">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn eine Bytefolge nicht mit der aktuellen Codierung decodiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1598">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span></span></param>
        <summary><span data-ttu-id="1959a-1599">Gibt die dem angegebenen Codepagenamen zugeordnete Codierung zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-1599">Returns the encoding associated with the specified code page name.</span></span> <span data-ttu-id="1959a-1600">Parameter geben einen Fehlerhandler für Zeichen an, die nicht codiert werden können, und für Bytefolgen, die nicht decodiert werden können.</span><span class="sxs-lookup"><span data-stu-id="1959a-1600">Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</span></span></summary>
        <returns><span data-ttu-id="1959a-1601">Die Codierung, die der angegebenen Codepage zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1601">The encoding that is associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="1959a-1602">In der .NET Framework basiert die <xref:System.Text.Encoding.GetEncoding%2A>-Methode auf der zugrunde liegenden Plattform, um die meisten Codepages zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1602">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="1959a-1603">Allerdings unterstützt die .NET Framework nativ einige Codierungen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1603">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="1959a-1604">Eine Liste der Codepages finden Sie im Thema <xref:System.Text.Encoding>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1959a-1604">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="1959a-1605">In .net Core gibt die <xref:System.Text.Encoding.GetEncoding%2A>-Methode die Codierungen zurück, die von .net Core unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1605">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="1959a-1606">Bei beiden .net-Implementierungen können Sie die <xref:System.Text.Encoding.GetEncodings%2A>-Methode zum Abrufen eines Arrays von <xref:System.Text.EncodingInfo> Objekten, das Informationen zu allen verfügbaren Codierungen enthält, abrufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1606">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span>

 <span data-ttu-id="1959a-1607">Zusätzlich zu den Codierungen, die in .net Core nativ verfügbar sind oder auf einer bestimmten Platt Form Version der .NET Framework intrinsisch unterstützt werden, gibt die <xref:System.Text.Encoding.GetEncoding%2A>-Methode alle zusätzlichen Codierungen zurück, die durch das Registrieren eines <xref:System.Text.EncodingProvider> Objekts verfügbar gemacht werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1607">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="1959a-1608">Wenn dieselbe Codierung von mehreren <xref:System.Text.EncodingProvider> Objekten registriert wurde, gibt diese Methode die zuletzt registrierte zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-1608">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>

> [!NOTE]
>  <span data-ttu-id="1959a-1609">Die ANSI-Codepages können sich auf verschiedenen Computern unterscheiden und können auf einem einzelnen Computer geändert werden, was zu Daten Beschädigungen führt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1609">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="1959a-1610">Um möglichst konsistente Ergebnisse zu erzielen, sollten Sie eine Unicode-Codierung, z. b. UTF-8 (Codepage 65001) oder UTF-16, anstelle einer bestimmten Codepage verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1610">For the most consistent results, you should use a Unicode encoding, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>

 <span data-ttu-id="1959a-1611"><xref:System.Text.Encoding.GetEncoding%2A> gibt eine zwischengespeicherte-Instanz mit Standardeinstellungen zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-1611"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="1959a-1612">Verwenden Sie die Konstruktoren abgeleiteter Klassen, um eine Instanz mit unterschiedlichen Einstellungen zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1612">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="1959a-1613">Beispielsweise stellt die <xref:System.Text.UTF32Encoding>-Klasse einen Konstruktor bereit, mit dem Sie die Fehlererkennung aktivieren können.</span><span class="sxs-lookup"><span data-stu-id="1959a-1613">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>



## Examples
 <span data-ttu-id="1959a-1614">Das folgende Beispiel veranschaulicht die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="1959a-1614">The following example demonstrates the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> method.</span></span>

 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1959a-1615"><paramref name="name" /> ist kein gültiger Codepagename.</span><span class="sxs-lookup"><span data-stu-id="1959a-1615"><paramref name="name" /> is not a valid code page name.</span></span>

<span data-ttu-id="1959a-1616">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1616">-or-</span></span>

<span data-ttu-id="1959a-1617">Die durch <paramref name="name" /> angegebene Codepage wird von der zugrunde liegenden Plattform nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1617">The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1959a-1618">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1959a-1618">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1959a-1619">Gibt ein Array zurück, das alle Codierungen enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1619">Returns an array that contains all encodings.</span></span></summary>
        <returns><span data-ttu-id="1959a-1620">Ein Array, das alle Codierungen enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1620">An array that contains all encodings.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1621">Diese Methode gibt eine Liste der unterstützten Codierungen zurück, die durch die Codepage eindeutig unterschieden werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1621">This method returns a list of supported encodings, uniquely distinguished by code page.</span></span> <span data-ttu-id="1959a-1622">Eine Tabelle, in der die unterstützten Codierungen aufgeführt sind, finden Sie im Thema <xref:System.Text.Encoding>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1959a-1622">For a table that lists the supported encodings, see the <xref:System.Text.Encoding> class topic.</span></span>

> [!NOTE]
>  <span data-ttu-id="1959a-1623">Die Liste der unterstützten Codierungen, die von der <xref:System.Text.Encoding.GetEncodings%2A>-Methode zurückgegeben werden, umfasst keine zusätzlichen Codierungen, die von <xref:System.Text.EncodingProvider> Implementierungen bereitgestellt werden, die durch Aufrufe der <xref:System.Text.Encoding.RegisterProvider%2A>-Methode registriert wurden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1623">The list of supported encodings returned by the <xref:System.Text.Encoding.GetEncodings%2A> method does not include any additional encodings made available by any <xref:System.Text.EncodingProvider> implementations that were registered by calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method.</span></span>

 <span data-ttu-id="1959a-1624">Auf der .NET Framework sind die Codierungen 50220 und 50222 mit dem Namen "ISO-2022-JP" verknüpft, sind jedoch nicht identisch.</span><span class="sxs-lookup"><span data-stu-id="1959a-1624">On the .NET Framework, encodings 50220 and 50222 are both associated with the name "iso-2022-jp", but they are not identical.</span></span> <span data-ttu-id="1959a-1625">Codierung 50220 konvertiert Katakana-Zeichen mit halber Breite in Katakana-Zeichen mit voller Breite, während die Codierung 50222 eine UMSCHALT-in/UMSCHALT-out-Sequenz verwendet, um Katakana-Zeichen mit halber Breite zu codieren.</span><span class="sxs-lookup"><span data-stu-id="1959a-1625">Encoding 50220 converts half-width Katakana characters to full-width Katakana characters, whereas encoding 50222 uses a shift-in/shift-out sequence to encode half-width Katakana characters.</span></span> <span data-ttu-id="1959a-1626">Der Anzeige Name für die Codierung 50222 lautet "Japanisch (JIS-Allow 1 Byte Kana-so/SI)", um ihn von der Codierung 50220 mit dem anzeigen Amen "Japanese (JIS)" zu unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1626">The display name for encoding 50222 is "Japanese (JIS-Allow 1 byte Kana - SO/SI)" to distinguish it from encoding 50220, which has the display name "Japanese (JIS)".</span></span>

 <span data-ttu-id="1959a-1627">Wenn Sie den Codierungs Namen "ISO-2022-JP" anfordern, gibt der .NET Framework Encoding 50220 zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-1627">If you request the encoding name "iso-2022-jp", the .NET Framework returns encoding 50220.</span></span> <span data-ttu-id="1959a-1628">Die für Ihre APP geeignete Codierung hängt jedoch von der bevorzugten Behandlung der Katakana-Zeichen mit halber Breite ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-1628">However, the encoding that is appropriate for your app depends on the preferred treatment of the half-width Katakana characters.</span></span>

 <span data-ttu-id="1959a-1629">Um eine bestimmte Codierung zu erhalten, sollten Sie die <xref:System.Text.Encoding.GetEncoding%2A>-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1629">To get a specific encoding, you should use the <xref:System.Text.Encoding.GetEncoding%2A> method.</span></span>

 <span data-ttu-id="1959a-1630"><xref:System.Text.Encoding.GetEncodings%2A> wird manchmal verwendet, um dem Benutzer eine Liste der Codierungen im Dialogfeld Datei **Speichern** unter zu präsentieren.</span><span class="sxs-lookup"><span data-stu-id="1959a-1630"><xref:System.Text.Encoding.GetEncodings%2A> is sometimes used to present the user with a list of encodings in a File **Save as** dialog box.</span></span> <span data-ttu-id="1959a-1631">Viele nicht-Unicode-Codierungen sind jedoch entweder unvollständig und übersetzen viele Zeichen in "?" oder verfügen über ein unterschiedliches Verhalten auf verschiedenen Plattformen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1631">However, many non-Unicode encodings are either incomplete and translate many characters to "?", or have subtly different behavior on different platforms.</span></span> <span data-ttu-id="1959a-1632">Verwenden Sie als Standard UTF-8 oder UTF-16.</span><span class="sxs-lookup"><span data-stu-id="1959a-1632">Consider using UTF-8 or UTF-16 as the default.</span></span>



## Examples
 <span data-ttu-id="1959a-1633">Im folgenden Beispiel werden die Werte der booleschen Eigenschaften der einzelnen Codierungen überprüft.</span><span class="sxs-lookup"><span data-stu-id="1959a-1633">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1959a-1634">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1959a-1634">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1959a-1635">Gibt den Hashcode für die aktuelle Instanz zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-1635">Returns the hash code for the current instance.</span></span></summary>
        <returns><span data-ttu-id="1959a-1636">Der Hashcode für die aktuelle Instanz.</span><span class="sxs-lookup"><span data-stu-id="1959a-1636">The hash code for the current instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount"><span data-ttu-id="1959a-1637">Die Anzahl der zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1637">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1959a-1638">Berechnet beim Überschreiben in einer abgeleiteten Klasse die maximale Anzahl der Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1638">When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.</span></span></summary>
        <returns><span data-ttu-id="1959a-1639">Die maximale Anzahl an Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1639">The maximum number of bytes produced by encoding the specified number of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1640">Der `charCount`-Parameter gibt tatsächlich die Anzahl der <xref:System.Char> Objekte an, die die zu codierende Unicode-Zeichen darstellen, da .NET intern UTF-16 verwendet, um Unicode-Zeichen darzustellen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1640">The `charCount` parameter actually specifies the number of <xref:System.Char> objects that represent the Unicode characters to encode, because .NET internally uses UTF-16 to represent Unicode characters.</span></span> <span data-ttu-id="1959a-1641">Folglich können die meisten Unicode-Zeichen durch ein <xref:System.Char> Objekt dargestellt werden, aber ein Unicode-Zeichen, das durch ein Ersatz Zeichenpaar dargestellt wird, erfordert beispielsweise zwei <xref:System.Char> Objekte.</span><span class="sxs-lookup"><span data-stu-id="1959a-1641">Consequently, most Unicode characters can be represented by one <xref:System.Char> object, but a Unicode character represented by a surrogate pair, for example, requires two <xref:System.Char> objects.</span></span>

 <span data-ttu-id="1959a-1642">Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, sollten Sie die <xref:System.Text.Encoding.GetByteCount%2A>-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1642">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should use the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1959a-1643">Verwenden Sie die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode, um die maximale Array Größe zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1643">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1959a-1644">Die <xref:System.Text.Encoding.GetByteCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1644">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-1645"><xref:System.Text.Encoding.GetMaxByteCount%2A> Ruft die Nummer des ungünstigsten Falls ab, einschließlich des ungünstigsten Falls für den aktuell ausgewählten <xref:System.Text.EncoderFallback>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1645"><xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>.</span></span> <span data-ttu-id="1959a-1646">Wenn ein Fall Back mit einer potenziell großen Zeichenfolge ausgewählt wird, werden von <xref:System.Text.Encoding.GetMaxByteCount%2A> große Werte abgerufen, insbesondere in Fällen, in denen der schlechteste Fall für die Codierung das Wechseln von Modi für jedes Zeichen einschließt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1646">If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves large values, particularly in cases where the worst case for the encoding involves switching modes for every character.</span></span> <span data-ttu-id="1959a-1647">Dies kann z. b. bei ISO-2022-JP der Fall sein.</span><span class="sxs-lookup"><span data-stu-id="1959a-1647">For example, this can happen for ISO-2022-JP.</span></span> <span data-ttu-id="1959a-1648">Weitere Informationen finden Sie im Blogbeitrag "[Was ist mit Encoding. GetMaxByteCount () und Encoding. GetMaxCharCount ()?](https://blogs.msdn.microsoft.com/shawnste/2005/03/02/whats-with-encoding-getmaxbytecount-and-encoding-getmaxcharcount/)".</span><span class="sxs-lookup"><span data-stu-id="1959a-1648">For more information, see the blog post "[What's with Encoding.GetMaxByteCount() and Encoding.GetMaxCharCount()?](https://blogs.msdn.microsoft.com/shawnste/2005/03/02/whats-with-encoding-getmaxbytecount-and-encoding-getmaxcharcount/).</span></span>

 <span data-ttu-id="1959a-1649">In den meisten Fällen ruft diese Methode angemessene Werte für kleine Zeichen folgen ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-1649">In most cases, this method retrieves reasonable values for small strings.</span></span> <span data-ttu-id="1959a-1650">Bei großen Zeichen folgen müssen Sie möglicherweise zwischen der Verwendung sehr großer Puffer und dem Abfangen von Fehlern in seltenen Fällen wählen, wenn ein sinnvoller Puffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1650">For large strings, you might have to choose between using very large buffers and catching errors in the rare case when a more reasonable buffer is too small.</span></span> <span data-ttu-id="1959a-1651">Möglicherweise möchten Sie auch einen anderen Ansatz mit <xref:System.Text.Encoding.GetByteCount%2A> oder <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>in Erwägung gezogen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1651">You might also want to consider a different approach using <xref:System.Text.Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="1959a-1652">Wenn Sie <xref:System.Text.Encoding.GetMaxByteCount%2A>verwenden, sollten Sie den Ausgabepuffer basierend auf der maximalen Größe des Eingabe Puffers zuordnen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1652">When using <xref:System.Text.Encoding.GetMaxByteCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer.</span></span> <span data-ttu-id="1959a-1653">Wenn die Größe des Ausgabepuffers eingeschränkt ist, können Sie die <xref:System.Text.Encoding.Convert%2A>-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1653">If the output buffer is constrained in size, you might use the <xref:System.Text.Encoding.Convert%2A> method.</span></span>

 <span data-ttu-id="1959a-1654">Beachten Sie, dass <xref:System.Text.Encoding.GetMaxByteCount%2A> potenzielle Ersatz Zeichen von einem vorherigen Decoder-Vorgang berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1654">Note that <xref:System.Text.Encoding.GetMaxByteCount%2A> considers potential leftover surrogates from a previous decoder operation.</span></span> <span data-ttu-id="1959a-1655">Aufgrund des Decoders wird durch Übergeben des Werts 1 an die-Methode 2 für eine Einzel Byte Codierung, z. b. ASCII, abgerufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1655">Because of the decoder, passing a value of 1 to the method retrieves 2 for a single-byte encoding, such as ASCII.</span></span> <span data-ttu-id="1959a-1656">Wenn diese Informationen erforderlich sind, sollten Sie die <xref:System.Text.ASCIIEncoding.IsSingleByte%2A>-Eigenschaft verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1656">You should use the <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> property if this information is necessary.</span></span>

> [!NOTE]
>  <span data-ttu-id="1959a-1657">`GetMaxByteCount(N)` ist nicht notwendigerweise derselbe Wert wie `N* GetMaxByteCount(1)`.</span><span class="sxs-lookup"><span data-stu-id="1959a-1657">`GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`.</span></span>



## Examples
 <span data-ttu-id="1959a-1658">Im folgenden Beispiel wird die Anzahl der Bytes bestimmt, die zum Codieren eines Zeichen Arrays erforderlich sind, die Zeichen codiert und die resultierenden Bytes angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1658">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-1659"><paramref name="charCount" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="1959a-1659"><paramref name="charCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1959a-1660">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-1660">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-1661">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-1661">-and-</span></span>

 <span data-ttu-id="1959a-1662">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1662"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="1959a-1663">Alle <see cref="T:System.Text.Encoding" /> Implementierungen müssen sicherstellen, dass keine Pufferüberlauf Ausnahmen auftreten, wenn Puffer entsprechend den Ergebnissen der Berechnungen dieser Methode vergrößert werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1663">All <see cref="T:System.Text.Encoding" /> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</span></span></para></block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount"><span data-ttu-id="1959a-1664">Die Anzahl der zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-1664">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1959a-1665">Berechnet beim Überschreiben in einer abgeleiteten Klasse die maximale Anzahl an Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1665">When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.</span></span></summary>
        <returns><span data-ttu-id="1959a-1666">Die maximale Anzahl von Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1666">The maximum number of characters produced by decoding the specified number of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1667">Um die genaue Array Größe zu berechnen, die <xref:System.Text.Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, sollten Sie die <xref:System.Text.Encoding.GetCharCount%2A>-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1667">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1959a-1668">Verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode, um die maximale Array Größe zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1668">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1959a-1669">Die <xref:System.Text.Encoding.GetCharCount%2A>-Methode ermöglicht im Allgemeinen die Zuordnung von weniger Arbeitsspeicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1669">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="1959a-1670"><xref:System.Text.Encoding.GetMaxCharCount%2A> Ruft die Nummer des ungünstigsten Falls ab, einschließlich des ungünstigsten Falls für den aktuell ausgewählten <xref:System.Text.DecoderFallback>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1670"><xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>.</span></span> <span data-ttu-id="1959a-1671">Wenn ein Fall Back mit einer potenziell großen Zeichenfolge ausgewählt wird, ruft <xref:System.Text.Encoding.GetMaxCharCount%2A> große Werte ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-1671">If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves large values.</span></span>

 <span data-ttu-id="1959a-1672">In den meisten Fällen ruft diese Methode angemessene Zahlen für kleine Zeichen folgen ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-1672">In most cases, this method retrieves reasonable numbers for small strings.</span></span> <span data-ttu-id="1959a-1673">Bei großen Zeichen folgen müssen Sie möglicherweise zwischen der Verwendung sehr großer Puffer und dem Abfangen von Fehlern wählen, wenn ein sinnvoller Puffer zu klein ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1673">For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is too small.</span></span> <span data-ttu-id="1959a-1674">Möglicherweise möchten Sie auch einen anderen Ansatz mit <xref:System.Text.Encoding.GetCharCount%2A> oder <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>in Erwägung gezogen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1674">You might also want to consider a different approach using <xref:System.Text.Encoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="1959a-1675"><xref:System.Text.Encoding.GetMaxCharCount%2A> hat keine Beziehung zu <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1675"><xref:System.Text.Encoding.GetMaxCharCount%2A> has no relation to <xref:System.Text.Encoding.GetBytes%2A>.</span></span> <span data-ttu-id="1959a-1676">Wenn Sie eine ähnliche Funktion benötigen, die mit <xref:System.Text.Encoding.GetBytes%2A>verwendet werden soll, sollten Sie <xref:System.Text.Encoding.GetMaxByteCount%2A>verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1676">If you needs a similar function to use with <xref:System.Text.Encoding.GetBytes%2A>, you should use <xref:System.Text.Encoding.GetMaxByteCount%2A>.</span></span>

 <span data-ttu-id="1959a-1677">Wenn Sie <xref:System.Text.Encoding.GetMaxCharCount%2A>verwenden, sollten Sie den Ausgabepuffer basierend auf der maximalen Größe des Eingabe Puffers zuordnen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1677">When using <xref:System.Text.Encoding.GetMaxCharCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer.</span></span> <span data-ttu-id="1959a-1678">Wenn die Größe des Ausgabepuffers eingeschränkt ist, können Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1678">If the output buffer is constrained in size, you might use the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method.</span></span>

 <span data-ttu-id="1959a-1679">Beachten Sie, dass <xref:System.Text.Encoding.GetMaxCharCount%2A> den ungünstigsten Fall für übrig gebliebene Bytes aus einem vorherigen Codierungs Vorgang berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1679">Note that <xref:System.Text.Encoding.GetMaxCharCount%2A> considers the worst case for leftover bytes from a previous encoder operation.</span></span> <span data-ttu-id="1959a-1680">Bei den meisten Codepages ruft der Wert 0 (null) an diese Methode Werte ab, die größer oder gleich 1 sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1680">For most code pages, passing a value of 0 to this method retrieves values greater than or equal to 1.</span></span>

> [!NOTE]
>  <span data-ttu-id="1959a-1681">`GetMaxCharCount(N)` ist nicht notwendigerweise derselbe Wert wie `N* GetMaxCharCount(1)`.</span><span class="sxs-lookup"><span data-stu-id="1959a-1681">`GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`.</span></span>



## Examples
 <span data-ttu-id="1959a-1682">Im folgenden Beispiel wird eine Zeichenfolge in ein Bytearray codiert und dann in ein Zeichen Array decodiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1682">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-1683"><paramref name="byteCount" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="1959a-1683"><paramref name="byteCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1959a-1684">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-1684">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-1685">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-1685">-and-</span></span>

 <span data-ttu-id="1959a-1686">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1686"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="1959a-1687">Alle <see cref="T:System.Text.Encoding" /> Implementierungen müssen sicherstellen, dass keine Pufferüberlauf Ausnahmen auftreten, wenn Puffer entsprechend den Ergebnissen der Berechnungen dieser Methode vergrößert werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1687">All <see cref="T:System.Text.Encoding" /> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</span></span></para></block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1959a-1688">Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge zurückgegeben, die die verwendete Codierung angibt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1688">When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.</span></span></summary>
        <returns><span data-ttu-id="1959a-1689">Ein Bytearray, das eine Bytefolge enthält, in der die verwendete Codierung angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1689">A byte array containing a sequence of bytes that specifies the encoding used.</span></span>

 <span data-ttu-id="1959a-1690">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1690">-or-</span></span>

 <span data-ttu-id="1959a-1691">Ein Bytearray der Länge 0 (null), wenn keine Präambel erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1691">A byte array of length zero, if a preamble is not required.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1692">Das <xref:System.Text.Encoding>-Objekt stellt optional eine Präambel bereit, bei der es sich um ein Bytearray handelt, dem die Byte Sequenz vorangestellt werden kann, die sich aus dem Codierungsprozess ergibt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1692">Optionally, the <xref:System.Text.Encoding> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.</span></span> <span data-ttu-id="1959a-1693">Wenn die Präambel eine Byte Reihenfolge-Markierung (in Unicode, Codepunkt U + FEFF) enthält, unterstützt Sie der Decoder dabei, die Byte Reihenfolge und das Transformations Format oder UTF zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1693">If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.</span></span>

 <span data-ttu-id="1959a-1694">Die Unicode-Byte Reihenfolge Markierung (BOM) wird wie folgt serialisiert (in Hexadezimal):</span><span class="sxs-lookup"><span data-stu-id="1959a-1694">The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</span></span>

-   <span data-ttu-id="1959a-1695">UTF-8: EF BB BF</span><span class="sxs-lookup"><span data-stu-id="1959a-1695">UTF-8: EF BB BF</span></span>

-   <span data-ttu-id="1959a-1696">UTF-16 Big-Endian-Byte Reihenfolge: FE FF</span><span class="sxs-lookup"><span data-stu-id="1959a-1696">UTF-16 big endian byte order: FE FF</span></span>

-   <span data-ttu-id="1959a-1697">UTF-16 Little-Endian-Byte Reihenfolge: FF FE</span><span class="sxs-lookup"><span data-stu-id="1959a-1697">UTF-16 little endian byte order: FF FE</span></span>

-   <span data-ttu-id="1959a-1698">UTF-32 Big Endian-Byte Reihenfolge: 00 00 FE FF</span><span class="sxs-lookup"><span data-stu-id="1959a-1698">UTF-32 big endian byte order: 00 00 FE FF</span></span>

-   <span data-ttu-id="1959a-1699">UTF-32 Little-Endian-Byte Reihenfolge: FF FE 00 00</span><span class="sxs-lookup"><span data-stu-id="1959a-1699">UTF-32 little endian byte order: FF FE 00 00</span></span>

 <span data-ttu-id="1959a-1700">Sie sollten die BOM verwenden, da Sie fast eine bestimmte Identifizierung einer Codierung für Dateien bereitstellt, die andernfalls den Verweis auf das <xref:System.Text.Encoding> Objekt verloren haben, z. b. nicht markierte oder nicht ordnungsgemäß markierte Webdaten oder Zufalls Textdateien, die gespeichert wurden, wenn ein Unternehmen über keine internationalen Probleme oder andere Daten verfügte.</span><span class="sxs-lookup"><span data-stu-id="1959a-1700">You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.Encoding> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data.</span></span> <span data-ttu-id="1959a-1701">Häufig können Benutzer Probleme vermieden werden, wenn die Daten konsistent und ordnungsgemäß gekennzeichnet sind, vorzugsweise in UTF-8 oder UTF-16.</span><span class="sxs-lookup"><span data-stu-id="1959a-1701">Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.</span></span>

 <span data-ttu-id="1959a-1702">Bei Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant.</span><span class="sxs-lookup"><span data-stu-id="1959a-1702">For standards that provide an encoding type, a BOM is somewhat redundant.</span></span> <span data-ttu-id="1959a-1703">Sie kann jedoch verwendet werden, um einem Server zu helfen, den richtigen Codierungs Header zu senden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1703">However, it can be used to help a server send the correct encoding header.</span></span> <span data-ttu-id="1959a-1704">Alternativ kann es als Fall Back für den Fall verwendet werden, dass die Codierung andernfalls verloren geht.</span><span class="sxs-lookup"><span data-stu-id="1959a-1704">Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</span></span>

 <span data-ttu-id="1959a-1705">Es gibt einige Nachteile bei der Verwendung einer BOM.</span><span class="sxs-lookup"><span data-stu-id="1959a-1705">There are some disadvantages to using a BOM.</span></span> <span data-ttu-id="1959a-1706">Beispielsweise kann das Einschränken der Datenbankfelder, die eine BOM verwenden, schwierig sein.</span><span class="sxs-lookup"><span data-stu-id="1959a-1706">For example, knowing how to limit the database fields that use a BOM can be difficult.</span></span> <span data-ttu-id="1959a-1707">Die Verkettung von Dateien kann auch ein Problem darstellen, z. b. wenn Dateien so zusammengeführt werden, dass ein unnötiges Zeichen in der Mitte der Daten enden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1707">Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</span></span> <span data-ttu-id="1959a-1708">Trotz der wenigen Nachteile wird die Verwendung einer BOM dringend empfohlen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1708">In spite of the few disadvantages, however, the use of a BOM is highly recommended.</span></span>

 <span data-ttu-id="1959a-1709">Weitere Informationen zur Byte Reihenfolge und zur Byte Reihenfolge-Markierung finden Sie im Unicode-Standard auf der [Unicode-Homepage](https://go.microsoft.com/fwlink/?LinkId=37123).</span><span class="sxs-lookup"><span data-stu-id="1959a-1709">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](https://go.microsoft.com/fwlink/?LinkId=37123).</span></span>

> [!CAUTION]
>  <span data-ttu-id="1959a-1710">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie codierte Bytes mit einer Präambel versehen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1710">To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble.</span></span> <span data-ttu-id="1959a-1711">Bei den meisten Codierungen wird jedoch keine Präambel bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1711">However, most encodings do not provide a preamble.</span></span> <span data-ttu-id="1959a-1712">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie eine Unicode-Codierung verwenden, d. h., <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>oder <xref:System.Text.UTF32Encoding>mit einer Präambel.</span><span class="sxs-lookup"><span data-stu-id="1959a-1712">To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, or <xref:System.Text.UTF32Encoding>, with a preamble.</span></span>



## Examples
 <span data-ttu-id="1959a-1713">Im folgenden Beispiel wird die Byte Reihenfolge der Codierung basierend auf der Präambel bestimmt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1713">The following example determines the byte order of the encoding based on the preamble.</span></span>

 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1959a-1714">Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge in eine Zeichenfolge decodiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1714">When overridden in a derived class, decodes a sequence of bytes into a string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1959a-1715">Das Bytearray, das die zu decodierende Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1715">The byte array containing the sequence of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1959a-1716">Beim Überschreiben in einer abgeleiteten Klasse werden alle Bytes im angegebenen Bytearray in eine Zeichenfolge decodiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1716">When overridden in a derived class, decodes all the bytes in the specified byte array into a string.</span></span></summary>
        <returns><span data-ttu-id="1959a-1717">Eine Zeichenfolge, die die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1717">A string that contains the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1718">Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie das <xref:System.Text.Decoder>-Objekt verwenden, das von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode einer abgeleiteten Klasse zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1718">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.</span></span>

 <span data-ttu-id="1959a-1719">Weitere Informationen zu Decodierungs Techniken und-Überlegungen finden Sie im Abschnitt "Hinweise" des <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Referenz Themas.</span><span class="sxs-lookup"><span data-stu-id="1959a-1719">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>

 <span data-ttu-id="1959a-1720">Beachten Sie, dass das genaue Verhalten der <xref:System.Text.Encoding.GetString%2A> Methode für eine bestimmte <xref:System.Text.Encoding> Implementierung von der Fall Back Strategie abhängt, die für dieses <xref:System.Text.Encoding> Objekt definiert ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1720">Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object.</span></span> <span data-ttu-id="1959a-1721">Weitere Informationen finden Sie im Abschnitt "Auswählen einer Fall Back Strategie" des Themas [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md) .</span><span class="sxs-lookup"><span data-stu-id="1959a-1721">For more information, see the "Choosing a Fallback Strategy" section of the [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) topic.</span></span>



## Examples
 <span data-ttu-id="1959a-1722">Im folgenden Beispiel wird eine UTF-8-codierte Zeichenfolge aus einer Binärdatei gelesen, die von einem <xref:System.IO.FileStream>-Objekt dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1722">The following example reads a UTF-8 encoded string from a binary file represented by a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="1959a-1723">Bei Dateien, die kleiner als 2.048 Bytes sind, liest der Inhalt der gesamten Datei in ein Bytearray und ruft die <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29>-Methode auf, um die Decodierung auszuführen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1723">For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> method to perform the decoding.</span></span> <span data-ttu-id="1959a-1724">Bei größeren Dateien liest Sie jeweils 2.048 Bytes in ein Bytearray, ruft die <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>-Methode auf, um zu bestimmen, wie viele Zeichen im Array enthalten sind, und ruft dann die <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType>-Methode auf, um die Decodierung auszuführen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1724">For larger files, it reads 2,048 bytes at a time into a byte array, calls the <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to determine how many characters are contained in the array, and then calls the <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> method to perform the decoding.</span></span>

 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]

 <span data-ttu-id="1959a-1725">Im Beispiel wird der folgende Text verwendet, der in einer UTF-8-codierten Datei mit dem Namen Utf8Example. txt gespeichert werden soll.</span><span class="sxs-lookup"><span data-stu-id="1959a-1725">The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</span></span>

```

This is a UTF-8-encoded file that contains primarily Latin text, although it
does list the first twelve letters of the Russian (Cyrillic) alphabet:

А б в г д е ё ж з и й к

The goal is to save this file, then open and decode it as a binary stream.

```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1959a-1726">Das Bytearray enthält ungültige Unicode-Codepunkte.</span><span class="sxs-lookup"><span data-stu-id="1959a-1726">The byte array contains invalid Unicode code points.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-1727"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1727"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1959a-1728">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-1728">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-1729">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-1729">-and-</span></span>

 <span data-ttu-id="1959a-1730">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1730"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1959a-1731">Eine schreibgeschützte Bytespanne, die in eine Unicode-Zeichenfolge decodiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="1959a-1731">A read-only byte span to decode to a Unicode string.</span></span></param>
        <summary><span data-ttu-id="1959a-1732">Decodiert beim Überschreiben in einer abgeleiteten Klasse alle Bytes in der angegebenen Bytespanne in eine Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1959a-1732">When overridden in a derived class, decodes all the bytes in the specified byte span into a string.</span></span></summary>
        <returns><span data-ttu-id="1959a-1733">Eine Zeichenfolge, die die decodierten Bytes aus der angegebenen schreibgeschützten Spanne enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1733">A string that contains the decoded bytes from the provided read-only span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1734">Die <xref:System.Text.Encoding.GetString%2A>-Methode wurde entwickelt, um die Leistung zu optimieren.</span><span class="sxs-lookup"><span data-stu-id="1959a-1734">The <xref:System.Text.Encoding.GetString%2A> method is designed to optimize performance.</span></span> <span data-ttu-id="1959a-1735">Anstatt ein verwaltetes Bytearray zu erstellen und anschließend zu decodieren, können Sie stattdessen diese Methode aufrufen, ohne zwischen Objekte erstellen zu müssen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1735">Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.</span></span>

 <span data-ttu-id="1959a-1736">Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie das <xref:System.Text.Decoder>-Objekt verwenden, das von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode einer abgeleiteten Klasse zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1736">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.</span></span>

 <span data-ttu-id="1959a-1737">Weitere Informationen zu Decodierungs Techniken und-Überlegungen finden Sie im Abschnitt "Hinweise" des <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Referenz Themas.</span><span class="sxs-lookup"><span data-stu-id="1959a-1737">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>

 <span data-ttu-id="1959a-1738">Beachten Sie, dass das genaue Verhalten der <xref:System.Text.Encoding.GetString%2A> Methode für eine bestimmte <xref:System.Text.Encoding> Implementierung von der Fall Back Strategie abhängt, die für dieses <xref:System.Text.Encoding> Objekt definiert ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1738">Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object.</span></span> <span data-ttu-id="1959a-1739">Weitere Informationen finden Sie im Abschnitt "Auswählen einer Fall Back Strategie" des Themas [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md) .</span><span class="sxs-lookup"><span data-stu-id="1959a-1739">For more information, see the "Choosing a Fallback Strategy" section of the [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) topic.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1959a-1740">Ein Zeiger auf ein Bytearray.</span><span class="sxs-lookup"><span data-stu-id="1959a-1740">A pointer to a byte array.</span></span></param>
        <param name="byteCount"><span data-ttu-id="1959a-1741">Die Anzahl der zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-1741">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1959a-1742">Beim Überschreiben in einer abgeleiteten Klasse wird eine angegebene Anzahl von Bytes ab einer angegebenen Adresse in eine Zeichenfolge decodiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1742">When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string.</span></span></summary>
        <returns><span data-ttu-id="1959a-1743">Eine Zeichenfolge, die die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1743">A string that contains the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1744">Die <xref:System.Text.Encoding.GetString%2A>-Methode wurde entwickelt, um die Leistung zu optimieren, wenn Sie einen systemeigenen Zeiger auf ein Bytearray haben.</span><span class="sxs-lookup"><span data-stu-id="1959a-1744">The <xref:System.Text.Encoding.GetString%2A> method is designed to optimize performance when you have a native pointer to a byte array.</span></span> <span data-ttu-id="1959a-1745">Anstatt ein verwaltetes Bytearray zu erstellen und anschließend zu decodieren, können Sie stattdessen diese Methode aufrufen, ohne zwischen Objekte erstellen zu müssen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1745">Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.</span></span>

 <span data-ttu-id="1959a-1746">Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie das <xref:System.Text.Decoder>-Objekt verwenden, das von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode einer abgeleiteten Klasse zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1746">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.</span></span>

 <span data-ttu-id="1959a-1747">Weitere Informationen zu Decodierungs Techniken und-Überlegungen finden Sie im Abschnitt "Hinweise" des <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Referenz Themas.</span><span class="sxs-lookup"><span data-stu-id="1959a-1747">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>

 <span data-ttu-id="1959a-1748">Beachten Sie, dass das genaue Verhalten der <xref:System.Text.Encoding.GetString%2A> Methode für eine bestimmte <xref:System.Text.Encoding> Implementierung von der Fall Back Strategie abhängt, die für dieses <xref:System.Text.Encoding> Objekt definiert ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1748">Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object.</span></span> <span data-ttu-id="1959a-1749">Weitere Informationen finden Sie im Abschnitt "Auswählen einer Fall Back Strategie" des Themas [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md) .</span><span class="sxs-lookup"><span data-stu-id="1959a-1749">For more information, see the "Choosing a Fallback Strategy" section of the [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) topic.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-1750"><paramref name="bytes" /> ist ein NULL-Zeiger</span><span class="sxs-lookup"><span data-stu-id="1959a-1750"><paramref name="bytes" /> is a null pointer.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-1751"><paramref name="byteCount" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="1959a-1751"><paramref name="byteCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1959a-1752">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="1959a-1752">A   fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for a complete explanation)</span></span>

<span data-ttu-id="1959a-1753">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-1753">-and-</span></span>

 <span data-ttu-id="1959a-1754">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1754"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1959a-1755">Das Bytearray, das die zu decodierende Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1755">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="1959a-1756">Der Index des ersten zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-1756">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="1959a-1757">Die Anzahl der zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1959a-1757">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1959a-1758">Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge aus dem angegebenen Bytearray in eine Zeichenfolge decodiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1758">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.</span></span></summary>
        <returns><span data-ttu-id="1959a-1759">Eine Zeichenfolge, die die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1959a-1759">A string that contains the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1760">Wenn die zu konvertierenden Daten nur in sequenziellen Blöcken (z. b. aus einem Stream gelesene Daten) verfügbar sind, oder wenn die Menge der Daten so groß ist, dass Sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> verwenden, die von der <xref:System.Text.Encoding.GetDecoder%2A>-Methode bzw. der <xref:System.Text.Encoding.GetEncoder%2A>-Methode der abgeleiteten Klasse bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1760">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="1959a-1761">Weitere Informationen zu Decodierungs Techniken und-Überlegungen finden Sie im Abschnitt "Hinweise" des <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Referenz Themas.</span><span class="sxs-lookup"><span data-stu-id="1959a-1761">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>



## Examples
 <span data-ttu-id="1959a-1762">Im folgenden Beispiel wird eine UTF-8-codierte Zeichenfolge aus einer Binärdatei gelesen, die durch ein <xref:System.IO.FileStream>-Objekt dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1762">The following example reads a UTF-8 encoded string from a binary file that is represented by a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="1959a-1763">Bei Dateien, die kleiner als 2.048 Bytes sind, liest der Inhalt der gesamten Datei in ein Bytearray und ruft die <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Methode auf, um die Decodierung auszuführen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1763">For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method to perform the decoding.</span></span> <span data-ttu-id="1959a-1764">Bei größeren Dateien liest Sie jeweils 2.048 Bytes in ein Bytearray, ruft die <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>-Methode auf, um zu bestimmen, wie viele Zeichen im Array enthalten sind, und ruft dann die <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType>-Methode auf, um die Decodierung auszuführen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1764">For larger files, it reads 2,048 bytes at a time into a byte array, calls the <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to determine how many characters are contained in the array, and then calls the <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> method to perform the decoding.</span></span>

 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]

 <span data-ttu-id="1959a-1765">Im Beispiel wird der folgende Text verwendet, der in einer UTF-8-codierten Datei mit dem Namen Utf8Example. txt gespeichert werden soll.</span><span class="sxs-lookup"><span data-stu-id="1959a-1765">The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</span></span>

```

This is a UTF-8-encoded file that contains primarily Latin text, although it
does list the first twelve letters of the Russian (Cyrillic) alphabet:

А б в г д е ё ж з и й к

The goal is to save this file, then open and decode it as a binary stream.

```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1959a-1766">Das Bytearray enthält ungültige Unicode-Codepunkte.</span><span class="sxs-lookup"><span data-stu-id="1959a-1766">The byte array contains invalid Unicode code points.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-1767"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1767"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1959a-1768"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="1959a-1768"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="1959a-1769">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1769">-or-</span></span>

 <span data-ttu-id="1959a-1770"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</span><span class="sxs-lookup"><span data-stu-id="1959a-1770"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1959a-1771">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1959a-1771">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="1959a-1772">-und-</span><span class="sxs-lookup"><span data-stu-id="1959a-1772">-and-</span></span>

 <span data-ttu-id="1959a-1773">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1773"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-1774">Beim Überschreiben in einer abgeleiteten Klasse wird ein Name für die aktuelle Codierung abgerufen, die mit den Header-Tags des E-Mail-Agenten verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1774">When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.</span></span></summary>
        <value><span data-ttu-id="1959a-1775">Ein Name für die aktuelle <see cref="T:System.Text.Encoding" />, die für die Header-Tags des E-Mail-Agenten verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1775">A name for the current <see cref="T:System.Text.Encoding" /> to use with mail agent header tags.</span></span>

<span data-ttu-id="1959a-1776">- oder -</span><span class="sxs-lookup"><span data-stu-id="1959a-1776">-or-</span></span>

<span data-ttu-id="1959a-1777">Eine leere Zeichenfolge (""), wenn das aktuelle <see cref="T:System.Text.Encoding" /> nicht verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1777">An empty string (""), if the current <see cref="T:System.Text.Encoding" /> cannot be used.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1778">Wenn Sie eine Codierung für einen Header Namen benötigen, sollten Sie die <xref:System.Text.Encoding.GetEncoding%2A>-Methode mit der <xref:System.Text.Encoding.HeaderName%2A>-Eigenschaft aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1778">If you need an encoding for a header name, you should call the <xref:System.Text.Encoding.GetEncoding%2A> method with the <xref:System.Text.Encoding.HeaderName%2A> property.</span></span> <span data-ttu-id="1959a-1779">Häufig wird von der-Methode eine andere Codierung von der im-Befehl bereitgestellten Test Codierung abgerufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1779">Often the method retrieves a different encoding from the test encoding furnished in the call.</span></span> <span data-ttu-id="1959a-1780">Im Allgemeinen müssen nur e-Mail-Anwendungen eine solche Codierung abrufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1780">Generally only email applications need to retrieve such an encoding.</span></span>

 <span data-ttu-id="1959a-1781">In einigen Fällen entspricht der Wert der <xref:System.Text.Encoding.BodyName%2A>-Eigenschaft dem internationalen Standard, der diese Codierung definiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1781">In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding.</span></span> <span data-ttu-id="1959a-1782">Dies bedeutet nicht, dass die Implementierung vollständig mit diesem Standard übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1782">This doesn't mean that the implementation complies in full with that standard.</span></span>

 <span data-ttu-id="1959a-1783">Beachten Sie, dass <xref:System.Text.Encoding.WebName%2A> den Namen zurückgibt, der zum Beschreiben einer Codierung verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1783">Note that <xref:System.Text.Encoding.WebName%2A> returns the name to use to describe an encoding.</span></span> <span data-ttu-id="1959a-1784">Die <xref:System.Text.Encoding.HeaderName%2A>-Eigenschaft definiert eine andere Codierung, die möglicherweise für eine e-Mail-Anwendung besser geeignet ist, beispielsweise.</span><span class="sxs-lookup"><span data-stu-id="1959a-1784">The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for an email application, for example.</span></span> <span data-ttu-id="1959a-1785">Die Verwendung der-Eigenschaft zum Definieren der Codierung wird jedoch nicht empfohlen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1785">However, use of the property to define the encoding is not recommended.</span></span>



## Examples
 <span data-ttu-id="1959a-1786">Im folgenden Beispiel werden die anderen Namen für die einzelnen Codierungen abgerufen und die Codierungen mit einem oder mehreren Namen angezeigt, die sich von <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1786">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1959a-1787">Es wird <xref:System.Text.Encoding.EncodingName%2A> angezeigt, aber nicht mit diesem verglichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1787">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1959a-1788">Ruft einen Wert ab, der angibt, ob die aktuelle Codierung immer normalisiert ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1788">Gets a value indicating whether the current encoding is always normalized.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1959a-1789">Ruft einen Wert ab, der angibt, ob die aktuelle Codierung immer normalisiert ist. Es wird die Standardnormalisierungsform verwendet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1789">Gets a value indicating whether the current encoding is always normalized, using the default normalization form.</span></span></summary>
        <returns><span data-ttu-id="1959a-1790"><see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" />-Klasse immer normalisiert ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1790"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> is always normalized; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="1959a-1791">Der Standardwert ist <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1791">The default is <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1792">Die Standard normalisierungs Form ist <xref:System.Text.NormalizationForm.FormC>, bei der die vollständige kanonische Zerlegung verwendet wird, gefolgt von der Ersetzung von Sequenzen durch ihre primären Verbund, wenn möglich.</span><span class="sxs-lookup"><span data-stu-id="1959a-1792">The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="form"><span data-ttu-id="1959a-1793">Einer der <see cref="T:System.Text.NormalizationForm" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="1959a-1793">One of the <see cref="T:System.Text.NormalizationForm" /> values.</span></span></param>
        <summary><span data-ttu-id="1959a-1794">Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung immer normalisiert ist. Hierzu wird die angegebene Normalisierungsform verwendet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1794">When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.</span></span></summary>
        <returns><span data-ttu-id="1959a-1795"><see langword="true" />, wenn das aktuelle <see cref="T:System.Text.Encoding" />-Objekt immer mit dem angegebenen <see cref="T:System.Text.NormalizationForm" />-Wert normalisiert wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1795"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> object is always normalized using the specified <see cref="T:System.Text.NormalizationForm" /> value; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="1959a-1796">Der Standardwert ist <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1796">The default is <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1797">Die Standard normalisierungs Form ist <xref:System.Text.NormalizationForm.FormC>, bei der die vollständige kanonische Zerlegung verwendet wird, gefolgt von der Ersetzung von Sequenzen durch ihre primären Verbund, wenn möglich.</span><span class="sxs-lookup"><span data-stu-id="1959a-1797">The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-1798">Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung von Browserclients zum Anzeigen des Inhalts verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1798">When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.</span></span></summary>
        <value><span data-ttu-id="1959a-1799"><see langword="true" /> wenn das aktuelle <see cref="T:System.Text.Encoding" /> von Browserclients verwendet werden kann, um Inhalt anzuzeigen; andernfalls, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1799"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by browser clients for displaying content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="1959a-1800">Im folgenden Beispiel werden die Werte der booleschen Eigenschaften der einzelnen Codierungen überprüft.</span><span class="sxs-lookup"><span data-stu-id="1959a-1800">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-1801">Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung von Browserclients zum Speichern von Inhalt verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1801">When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.</span></span></summary>
        <value><span data-ttu-id="1959a-1802"><see langword="true" /> wenn das aktuelle <see cref="T:System.Text.Encoding" /> von Browserclients verwendet werden kann, um Inhalt zu speichern; andernfalls, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1802"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by browser clients for saving content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="1959a-1803">Im folgenden Beispiel werden die Werte der booleschen Eigenschaften der einzelnen Codierungen überprüft.</span><span class="sxs-lookup"><span data-stu-id="1959a-1803">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-1804">Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung von Mail- und Newsclients zum Anzeigen von Inhalt verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1804">When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.</span></span></summary>
        <value><span data-ttu-id="1959a-1805"><see langword="true" /> wenn die aktuelle <see cref="T:System.Text.Encoding" />-Klasse von Mail- und Newsclients verwendet werden kann, um Inhalt anzuzeigen; andernfalls, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1805"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by mail and news clients for displaying content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="1959a-1806">Im folgenden Beispiel werden die Werte der booleschen Eigenschaften der einzelnen Codierungen überprüft.</span><span class="sxs-lookup"><span data-stu-id="1959a-1806">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-1807">Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung von Mail- und Newsclients zum Speichern von Inhalt verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1807">When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.</span></span></summary>
        <value><span data-ttu-id="1959a-1808"><see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> von Mail- und Newsclients verwendet werden kann, um Inhalt zu speichern, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1808"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by mail and news clients for saving content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="1959a-1809">Im folgenden Beispiel werden die Werte der booleschen Eigenschaften der einzelnen Codierungen überprüft.</span><span class="sxs-lookup"><span data-stu-id="1959a-1809">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-1810">Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob die aktuelle Codierung schreibgeschützt ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1810">When overridden in a derived class, gets a value indicating whether the current encoding is read-only.</span></span></summary>
        <value><span data-ttu-id="1959a-1811"><see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> schreibgeschützt ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1811"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> is read-only; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="1959a-1812">Der Standardwert ist <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1812">The default is <see langword="true" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-1813">Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob die aktuelle Codierung Einzelbyte-Codepunkte verwendet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1813">When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.</span></span></summary>
        <value><span data-ttu-id="1959a-1814"><see langword="true" />, wenn das aktuelle <see cref="T:System.Text.Encoding" /> Einzelbyte-Codepunkte verwendet; andernfalls, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1814"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> uses single-byte code points; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1815">Bei einer Single-Byte-Codierung, z. b. <xref:System.Text.ASCIIEncoding>, ruft diese Eigenschaft `true`ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-1815">For a single-byte encoding, for example, <xref:System.Text.ASCIIEncoding>, this property retrieves `true`.</span></span>

> [!CAUTION]
>  <span data-ttu-id="1959a-1816">Sie sollten mit dem Wert für <xref:System.Text.Encoding.IsSingleByte%2A>vorsichtig vorgehen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1816">You should be careful in what your application does with the value for <xref:System.Text.Encoding.IsSingleByte%2A>.</span></span> <span data-ttu-id="1959a-1817">Eine Annahme, wie eine Codierung fortgesetzt wird, ist möglicherweise trotzdem falsch.</span><span class="sxs-lookup"><span data-stu-id="1959a-1817">An assumption of how an Encoding will proceed may still be wrong.</span></span> <span data-ttu-id="1959a-1818">Windows-1252 hat z. b. den Wert `true` für <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, aber Encoding. GetMaxByteCount (1) gibt 2 zurück.</span><span class="sxs-lookup"><span data-stu-id="1959a-1818">For example, Windows-1252 has a value of `true` for <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, but Encoding.GetMaxByteCount(1) returns 2.</span></span> <span data-ttu-id="1959a-1819">Dies liegt daran, dass die-Methode potenzielle Ersatz Zeichen aus einem vorherigen Decoder-Vorgang berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1819">This is because the method considers potential leftover surrogates from a previous decoder operation.</span></span>



## Examples
 <span data-ttu-id="1959a-1820">Im folgenden Beispiel werden die Werte der booleschen Eigenschaften der einzelnen Codierungen überprüft.</span><span class="sxs-lookup"><span data-stu-id="1959a-1820">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-1821">Gibt beim Überschreiben in einer abgeleiteten Klasse eine Bytefolge zurück, die die verwendete Codierung angibt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1821">When overridden in a derived class, returns a span containing the sequence of bytes that specifies the encoding used.</span></span></summary>
        <value><span data-ttu-id="1959a-1822">Eine Bytespanne mit einer Bytefolge, die die verwendete Codierung angibt, oder eine Spanne der Länge 0 (null), wenn keine Präambel erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1822">A byte span containing a sequence of bytes that specifies the encoding used, or a span of length zero, if a preamble is not required.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1823">Das <xref:System.Text.Encoding>-Objekt stellt optional eine Präambel bereit, bei der es sich um eine Byte Sequenz handelt, die den Bytes vorangestellt werden kann, die sich aus dem Codierungsprozess ergeben.</span><span class="sxs-lookup"><span data-stu-id="1959a-1823">Optionally, the <xref:System.Text.Encoding> object provides a preamble that is an sequence of bytes that can be prefixed to the bytes resulting from the encoding process.</span></span> <span data-ttu-id="1959a-1824">Wenn die Präambel eine Byte Reihenfolge-Markierung (in Unicode, Codepunkt U + FEFF) enthält, unterstützt Sie der Decoder dabei, die Byte Reihenfolge und das Transformations Format oder UTF zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1824">If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.</span></span>

 <span data-ttu-id="1959a-1825">Die Unicode-Byte Reihenfolge Markierung (BOM) wird wie folgt serialisiert (in Hexadezimal):</span><span class="sxs-lookup"><span data-stu-id="1959a-1825">The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</span></span>

-   <span data-ttu-id="1959a-1826">UTF-8: EF BB BF</span><span class="sxs-lookup"><span data-stu-id="1959a-1826">UTF-8: EF BB BF</span></span>

-   <span data-ttu-id="1959a-1827">UTF-16 Big-Endian-Byte Reihenfolge: FE FF</span><span class="sxs-lookup"><span data-stu-id="1959a-1827">UTF-16 big endian byte order: FE FF</span></span>

-   <span data-ttu-id="1959a-1828">UTF-16 Little-Endian-Byte Reihenfolge: FF FE</span><span class="sxs-lookup"><span data-stu-id="1959a-1828">UTF-16 little endian byte order: FF FE</span></span>

-   <span data-ttu-id="1959a-1829">UTF-32 Big Endian-Byte Reihenfolge: 00 00 FE FF</span><span class="sxs-lookup"><span data-stu-id="1959a-1829">UTF-32 big endian byte order: 00 00 FE FF</span></span>

-   <span data-ttu-id="1959a-1830">UTF-32 Little-Endian-Byte Reihenfolge: FF FE 00 00</span><span class="sxs-lookup"><span data-stu-id="1959a-1830">UTF-32 little endian byte order: FF FE 00 00</span></span>

 <span data-ttu-id="1959a-1831">Sie sollten die BOM verwenden, da Sie fast eine bestimmte Identifizierung einer Codierung für Dateien bereitstellt, die andernfalls den Verweis auf das <xref:System.Text.Encoding> Objekt verloren haben, z. b. nicht markierte oder nicht ordnungsgemäß markierte Webdaten oder Zufalls Textdateien, die gespeichert wurden, wenn ein Unternehmen über keine internationalen Probleme oder andere Daten verfügte.</span><span class="sxs-lookup"><span data-stu-id="1959a-1831">You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.Encoding> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data.</span></span> <span data-ttu-id="1959a-1832">Häufig können Benutzer Probleme vermieden werden, wenn die Daten konsistent und ordnungsgemäß gekennzeichnet sind, vorzugsweise in UTF-8 oder UTF-16.</span><span class="sxs-lookup"><span data-stu-id="1959a-1832">Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.</span></span>

 <span data-ttu-id="1959a-1833">Bei Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant.</span><span class="sxs-lookup"><span data-stu-id="1959a-1833">For standards that provide an encoding type, a BOM is somewhat redundant.</span></span> <span data-ttu-id="1959a-1834">Sie kann jedoch verwendet werden, um einem Server zu helfen, den richtigen Codierungs Header zu senden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1834">However, it can be used to help a server send the correct encoding header.</span></span> <span data-ttu-id="1959a-1835">Alternativ kann es als Fall Back für den Fall verwendet werden, dass die Codierung andernfalls verloren geht.</span><span class="sxs-lookup"><span data-stu-id="1959a-1835">Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</span></span>

 <span data-ttu-id="1959a-1836">Es gibt einige Nachteile bei der Verwendung einer BOM.</span><span class="sxs-lookup"><span data-stu-id="1959a-1836">There are some disadvantages to using a BOM.</span></span> <span data-ttu-id="1959a-1837">Beispielsweise kann das Einschränken der Datenbankfelder, die eine BOM verwenden, schwierig sein.</span><span class="sxs-lookup"><span data-stu-id="1959a-1837">For example, knowing how to limit the database fields that use a BOM can be difficult.</span></span> <span data-ttu-id="1959a-1838">Die Verkettung von Dateien kann auch ein Problem darstellen, z. b. wenn Dateien so zusammengeführt werden, dass ein unnötiges Zeichen in der Mitte der Daten enden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1838">Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</span></span> <span data-ttu-id="1959a-1839">Trotz der wenigen Nachteile wird jedoch dringend empfohlen, eine BOM zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1839">Despite the few disadvantages, however, the use of a BOM is highly recommended.</span></span>

 <span data-ttu-id="1959a-1840">Weitere Informationen zur Byte Reihenfolge und zur Byte Reihenfolge-Markierung finden Sie im Unicode-Standard auf der [Unicode-Homepage](https://home.unicode.org/).</span><span class="sxs-lookup"><span data-stu-id="1959a-1840">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](https://home.unicode.org/).</span></span>

> [!CAUTION]
>  <span data-ttu-id="1959a-1841">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie codierte Bytes mit einer Präambel versehen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1841">To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble.</span></span> <span data-ttu-id="1959a-1842">Bei den meisten Codierungen wird jedoch keine Präambel bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1842">However, most encodings do not provide a preamble.</span></span> <span data-ttu-id="1959a-1843">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie eine Unicode-Codierung verwenden, d. h., <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>oder <xref:System.Text.UTF32Encoding>mit einer Präambel.</span><span class="sxs-lookup"><span data-stu-id="1959a-1843">To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, or <xref:System.Text.UTF32Encoding>, with a preamble.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="1959a-1844">Eine Unterklasse von <see cref="T:System.Text.EncodingProvider" />, die Zugriff auf zusätzliche Zeichencodierungen bietet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1844">A subclass of <see cref="T:System.Text.EncodingProvider" /> that provides access to additional character encodings.</span></span></param>
        <summary><span data-ttu-id="1959a-1845">Registriert einen Codierungsanbieter.</span><span class="sxs-lookup"><span data-stu-id="1959a-1845">Registers an encoding provider.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1846">Die <xref:System.Text.Encoding.RegisterProvider%2A>-Methode ermöglicht es Ihnen, eine von <xref:System.Text.EncodingProvider> abgeleitete Klasse zu registrieren, die Zeichen Codierungen auf einer Plattform zur Verfügung stellt, von der Sie andernfalls nicht unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1846">The <xref:System.Text.Encoding.RegisterProvider%2A> method allows you to register a class derived from <xref:System.Text.EncodingProvider> that makes character encodings available on a platform that does not otherwise support them.</span></span> <span data-ttu-id="1959a-1847">Nachdem der Codierungs Anbieter registriert wurde, können die Codierungen, die er unterstützt, durch Aufrufen beliebiger <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> Überladungen abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1847">Once the encoding provider is registered, the encodings that it supports can be retrieved by calling any <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> overload.</span></span> <span data-ttu-id="1959a-1848">Wenn mehrere Codierungs Anbieter vorhanden sind, versucht die <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> Methode, eine angegebene Codierung von jedem Anbieter abzurufen, beginnend mit dem zuletzt registrierten.</span><span class="sxs-lookup"><span data-stu-id="1959a-1848">If there are multiple encoding providers, the <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> method attempts to retrieve a specified encoding from each provider starting with the one most recently registered.</span></span>

<span data-ttu-id="1959a-1849">Durch das Registrieren eines Codierungs Anbieters mithilfe der <xref:System.Text.Encoding.RegisterProvider%2A>-Methode wird auch das Verhalten der Methoden [Encoding. GetEncoding (Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) und [encodingprovider. GetEncoding (Int32, EncoderFallback, DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) geändert, wenn ein Argument von `0`übermittelt wird:</span><span class="sxs-lookup"><span data-stu-id="1959a-1849">Registering an encoding provider by using the <xref:System.Text.Encoding.RegisterProvider%2A> method also modifies the behavior of the [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) and [EncodingProvider.GetEncoding(Int32, EncoderFallback, DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) methods when passed an argument of `0`:</span></span>

- <span data-ttu-id="1959a-1850">Wenn der registrierte Anbieter die <xref:System.Text.CodePagesEncodingProvider>ist, gibt die Methode die Codierung zurück, die mit der aktiven System Codepage übereinstimmt, wenn Sie unter dem Windows-Betriebssystem ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1850">If the registered provider is the <xref:System.Text.CodePagesEncodingProvider>, the method returns the encoding that matches the system active code page when running on the Windows operating system.</span></span>

- <span data-ttu-id="1959a-1851">Ein benutzerdefinierter Codierungs Anbieter kann auswählen, welche Codierung zurückgegeben werden soll, wenn einer dieser <xref:System.Text.Encoding.GetEncoding%2A> Methoden Überladungen ein Argument von `0`übertragen wird.</span><span class="sxs-lookup"><span data-stu-id="1959a-1851">A custom encoding provider can choose which encoding to return when either of these <xref:System.Text.Encoding.GetEncoding%2A> method overloads is passed an argument of `0`.</span></span> <span data-ttu-id="1959a-1852">Der Anbieter kann auch auswählen, dass keine Codierung zurückgegeben wird, wenn die <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType>-Methode `null`zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1852">The provider can also choose to not return an encoding by having the <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> method return `null`.</span></span>

<span data-ttu-id="1959a-1853">Beginnend mit dem .NET Framework 4,6 umfasst der .NET Framework einen Codierungs Anbieter, <xref:System.Text.CodePagesEncodingProvider>, der die Codierungen verfügbar macht, die im vollständigen .NET Framework vorhanden sind, aber nicht im universelle Windows-Plattform verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="1959a-1853">Starting with the .NET Framework 4.6, the .NET Framework includes one encoding provider, <xref:System.Text.CodePagesEncodingProvider>, that makes the encodings available that are present in the full .NET Framework but are not available in the Universal Windows Platform.</span></span> <span data-ttu-id="1959a-1854">Standardmäßig unterstützt die universelle Windows-Plattform nur die Unicode-Codierungen, ASCII und Codepage 28591.</span><span class="sxs-lookup"><span data-stu-id="1959a-1854">By default, the Universal Windows Platform only supports the Unicode encodings, ASCII, and code page 28591.</span></span>

 <span data-ttu-id="1959a-1855">Wenn derselbe Codierungs Anbieter in mehreren Aufrufen der <xref:System.Text.Encoding.RegisterProvider%2A>-Methode verwendet wird, registriert nur der erste Methodenaufruf den Anbieter.</span><span class="sxs-lookup"><span data-stu-id="1959a-1855">If the same encoding provider is used in multiple calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method, only the first method call registers the provider.</span></span> <span data-ttu-id="1959a-1856">Nachfolgende Aufrufe werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1856">Subsequent calls are ignored.</span></span>

 <span data-ttu-id="1959a-1857">Wenn die <xref:System.Text.Encoding.RegisterProvider%2A>-Methode aufgerufen wird, um mehrere Anbieter zu registrieren, die dieselbe Codierung verarbeiten, wird der zuletzt registrierte Anbieter für alle Codierungs-und Decodierungs Vorgänge verwendet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1857">If the <xref:System.Text.Encoding.RegisterProvider%2A> method is called to register multiple providers that handle the same encoding, the last registered provider is the used for all encoding and decoding operations.</span></span> <span data-ttu-id="1959a-1858">Alle zuvor registrierten Anbieter werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1858">Any previously registered providers are ignored.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1959a-1859"><paramref name="provider" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1859"><paramref name="provider" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-1860">Ruft eine Codierung für das UTF-16-Format in der Little-Endian-Bytereihenfolge ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-1860">Gets an encoding for the UTF-16 format using the little endian byte order.</span></span></summary>
        <value><span data-ttu-id="1959a-1861">Eine Codierung für das UTF-16-Format mit Little-Endian-Bytereihenfolge.</span><span class="sxs-lookup"><span data-stu-id="1959a-1861">An encoding for the UTF-16 format using the little endian byte order.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1862">Informationen zu den von .NET unterstützten Codierungen und eine Erörterung der zu verwendenden Unicode-Codierung finden Sie unter [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="1959a-1862">For information about the encodings supported by the .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>

 <span data-ttu-id="1959a-1863">Das <xref:System.Text.UnicodeEncoding> Objekt, das von dieser Eigenschaft zurückgegeben wird, verfügt möglicherweise nicht über das entsprechende Verhalten für Ihre APP.</span><span class="sxs-lookup"><span data-stu-id="1959a-1863">The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="1959a-1864">Er verwendet einen Ersatz Fall Back, um jede Zeichenfolge zu ersetzen, die nicht codiert werden kann, und jedes Byte, das nicht mit einem Fragezeichen ("?") decodiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1864">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="1959a-1865">Stattdessen können Sie den <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>-Konstruktor zum Instanziieren eines kleinen Enumeration<xref:System.Text.UnicodeEncoding> Objekts, dessen Fall Back entweder <xref:System.Text.EncoderFallbackException> oder <xref:System.Text.DecoderFallbackException>ist, wie im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="1959a-1865">Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a little endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>

 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]



## Examples
 <span data-ttu-id="1959a-1866">Im folgenden Beispiel wird die Anzahl der Bytes bestimmt, die zum Codieren eines Zeichen Arrays erforderlich sind, die Zeichen codiert und die resultierenden Bytes angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1866">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1959a-1867">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1959a-1867">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-1868">Ruft eine Codierung für das UTF-32-Format in der Little-Endian-Bytereihenfolge ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-1868">Gets an encoding for the UTF-32 format using the little endian byte order.</span></span></summary>
        <value><span data-ttu-id="1959a-1869">Ein Codierungsobjekt für das UTF-32-Format mit Little-Endian-Bytereihenfolge.</span><span class="sxs-lookup"><span data-stu-id="1959a-1869">An  encoding object for the UTF-32 format using the little endian byte order.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1870">Das <xref:System.Text.UTF32Encoding> Objekt, das von dieser Eigenschaft zurückgegeben wird, verfügt möglicherweise nicht über das entsprechende Verhalten für Ihre APP.</span><span class="sxs-lookup"><span data-stu-id="1959a-1870">The <xref:System.Text.UTF32Encoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="1959a-1871">Er verwendet einen Ersatz Fall Back, um jede Zeichenfolge zu ersetzen, die nicht codiert werden kann, und jedes Byte, das nicht mit dem Unicode-Ersetzungs Zeichen (U + FFFE) decodiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1871">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with the Unicode REPLACEMENT CHARACTER (U+FFFE).</span></span> <span data-ttu-id="1959a-1872">Stattdessen können Sie den <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>-Konstruktor aufzurufen, um ein <xref:System.Text.UTF32Encoding> Objekt zu instanziieren, dessen Fall Back entweder eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>ist, wie im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="1959a-1872">Instead, you can call the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.UTF32Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>

 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]

 <span data-ttu-id="1959a-1873">Eine Erläuterung der Little-Endian-Byte Reihenfolge finden Sie im Thema <xref:System.Text.Encoding>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1959a-1873">For a discussion of little endian byte order, see the <xref:System.Text.Encoding> class topic.</span></span>

 <span data-ttu-id="1959a-1874">Weitere Informationen zu den von .NET unterstützten Codierungen und eine Erörterung der zu verwendenden Unicode-Codierung finden Sie unter [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="1959a-1874">For information about the encodings supported by .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>



## Examples
 <span data-ttu-id="1959a-1875">Im folgenden Beispiel wird die Anzahl der Bytes bestimmt, die zum Codieren eines Zeichen Arrays erforderlich sind, die Zeichen codiert und die resultierenden Bytes angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1875">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1959a-1876">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1959a-1876">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-1877">Ruft eine Codierung für das UTF-7-Format ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-1877">Gets an encoding for the UTF-7 format.</span></span></summary>
        <value><span data-ttu-id="1959a-1878">Eine Codierung für das UTF-7-Format.</span><span class="sxs-lookup"><span data-stu-id="1959a-1878">An encoding for the UTF-7 format.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1879">UTF-7-Codierung wird hauptsächlich in Umgebungen verwendet, die in der Vergangenheit auf 7 Bits beschränkt waren, wie z. b. NNTP und einige e-Mail-Anwendungen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1879">UTF-7 encoding is used primarily in environments that historically have been restricted to 7 bits, such as NNTP and some email applications.</span></span> <span data-ttu-id="1959a-1880">Aufgrund von Problemen mit Stabilität und Sicherheit sollten Sie UTF7 Encoding nicht in 8-Bit-Umgebungen verwenden, in denen stattdessen UTF-8-Codierung verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1880">Because of issues with robustness and security, you should not use UTF7 encoding in 8-bit environments where UTF-8 encoding can be used instead.</span></span>



## Examples
 <span data-ttu-id="1959a-1881">Im folgenden Beispiel wird die Anzahl der Bytes bestimmt, die zum Codieren eines Zeichen Arrays erforderlich sind, die Zeichen codiert und die resultierenden Bytes angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1881">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1959a-1882">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1959a-1882">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-1883">Ruft eine Codierung für das UTF-8-Format ab.</span><span class="sxs-lookup"><span data-stu-id="1959a-1883">Gets an encoding for the UTF-8 format.</span></span></summary>
        <value><span data-ttu-id="1959a-1884">Eine Codierung für das UTF-8-Format.</span><span class="sxs-lookup"><span data-stu-id="1959a-1884">An encoding for the UTF-8 format.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1885">Diese Eigenschaft gibt ein <xref:System.Text.UTF8Encoding> Objekt zurück, das Unicode-Zeichen (UTF-16-codierte Zeichen) in eine Sequenz von einem bis vier Bytes pro Zeichen codiert und ein UTF-8-codiertes Bytearray in Unicode-Zeichen (UTF-16-codiert) decodiert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1885">This property returns a <xref:System.Text.UTF8Encoding> object that encodes Unicode (UTF-16-encoded) characters into a sequence of one to four bytes per character, and that decodes a UTF-8-encoded byte array to Unicode (UTF-16-encoded) characters.</span></span> <span data-ttu-id="1959a-1886">Informationen zu den von .NET unterstützten Zeichen Codierungen und eine Erörterung der zu verwendenden Unicode-Codierung finden Sie unter [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="1959a-1886">For information about the character encodings supported by .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>

 <span data-ttu-id="1959a-1887">Das <xref:System.Text.UTF8Encoding> Objekt, das von dieser Eigenschaft zurückgegeben wird, verfügt möglicherweise nicht über das entsprechende Verhalten für Ihre APP.</span><span class="sxs-lookup"><span data-stu-id="1959a-1887">The <xref:System.Text.UTF8Encoding> object that is returned by this property might not have the appropriate behavior for your app.</span></span>

-   <span data-ttu-id="1959a-1888">Es gibt ein <xref:System.Text.UTF8Encoding> Objekt zurück, das eine Unicode-Byte Reihenfolge Markierung (BOM) bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1888">It returns a <xref:System.Text.UTF8Encoding> object that provides a Unicode byte order mark (BOM).</span></span> <span data-ttu-id="1959a-1889">Um eine UTF8-Codierung zu instanziieren, die keine BOM bereitstellt, müssen Sie eine beliebige Überladung des <xref:System.Text.UTF8Encoding.%23ctor%2A> Konstruktors aufrufen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1889">To instantiate a UTF8 encoding that doesn't provide a BOM, call any overload of the <xref:System.Text.UTF8Encoding.%23ctor%2A> constructor.</span></span>

-   <span data-ttu-id="1959a-1890">Es gibt ein <xref:System.Text.UTF8Encoding> Objekt zurück, das den Ersatz Fall Back verwendet, um jede Zeichenfolge zu ersetzen, die nicht codiert werden kann, und jedes Byte, das nicht mit einem Fragezeichen ("?") decodiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="1959a-1890">It returns a <xref:System.Text.UTF8Encoding> object that uses replacement fallback to replace each string that it can't encode and each byte that it can't decode with a question mark ("?") character.</span></span> <span data-ttu-id="1959a-1891">Stattdessen können Sie den <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>-Konstruktor aufzurufen, um ein <xref:System.Text.UTF8Encoding> Objekt zu instanziieren, dessen Fall Back entweder eine <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>ist, wie im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="1959a-1891">Instead, you can call the <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.UTF8Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>

     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]



## Examples
 <span data-ttu-id="1959a-1892">Im folgenden Beispiel wird ein Array definiert, das aus den folgenden Zeichen besteht:</span><span class="sxs-lookup"><span data-stu-id="1959a-1892">The following example defines an array that consists of the following characters:</span></span>

-   <span data-ttu-id="1959a-1893">Latin Small Letter Z (U + 007A)</span><span class="sxs-lookup"><span data-stu-id="1959a-1893">LATIN SMALL LETTER Z (U+007A)</span></span>

-   <span data-ttu-id="1959a-1894">Lateinisch Kleinbuchstabe A (U + 0061)</span><span class="sxs-lookup"><span data-stu-id="1959a-1894">LATIN SMALL LETTER A (U+0061)</span></span>

-   <span data-ttu-id="1959a-1895">Kombinieren von Breve (U + 0306)</span><span class="sxs-lookup"><span data-stu-id="1959a-1895">COMBINING BREVE (U+0306)</span></span>

-   <span data-ttu-id="1959a-1896">Lateinisch kleiner Buchstabe Ae mit akut (U + 01fd)</span><span class="sxs-lookup"><span data-stu-id="1959a-1896">LATIN SMALL LETTER AE WITH ACUTE (U+01FD)</span></span>

-   <span data-ttu-id="1959a-1897">Griechisch Small Letter Beta (U + 03b2)</span><span class="sxs-lookup"><span data-stu-id="1959a-1897">GREEK SMALL LETTER BETA (U+03B2)</span></span>

-   <span data-ttu-id="1959a-1898">Ein Ersatz Zeichenpaar (u + D800 und u + DD54), das griechisch-acrophonische Dachboden 1000-Status (u + 10154) bildet.</span><span class="sxs-lookup"><span data-stu-id="1959a-1898">A surrogate pair (U+D800 U+DD54) that forms GREEK ACROPHONIC ATTIC ONE THOUSAND STATERS (U+10154).</span></span>

 <span data-ttu-id="1959a-1899">Es zeigt die UTF-16-Code Einheiten der einzelnen Zeichen an und bestimmt die Anzahl von Bytes, die von einem UTF-8-Encoder zum Codieren des Zeichen Arrays benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1899">It displays the UTF-16 code units of each character and determines the number of bytes required by a UTF-8 encoder to encode the character array.</span></span> <span data-ttu-id="1959a-1900">Anschließend werden die Zeichen codiert und die resultierenden UTF-8-codierten Bytes angezeigt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1900">It then encodes the characters and displays the resulting UTF-8-encoded bytes.</span></span>

 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1959a-1901">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1959a-1901">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-1902">Beim Überschreiben in einer abgeleiteten Klasse wird der Name für die aktuelle Codierung bei der Internet Assigned Numbers Authority (IANA) registriert.</span><span class="sxs-lookup"><span data-stu-id="1959a-1902">When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.</span></span></summary>
        <value><span data-ttu-id="1959a-1903">Der IANA-Name für die aktuelle <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="1959a-1903">The IANA name for the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1904">Die <xref:System.Text.Encoding.WebName%2A>-Eigenschaft ist identisch mit der <xref:System.Text.EncodingInfo.Name%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="1959a-1904">The <xref:System.Text.Encoding.WebName%2A> property is the same as the <xref:System.Text.EncodingInfo.Name%2A> property.</span></span>

 <span data-ttu-id="1959a-1905">Beachten Sie, dass <xref:System.Text.Encoding.WebName%2A> einen IANA-registrierten Namen für die Codierung zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="1959a-1905">Note that <xref:System.Text.Encoding.WebName%2A> returns an IANA-registered name for the encoding.</span></span> <span data-ttu-id="1959a-1906">Wenn der Wert dem Namen eines Standards entspricht, entspricht die Implementierung der Codierung möglicherweise nicht vollständig dem Standard.</span><span class="sxs-lookup"><span data-stu-id="1959a-1906">When its value is the name of a standard, the implementation of the encoding might not conform in full to that standard.</span></span> <span data-ttu-id="1959a-1907">Die <xref:System.Text.Encoding.HeaderName%2A>-Eigenschaft definiert eine andere Codierung, die für e-Mail-Header besser geeignet ist.</span><span class="sxs-lookup"><span data-stu-id="1959a-1907">The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for email headers.</span></span> <span data-ttu-id="1959a-1908">Allerdings sollten die meisten apps stattdessen <xref:System.Text.Encoding.WebName%2A> verwenden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1908">However, most apps should use <xref:System.Text.Encoding.WebName%2A> instead.</span></span>

 <span data-ttu-id="1959a-1909">Weitere Informationen zu IANA finden Sie unter [www.iana.org](https://www.iana.org/).</span><span class="sxs-lookup"><span data-stu-id="1959a-1909">For more information on the IANA, go to [www.iana.org](https://www.iana.org/).</span></span>

 <span data-ttu-id="1959a-1910">Der <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> ist identisch mit dem von <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>zurückgegebenen <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1910">The <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> is the same as the <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> returned by <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1959a-1911">Einige Webnamen sind Duplikate. Weitere Informationen finden Sie in den Hinweisen zum <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1959a-1911">Some of the web names are duplicates; see the remarks for <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> for more information.</span></span>



## Examples
 <span data-ttu-id="1959a-1912">Das folgende Beispiel schließt die <xref:System.Text.Encoding.WebName%2A> in einen HTML-Header ein.</span><span class="sxs-lookup"><span data-stu-id="1959a-1912">The following example includes the <xref:System.Text.Encoding.WebName%2A> in an HTML header.</span></span>

 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]

 <span data-ttu-id="1959a-1913">Im folgenden Beispiel werden die anderen Namen für die einzelnen Codierungen abgerufen und die Codierungen mit einem oder mehreren Namen angezeigt, die sich von <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="1959a-1913">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1959a-1914">Es wird <xref:System.Text.Encoding.EncodingName%2A> angezeigt, aber nicht mit diesem verglichen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1914">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1959a-1915">Beim Überschreiben in einer abgeleiteten Klasse wird die Codepage des Betriebssystems Windows abgerufen, die der aktuellen Codierung am ehesten entspricht.</span><span class="sxs-lookup"><span data-stu-id="1959a-1915">When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.</span></span></summary>
        <value><span data-ttu-id="1959a-1916">Die Codepage des Betriebssystems Windows, die der aktuellen <see cref="T:System.Text.Encoding" /> am ehesten entspricht.</span><span class="sxs-lookup"><span data-stu-id="1959a-1916">The Windows operating system code page that most closely corresponds to the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="1959a-1917">Diese Eigenschaft wird aus Gründen der Kompatibilität mit den MLang-APIs (Windows Multilanguage) bereitgestellt, z. b. beim Bestimmen von Schriftfamilien.</span><span class="sxs-lookup"><span data-stu-id="1959a-1917">This property is provided for compatibility with the Windows MultiLanguage (MLang) APIs, for example, in determining font families.</span></span> <span data-ttu-id="1959a-1918">Bei der Globalisierung wird stattdessen die Verwendung einer der Unicode-Codierungen empfohlen.</span><span class="sxs-lookup"><span data-stu-id="1959a-1918">For globalization, using one of the Unicode encodings is recommended instead.</span></span> <span data-ttu-id="1959a-1919">Außerdem wird empfohlen, anstelle von <xref:System.Text.Encoding.WindowsCodePage%2A> <xref:System.Text.Encoding.WebName%2A> zu verwenden, um die Codepage zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="1959a-1919">It is also recommended to use <xref:System.Text.Encoding.WebName%2A> instead of <xref:System.Text.Encoding.WindowsCodePage%2A> to identify the code page.</span></span>



## Examples
 <span data-ttu-id="1959a-1920">Im folgenden Beispiel wird die Windows-Codepage festgelegt, die den einzelnen Codierungen am ehesten entspricht.</span><span class="sxs-lookup"><span data-stu-id="1959a-1920">The following example determines the Windows code page that most closely corresponds to each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>
