<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="95471ea1cd06b4d172c2cb1dbaa217926e96a39f" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52246110" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Zeichencodierung dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Kodieren werden Unicode-Zeichen in eine Bytefolge transformiert. Im Gegensatz dazu ist die Decodierung transformiert eine codierte Bytefolge in eine Reihe von Unicode-Zeichen. Informationen zu Unicode Transformation Format (UTFs) und andere Codierungen, die von unterstützt <xref:System.Text.Encoding>, finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md).  
  
 Beachten Sie, dass <xref:System.Text.Encoding> für Unicode-Zeichen anstelle von beliebigen Binärdaten, z. B. Byte-Arrays verwendet werden soll. Wenn Sie beliebige binäre Daten in Text codiert werden müssen, verwenden Sie ein Protokoll wie Uuencode, die von Methoden, wie z. B. implementiert wird <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Bietet die folgenden Implementierungen von .NET die <xref:System.Text.Encoding> Klasse, um die aktuellen Unicode-Codierungen und andere Codierungen zu unterstützen:  
  
-   <xref:System.Text.ASCIIEncoding> Unicode-Zeichen werden als einzelne 7-Bit-ASCII-Zeichen codiert. Diese Codierung unterstützt nur Zeichenwerte zwischen U + 0000 und U + 007F. -Codepage 20127. Auch verfügbar durch die <xref:System.Text.Encoding.ASCII%2A> Eigenschaft.  
  
-   <xref:System.Text.UTF7Encoding> Unicode-Zeichen, die unter Verwendung der UTF-7-Codierung codiert. Diese Codierung unterstützt alle Unicode-Zeichenwerte. -Codepage 65000. Auch verfügbar durch die <xref:System.Text.Encoding.UTF7%2A> Eigenschaft.  
  
-   <xref:System.Text.UTF8Encoding> Unicode-Zeichen, die unter Verwendung der UTF-8-Codierung codiert. Diese Codierung unterstützt alle Unicode-Zeichenwerte. -Codepage 65001. Auch verfügbar durch die <xref:System.Text.Encoding.UTF8%2A> Eigenschaft.  
  
-   <xref:System.Text.UnicodeEncoding> Unicode-Zeichen, die unter Verwendung der UTF-16-Codierung codiert. Sowohl little endian und big-endian-Byte-Aufträge werden unterstützt. Auch verfügbar durch die <xref:System.Text.Encoding.Unicode%2A> Eigenschaft und die <xref:System.Text.Encoding.BigEndianUnicode%2A> Eigenschaft.  
  
-   <xref:System.Text.UTF32Encoding> Unicode-Zeichen, die unter Verwendung der UTF-32-Codierung codiert. Sowohl little Endian (Codepage 12000) und big-Endian (Codepage 12001) Aufträge werden unterstützt. Auch verfügbar durch die <xref:System.Text.Encoding.UTF32%2A> Eigenschaft.  
  
 Die <xref:System.Text.Encoding> Klasse dient in erster Linie zum Konvertieren zwischen verschiedenen Codierungen und Unicode. Häufig ist eine der abgeleiteten Klassen Unicode die richtige Wahl für Ihre app.  
  
 Verwenden der <xref:System.Text.Encoding.GetEncoding%2A> Methode, um andere Codierungen, abzurufen, und rufen Sie die <xref:System.Text.Encoding.GetEncodings%2A> Methode, um eine Liste mit allen Codierungen zu erhalten.  
  
 Die folgende Tabelle enthält die Codierungen, die von .NET Framework und .NET Core unterstützt werden. Jede Codierung Codepagenummer und die Werte der Codierung des aufgeführt <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> und <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> Eigenschaften. Ein Häkchen in der **.NET Framework-Unterstützung** und **Unterstützung für .NET Core** Spalten gibt an, dass die Codepage von dieser Implementierung von .NET ist unabhängig von der zugrunde liegenden Plattform nativ unterstützt wird. Für .NET Framework hängt das Betriebssystem die Verfügbarkeit der anderen Codierungen, die in der Tabelle aufgeführt. Für .NET Core, sind andere Codierungen sind verfügbar unter Verwendung der <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> Klasse oder durch Ableiten von der <xref:System.Text.EncodingProvider?displayProperty=nameWithType> Klasse.  

> [!NOTE]
> Codepages, deren <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> -Eigenschaft entspricht einem internationalen Standard nicht notwendigerweise vollständig mit diesem Standard entsprechen. 

|Codepage|name|Angezeigter Name|.NET Framework-Unterstützung| .NET Core-Unterstützung | 
|---------|----|------------|----------------------|-------------------|    
|37|IBM037|IBM EBCDIC (USA-Kanada)|||  
|437|IBM437|OEM-USA|||  
|500|IBM500|IBM EBCDIC (International)|||  
|708|ASMO-708|Arabisch (ASMO 708)|||  
|720|DOS-720|Arabisch (DOS)|||  
|737|ibm737|Griechisch (DOS)|||  
|775|ibm775|Baltisch (DOS)|||  
|850|ibm850|Westeuropäisch (DOS)|||  
|852|ibm852|Mitteleuropäisch (DOS)|||  
|855|IBM855|OEM-Kyrillisch|||  
|857|ibm857|Türkisch (DOS)|||  
|858|IBM00858|OEM Multilingual Lateinisch I|||  
|860|IBM860|Portugiesisch (DOS)|||  
|861|ibm861|Isländisch (DOS)|||  
|862|DOS-862|Hebräisch (DOS)|||  
|863|IBM863|Französisch-Kanada (DOS)|||  
|864|IBM864|Arabisch (864)|||  
|865|IBM865|Nordisch (DOS)|||  
|866|cp866|Cyrilice (DOS)|||  
|869|ibm869|Griechisch, Modern (DOS)|||  
|870|IBM870|IBM EBCDIC (Multilingual Lateinisch-2)|||  
|874|windows-874|Thailändisch (Windows)|||  
|875|cp875|IBM EBCDIC (Griechisch, Modern)|||  
|932|Shift_jis|Japanisch (Shift-JIS)|||  
|936|gb2312|Chinesisch vereinfacht (GB2312)|✓||  
|949|ks_c_5601-1987|Koreanisch|||  
|950|Big5|Chinesisch traditionell (Big5)|||  
|1026|IBM1026|IBM EBCDIC (Türkisch, Lateinisch-5)|||  
|1047|IBM01047|IBM Latin 1|||  
|1140|IBM01140|IBM EBCDIC (USA-Kanada-Euro)|||  
|1141|IBM01141|IBM EBCDIC (Deutschland-Euro)|||  
|1142|IBM01142|IBM EBCDIC (Dänemark-Norwegen-Euro)|||  
|1143|IBM01143|IBM EBCDIC (Finnland-Schweden-Euro)|||  
|1144|IBM01144|IBM EBCDIC (Italien-Euro)|||  
|1145|IBM01145|IBM EBCDIC (Spanien-Euro)|||  
|1146|IBM01146|IBM EBCDIC (Vereinigtes Königreich-Euro)|||  
|1147|IBM01147|IBM EBCDIC (Francie-Euro)|||  
|1148|IBM01148|IBM EBCDIC (International-Euro)|||  
|1149|IBM01149|IBM EBCDIC (Island-Euro)|||  
|1200|UTF-16|Unicode|✓|✓|  
|1201|unicodeFFFE|Unicode (Big Endian)|✓|✓|  
|1250|windows-1250|Mitteleuropäisch (Windows)|||  
|1251|windows-1251|Kyrillisch (Windows)|||  
|1252|Windows-1252|Westeuropäisch (Windows)|✓||  
|1253|windows-1253|Griechisch (Windows)|||  
|1254|windows-1254|Türkisch (Windows)|||  
|1255|windows-1255|Hebräisch (Windows)|||  
|1256|windows-1256|Arabisch (Windows)|||  
|1257|windows-1257|Baltisch (Windows)|||  
|1258|windows-1258|Vietnamesisch (Windows)|||  
|1361|Johab|Koreanisch (Johab)|||  
|10000|Macintosh|Westeuropäisch (Mac)|||  
|10001|X – Mac – Japanisch|Japanisch (Mac)|||  
|10002|X-Mac-Chinesisch (traditionell)|Chinesisch traditionell (Mac)|||  
|10003|X – Mac – Koreanisch|Koreanisch (Mac)|✓||  
|10004|X-Mac-Arabisch|Arabisch (Mac)|||  
|10005|X-Mac-Hebräisch|Hebräisch (Mac)|||  
|10006|X-Mac-Griechisch|Griechisch (Mac)|||  
|10007|X-Mac-Kyrillisch|Cyrilice (Mac)|||  
|10008|X-Mac-chinesesimp|Chinesisch vereinfacht (Mac)|✓||  
|10010|X-Mac-Rumänisch|Rumänisch (Mac)|||  
|10017|X / Mac-Ukrainisch|Ukrainisch (Mac)|||  
|10021|X-Mac-thai|Thailändisch (Mac)|||  
|10029|X-Mac-ce|Mitteleuropäisch (Mac)|||  
|10079|X-Mac-Isländisch|Isländisch (Mac)|||  
|10081|X-Mac-Türkisch|Türkisch (Mac)|||  
|10082|X-Mac-Kroatisch|Kroatisch (Mac)|||  
|12000|UTF-32|Unicode (UTF-32)|✓|✓|  
|12001|UTF-32BE|Unicode (UTF-32 Big Endian)|✓|✓|  
|20000|X-Chinesisch-CNS|Chinesisch traditionell (CNS)|||  
|20001|x-cp20001|-WAN TCA|||  
|20002|X-Chinesisch-Eten|Chinesisch traditionell (Eten)|||  
|20003|x-cp20003|IBM5550 Taiwan|||  
|20004|x-cp20004|-WAN Teletext|||  
|20005|x-cp20005|Tchaj-WAN|||  
|20105|x-IA5|Westeuropäisch (IA5)|||  
|20106|x-IA5-German|Deutsch (IA5)|||  
|20107|X-IA5-Schwedisch|Schwedisch (IA5)|||  
|20108|X-IA5-Norwegisch|Norwegisch (IA5)|||  
|20127|us-ascii|US-ASCII|✓|✓|  
|20261|x-cp20261|T.61|||  
|20269|x-cp20269|ISO-6937|||  
|20273|IBM273|IBM EBCDIC (Deutschland)|||  
|20277|IBM277|IBM EBCDIC (Dänemark-Norwegen)|||  
|20278|IBM278|IBM EBCDIC (Finnland-Schweden)|||  
|20280|IBM280|IBM EBCDIC (Italien)|||  
|20284|IBM284|IBM EBCDIC (Spanien)|||  
|20285|IBM285|IBM EBCDIC (UK)|||  
|20290|IBM290|IBM EBCDIC (Japonsko-Katakana)|||  
|20297|IBM297|IBM EBCDIC (Francie)|||  
|20420|IBM420|IBM EBCDIC (Arabisch)|||  
|20423|IBM423|IBM EBCDIC (Griechisch)|||  
|20424|IBM424|IBM EBCDIC (Hebräisch)|||  
|20833|X-EBCDIC-KoreanExtended|IBM EBCDIC (Koreanisch, erweitert)|||  
|20838|IBM-Thai|IBM EBCDIC (Thailändisch)|||  
|20866|KOI8-r|Kyrillisch (KOI8-R)|||  
|20871|IBM871|IBM EBCDIC (Isländisch)|||  
|20880|IBM880|IBM EBCDIC (Kyrillisch, Russisch)|||  
|20905|IBM905|IBM EBCDIC (Türkisch)|||  
|20924|IBM00924|IBM Latin 1|||  
|20932|EUC-JP|Japanisch (JIS 0208-1990 und 0212-1990)|||  
|20936|x-cp20936|Chinesisch vereinfacht (GB2312-80)|✓||  
|20949|x-cp20949|Koreanisch Wansung|✓||  
|21025|cp1025|IBM EBCDIC (Kyrillisch, Serbisch-Bulgarisch)|||  
|21866|KOI8-u|Kyrillisch (KOI8-U)|||  
|28591|iso-8859-1|Westeuropäisch (ISO)|✓|✓|  
|28592|iso-8859-2|Mitteleuropäisch (ISO)|||  
|28593|iso-8859-3|Lateinisch-3 (ISO)|||  
|28594|iso-8859-4|Baltisch (ISO)|||  
|28595|iso-8859-5|Cyrilice (ISO)|||  
|28596|iso-8859-6|Arabisch (ISO)|||  
|28597|iso-8859-7|Griechisch (ISO)|||  
|28598|iso-8859-8|Hebräisch (ISO visuell)|✓||  
|28599|iso-8859-9|Türkisch (ISO)|||  
|28603|iso-8859-13|Estnisch (ISO)|||  
|28605|iso-8859-15|Lateinisch 9 (ISO)|||  
|29001|X-Europa|Europa|||  
|38598|iso-8859-8-i|Hebräisch (ISO logisch)|✓||  
|50220|ISO-2022-jp|Japanisch (JIS)|✓||  
|50221|csISO2022JP|Japanisch (JIS-1 Byte Kana erlaubt)|✓||  
|50222|ISO-2022-jp|Japanisch (JIS, 1 Byte erlaubt Kana - SO / SI)|✓||  
|50225|ISO-2022-kr|Koreanisch (ISO)|✓||  
|50227|x-cp50227|Chinesisch vereinfacht (ISO-2022)|✓||  
|51932|EUC-jp|Japanisch (EUC)|✓||  
|51936|EUC-CN|Chinesisch vereinfacht (EUC)|✓||  
|51949|EUC-kr|Koreanisch (EUC)|✓||  
|52936|Hz-gb-2312|Chinesisch vereinfacht (HZ)|✓||  
|54936|GB18030|Chinesisch vereinfacht (GB18030)|✓||  
|57002|X-Iscii – de|ISCII Devanagari|✓||  
|57003|X-Iscii-be|ISCII Bangla|✓||  
|57004|x-iscii-ta|ISCII Tamil|✓||  
|57005|X-Iscii-te|ISCII Telugu|✓||  
|57006|X-Iscii als|ISCII Assamesisch|✓||  
|57007|X-Iscii-oder|ISCII Oriya|✓||  
|57008|X-Iscii-ka|ISCII Kannada|✓||  
|57009|X-Iscii-ma|ISCII Malayalam|✓||  
|57010|X-Iscii-gu|ISCII Gujarati|✓||  
|57011|X-Iscii-pa|ISCII Punjabi|✓||  
|65000|UTF-7|Unicode (UTF-7)|✓|✓|  
|65001|UTF-8|Unicode (UTF-8)|✓|✓|  
  
 Im folgenden Beispiel wird die <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> und <xref:System.Text.Encoding.GetEncoding%28System.String%29> Methoden zum Abrufen der Griechisch (Windows) code Systemcodeseiten-Codierung. Es vergleicht die <xref:System.Text.Encoding> die Methodenaufrufe an, dass sie gleich sind, und klicken Sie dann Zuordnungen zeigt den Unicode-Codepunkt und die entsprechende Codepage-Wert für jedes Zeichen im griechischen Alphabet zurückgegebener Objekte.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass er in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen die <xref:System.Text.Encoding.GetDecoder%2A> Methode oder der <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die UTF-16 und UTF-32-Encoder verwenden, können die big-endian-Bytereihenfolge (höchstwertigen Byte zuerst) oder little-endian-Bytereihenfolge (am wenigsten signifikanten Byte zuerst). Zum Beispiel folgt die Latin Capital Letter (U + 0041) als serialisiert wird (hexadezimal):  
  
-   UTF-16 big-endian-Bytereihenfolge: 00 41  
  
-   UTF-16 little-endian-Bytereihenfolge: 41 00  
  
-   UTF-32 big-endian-Bytereihenfolge: 00 00 00 41  
  
-   UTF-32 little-endian-Bytereihenfolge: 41 00 00 00  
  
 Es ist in der Regel effizienter, Unicode-Zeichen mit der systemeigenen Bytereihenfolge speichern. Beispielsweise ist es besser, die die little-endian-Bytereihenfolge in little-endian-Plattformen wie Intel Computer verwenden.  
  
 Die <xref:System.Text.Encoding.GetPreamble%2A> Methode ruft ein Array von Bytes, die der Bytereihenfolge-Marke (BOM) enthält. Wenn dieses Bytearray in einen codierten Datenstrom vorangestellt ist, unterstützt sie der Decoder das Codierungsformat zu identifizieren.  
  
 Weitere Informationen zu Byte-Reihenfolge und die Bytereihenfolge-Marke, finden Sie im Unicode-Standard auf die [Unicode-Homepage](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Beachten Sie, dass die Codierungsklassen Fehler an:  
  
-   Ändern Sie im Hintergrund in ein "?" Zeichen.  
  
-   Verwenden Sie ein Zeichen "best fit".  
  
-   Ändern Sie auf ein anwendungsspezifisches Verhalten durch die Verwendung von der <xref:System.Text.EncoderFallback> und <xref:System.Text.DecoderFallback> Klassen mit dem U + FFFD Unicode-Ersatzzeichen.  
  
 Sie sollten eine Ausnahme bei jedem Data Stream-Fehler auslösen. Eine app wird mit einem "Throwonerror"-Flag bei Bedarf oder verwendet den <xref:System.Text.EncoderExceptionFallback> und <xref:System.Text.DecoderExceptionFallback> Klassen. Beste mit ähnlichen Zeichen Fallback wird häufig nicht empfohlen, da sie dazu führen, Daten verloren gehen oder zu Verwirrung dass können und langsamer als einfaches Zeichen der Ersetzungen ist. Für ANSI-Codierungen ist die am besten geeignete Verhalten die Standardeinstellung.  
  
   
  
## Examples  
 Im folgende Beispiel konvertiert eine Zeichenfolge aus einer Codierung in einen anderen.  
  
> [!NOTE]
>  Das Byte []-Array ist der einzige Typ in diesem Beispiel, das die codierten Daten enthält. Die .NET Char und String-Typen werden selbst Unicode, sodass die <xref:System.Text.Encoding.GetChars%2A> Aufruf decodiert die Daten wieder in Unicode.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Encoding" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Encoding" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen überschreiben dieses Konstruktors.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">Der Codepagebezeichner der bevorzugten Codierung.  
  
- oder -  
0, um die Standardcodierung zu verwenden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Encoding" />-Klasse, die der angegebenen Codepage entspricht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen überschreiben dieses Konstruktors.  
  
 Aufrufe dieses Konstruktors durch eine abgeleitete Klasse erstellen eine <xref:System.Text.Encoding> Objekt, das Fallback mit ähnlichen Zeichen für sowohl Codierungs- und Decodierungsvorgänge verwendet. Sowohl die <xref:System.Text.Encoding.DecoderFallback%2A> und <xref:System.Text.Encoding.EncoderFallback%2A> Eigenschaften sind schreibgeschützt und kann nicht geändert werden. Die alternative Strategie festlegen, für eine Klasse von abgeleitet <xref:System.Text.Encoding>, rufen Sie die <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> Konstruktor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> ist kleiner als Null.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">Der Bezeichner der Codierungs-Codepage.</param>
        <param name="encoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn ein Zeichen nicht mit der aktuellen Codierung codiert werden kann.</param>
        <param name="decoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn eine Bytefolge nicht mit der aktuellen Codierung decodiert werden kann.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Encoding" />-Klasse, die der angegebenen Codepage entspricht, mit den angegebenen Fallbackstrategien für Codierer und Decodierer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ist `protected`; abgeleitete Klassen überschreiben.  
  
 Rufen Sie diesen Konstruktor, von einer abgeleiteten Klasse zum Steuern des Fallbacks codieren und Decodieren von Strategien. Die <xref:System.Text.Encoding> Klassenkonstruktoren erstellen nur-Lese encoding-Objekte, die nicht zulassen, Encoder oder Decoder fallback festgelegt werden, nachdem das Objekt erstellt wird.  
  
 Wenn entweder `encoderFallback` oder `decoderFallback` null ist, als die entsprechenden Fallbackstrategie Fallback mit ähnlichen Zeichen verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für den ASCII-Zeichensatz (7-Bit) ab.</summary>
        <value>Eine Codierung für den ASCII-Zeichensatz (7 Bits).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASCII-Zeichen sind auf die ersten 128 Unicode-Zeichen von U + 0000 bis U + 007F beschränkt.  
  
 Wenn Sie auswählen, die ASCII-Codierung für Ihre app, beachten Sie Folgendes ein:  
  
-   Die ASCII-Codierung eignet sich in der Regel für Protokolle, die ASCII erfordern.  
  
-   Wenn Sie die 8-Bit-Codierung (die manchmal fälschlicherweise als "ASCII" bezeichnet wird) erforderlich ist, die UTF-8-Codierung empfiehlt sich gegenüber der ASCII-Codierung. Für die Zeichen 0-7F sind die Ergebnisse sind identisch, aber mit UTF-8 vermeidet Daten verloren gehen, indem Sie ermöglicht die Darstellung alle Unicode-Zeichen dargestellt werden kann. Beachten Sie, dass die ASCII-Codierung ein 8-bit-Mehrdeutigkeit, die böswilligen Verwendung ermöglichen, aber die UTF-8-Codierung Mehrdeutigkeit in Bezug auf das 8. Bit entfernt.  
  
-   Zulässig, die .NET Framework vor .NET Framework, Version 2.0 spoofing durch ignorieren des 8. Bits. Ab .NET Framework 2.0 ist möglich, nicht-ASCII-Codepunkte während der Decodierung.  
  
 Die <xref:System.Text.ASCIIEncoding> -Objekt, das von dieser Eigenschaft zurückgegeben wird möglicherweise nicht das richtige Verhalten für Ihre app. Er verwendet einen Ersatzfallback, ersetzen Sie jede Zeichenfolge, die nicht codiert werden können und jedes Byte, die nicht decodiert durch ein Fragezeichen ("?") Zeichen. Stattdessen rufen Sie die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> Methode zum Instanziieren einer <xref:System.Text.ASCIIEncoding> -Objekt, dessen Fallback entweder ist, ein <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>, wie im folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Auswirkungen der ASCII-Codierung für Zeichen, die sich außerhalb des ASCII-Bereichs befinden.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für das UTF-16-Format mit Big-Endian-Bytereihenfolge ab.</summary>
        <value>Ein Codierungsobjekt für das UTF-16-Format, das die Big-Endian-Bytereihenfolge verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.UnicodeEncoding> -Objekt, das von dieser Eigenschaft zurückgegeben wird möglicherweise nicht das richtige Verhalten für Ihre app. Er verwendet einen Ersatzfallback, ersetzen Sie jede Zeichenfolge, die nicht codiert werden können und jedes Byte, die nicht decodiert durch ein Fragezeichen ("?") Zeichen. Stattdessen rufen Sie die <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor zum Instanziieren ein big-Endian <xref:System.Text.UnicodeEncoding> -Objekt, dessen Fallback entweder ist, ein <xref:System.Text.EncoderFallbackException> oder <xref:System.Text.DecoderFallbackException>, wie im folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 Das zurückgegebene <xref:System.Text.UnicodeEncoding> Objekt verfügt über <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, und <xref:System.Text.Encoding.WebName%2A> Eigenschaften, die den Namen "UnicodeFFFE" ergeben. Obwohl die UTF-16 big-endian-Bytereihenfolge-Marke hexadezimale FEFF ist, wurde der Namen "UnicodeFFFE" gewählt, weil es sich bei der Bytereihenfolge-Marke als hexadezimale FFFE in little-endian-Windows-Computer angezeigt wird.  
  
   
  
## Examples  
 Das folgende Beispiel liest eine Textdatei mit einer UTF-16-Codierung mit der big-endian-Bytereihenfolge.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Name für die aktuelle Codierung abgerufen, die mit den Body-Tags des E-Mail-Agenten verwendet werden kann.</summary>
        <value>Ein Name der aktuellen <see cref="T:System.Text.Encoding" />-Klasse, die mit den Body-Tags des E-Mail-Agenten verwendet werden kann.  
  
- oder -  
Eine leere Zeichenfolge (""), wenn das aktuelle <see cref="T:System.Text.Encoding" /> nicht verwendet werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Codierung für einen Textnamen benötigen, Sie sollten Aufrufen <xref:System.Text.Encoding.GetEncoding%2A> mit der <xref:System.Text.Encoding.BodyName%2A> Eigenschaft. Häufig die Methode ruft eine andere Codierung aus der Test-Codierung zur Verfügung gestellt, in dem Aufruf ab. Nur e-Mail-Anwendungen müssen in der Regel abrufen, diese Codierung; Die meisten anderen Anwendungen, die Beschreibung einer Codierung verwenden, sollten die <xref:System.Text.Encoding.WebName%2A>.  
  
 In einigen Fällen den Wert des der <xref:System.Text.Encoding.BodyName%2A> Eigenschaft entspricht der internationalen Norm, die diese Codierung definiert. Dies bedeutet nicht, dass die Implementierung vollständig mit diesem Standard entspricht.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die anderen Namen für jede Codierung abgerufen, und zeigt die Codierungen mit ein oder mehrere Namen, die von unterscheiden <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Es zeigt <xref:System.Text.Encoding.EncodingName%2A> jedoch nicht dafür verglichen.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt beim Überschreiben in einer abgeleiteten Klasse eine flache Kopie des aktuellen <see cref="T:System.Text.Encoding" />-Objekts.</summary>
        <returns>Eine Kopie des aktuellen <see cref="T:System.Text.Encoding" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Klon überschreibbar. selbst wenn die ursprüngliche <xref:System.Text.Encoding> Objekt ist schreibgeschützt. Aus diesem Grund können die Eigenschaften des Klons geändert werden.  
  
 Eine flache Kopie eines Objekts ist eine Kopie des Objekts nur. Wenn das Objekt Verweise auf andere Objekte enthält, erstellt der flache Kopie keine Kopien der Objekte verwiesen wird. Es verweist stattdessen auf die ursprünglichen Objekte. Im Gegensatz dazu erstellt eine tiefe Kopie eines Objekts auf, eine Kopie des Objekts und eine Kopie aller Elemente auf die dieses Objekt direkt oder indirekt verweist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Codepagebezeichner der aktuellen <see cref="T:System.Text.Encoding" />-Klasse beim Überschreiben in einer abgeleiteten Klasse ab.</summary>
        <value>Der Codepagebezeichner der aktuellen <see cref="T:System.Text.Encoding" />-Klasse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel werden die anderen Namen für jede Codierung abgerufen, und zeigt die Codierungen mit ein oder mehrere Namen, die von unterscheiden <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Es zeigt <xref:System.Text.Encoding.EncodingName%2A> jedoch nicht dafür verglichen.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert ein Bytearray aus einer Codierung in eine andere.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Das Codierungsformat von <paramref name="bytes" />.</param>
        <param name="dstEncoding">Das Zielcodierungsformat.</param>
        <param name="bytes">Die zu konvertierenden Bytes.</param>
        <summary>Konvertiert ein vollständiges Bytearray aus einer Codierung in eine andere.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Byte" />, das die Ergebnisse der Konvertierung in <paramref name="bytes" /> von <paramref name="srcEncoding" /> in <paramref name="dstEncoding" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel konvertiert eine Unicode-codierte Zeichenfolge in eine ASCII-codierte Zeichenfolge. Da das ASCII-Codierung von Objekt zurückgegebene der <xref:System.Text.Encoding.ASCII%2A> Eigenschaft verwendet einen Ersatzfallback und das Pi-Zeichen ist nicht Teil der ASCII-Zeichensatz, das Pi-Zeichen wird durch ein Fragezeichen ersetzt, wie die Ausgabe des Beispiels zeigt.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="dstEncoding" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 **srcEncoding.** Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 **dstEncoding.** Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Die Codierung des Quellarrays, <paramref name="bytes" />.</param>
        <param name="dstEncoding">Die Codierung des Ausgabearrays.</param>
        <param name="bytes">Das zu konvertierende Bytearray.</param>
        <param name="index">Der Index des ersten zu konvertierenden Elements von <paramref name="bytes" />.</param>
        <param name="count">Die Anzahl der zu konvertierenden Bytes.</param>
        <summary>Konvertiert einen Bereich von Bytes in einem Bytearray aus einer Codierung in eine andere.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Byte" />, das das Ergebnis der Konvertierung eines Bereichs von Bytes in <paramref name="bytes" /> von <paramref name="srcEncoding" /> in <paramref name="dstEncoding" /> enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="dstEncoding" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich im Bytearray an.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 **srcEncoding.** Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 **dstEncoding.** Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Text.DecoderFallback" />-Objekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt ab.</summary>
        <value>Das Decoderfallbackobjekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.DecoderFallback> Objekt darstellt, einen Fehlerhandler, der aufgerufen wird, wenn eine codierte Bytefolge in ein Zeichen nicht decodiert werden kann. Eine der folgenden Handlertypen wird unterstützt:  
  
-   Einen Fallback mit ähnlichen fallback-Handler, der Bytes, die nicht decodiert werden können, durch ein geeigneter Ersatz-Zeichen ersetzt.  
  
-   Einen Replacement fallback-Handler, der Bytes, die nicht decodiert werden können mit einem beliebigen Ersatzzeichen ersetzt. .NET umfasst eine Replacement fallback-Handler <xref:System.Text.DecoderFallback>, die in der Standardeinstellung ersetzt Bytes, die nicht decodiert werden können, mit einem Fragezeichen ("?") Zeichen.  
  
-   Eine Ausnahme fallback-Handler, der eine Ausnahme auslöst, wenn die Bytes nicht decodiert werden können. .NET enthält einen fallback Ausnahmehandler <xref:System.Text.DecoderExceptionFallback>, welche löst eine <xref:System.Text.DecoderFallbackException> Wenn Bytes nicht decodiert werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert in einem set-Vorgang ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Wert kann in einem set-Vorgang nicht zugewiesen werden, da das aktuelle <see cref="T:System.Text.Encoding" />-Objekt schreibgeschützt ist.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardcodierung für diese .NET-Implementierung ab.</summary>
        <value>Die standardcodierung für diese .NET-Implementierung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Unterschiedliche Computer können unterschiedliche Codierungen verwenden, als Standard ein, und die standardcodierung auf einem einzelnen Computer ändern kann. Bei Verwendung der <xref:System.Text.Encoding.Default%2A> Codierung zum Codieren und Decodieren von Daten zwischen Computern übertragen oder zu unterschiedlichen Zeiten auf dem gleichen Computer abgerufen, es kann übersetzt werden diese Daten nicht ordnungsgemäß. Darüber hinaus zurückgegebenes die Codierung der <xref:System.Text.Encoding.Default%2A> Eigenschaft Fallback mit ähnlichen Zeichen verwendet, um nicht unterstützte Zeichen Zeichen unterstützt, die von der Codepage zuzuordnen. Aus diesen Gründen wird die Verwendung der standardcodierung nicht empfohlen. Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, verwenden Sie eine Unicode-Codierung, z. B. <xref:System.Text.UTF8Encoding> oder <xref:System.Text.UnicodeEncoding>. Sie können ein übergeordneten Protokolls auch verwenden, um sicherzustellen, dass das gleiche Format verwendet wird, zum Codieren und decodieren.  

### <a name="the-default-property-in-the-net-framework"></a>Die Standardeigenschaft in .NET Framework

In .NET Framework auf dem Windows-Desktop den <xref:System.Text.Encoding.Default%2A> Eigenschaft immer ruft active-Codepage des Systems ab und erstellt eine <xref:System.Text.Encoding> Objekt, das es entspricht. Die aktiven Codepage möglicherweise eine ANSI-Codepage enthält, die das ASCII-Zeichen zusammen mit zusätzlichen Zeichen, die unterschiedlich sind von der Codepage festgelegt. Da alle <xref:System.Text.Encoding.Default%2A> Codierungen, die basierend auf ANSI-Codepages Daten verloren gehen, sollten Sie verwenden die <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> stattdessen codieren. UTF-8 ist häufig in U + 00 U + 7F. Bereich identisch, aber Sie können Zeichen außerhalb des ASCII-Bereichs ohne Verlust codieren.

## <a name="the-default-property-on-net-core"></a>Die Standardeigenschaft in .NET Core

.NET Core die <xref:System.Text.Encoding.Default%2A> -Eigenschaft gibt immer die <xref:System.Text.UTF8Encoding>. UTF-8 werden alle Betriebssysteme (Windows, Linux und Max OS X) auf die .NET Core-Anwendungen ausführen.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Text.EncoderFallback" />-Objekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt ab.</summary>
        <value>Das Encoderfallbackobjekt für das aktuelle <see cref="T:System.Text.Encoding" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.EncoderFallback> Objekt darstellt, einen Fehlerhandler, der aufgerufen wird, wenn ein Zeichen in eine codierte Bytefolge konvertiert werden kann. Eine der folgenden Handlertypen wird unterstützt:  
  
-   Einen Fallback mit ähnlichen fallback-Handler, der Zeichen, die nicht codiert werden können, durch ein geeigneter Ersatz-Zeichen ersetzt.  
  
-   Einen Replacement fallback-Handler, der Zeichen, die nicht codiert werden können, durch die einem beliebigen Ersatzzeichen ersetzt. .NET umfasst eine Replacement fallback-Handler <xref:System.Text.EncoderFallback>, die in der Standardeinstellung ersetzt Zeichen, die nicht codiert werden können, mit einem Fragezeichen ("?") Zeichen.  
  
-   Eine Ausnahme fallback-Handler, der eine Ausnahme auslöst, wenn Zeichen nicht codiert werden können. .NET enthält einen fallback Ausnahmehandler <xref:System.Text.EncoderExceptionFallback>, welche löst eine <xref:System.Text.EncoderFallbackException> Wenn Zeichen nicht decodiert werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert in einem set-Vorgang ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Wert kann in einem set-Vorgang nicht zugewiesen werden, da das aktuelle <see cref="T:System.Text.Encoding" />-Objekt schreibgeschützt ist.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird die Klartextbeschreibung der aktuellen Codierung abgerufen.</summary>
        <value>Die Klartextbeschreibung der aktuellen <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoding.EncodingName%2A> Eigenschaft ist für die Anzeige vorgesehen. Um einen Namen zu finden, die übergeben werden kann die <xref:System.Text.Encoding.GetEncoding%2A> -Methode, mit der <xref:System.Text.Encoding.WebName%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die anderen Namen für jede Codierung abgerufen, und zeigt die Codierungen mit ein oder mehrere Namen, die von unterscheiden <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Es zeigt <xref:System.Text.Encoding.EncodingName%2A> jedoch nicht dafür verglichen.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das <see cref="T:System.Object" />, das mit der aktuellen Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob das angegebene <see cref="T:System.Object" /> und die aktuelle Instanz gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="value" /> eine Instanz von <see cref="T:System.Text.Encoding" /> und gleich der aktuellen Instanz ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei Instanzen von <xref:System.Text.Encoding> werden als gleich betrachtet, wenn sie dieselbe Codepage entsprechen und deren `EncoderFallback` und `DecoderFallback` Objekte gleich sind. Insbesondere abgeleiteten Codepages, die alle eine Codepage 0 und die Fallbacks sind normalerweise `null` (`Nothing` in Visual Basic .NET). Daher werden sie alle anderen gleich betrachtet. Ein Vorteil ist, die bei der <xref:System.Text.Encoding.Equals%2A> , alle Codierungen Vergleichen gleich abgeleitet und fallen in der gleichen Tabelle hashslot zum Auffüllen einer Hashtabelle verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft zwei Instanzen der gleichen Codierung (eine von der Codepage) und einen anderen anhand des Namens ab und überprüft die Gleichheit.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl an Bytes, die beim Codieren der Zeichen erzeugt werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray mit den zu codierenden Zeichen.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl an Bytes, die beim Codieren aller Zeichen im angegebenen Zeichenarray erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die durch Codieren aller Zeichen im angegebenen Zeichenarray erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.Encoding.GetBytes%2A> aufrufen, um die resultierenden Bytes zu speichern, die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Größe zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes in einen Satz von Unicode-Zeichen, Codierung und die <xref:System.Text.Encoding.GetBytes%2A> Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app müssen möglicherweise viele Eingabe Zeichen in eine Codepage codiert werden und die Zeichen, die durch mehrere Aufrufe zu verarbeiten. In diesem Fall wahrscheinlich müssen Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird die <xref:System.Text.Encoder> Objekt verwendet wird.  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, befolgen Sie die zeichenfolgenversionen von der <xref:System.Text.Encoding.GetBytes%2A> Methode.  
  
-   Die Unicode-Puffer Version der <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere durch mehrere Aufrufe, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten Sie den Ausgabepuffer wiederverwenden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte-Arrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolge mit den zu codierenden Zeichen.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Bytes, die beim Codieren der Zeichen in der angegebenen Zeichenfolge erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.Encoding.GetBytes%2A> aufrufen, um die resultierenden Bytes zu speichern, die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Größe zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes in einen Satz von Unicode-Zeichen, Codierung und die <xref:System.Text.Encoding.GetBytes%2A> Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app müssen möglicherweise viele Eingabe Zeichen in eine Codepage codiert werden und die Zeichen, die durch mehrere Aufrufe zu verarbeiten. In diesem Fall wahrscheinlich müssen Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird die <xref:System.Text.Encoder> Objekt verwendet wird.  
  
-   Wenn Ihre app Zeichenfolgeneingaben, die Version der Zeichenfolge behandelt <xref:System.Text.Encoding.GetBytes%2A> wird empfohlen.  
  
-   Die Unicode-Puffer Version der <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere durch mehrere Aufrufe, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten den Ausgabepuffer wiederverwendet werden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte-Arrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Ein Zeiger auf das erste zu codierende Zeichen.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Bytes, die beim Codieren der Zeichen ab dem Zeichenzeiger erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> erfordert die resultierenden Bytes zu speichern, rufen Sie die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Größe zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> -Methode bestimmt, wie viele Bytes in einen Satz von Unicode-Zeichen, Codierung und die <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Überlegungen zur Verwendung dieser Methoden:  
  
-   Ihre app muss möglicherweise viele Eingabe Zeichen in eine Codepage codiert werden und die Zeichen, die durch mehrere Aufrufe zu verarbeiten. In diesem Fall wahrscheinlich müssen Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird die <xref:System.Text.Encoder> Objekt verwendet wird.  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, verwenden Sie die Version der Zeichenfolge die <xref:System.Text.Encoding.GetBytes%2A> Methode.  
  
-   Die Unicode-Puffer Version der <xref:System.Text.Encoding.GetBytes%2A> lässt einige schnelle Verfahren, insbesondere durch mehrere Aufrufe, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten den Ausgabepuffer wiederverwendet werden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte-Arrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist kleiner als Null.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray, das die zu codierenden Zeichen enthält.</param>
        <param name="index">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl an Bytes, die beim Codieren der Zeichen aus dem angegebenen Zeichenarray erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.Encoding.GetBytes%2A> aufrufen, um die resultierenden Bytes zu speichern, die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Größe zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes in einen Satz von Unicode-Zeichen, Codierung und die <xref:System.Text.Encoding.GetBytes%2A> Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app müssen möglicherweise viele Eingabe Zeichen in eine Codepage codiert werden und die Zeichen, die durch mehrere Aufrufe zu verarbeiten. In diesem Fall wahrscheinlich müssen Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird die <xref:System.Text.Encoder> Objekt verwendet wird.  
  
-   Wenn Ihre app Zeichenfolgeneingaben, die Version der Zeichenfolge behandelt <xref:System.Text.Encoding.GetBytes%2A> wird empfohlen.  
  
-   Die Unicode-Puffer Version der <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere durch mehrere Aufrufe, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten den Ausgabepuffer wiederverwendet werden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte-Arrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um drei Zeichen aus einem Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen in eine Bytefolge codiert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray mit den zu codierenden Zeichen.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden alle Zeichen im angegebenen Zeichenarray in eine Bytefolge codiert.</summary>
        <returns>Ein Bytearray mit den Ergebnissen der Codierung der angegebenen Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass er in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen die <xref:System.Text.Encoding.GetDecoder%2A> Methode oder der <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes in einen Satz von Unicode-Zeichen, Codierung und die <xref:System.Text.Encoding.GetBytes%2A> Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app müssen möglicherweise viele Eingabe Zeichen in eine Codepage codiert werden und die Zeichen, die durch mehrere Aufrufe zu verarbeiten. In diesem Fall wahrscheinlich müssen Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird die <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Surrogate-Paare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> speichert, hohe Ersatzzeichen, damit er mit einem niedrigen Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding> wird nicht in der Lage, den Status zu verwalten, damit das Zeichen an gesendet werden, wird die <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, sollten Sie die Version der Zeichenfolge Aufrufen der <xref:System.Text.Encoding.GetBytes%2A> Methode.  
  
-   Die Unicode-Puffer Version der <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere durch mehrere Aufrufe, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten den Ausgabepuffer wiederverwendet werden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte-Arrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolge mit den zu codierenden Zeichen.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden alle Zeichen in der angegebenen Zeichenfolge in eine Bytefolge codiert.</summary>
        <returns>Ein Bytearray mit den Ergebnissen der Codierung der angegebenen Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass er in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen die <xref:System.Text.Encoding.GetDecoder%2A> Methode oder der <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes in einen Satz von Unicode-Zeichen, Codierung und die <xref:System.Text.Encoding.GetBytes%2A> Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app müssen möglicherweise viele Eingabe Zeichen in eine Codepage codiert werden und die Zeichen, die durch mehrere Aufrufe zu verarbeiten. In diesem Fall wahrscheinlich müssen Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird die <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Surrogate-Paare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> speichert, hohe Ersatzzeichen, damit er mit einem niedrigen Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding> wird nicht in der Lage, den Status zu verwalten, damit das Zeichen an gesendet werden, wird die <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, verwenden Sie die Version der Zeichenfolge <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Die Unicode-Puffer Version der <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere durch mehrere Aufrufe, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten den Ausgabepuffer wiederverwendet werden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte-Arrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray, das die zu codierenden Zeichen enthält.</param>
        <param name="index">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen im angegebenen Zeichenarray in eine Bytefolge codiert.</summary>
        <returns>Ein Bytearray mit den Ergebnissen der Codierung der angegebenen Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass er in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen die <xref:System.Text.Encoding.GetDecoder%2A> Methode oder der <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes in einen Satz von Unicode-Zeichen, Codierung und die <xref:System.Text.Encoding.GetBytes%2A> Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app müssen möglicherweise viele Eingabe Zeichen in eine Codepage codiert werden und die Zeichen, die durch mehrere Aufrufe zu verarbeiten. In diesem Fall wahrscheinlich müssen Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird die <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Surrogate-Paare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> speichert, hohe Ersatzzeichen, damit er mit einem niedrigen Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding> wird nicht in der Lage, den Status zu verwalten, damit das Zeichen an gesendet werden, wird die <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, verwenden Sie die Version der Zeichenfolge <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Die Unicode-Puffer Version der <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere durch mehrere Aufrufe, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten den Ausgabepuffer wiederverwendet werden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte-Arrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um drei Zeichen aus einem Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Ein Zeiger auf das erste zu codierende Zeichen.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <param name="byteCount">Die maximale Anzahl der zu schreibenden Bytes.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen beginnend am angegebenen Zeichenzeiger in eine Bytefolge codiert, die ab Beginn des angegebenen Bytezeigers gespeichert wird.</summary>
        <returns>Die tatsächliche Anzahl an Bytes, die an der durch den <paramref name="bytes" />-Parameter angegebenen Position geschrieben wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetBytes%2A> erfordert die resultierenden Bytes zu speichern, rufen Sie die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Größe zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> Objekt von der bereitgestellten <xref:System.Text.Encoding.GetDecoder%2A> oder <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes in einen Satz von Unicode-Zeichen, Codierung und die <xref:System.Text.Encoding.GetBytes%2A> Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app müssen möglicherweise viele Eingabe Zeichen in eine Codepage codiert werden und die Zeichen, die durch mehrere Aufrufe zu verarbeiten. In diesem Fall wahrscheinlich müssen Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird die <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Surrogate-Paare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> speichert, hohe Ersatzzeichen, damit er mit einem niedrigen Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding> wird nicht in der Lage, den Status zu verwalten, damit das Zeichen an gesendet werden, wird die <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, verwenden Sie die Version der Zeichenfolge <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Die Unicode-Puffer Version der <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere durch mehrere Aufrufe, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten den Ausgabepuffer wiederverwendet werden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte-Arrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> oder <paramref name="byteCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> ist niedriger als die sich ergebende Anzahl von Bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray, das die zu codierenden Zeichen enthält.</param>
        <param name="charIndex">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</param>
        <param name="byteIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen aus dem angegebenen Zeichenarray in das angegebene Bytearray codiert.</summary>
        <returns>Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.Encoding.GetBytes%2A> um die resultierenden Bytes zu speichern, rufen Sie die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Größe zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass er in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen die <xref:System.Text.Encoding.GetDecoder%2A> Methode oder der <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes in einen Satz von Unicode-Zeichen, Codierung und die <xref:System.Text.Encoding.GetBytes%2A> Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app müssen möglicherweise viele Eingabe Zeichen in eine Codepage codiert werden und die Zeichen, die durch mehrere Aufrufe zu verarbeiten. In diesem Fall wahrscheinlich müssen Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird die <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Surrogate-Paare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> speichert, hohe Ersatzzeichen, damit er mit einem niedrigen Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding> wird nicht in der Lage, den Status zu verwalten, damit das Zeichen an gesendet werden, wird die <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, verwenden Sie die Version der Zeichenfolge <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Die Unicode-Puffer Version der <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere durch mehrere Aufrufe, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten den Ausgabepuffer wiederverwendet werden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte-Arrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um drei Zeichen aus einem Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).  
  
- oder -  
 <paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.  
  
- oder -  
 <paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> hat von <paramref name="byteIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolge mit den zu codierenden Zeichen.</param>
        <param name="charIndex">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</param>
        <param name="byteIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden die Zeichen aus der angegebenen Zeichenfolge in das angegebene Bytearray codiert.</summary>
        <returns>Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.Encoding.GetBytes%2A> um die resultierenden Bytes zu speichern, rufen Sie die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Um die maximale Größe zu berechnen, rufen die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass er in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen die <xref:System.Text.Encoding.GetDecoder%2A> Methode oder der <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Die <xref:System.Text.Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes in einen Satz von Unicode-Zeichen, Codierung und die <xref:System.Text.Encoding.GetBytes%2A> Methode führt die eigentliche Codierung. Die <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> -Methode, die mehrere Konvertierungen für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetByteCount%2A> und <xref:System.Text.Encoding.GetBytes%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app müssen möglicherweise viele Eingabe Zeichen in eine Codepage codiert werden und die Zeichen, die durch mehrere Aufrufe zu verarbeiten. In diesem Fall wahrscheinlich müssen Zustand zwischen aufrufen, die Berücksichtigung des Zustands, der vom beibehalten wird die <xref:System.Text.Encoder> Objekt verwendet wird. (Z. B. möglicherweise eine Folge von Zeichen, die Surrogate-Paare enthält ein hohes Ersatzzeichen enden. Die <xref:System.Text.Encoder> speichert, hohe Ersatzzeichen, damit er mit einem niedrigen Ersatzzeichen am Anfang eines folgenden Aufrufs kombiniert werden kann. <xref:System.Text.Encoding> wird nicht in der Lage, den Status zu verwalten, damit das Zeichen an gesendet werden, wird die <xref:System.Text.EncoderFallback>.)  
  
-   Wenn Ihre app Zeichenfolgen als Eingabe behandelt wird, verwenden Sie die Version der Zeichenfolge <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Die Unicode-Puffer Version der <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere durch mehrere Aufrufe, die mit der <xref:System.Text.Encoder> Objekt oder Einfügen in vorhandene Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten den Ausgabepuffer wiederverwendet werden. In diesem Fall die <xref:System.Text.Encoding.GetBytes%2A> Version, die Byte-Arrays unterstützt, ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetByteCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Codierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um eine Zeichenfolge oder einen Bereich in der Zeichenfolge zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).  
  
- oder -  
 <paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.  
  
- oder -  
 <paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> hat von <paramref name="byteIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren einer Bytefolge erzeugt werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren aller Bytes in dem angegebenen Bytearray erzeugt werden.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> um die sich ergebenden Zeichen speichern zu können, verwenden Sie die <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> Methode. Um die maximale Größe zu berechnen, verwenden Sie die <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> Methode. Die <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> -Methode bestimmt, wie viele Zeichen in eine Folge von Bytes, Decodierung und die <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> Methode führt die eigentliche Decodierung. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app müssen möglicherweise mehrere Eingabebytes aus einer Codepage decodieren und die Bytes, die durch mehrere Aufrufe verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen den aufrufen.  
  
-   Wenn Ihre app Zeichenfolgenausgaben behandelt wird, verwenden Sie die <xref:System.Text.Encoding.GetString%2A> Methode. Da diese Methode muss überprüfen Sie die Länge der Zeichenfolge und einen Puffer zuzuordnen, ist es etwas langsamer, jedoch ist der resultierende <xref:System.String> Typ ist zu bevorzugen.  
  
-   Die Byteversion des <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten den Ausgabepuffer wiederverwendet werden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, die Zeichen unterstützt werden soll Puffer ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert, und klicken Sie dann die Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf das erste zu decodierende Byte.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren einer Bytefolge ab dem angegebenen Bytezeiger erzeugt werden.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetChars%2A> ist erforderlich, die sich ergebenden Zeichen speichern zu können, sollten Sie verwenden die <xref:System.Text.Encoding.GetCharCount%2A> Methode. Verwenden Sie um die maximale Größe zu berechnen, die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.Encoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen in eine Folge von Bytes, Decodierung und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die eigentliche Decodierung. Die <xref:System.Text.Encoding.GetChars%2A> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app müssen möglicherweise mehrere Eingabebytes aus einer Codepage decodieren und die Bytes, die durch mehrere Aufrufe verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen den aufrufen.  
  
-   Wenn Ihre app Zeichenfolgenausgaben behandelt, es wird empfohlen, verwenden Sie die <xref:System.Text.Encoding.GetString%2A> Methode. Da diese Methode muss überprüfen Sie die Länge der Zeichenfolge und einen Puffer zuzuordnen, ist es etwas langsamer, jedoch ist der resultierende <xref:System.String> Typ ist zu bevorzugen.  
  
-   Die Byteversion des <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten den Ausgabepuffer wiederverwendet werden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, die Zeichen unterstützt werden soll Puffer ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ist kleiner als Null.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="index">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Zeichen, die beim Decodieren einer Bytefolge aus dem angegebenen Bytearray erzeugt werden.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.Encoding.GetChars%2A> um die sich ergebenden Zeichen speichern zu können, verwenden Sie die <xref:System.Text.Encoding.GetCharCount%2A> Methode. Verwenden Sie um die maximale Größe zu berechnen, die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.Encoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen in eine Folge von Bytes, Decodierung und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die eigentliche Decodierung. Die <xref:System.Text.Encoding.GetChars%2A> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app müssen möglicherweise mehrere Eingabebytes aus einer Codepage decodieren und die Bytes, die durch mehrere Aufrufe verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen den aufrufen.  
  
-   Wenn Ihre app Zeichenfolgenausgaben behandelt, es wird empfohlen, verwenden Sie die <xref:System.Text.Encoding.GetString%2A> Methode. Da diese Methode muss überprüfen Sie die Länge der Zeichenfolge und einen Puffer zuzuordnen, ist es etwas langsamer, jedoch ist der resultierende <xref:System.String> Typ ist zu bevorzugen.  
  
-   Die Byteversion des <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten den Ausgabepuffer wiederverwendet werden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, die Zeichen unterstützt werden soll Puffer ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel konvertiert eine Zeichenfolge aus einer Codierung in einen anderen.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert und anschließend einen Bereich von Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge in Zeichen decodiert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden alle Bytes im angegebenen Bytearray in Zeichen decodiert.</summary>
        <returns>Ein Zeichenarray, das die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft das Zeichen aus einer Eingabebytefolge ab. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> da <xref:System.Text.Encoding> erwartet, dass Konvertierungen, die diskrete während <xref:System.Text.Decoder> für mehrere Durchläufe für genau einen Eingabedatenstrom dient.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass er in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen die <xref:System.Text.Encoding.GetDecoder%2A> Methode oder der <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 **Beachten Sie** richtet sich an diese Methode zum Verarbeiten von Unicode-Zeichen, nicht für den beliebigen Binärdaten, z. B. Byte-Arrays. Wenn Sie beliebige binäre Daten in Text codiert werden müssen, verwenden Sie ein Protokoll wie Uuencode, die von Methoden, wie z. B. implementiert wird <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen in eine Folge von Bytes, Decodierung und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die eigentliche Decodierung. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app müssen möglicherweise mehrere Eingabebytes aus einer Codepage decodieren und die Bytes, die durch mehrere Aufrufe verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen den aufrufen, da Bytefolgen unterbrochen werden können, wenn in Batches verarbeitet. (Z. B. Teil einer ISO-2022-UMSCHALT-Sequenz kann am Ende einer <xref:System.Text.Encoding.GetChars%2A> aufrufen, und fahren Sie mit den Anfang des nächsten <xref:System.Text.Encoding.GetChars%2A> aufrufen. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft das Fallback für diese unvollständigen Sequenzen, aber <xref:System.Text.Decoder> speichert diese Sequenzen, für den nächsten Anruf.)  
  
-   Wenn Ihre app Zeichenfolgenausgaben behandelt, es wird empfohlen, verwenden Sie die <xref:System.Text.Encoding.GetString%2A> Methode. Da diese Methode muss überprüfen Sie die Länge der Zeichenfolge und einen Puffer zuzuordnen, ist es etwas langsamer, jedoch ist der resultierende <xref:System.String> Typ ist zu bevorzugen.  
  
-   Die Byteversion des <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten den Ausgabepuffer wiederverwendet werden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, die Zeichen unterstützt werden soll Puffer ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert, und klicken Sie dann die Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="index">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge aus dem angegebenen Bytearray in Zeichen decodiert.</summary>
        <returns>Ein Zeichenarray, das die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft das Zeichen aus einer Eingabebytefolge ab. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> da <xref:System.Text.Encoding> erwartet, dass Konvertierungen, die diskrete während <xref:System.Text.Decoder> für mehrere Durchläufe für genau einen Eingabedatenstrom dient.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass er in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen die <xref:System.Text.Encoding.GetDecoder%2A> Methode oder der <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 **Beachten Sie** richtet sich an diese Methode zum Verarbeiten von Unicode-Zeichen, nicht für den beliebigen Binärdaten, z. B. Byte-Arrays. Wenn Sie beliebige binäre Daten in Text codiert werden müssen, verwenden Sie ein Protokoll wie Uuencode, die von Methoden, wie z. B. implementiert wird <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen in eine Folge von Bytes, Decodierung und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die eigentliche Decodierung. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app müssen möglicherweise mehrere Eingabebytes aus einer Codepage decodieren und die Bytes, die durch mehrere Aufrufe verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen den aufrufen, da Bytefolgen unterbrochen werden können, wenn in Batches verarbeitet. (Z. B. Teil einer ISO-2022-UMSCHALT-Sequenz kann am Ende einer <xref:System.Text.Encoding.GetChars%2A> aufrufen, und fahren Sie mit den Anfang des nächsten <xref:System.Text.Encoding.GetChars%2A> aufrufen. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft das Fallback für diese unvollständigen Sequenzen, aber <xref:System.Text.Decoder> speichert diese Sequenzen, für den nächsten Anruf.)  
  
-   Wenn Ihre app Zeichenfolgenausgaben behandelt, es wird empfohlen, verwenden Sie die <xref:System.Text.Encoding.GetString%2A> Methode. Da diese Methode muss überprüfen Sie die Länge der Zeichenfolge und einen Puffer zuzuordnen, ist es etwas langsamer, jedoch ist der resultierende <xref:System.String> Typ ist zu bevorzugen.  
  
-   Die Byteversion des <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten den Ausgabepuffer wiederverwendet werden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, die Zeichen unterstützt werden soll Puffer ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert und anschließend einen Bereich von Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf das erste zu decodierende Byte.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="chars">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</param>
        <param name="charCount">Die maximale Anzahl der zu schreibenden Zeichen.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge beginnend am angegebenen Bytezeiger in Zeichen decodiert, die ab Beginn des angegebenen Zeichenzeigers gespeichert werden.</summary>
        <returns>Die tatsächliche Anzahl der Zeichen, die an der durch den <paramref name="chars" />-Parameter angegebenen Position geschrieben wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.Encoding.GetChars%2A> ist erforderlich, die sich ergebenden Zeichen speichern zu können, sollten Sie verwenden die <xref:System.Text.Encoding.GetCharCount%2A> Methode. Verwenden Sie um die maximale Größe zu berechnen, die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.Encoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft das Zeichen aus einer Eingabebytefolge ab. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> da <xref:System.Text.Encoding> erwartet, dass Konvertierungen, die diskrete während <xref:System.Text.Decoder> für mehrere Durchläufe für genau einen Eingabedatenstrom dient.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass sie in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> Objekt von der bereitgestellten <xref:System.Text.Encoding.GetDecoder%2A> oder <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 **Beachten Sie** richtet sich an diese Methode zum Verarbeiten von Unicode-Zeichen, nicht für den beliebigen Binärdaten, z. B. Byte-Arrays. Wenn Sie beliebige binäre Daten in Text codiert werden müssen, verwenden Sie ein Protokoll wie Uuencode, die von Methoden, wie z. B. implementiert wird <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen in eine Folge von Bytes, Decodierung und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die eigentliche Decodierung. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app müssen möglicherweise mehrere Eingabebytes aus einer Codepage decodieren und die Bytes, die durch mehrere Aufrufe verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen den aufrufen, da Bytefolgen unterbrochen werden können, wenn in Batches verarbeitet. (Z. B. Teil einer ISO-2022-UMSCHALT-Sequenz kann am Ende einer <xref:System.Text.Encoding.GetChars%2A> aufrufen, und fahren Sie mit den Anfang des nächsten <xref:System.Text.Encoding.GetChars%2A> aufrufen. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Ruft das Fallback für diese unvollständigen Sequenzen, aber <xref:System.Text.Decoder> speichert diese Sequenzen, für den nächsten Anruf.)  
  
-   Wenn Ihre app Zeichenfolgenausgaben, behandelt der <xref:System.Text.Encoding.GetString%2A> Methode wird empfohlen. Da diese Methode muss überprüfen Sie die Länge der Zeichenfolge und einen Puffer zuzuordnen, ist es etwas langsamer, jedoch ist der resultierende <xref:System.String> Typ ist zu bevorzugen.  
  
-   Die Byteversion des <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten den Ausgabepuffer wiederverwendet werden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, die Zeichen unterstützt werden soll Puffer ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> oder <paramref name="charCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> ist niedriger als die sich ergebende Anzahl von Zeichen.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="byteIndex">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="chars">Das Zeichenarray, das die sich ergebenden Zeichen enthalten soll.</param>
        <param name="charIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge aus dem angegebenen Bytearray in das angegebene Zeichenarray decodiert.</summary>
        <returns>Die tatsächliche Anzahl der Zeichen, die in <paramref name="chars" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.Encoding.GetChars%2A> um die sich ergebenden Zeichen speichern zu können, verwenden Sie die <xref:System.Text.Encoding.GetCharCount%2A> Methode. Verwenden Sie um die maximale Größe zu berechnen, die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.Encoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > ruft Zeichen aus einer Eingabebytefolge ab. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > unterscheidet sich von <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> da <xref:System.Text.Encoding> erwartet, dass Konvertierungen, die diskrete während <xref:System.Text.Decoder> dient zur mehrere Durchläufe für genau einen Eingabedatenstrom.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass er in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen die <xref:System.Text.Encoding.GetDecoder%2A> Methode oder der <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 **Beachten Sie** richtet sich an diese Methode zum Verarbeiten von Unicode-Zeichen, nicht für den beliebigen Binärdaten, z. B. Byte-Arrays. Wenn Sie beliebige binäre Daten in Text codiert werden müssen, verwenden Sie ein Protokoll wie Uuencode, die von Methoden, wie z. B. implementiert wird <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Die <xref:System.Text.Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen in eine Folge von Bytes, Decodierung und die <xref:System.Text.Encoding.GetChars%2A> Methode führt die eigentliche Decodierung. Die <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Methode erwartet diskrete Konvertierungen, die im Gegensatz zu den <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> -Methode, die mehrere Durchläufe für genau einen Eingabedatenstrom behandelt.  
  
 Mehrere Versionen von <xref:System.Text.Encoding.GetCharCount%2A> und <xref:System.Text.Encoding.GetChars%2A> werden unterstützt. Es folgen einige Programmiersprachen Überlegungen für die Verwendung der folgenden Methoden:  
  
-   Ihre app müssen möglicherweise mehrere Eingabebytes aus einer Codepage decodieren und die Bytes, die durch mehrere Aufrufe verarbeiten. In diesem Fall müssen Sie wahrscheinlich zur Beibehaltung des Zustands zwischen den aufrufen, da Bytefolgen unterbrochen werden können, wenn in Batches verarbeitet. (Z. B. Teil einer ISO-2022-UMSCHALT-Sequenz kann am Ende einer [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > aufrufen, und fahren Sie mit den Anfang des nächsten [\], Int32, Int32, Char\<Xref : System.Text.Encoding.GetChars%2A > aufrufen. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > Ruft das Fallback für diese unvollständigen Sequenzen, aber <xref:System.Text.Decoder> speichert diese Sequenzen, für den nächsten Anruf.)  
  
-   Wenn Ihre app Zeichenfolgenausgaben, behandelt der <xref:System.Text.Encoding.GetString%2A> Methode wird empfohlen. Da diese Methode muss überprüfen Sie die Länge der Zeichenfolge und einen Puffer zuzuordnen, ist es etwas langsamer, jedoch ist der resultierende <xref:System.String> Typ ist zu bevorzugen.  
  
-   Die Byteversion des <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> lässt einige schnelle Verfahren, insbesondere bei mehreren Aufrufen an große Puffer. Beachten Sie jedoch, dass diese Methodenversion manchmal unsicher, da Zeiger erforderlich sind.  
  
-   Wenn Ihre app eine große Datenmenge konvertieren muss, sollten den Ausgabepuffer wiederverwendet werden. In diesem Fall die [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > Version, die Zeichen unterstützt werden soll Puffer ist die beste Wahl.  
  
-   Erwägen Sie die Verwendung der <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Text.Encoding.GetCharCount%2A>. Die Konvertierungsmethode konvertiert so viele Daten wie möglich und löst eine Ausnahme aus, wenn der Ausgabepuffer zu klein ist. Für die fortlaufende Decodierung eines Datenstroms, ist diese Methode häufig die beste Wahl.  
  
   
  
## Examples  
 Im folgende Beispiel konvertiert eine Zeichenfolge aus einer Codierung in einen anderen.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert und anschließend einen Bereich von Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" />, <paramref name="byteCount" /> oder <paramref name="charIndex" /> ist kleiner als 0 (null).  
  
- oder -  
 <paramref name="byteindex" /> und <paramref name="byteCount" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.  
  
- oder -  
 <paramref name="charIndex" /> ist kein gültiger Index in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> hat von <paramref name="charIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Zeichen aufzunehmen.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Decoder abgerufen, der eine codierte Bytefolge in Zeichen konvertiert.</summary>
        <returns>Eine <see cref="T:System.Text.Decoder" />-Klasse, die eine codierte Bytefolge in eine Folge von Zeichen codiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Methode konvertiert die Blöcke von Bytes in sequenzielle Blöcke von Zeichen, ähnlich wie die <xref:System.Text.Encoding.GetChars%2A> Methode dieser Klasse. Allerdings eine <xref:System.Text.Decoder> verwaltet Zustandsinformationen zwischen den aufrufen, damit es Bytefolgen ordnungsgemäß decodiert, die Blöcke umfassen. Die <xref:System.Text.Decoder> behält nachfolgende Bytes am Ende der Datenblöcke und verwendet Sie im nächsten Decodierungsvorgang. Aus diesem Grund <xref:System.Text.Encoding.GetDecoder%2A> und <xref:System.Text.Encoding.GetEncoder%2A> eignen sich für die Übertragung im Netzwerk und Dateivorgänge, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die Standardimplementierung gibt eine <see cref="T:System.Text.Decoder" /> aufruft, die <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> und <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> Methoden des aktuellen <see cref="T:System.Text.Encoding" />. Müssen Sie festlegen, überschreiben diese Methode zum Zurückgeben einer <see cref="T:System.Text.Decoder" /> , verwaltet den Zustand zwischen aufrufen.</para>
        </block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Encoder abgerufen, der eine Folge von Unicode-Zeichen in eine codierte Bytefolge konvertiert.</summary>
        <returns>Ein <see cref="T:System.Text.Encoder" />, der eine Folge von Unicode-Zeichen in eine codierte Bytefolge konvertiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> konvertiert sequenzielle Blöcke von Zeichen in sequenzielle Blöcke von Bytes, ähnlich wie die <xref:System.Text.Encoding.GetBytes%2A> Methode dieser Klasse. Allerdings eine <xref:System.Text.Encoder> verwaltet Zustandsinformationen zwischen den aufrufen, sodass korrekt Zeichenfolgen codiert, die Blöcke umfassen. Die <xref:System.Text.Encoder> auch behält nachfolgende Zeichen am Ende der Datenblöcke und die nachgestellten Zeichen in den nächsten Vorgang für die Codierung verwendet. Z. B. ein Datenblock kann eine hohe Ersatzzeichen ohne Entsprechung enden, und das entsprechende niedrige Ersatzzeichen möglicherweise der nächste Datenblock. Aus diesem Grund <xref:System.Text.Encoding.GetDecoder%2A> und <xref:System.Text.Encoding.GetEncoder%2A> eignen sich für die Übertragung im Netzwerk und Dateivorgänge, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die Standardimplementierung gibt eine <see cref="T:System.Text.Encoder" /> aufruft, die <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> und <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> Methoden des aktuellen <see cref="T:System.Text.Encoding" />. Müssen Sie festlegen, überschreiben diese Methode zum Zurückgeben einer <see cref="T:System.Text.Encoder" /> , verwaltet den Zustand zwischen aufrufen.</para>
        </block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Codierung für die angegebene Codepage zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">Der Codepagebezeichner der bevorzugten Codierung. Mögliche Werte sind in der Codepage-Spalte der Tabelle aufgeführt, die im Thema zur <see cref="T:System.Text.Encoding" />-Klasse angezeigt wird.  
  
- oder -  
0 (null), um die Standardcodierung zu verwenden.</param>
        <summary>Gibt die dem angegebenen Codepagebezeichner zugeordnete Codierung zurück.</summary>
        <returns>Die Codierung, die der angegebenen Codepage zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der fallback-Handler hängt von den Codierungstyp des `codepage`. Wenn `codepage` ist ein Code Seiten- oder Doppelbyte-Zeichensatz (DBCS) zu codieren, ein Fallback mit ähnlichen fallback-Handler wird verwendet. Andernfalls wird ein Ersatz-fallback-Handler verwendet. Diese fallback-Handler können nicht für Ihre app geeignet. An den fallback-Handler die Codierung gemäß `codepage`, rufen Sie die <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> überladen.  
  
 In .NET Framework die <xref:System.Text.Encoding.GetEncoding%2A> Methode beruht auf der zugrunde liegenden Plattform zur Unterstützung von den meisten Codepages. .NET Framework unterstützt systemintern jedoch einige Codierungen. Eine Liste der Codepages, finden Sie unter den <xref:System.Text.Encoding> Thema-Klasse. In .NET Core die <xref:System.Text.Encoding.GetEncoding%2A> Methode gibt zurück, die nativ von .NET Core unterstützten Codierungen. Sie können für beide Implementierungen von .NET, Aufrufen der <xref:System.Text.Encoding.GetEncodings%2A> -Methode zum Abrufen der ein Array von <xref:System.Text.EncodingInfo> Objekte, die Informationen über alle verfügbaren Codierungen enthält. 

 Zusätzlich zu den Codierungen, die nativ auf .NET Core verfügbar sind oder systemintern unter einer bestimmten Plattform-Version von .NET Framework unterstützt werden, die <xref:System.Text.Encoding.GetEncoding%2A> Methode gibt alle zusätzlichen Codierungen, die zur Verfügung gestellt werden, durch die Registrierung einer zurück.<xref:System.Text.EncodingProvider> Objekt. Wenn die gleiche Codierung, von mehreren registriert wurde <xref:System.Text.EncodingProvider> Objekten, die diese Methode gibt zurück, der letzte Suchvorgang registriert.  

Sie können auch angeben, der Wert 0 für die `codepage` Argument. Das genaue Verhalten hängt von, ob alle Codierungen verfügbar durch die Registrierung vorgenommen wurden ein <xref:System.Text.EncodingProvider> Objekt:

- Wenn eine oder mehrere Codierung Anbieter registriert wurden, gibt die Codierung des zuletzt registrierten Anbieters, die zurückgegeben wird, wenn eine Codierung gewählt hat die <xref:System.Text.Encoding.GetEncoding%2A> -Methode übergeben eine `codepage` Argument von 0.     

- In .NET Framework, wenn keine Codierung Anbieter registriert ist, wenn die <xref:System.Text.CodePagesEncodingProvider> ist der registrierte codierungsanbieter, oder wenn keine registrierten codierungsanbieter behandelt eine `codepage` Wert von 0 (null) gibt es aktive Codepage des Betriebssystems. Um die aktiven Codepage in Windows-Systeme zu ermitteln, rufen Sie die Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Funktion von .NET Framework auf dem Windows-Desktop.

- In .NET Core, wenn keine codierungsanbieter registriert wurde oder wenn keine registrierten codierungsanbieter behandelt eine `codepage` Wert von 0 (null) gibt die <xref:System.Text.UTF8Encoding>.
  
> [!NOTE]
>  Einige nicht unterstützte Codepages Ursache ein <xref:System.ArgumentException> ausgelöst wird, während andere auslösen, einen <xref:System.NotSupportedException>. Daher im Code muss abgefangen, alle Ausnahmen, die im Abschnitt mit Ausnahmen angegeben.  
  
> [!NOTE]
>  Die ANSI-Codepages können auf verschiedenen Computern unterschiedlich sein und können auf einem einzelnen Computer, führt zur Beschädigung von Daten ändern. Aus diesem Grund ist die aktiven Codepage eine ANSI-Codepage, codieren und Decodieren von Daten, die über die Standardcodepage zurückgegebenes `Encoding.GetEncoding(0)` wird nicht empfohlen. Die meisten konsistente Ergebnisse erzielen Sie sollten Sie verwenden, eine Unicode-Codierung, z. B. UTF-8 (Codepage 65001) oder UTF-16, anstelle einer bestimmten Codepage.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Gibt eine zwischengespeicherte Instanz mit den Standardeinstellungen zurück. Sie sollten die Konstruktoren von abgeleiteten Klassen verwenden, um eine Instanz mit unterschiedlichen Einstellungen abzurufen. Z. B. die <xref:System.Text.UTF32Encoding> Klasse bietet einen Konstruktor, der Sie die fehlererkennung aktivieren kann.  

   
  
## Examples  
 Im folgenden Beispiel ruft zwei Instanzen der gleichen Codierung (eine von der Codepage) und einen anderen anhand des Namens ab und überprüft die Gleichheit.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> ist kleiner als 0 (null) oder größer als 65535.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Codepagename der bevorzugten Codierung. Jeder von der <see cref="P:System.Text.Encoding.WebName" />-Eigenschaft zurückgegebene Wert ist gültig. Mögliche Werte sind in der Name-Spalte der Tabelle aufgeführt, die im Thema zur <see cref="T:System.Text.Encoding" />-Klasse angezeigt wird.</param>
        <summary>Gibt die dem angegebenen Codepagenamen zugeordnete Codierung zurück.</summary>
        <returns>Die der angegebenen Codepage zugeordnete Codierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der fallback-Handler hängt von den Codierungstyp des `name`. Wenn `name` ist ein Code Seiten- oder Doppelbyte-Zeichensatz (DBCS) zu codieren, ein Fallback mit ähnlichen fallback-Handler wird verwendet. Andernfalls wird ein Ersatz-fallback-Handler verwendet. Diese fallback-Handler können nicht für Ihre app geeignet. An den fallback-Handler die Codierung gemäß `name`, rufen Sie die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> überladen.  

In .NET Framework die <xref:System.Text.Encoding.GetEncoding%2A> Methode beruht auf der zugrunde liegenden Plattform zur Unterstützung von den meisten Codepages. .NET Framework unterstützt systemintern jedoch einige Codierungen. Eine Liste der Codepages, finden Sie unter den <xref:System.Text.Encoding> Thema-Klasse. In .NET Core die <xref:System.Text.Encoding.GetEncoding%2A> Methode gibt zurück, die nativ von .NET Core unterstützten Codierungen. Sie können für beide Implementierungen von .NET, Aufrufen der <xref:System.Text.Encoding.GetEncodings%2A> -Methode zum Abrufen der ein Array von <xref:System.Text.EncodingInfo> Objekte, die Informationen über alle verfügbaren Codierungen enthält. 

 Zusätzlich zu den Codierungen, die nativ auf .NET Core verfügbar sind oder systemintern unter einer bestimmten Plattform-Version von .NET Framework unterstützt werden, die <xref:System.Text.Encoding.GetEncoding%2A> Methode gibt alle zusätzlichen Codierungen, die zur Verfügung gestellt werden, durch die Registrierung einer zurück.<xref:System.Text.EncodingProvider> Objekt. Wenn die gleiche Codierung, von mehreren registriert wurde <xref:System.Text.EncodingProvider> Objekten, die diese Methode gibt zurück, der letzte Suchvorgang registriert.  
   
> [!NOTE]
>  Die ANSI-Codepages können auf verschiedenen Computern unterschiedlich sein, oder Sie können für einen einzelnen Computer, führt zur Beschädigung von Daten geändert werden. Für die meisten konsistente Ergebnisse sollten Sie Unicode verwenden, z. B. UTF-8 (Codepage 65001) oder UTF-16, anstelle einer bestimmten Codepage verwenden.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> Gibt eine zwischengespeicherte Instanz mit den Standardeinstellungen zurück. Sie sollten die Konstruktoren von abgeleiteten Klassen verwenden, um eine Instanz mit unterschiedlichen Einstellungen abzurufen. Z. B. die <xref:System.Text.UTF32Encoding> Klasse bietet einen Konstruktor, der Sie die fehlererkennung aktivieren kann.  
  
## Examples  
 Im folgenden Beispiel ruft zwei Instanzen der gleichen Codierung (eine von der Codepage) und einen anderen anhand des Namens ab und überprüft die Gleichheit.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> ist kein gültiger Codepagename.  
  
- oder -  
Die durch <paramref name="name" /> angegebene Codepage wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">Der Codepagebezeichner der bevorzugten Codierung. Mögliche Werte sind in der Codepage-Spalte der Tabelle aufgeführt, die im Thema zur <see cref="T:System.Text.Encoding" />-Klasse angezeigt wird.  
  
- oder -  
0 (null), um die Standardcodierung zu verwenden.</param>
        <param name="encoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn ein Zeichen nicht mit der aktuellen Codierung codiert werden kann.</param>
        <param name="decoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn eine Bytefolge nicht mit der aktuellen Codierung decodiert werden kann.</param>
        <summary>Gibt die dem angegebenen Codepagebezeichner zugeordnete Codierung zurück. Parameter geben einen Fehlerhandler für Zeichen an, die nicht codiert werden können, und für Bytefolgen, die nicht decodiert werden können.</summary>
        <returns>Die Codierung, die der angegebenen Codepage zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Einige nicht unterstützte Codepages dazu führen, dass die Ausnahme <xref:System.ArgumentException> ausgelöst wird, während andere auslösen, <xref:System.NotSupportedException>. Daher im Code muss abgefangen, alle Ausnahmen, die im Abschnitt mit Ausnahmen angegeben.  

In .NET Framework die <xref:System.Text.Encoding.GetEncoding%2A> Methode beruht auf der zugrunde liegenden Plattform zur Unterstützung von den meisten Codepages. .NET Framework unterstützt systemintern jedoch einige Codierungen. Eine Liste der Codepages, finden Sie unter den <xref:System.Text.Encoding> Thema-Klasse. In .NET Core die <xref:System.Text.Encoding.GetEncoding%2A> Methode gibt zurück, die nativ von .NET Core unterstützten Codierungen. Sie können für beide Implementierungen von .NET, Aufrufen der <xref:System.Text.Encoding.GetEncodings%2A> -Methode zum Abrufen der ein Array von <xref:System.Text.EncodingInfo> Objekte, die Informationen über alle verfügbaren Codierungen enthält. 

 Zusätzlich zu den Codierungen, die nativ auf .NET Core verfügbar sind oder systemintern unter einer bestimmten Plattform-Version von .NET Framework unterstützt werden, die <xref:System.Text.Encoding.GetEncoding%2A> Methode gibt alle zusätzlichen Codierungen, die zur Verfügung gestellt werden, durch die Registrierung einer zurück.<xref:System.Text.EncodingProvider> Objekt. Wenn die gleiche Codierung, von mehreren registriert wurde <xref:System.Text.EncodingProvider> Objekten, die diese Methode gibt zurück, der letzte Suchvorgang registriert.  

Sie können auch angeben, der Wert 0 für die `codepage` Argument. Das genaue Verhalten hängt von, ob alle Codierungen verfügbar durch die Registrierung vorgenommen wurden ein <xref:System.Text.EncodingProvider> Objekt:

- Wenn eine oder mehrere Codierung Anbieter registriert wurden, gibt die Codierung des zuletzt registrierten Anbieters, die zurückgegeben wird, wenn eine Codierung gewählt hat die <xref:System.Text.Encoding.GetEncoding%2A> -Methode übergeben eine `codepage` Argument von 0.     

- In .NET Framework, wenn keine Codierung Anbieter registriert ist, wenn die <xref:System.Text.CodePagesEncodingProvider> ist der registrierte codierungsanbieter, oder wenn keine registrierten codierungsanbieter behandelt eine `codepage` Wert von 0 (null) gibt es die Codepage für die active.

- In .NET Core, wenn keine codierungsanbieter registriert wurde oder wenn keine registrierten codierungsanbieter behandelt eine `codepage` Wert von 0 (null) gibt die <xref:System.Text.UTF8Encoding> Codierung.

> [!NOTE]
>  Die ANSI-Codepages können auf verschiedenen Computern unterschiedlich sein und können auf einem einzelnen Computer, führt zur Beschädigung von Daten ändern. Aus diesem Grund ist die aktiven Codepage eine ANSI-Codepage, codieren und Decodieren von Daten, die über die Standardcodepage zurückgegebenes `Encoding.GetEncoding(0)` wird nicht empfohlen. Für die meisten konsistente Ergebnisse sollten Sie Unicode verwenden, z. B. UTF-8 (Codepage 65001) oder UTF-16, anstelle einer bestimmten Codepage verwenden. 
  
 Rufen Sie die aktive Codepage zugeordnete Codierung können Sie entweder den Wert 0 für die `codepage` Argument oder, wenn Ihr Code auf .NET Framework auf dem Windows-Desktop ausgeführt wird, Abrufen des Werts der <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> Eigenschaft. Um die aktuelle aktive Codepage zu bestimmen, rufen Sie die Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Funktion von .NET Framework auf dem Windows-Desktop.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Gibt eine zwischengespeicherte Instanz mit den Standardeinstellungen zurück. Sie sollten die Konstruktoren von abgeleiteten Klassen verwenden, um eine Instanz mit unterschiedlichen Einstellungen abzurufen. Z. B. die <xref:System.Text.UTF32Encoding> Klasse bietet einen Konstruktor, der Sie die fehlererkennung aktivieren kann.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> Methode.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> ist kleiner als 0 (null) oder größer als 65535.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">Der Codepagename der bevorzugten Codierung. Jeder von der <see cref="P:System.Text.Encoding.WebName" />-Eigenschaft zurückgegebene Wert ist gültig. Mögliche Werte sind in der Name-Spalte der Tabelle aufgeführt, die im Thema zur <see cref="T:System.Text.Encoding" />-Klasse angezeigt wird.</param>
        <param name="encoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn ein Zeichen nicht mit der aktuellen Codierung codiert werden kann.</param>
        <param name="decoderFallback">Ein Objekt, das ein Fehlerbehandlungsverfahren bereitstellt, wenn eine Bytefolge nicht mit der aktuellen Codierung decodiert werden kann.</param>
        <summary>Gibt die dem angegebenen Codepagenamen zugeordnete Codierung zurück. Parameter geben einen Fehlerhandler für Zeichen an, die nicht codiert werden können, und für Bytefolgen, die nicht decodiert werden können.</summary>
        <returns>Die Codierung, die der angegebenen Codepage zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

In .NET Framework die <xref:System.Text.Encoding.GetEncoding%2A> Methode beruht auf der zugrunde liegenden Plattform zur Unterstützung von den meisten Codepages. .NET Framework unterstützt systemintern jedoch einige Codierungen. Eine Liste der Codepages, finden Sie unter den <xref:System.Text.Encoding> Thema-Klasse. In .NET Core die <xref:System.Text.Encoding.GetEncoding%2A> Methode gibt zurück, die nativ von .NET Core unterstützten Codierungen. Sie können für beide Implementierungen von .NET, Aufrufen der <xref:System.Text.Encoding.GetEncodings%2A> -Methode zum Abrufen der ein Array von <xref:System.Text.EncodingInfo> Objekte, die Informationen über alle verfügbaren Codierungen enthält. 

 Zusätzlich zu den Codierungen, die nativ auf .NET Core verfügbar sind oder systemintern unter einer bestimmten Plattform-Version von .NET Framework unterstützt werden, die <xref:System.Text.Encoding.GetEncoding%2A> Methode gibt alle zusätzlichen Codierungen, die zur Verfügung gestellt werden, durch die Registrierung einer zurück.<xref:System.Text.EncodingProvider> Objekt. Wenn die gleiche Codierung, von mehreren registriert wurde <xref:System.Text.EncodingProvider> Objekten, die diese Methode gibt zurück, der letzte Suchvorgang registriert.  
  
> [!NOTE]
>  Die ANSI-Codepages können auf verschiedenen Computern unterschiedlich sein und können auf einem einzelnen Computer, führt zur Beschädigung von Daten ändern. Die meisten konsistente Ergebnisse erzielen Sie sollten Sie verwenden, eine Unicode-Codierung, z. B. UTF-8 (Codepage 65001) oder UTF-16, anstelle einer bestimmten Codepage.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Gibt eine zwischengespeicherte Instanz mit den Standardeinstellungen zurück. Sie sollten die Konstruktoren von abgeleiteten Klassen verwenden, um eine Instanz mit unterschiedlichen Einstellungen abzurufen. Z. B. die <xref:System.Text.UTF32Encoding> Klasse bietet einen Konstruktor, der Sie die fehlererkennung aktivieren kann.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> Methode.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> ist kein gültiger Codepagename.  
  
- oder -  
Die durch <paramref name="name" /> angegebene Codepage wird von der zugrunde liegenden Plattform nicht unterstützt.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array zurück, das alle Codierungen enthält.</summary>
        <returns>Ein Array, das alle Codierungen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt eine Liste der unterstützten Codierungen, die eindeutig nach Codepage unterschieden. Eine Tabelle mit unterstützten Codierungen, finden Sie unter den <xref:System.Text.Encoding> Thema-Klasse.  
  
> [!NOTE]
>  Die Liste der unterstützten Codierungen, die zurückgegeben werden, indem die <xref:System.Text.Encoding.GetEncodings%2A> Methode umfasst keine zusätzlichen Codierungen, die von jedem zur Verfügung gestellt <xref:System.Text.EncodingProvider> Implementierungen, die durch Aufrufe von registriert wurden die <xref:System.Text.Encoding.RegisterProvider%2A> Methode.  
  
 In .NET Framework sind die Codierungen 50220 und 50222 sowohl mit dem Namen "Iso-2022-jp" verknüpft ist, aber sie sind nicht identisch. Codierung 50220 Katakana-Zeichen halber Breite in voller Breite Katakana-Zeichen konvertiert, während der Codierung 50222 verwendet eine UMSCHALT-in-Out/UMSCHALT-Sequenz die Katakana-Zeichen halber Breite zu codieren. Der Anzeigename für die Codierung 50222 ist "Japanisch (JIS-1 Byte Kana erlaubt - SO / SI)" zur Unterscheidung von Codierung 50220, mit dem Anzeigenamen "Japanisch (JIS)" nennen.  
  
 Wenn Sie die Codierung Name "Iso-2022-jp", die .NET Framework gibt zurück, die Codierung 50220 anfordern. Allerdings hängt die Codierung, die für Ihre app geeignet ist die bevorzugte Behandlung von die Katakana-Zeichen halber Breite.  
  
 Um einer bestimmten Codierung zu erhalten, verwenden Sie die <xref:System.Text.Encoding.GetEncoding%2A> Methode.  
  
 <xref:System.Text.Encoding.GetEncodings%2A> wird manchmal verwendet, um dem Benutzer eine Liste von Codierungen in eine Datei anzuzeigen **speichern als** Dialogfeld. Viele nicht-Unicode-Codierungen sind jedoch entweder unvollständig und übersetzen: zu viele Zeichen "?", oder weisen ein etwas anderes Verhalten auf verschiedenen Plattformen. Erwägen Sie die Verwendung von UTF-8 oder UTF-16 als Standard.  
  
   
  
## Examples  
 Das folgende Beispiel überprüft die Werte der booleschen Eigenschaften jeder Codierung.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für die aktuelle Instanz zurück.</summary>
        <returns>Der Hashcode für die aktuelle Instanz.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die maximale Anzahl der Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt werden.</summary>
        <returns>Die maximale Anzahl an Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `charCount` Parameter legt die Anzahl der <xref:System.Char> darstellende – Objekte die Unicode-Zeichen zu codieren, da .NET wird intern mit UTF-16 verwendet, um Unicode-Zeichen darstellen. Daher können die meisten Unicode-Zeichen dargestellt werden, von einem <xref:System.Char> Objekt handelt, sondern ein Unicode-Zeichen, die durch ein Ersatzzeichenpaar, z. B. dargestellt wird, erfordert zwei <xref:System.Char> Objekte.  
  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.Encoding.GetBytes%2A> um die resultierenden Bytes zu speichern, verwenden Sie die <xref:System.Text.Encoding.GetByteCount%2A> Methode. Verwenden Sie um die maximale Größe zu berechnen, die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.Encoding.GetByteCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> Ruft die maximal zu erwartende, einschließlich den schlimmsten Fall für das derzeit ausgewählte <xref:System.Text.EncoderFallback>. Wenn ein Fallback, eine potenziell große Zeichenfolge ausgewählt wird <xref:System.Text.Encoding.GetMaxByteCount%2A> ruft große Werte, insbesondere in Fällen, in dem der schlimmste Fall für die Codierung umfasst das Wechseln der Modi für jedes Zeichen, ab. Dies kann z. B. ISO-2022-JP haben. Weitere Informationen finden Sie im Blogeintrag "[neuerungen mit Encoding.GetMaxByteCount() und Encoding.GetMaxCharCount()?](https://go.microsoft.com/fwlink/?LinkId=153702)" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 In den meisten Fällen ruft diese Methode die angemessenen Werte für kurze Zeichenfolgen. Für lange Zeichenfolgen müssen Sie möglicherweise entscheiden Sie sehr große Puffer und Abfangen von Fehlern in dem seltenen Fall, wenn Sie ein geeigneteren Puffer zu klein ist. Sie sollten auch einen anderen Ansatz erwägen <xref:System.Text.Encoding.GetByteCount%2A> oder <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 Bei Verwendung <xref:System.Text.Encoding.GetMaxByteCount%2A>, reservieren Sie den Ausgabepuffer, der basierend auf der maximalen Größe des Eingabepuffers. Wenn der Ausgabepuffer Größe beschränkt ist, können Sie die <xref:System.Text.Encoding.Convert%2A> Methode.  
  
 Beachten Sie, dass <xref:System.Text.Encoding.GetMaxByteCount%2A> potenzielle übrig gebliebene Surrogate aus einer vorherigen berücksichtigt. Der Decoder ruft 2 für eine Single-Byte-Codierung, z. B. ASCII ab, wenn Sie den Wert 1 an die Methode übergeben. Verwenden Sie die <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> Eigenschaft, wenn diese Informationen erforderlich sind.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` ist nicht unbedingt der gleiche Wert wie `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> ist kleiner als Null.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <block subset="none" type="overrides">
          <para>Alle <see cref="T:System.Text.Encoding" /> Implementierungen müssen sicherstellen, dass keine Ausnahmen durch Pufferüberlauf auftreten, wenn die Größe von Puffern entsprechend den Ergebnissen von dieser Methode die Berechnungen.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet beim Überschreiben in einer abgeleiteten Klasse die maximale Anzahl an Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</summary>
        <returns>Die maximale Anzahl von Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.Encoding.GetChars%2A> um die sich ergebenden Zeichen speichern zu können, verwenden Sie die <xref:System.Text.Encoding.GetCharCount%2A> Methode. Verwenden Sie um die maximale Größe zu berechnen, die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.Encoding.GetCharCount%2A> Methode ermöglicht im Allgemeinen weniger Speicher, während die <xref:System.Text.Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> Ruft die maximal zu erwartende, einschließlich den schlimmsten Fall für das derzeit ausgewählte <xref:System.Text.DecoderFallback>. Wenn ein Fallback, eine potenziell große Zeichenfolge ausgewählt wird <xref:System.Text.Encoding.GetMaxCharCount%2A> ruft große Werte ab.  
  
 In den meisten Fällen ruft diese Methode geeignete Zahlen für kurze Zeichenfolgen. Für lange Zeichenfolgen müssen Sie möglicherweise entscheiden Sie sehr große Puffer und Abfangen von Fehlern in dem seltenen Fall, dass ein geeigneteren Puffer zu klein ist. Sie sollten auch einen anderen Ansatz erwägen <xref:System.Text.Encoding.GetCharCount%2A> oder <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> hat keinen Bezug zu <xref:System.Text.Encoding.GetBytes%2A>. Wenn Sie dazu eine ähnliche Funktion für die Verwendung mit <xref:System.Text.Encoding.GetBytes%2A>, verwenden Sie <xref:System.Text.Encoding.GetMaxByteCount%2A>.  
  
 Bei Verwendung <xref:System.Text.Encoding.GetMaxCharCount%2A>, reservieren Sie den Ausgabepuffer, der basierend auf der maximalen Größe des Eingabepuffers. Wenn der Ausgabepuffer Größe beschränkt ist, können Sie die <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> Methode.  
  
 Beachten Sie, dass <xref:System.Text.Encoding.GetMaxCharCount%2A> berücksichtigt den ungünstigsten Fall für übrig gebliebene Bytes aus einem vorherigen Encoder-Vorgang. Für die meisten Codepages Ruft Werte größer als oder gleich 1 ab, wenn Sie einen Wert von 0 an diese Methode übergeben.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` ist nicht unbedingt der gleiche Wert wie `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Array von Bytes codiert, und klicken Sie dann die Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> ist kleiner als Null.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <block subset="none" type="overrides">
          <para>Alle <see cref="T:System.Text.Encoding" /> Implementierungen müssen sicherstellen, dass keine Ausnahmen durch Pufferüberlauf auftreten, wenn die Größe von Puffern entsprechend den Ergebnissen von dieser Methode die Berechnungen.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge zurückgegeben, die die verwendete Codierung angibt.</summary>
        <returns>Ein Bytearray, das eine Bytefolge enthält, in der die verwendete Codierung angegeben ist.  
  
- oder -  
Ein Bytearray der Länge 0 (null), wenn keine Präambel erforderlich ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Optional können die <xref:System.Text.Encoding> Objekt stellt eine Präambel, die ein Array von Bytes, die die Abfolge von Bytes, die infolge des Codierungsvorgangs vorangestellt werden kann. Die Präambel einer Bytereihenfolge-Marke (in Unicode-Codepunkt U + FEFF) enthält, wird den Decoder bestimmt die Bytereihenfolge und die Transformationsformat oder UTF leichter.  
  
 Die Unicode-bytereihenfolgemarkierung (BOM) ist (im Hexadezimalformat) wie folgt serialisiert:  
  
-   UTF-8: EF BB BF  
  
-   UTF-16 big-endian-Bytereihenfolge: FE FF  
  
-   UTF-16 little-endian-Bytereihenfolge: FF FE  
  
-   UTF-32 big-endian-Bytereihenfolge: 00 00 FE FF  
  
-   UTF-32 little-endian-Bytereihenfolge: FF FE 00 00  
  
 Sollten Sie die BOM, verwenden, da es bietet nahezu bestimmte Identifikation einer Codierung für Dateien, die ansonsten auf verloren haben die <xref:System.Text.Encoding> -Objekt, z. B. nicht gekennzeichnet oder nicht ordnungsgemäß gekennzeichnet Webdaten oder zufälligen Text-Dateien gespeichert, wenn ein Unternehmen nicht haben Sie internationale Aspekte oder andere Daten. Häufig Probleme der Benutzer können vermieden werden, wenn Daten einheitlich und ordnungsgemäß, vorzugsweise in UTF-8 oder UTF-16 gekennzeichnet ist.  
  
 Für Standards, die einen Typ der codieren bereitstellen, ist eine Bytereihenfolge-Marke gewisse Weise redundant. Es kann jedoch verwendet werden, können Sie einen Server, den richtigen encoding-Header senden. Alternativ können sie als ausweichlösung verwendet werden, für den Fall, dass die Codierung verloren gegangen ist.  
  
 Es gibt einige Nachteile mit einer Bytereihenfolge-Marke. Wissen, wie die Datenbankfelder zu begrenzen, die eine Bytereihenfolge-Marke verwenden kann z. B. schwierig sein. Verkettung von Dateien, problematisch sein kann auch, z. B. beim Zusammenführen von Dateien so eine Möglichkeit, die ein unnötiges Zeichen in der Mitte Daten ergeben kann. Trotz der einige Nachteile wird jedoch dringend die Verwendung einer Stückliste empfohlen.  
  
 Weitere Informationen zu Byte-Reihenfolge und die Bytereihenfolge-Marke, finden Sie im Unicode-Standard auf die [Unicode-Homepage](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie den codierten Bytes mit einer Präambel Präfix voranstellen. Die meisten Codierungen bieten jedoch keine Präambel. Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie mit einer Unicode-Codierung, d. h. <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, oder <xref:System.Text.UTF32Encoding>, mit einer Präambel.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Bytereihenfolge der Codierung auf Grundlage der Präambel.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge in eine Zeichenfolge decodiert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse werden alle Bytes im angegebenen Bytearray in eine Zeichenfolge decodiert.</summary>
        <returns>Eine Zeichenfolge, die die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass er in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> zurückgegebenes Objekt der <xref:System.Text.Encoding.GetDecoder%2A> eine abgeleitete Methode geleitete Klasse.  
  
 Finden Sie im Abschnitt "Hinweise" der <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Verweis Themas beschriebenen Verfahren und Überlegungen zu decodieren.  
  
 Beachten Sie, dass das genaue Verhalten der <xref:System.Text.Encoding.GetString%2A> Methode für einen bestimmten <xref:System.Text.Encoding> Implementierung hängt von der dafür definierten Fallbackstrategie <xref:System.Text.Encoding> Objekt. Weitere Informationen finden Sie im Abschnitt "Auswählen einer Fallbackstrategie" die [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md) Thema.  
  
   
  
## Examples  
 Das folgende Beispiel liest eine UTF-8 codierte Zeichenfolge aus einer Binärdatei, dargestellt durch eine <xref:System.IO.FileStream> Objekt. Für Dateien, die weniger als 2.048 Bytes sind, liest er den Inhalt der gesamten Datei in ein Byte-Array und ruft die <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> Methode, um die Decodierung durchzuführen. Er liest für größere Dateien 2.048 Bytes zu einem Zeitpunkt in ein Bytearray, Aufrufe der <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um zu bestimmen, wie viele Zeichen im Array enthalten sind, und ruft dann die <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um die Decodierung durchzuführen.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 Das Beispiel verwendet den folgenden Text, der in eine UTF-8 codierte Datei, die mit dem Namen Utf8Example.txt gespeichert werden soll.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Bytearray enthält ungültige Unicode-Codepunkte.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf ein Bytearray.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine angegebene Anzahl von Bytes ab einer angegebenen Adresse in eine Zeichenfolge decodiert.</summary>
        <returns>Eine Zeichenfolge, die die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoding.GetString%2A> -Methode entwickelt, um die Leistung zu optimieren, wenn Sie über einen systemeigenen Zeiger auf ein Bytearray verfügen. Anstatt ein verwaltetes Bytearray erstellen, und klicken Sie dann Decodierung können Sie stattdessen diese Methode aufrufen, ohne jede Zwischenobjekten erstellen zu müssen.  
  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass er in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> zurückgegebenes Objekt der <xref:System.Text.Encoding.GetDecoder%2A> eine abgeleitete Methode geleitete Klasse.  
  
 Finden Sie im Abschnitt "Hinweise" der <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Verweis Themas beschriebenen Verfahren und Überlegungen zu decodieren.  
  
 Beachten Sie, dass das genaue Verhalten der <xref:System.Text.Encoding.GetString%2A> Methode für einen bestimmten <xref:System.Text.Encoding> Implementierung hängt von der dafür definierten Fallbackstrategie <xref:System.Text.Encoding> Objekt. Weitere Informationen finden Sie im Abschnitt "Auswählen einer Fallbackstrategie" die [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md) Thema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist ein NULL-Zeiger</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> ist kleiner als Null.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="index">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird eine Bytefolge aus dem angegebenen Bytearray in eine Zeichenfolge decodiert.</summary>
        <returns>Eine Zeichenfolge, die die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zu konvertierenden Daten nur in sequenzielle Blöcke (z. B. aus einem Stream gelesene Daten) verfügbar ist oder wenn die Menge der Daten so groß, dass er in kleinere Blöcke aufgeteilt werden muss, sollten Sie mit ist der <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> gebotenen die <xref:System.Text.Encoding.GetDecoder%2A> Methode oder der <xref:System.Text.Encoding.GetEncoder%2A> -Methode, von einer abgeleiteten Klasse.  
  
 Finden Sie im Abschnitt "Hinweise" der <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Verweis Themas beschriebenen Verfahren und Überlegungen zu decodieren.  
  
   
  
## Examples  
 Das folgende Beispiel liest eine UTF-8 codierte Zeichenfolge aus einer Binärdatei, die durch dargestellt wird ein <xref:System.IO.FileStream> Objekt. Für Dateien, die weniger als 2.048 Bytes sind, liest er den Inhalt der gesamten Datei in ein Byte-Array und ruft die <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Methode, um die Decodierung durchzuführen. Er liest für größere Dateien 2.048 Bytes zu einem Zeitpunkt in ein Bytearray, Aufrufe der <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um zu bestimmen, wie viele Zeichen im Array enthalten sind, und ruft dann die <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um die Decodierung durchzuführen.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 Das Beispiel verwendet den folgenden Text, der in eine UTF-8 codierte Datei, die mit dem Namen Utf8Example.txt gespeichert werden soll.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Bytearray enthält ungültige Unicode-Codepunkte.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md)) 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Name für die aktuelle Codierung abgerufen, die mit den Header-Tags des E-Mail-Agenten verwendet werden kann.</summary>
        <value>Ein Name für die aktuelle <see cref="T:System.Text.Encoding" />, die für die Header-Tags des E-Mail-Agenten verwendet werden kann.  
  
- oder -  
Eine leere Zeichenfolge (""), wenn das aktuelle <see cref="T:System.Text.Encoding" /> nicht verwendet werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie benötigen eine Codierung für einen Headernamen an, Sie sollten aufrufen, die <xref:System.Text.Encoding.GetEncoding%2A> -Methode mit der <xref:System.Text.Encoding.HeaderName%2A> Eigenschaft. Häufig die Methode ruft eine andere Codierung aus der Test-Codierung zur Verfügung gestellt, in dem Aufruf ab. Im Allgemeinen müssen nur e-Mail-Anwendungen diese Codierung abgerufen.  
  
 In einigen Fällen den Wert des der <xref:System.Text.Encoding.BodyName%2A> Eigenschaft entspricht der internationalen Norm, die diese Codierung definiert. Dies bedeutet nicht, dass die Implementierung vollständig mit diesem Standard entspricht.  
  
 Beachten Sie, dass <xref:System.Text.Encoding.WebName%2A> gibt den Namen zu verwenden, um die Beschreibung einer Codierung zurück. Die <xref:System.Text.Encoding.HeaderName%2A> Eigenschaft definiert eine andere Codierung, die besser für eine e-Mail-Anwendung, z. B. möglicherweise. Verwendung der Eigenschaft, die die Codierung definiert wird jedoch nicht empfohlen.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die anderen Namen für jede Codierung abgerufen, und zeigt die Codierungen mit ein oder mehrere Namen, die von unterscheiden <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Es zeigt <xref:System.Text.Encoding.EncodingName%2A> jedoch nicht dafür verglichen.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle Codierung immer normalisiert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle Codierung immer normalisiert ist. Es wird die Standardnormalisierungsform verwendet.</summary>
        <returns>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" />-Klasse immer normalisiert ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardformular für die Normalisierung ist <xref:System.Text.NormalizationForm.FormC>, vollständiger kanonischen Zerlegung und Sequenzen mit ihre primären kombinierenden Zeichen ersetzt wurden, sofern möglich verwendet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">Einer der <see cref="T:System.Text.NormalizationForm" />-Werte.</param>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung immer normalisiert ist. Hierzu wird die angegebene Normalisierungsform verwendet.</summary>
        <returns>
          <see langword="true" />, wenn das aktuelle <see cref="T:System.Text.Encoding" />-Objekt immer mit dem angegebenen <see cref="T:System.Text.NormalizationForm" />-Wert normalisiert wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardformular für die Normalisierung ist <xref:System.Text.NormalizationForm.FormC>, vollständiger kanonischen Zerlegung und Sequenzen mit ihre primären kombinierenden Zeichen ersetzt wurden, sofern möglich verwendet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung von Browserclients zum Anzeigen des Inhalts verwendet werden kann.</summary>
        <value>
          <see langword="true" /> wenn das aktuelle <see cref="T:System.Text.Encoding" /> von Browserclients verwendet werden kann, um Inhalt anzuzeigen; andernfalls, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel überprüft die Werte der booleschen Eigenschaften jeder Codierung.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung von Browserclients zum Speichern von Inhalt verwendet werden kann.</summary>
        <value>
          <see langword="true" /> wenn das aktuelle <see cref="T:System.Text.Encoding" /> von Browserclients verwendet werden kann, um Inhalt zu speichern; andernfalls, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel überprüft die Werte der booleschen Eigenschaften jeder Codierung.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung von Mail- und Newsclients zum Anzeigen von Inhalt verwendet werden kann.</summary>
        <value>
          <see langword="true" /> wenn die aktuelle <see cref="T:System.Text.Encoding" />-Klasse von Mail- und Newsclients verwendet werden kann, um Inhalt anzuzeigen; andernfalls, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel überprüft die Werte der booleschen Eigenschaften jeder Codierung.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird ein Wert abgerufen, der angibt, ob die aktuelle Codierung von Mail- und Newsclients zum Speichern von Inhalt verwendet werden kann.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> von Mail- und Newsclients verwendet werden kann, um Inhalt zu speichern, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel überprüft die Werte der booleschen Eigenschaften jeder Codierung.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob die aktuelle Codierung schreibgeschützt ist.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle <see cref="T:System.Text.Encoding" /> schreibgeschützt ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob die aktuelle Codierung Einzelbyte-Codepunkte verwendet.</summary>
        <value>
          <see langword="true" />, wenn das aktuelle <see cref="T:System.Text.Encoding" /> Einzelbyte-Codepunkte verwendet; andernfalls, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für ein Einzelbyte-Codierung, z. B. <xref:System.Text.ASCIIEncoding>, diese Eigenschaft ruft `true`.  
  
> [!CAUTION]
>  Vorsichtig in die Funktionsweise Ihrer Anwendung mit dem Wert für <xref:System.Text.Encoding.IsSingleByte%2A>. Eine Annahme des wie eine Codierung fortfährt, möglicherweise trotzdem falsch. Windows-1252 hat beispielsweise den Wert `true` für <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, aber Encoding.GetMaxByteCount (1) gibt 2 zurück. Dies ist, da die Methode potenzielle übrig gebliebene Surrogate aus einer vorherigen berücksichtigt.  
  
   
  
## Examples  
 Das folgende Beispiel überprüft die Werte der booleschen Eigenschaften jeder Codierung.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Eine Unterklasse von <see cref="T:System.Text.EncodingProvider" />, die Zugriff auf zusätzliche Zeichencodierungen bietet.</param>
        <summary>Registriert einen Codierungsanbieter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoding.RegisterProvider%2A> Methode können Sie zum Registrieren einer Klasse abgeleitet <xref:System.Text.EncodingProvider> , wird auf einer Plattform verfügbaren Codierungen Zeichen, die andernfalls diese nicht unterstützt. Nach der Codierung Anbieter registriert ist, können die Codierungen, die es unterstützt abgerufen werden, durch das Aufrufen einer <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> überladen. Wenn es mehrere Anbieter für Codierung sind, die <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> Methode versucht, zum Abrufen einer angegebenen Codierung aus jeder Anbieter ab, durch die zuletzt registriert.

Registriert einen codierungsanbieter mithilfe der <xref:System.Text.Encoding.RegisterProvider%2A> Methode ändert auch das Verhalten der [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) und [EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) Methoden, die beim Übergeben eines Arguments der `0`:

- Wenn der registrierte Anbieter ist die <xref:System.Text.CodePagesEncodingProvider>, die Methode gibt zurück, die Codierung, der die Codepage des Systems active entspricht, wenn auf dem Windows-Betriebssystem ausgeführt wird.

- Ein benutzerdefinierter Anbieter für die Codierung kann auswählen, welche Codierung beim Zurückgeben eines dieser <xref:System.Text.Encoding.GetEncoding%2A> Überladungen der Methode wird ein Argument übergeben `0`. Der Anbieter können auch nicht zurückgeben, eine Codierung, dass die <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> -Methodenrückgabe `null`. 
  
Ab .NET Framework 4.6, .NET Framework enthält einen codierungsanbieter, <xref:System.Text.CodePagesEncodingProvider>, verfügbaren Codierungen, die im vollständigen .NET Framework vorhanden sind, jedoch sind in die universelle Windows-Plattform nicht verfügbar ist. Standardmäßig unterstützt die universelle Windows-Plattform nur die Unicode-Codierungen, ASCII und Codepage 28591 entscheiden.  
  
 Wenn die gleiche Anbieter für die Codierung verwendet wird, in mehreren Aufrufen an die <xref:System.Text.Encoding.RegisterProvider%2A> nur der erste Methodenaufruf-Methode registriert den Ressourcenanbieter. Nachfolgende Aufrufe werden ignoriert.  
  
 Wenn die <xref:System.Text.Encoding.RegisterProvider%2A> Methode wird aufgerufen, um mehrere Anbieter zu registrieren, die die gleiche Codierung behandelt, der zuletzt registrierte Anbieter wird für alle Codierungs- und Decodierungsvorgänge verwendet. Alle zuvor registrierten Anbieter werden ignoriert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für das UTF-16-Format in der Little-Endian-Bytereihenfolge ab.</summary>
        <value>Eine Codierung für das UTF-16-Format mit Little-Endian-Bytereihenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen über die Codierungen, die von .NET und eine Beschreibung der um zu verwendende Codierung Unicode-Zeichen unterstützt werden, finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md).  
  
 Die <xref:System.Text.UnicodeEncoding> -Objekt, das von dieser Eigenschaft zurückgegeben wird möglicherweise nicht das richtige Verhalten für Ihre app. Er verwendet einen Ersatzfallback, ersetzen Sie jede Zeichenfolge, die nicht codiert werden können und jedes Byte, die nicht decodiert durch ein Fragezeichen ("?") Zeichen. Stattdessen rufen Sie die <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor zum Instanziieren einer little-Endian <xref:System.Text.UnicodeEncoding> -Objekt, dessen Fallback entweder ist, ein <xref:System.Text.EncoderFallbackException> oder <xref:System.Text.DecoderFallbackException>, wie im folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für das UTF-32-Format in der Little-Endian-Bytereihenfolge ab.</summary>
        <value>Ein Codierungsobjekt für das UTF-32-Format mit Little-Endian-Bytereihenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.UTF32Encoding> -Objekt, das von dieser Eigenschaft zurückgegeben wird möglicherweise nicht das richtige Verhalten für Ihre app. Ersatzfallback verwendet, um jede Zeichenfolge, die nicht codiert werden können und jedes Byte, die nicht decodiert mit dem Unicode-ERSATZZEICHEN (U + FFFE) ersetzen. Stattdessen rufen Sie die <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor zum Instanziieren einer <xref:System.Text.UTF32Encoding> -Objekt, dessen Fallback entweder ist, ein <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>, wie im folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Eine Erläuterung der little-endian-Bytereihenfolge, finden Sie unter den <xref:System.Text.Encoding> Thema-Klasse.  
  
 Weitere Informationen über die Codierungen, die von .NET und eine Beschreibung der um zu verwendende Codierung Unicode-Zeichen unterstützt werden, finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für das UTF-7-Format ab.</summary>
        <value>Eine Codierung für das UTF-7-Format.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 UTF-7-Codierung wird in erster Linie in Umgebungen verwendet werden, die in der Vergangenheit 7 Bits, z. B. NNTP und einige e-Mail-Anwendungen eingeschränkt wurden. Aufgrund von Problemen mit der Stabilität und Sicherheit sollten Sie nicht verwenden UTF7-Codierung in 8-Bit-Umgebungen, in denen kann UTF-8-Codierung stattdessen verwendet werden.  
  
   
  
## Examples  
 Im folgende Beispiel bestimmt die Anzahl der Bytes, die erforderlich sind, um ein Array von Zeichen zu codieren, codiert die Zeichen und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Codierung für das UTF-8-Format ab.</summary>
        <value>Eine Codierung für das UTF-8-Format.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt eine <xref:System.Text.UTF8Encoding> Objekt, das Unicode (UTF-16-codierte)-Zeichen in eine Folge von ein bis vier Bytes pro Zeichen codiert und, die ein UTF-8-codierte Bytearray in Unicode (UTF-16-codierte) Zeichen decodiert. Weitere Informationen dazu, die zeichencodierungen, die von .NET und eine Beschreibung der um zu verwendende Codierung Unicode-Zeichen unterstützt werden, finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md).  
  
 Die <xref:System.Text.UTF8Encoding> -Objekt, das von dieser Eigenschaft zurückgegeben wird möglicherweise nicht das richtige Verhalten für Ihre app.  
  
-   Gibt eine <xref:System.Text.UTF8Encoding> Objekt, das eine Unicode-bytereihenfolgemarkierung (BOM) bereitstellt. Rufen Sie Überladung der zum Instanziieren einer UTF8-Codierung, die eine Bytereihenfolge-Marke bereitstellen, nicht die <xref:System.Text.UTF8Encoding.%23ctor%2A> Konstruktor.  
  
-   Gibt eine <xref:System.Text.UTF8Encoding> -Objekt, das verwendet einen Ersatzfallback, ersetzen Sie jede Zeichenfolge, die nicht codiert werden können und jedes Byte, die nicht decodiert durch ein Fragezeichen ("?") Zeichen. Stattdessen rufen Sie die <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor zum Instanziieren einer <xref:System.Text.UTF8Encoding> -Objekt, dessen Fallback entweder ist, ein <xref:System.Text.EncoderFallbackException> oder ein <xref:System.Text.DecoderFallbackException>, wie im folgende Beispiel veranschaulicht.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 Das folgende Beispiel definiert ein Array, das aus der folgenden Zeichen:  
  
-   KLEINES LATEINISCHES Z (U + 007A)  
  
-   LATEINISCHE KLEINE BUCHSTABEN EINER (U + 0061 IST)  
  
-   KOMBINIEREN VON BREVIS (U + 0306)  
  
-   KLEINES LATEINISCHES AE MIT AKUTE (U + 01FD)  
  
-   GRIECHISCHE BUCHSTABE BETA (U + 03B2)  
  
-   Ein Ersatzzeichenpaar (U + D800 U + DD54), die griechischen ACROPHONIC ATTIC eine TAUSEND STATERS (U + 10154) bildet.  
  
 Es zeigt die UTF-16-Codeeinheiten der einzelnen Zeichen und bestimmt die Anzahl der Bytes, die durch einen UTF-8-Encoder zum Codieren der Zeichen erforderlich. Anschließend werden die Zeichen codiert und zeigt die resultierende UTF-8-codierten Bytes.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird der Name für die aktuelle Codierung bei der Internet Assigned Numbers Authority (IANA) registriert.</summary>
        <value>Der IANA-Name für die aktuelle <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoding.WebName%2A> Eigenschaft ist identisch mit der <xref:System.Text.EncodingInfo.Name%2A> Eigenschaft.  
  
 Beachten Sie, dass <xref:System.Text.Encoding.WebName%2A> gibt einen IANA registrierten Namen für die Codierung zurück. Wenn der Wert der Name der Standard ist, entspricht die Implementierung der Codierung möglicherweise nicht vollständig dieses Standards. Die <xref:System.Text.Encoding.HeaderName%2A> Eigenschaft definiert eine andere Codierung, die für die e-Mail-Header besser geeignet sein könnte. Allerdings sollten die meisten apps verwenden <xref:System.Text.Encoding.WebName%2A> stattdessen.  
  
 Weitere Informationen zur IANA finden Sie unter [www.iana.org](https://www.iana.org/).  
  
 Die <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> ist identisch mit der <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> zurückgegebenes <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. Einige der Webnamen sind Duplikate. finden Sie unter den Hinweisen zu <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> für Weitere Informationen.  
  
   
  
## Examples  
 Das folgende Beispiel schließt den <xref:System.Text.Encoding.WebName%2A> in einem HTML-Header.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 Im folgenden Beispiel werden die anderen Namen für jede Codierung abgerufen, und zeigt die Codierungen mit ein oder mehrere Namen, die von unterscheiden <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Es zeigt <xref:System.Text.Encoding.EncodingName%2A> jedoch nicht dafür verglichen.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beim Überschreiben in einer abgeleiteten Klasse wird die Codepage des Betriebssystems Windows abgerufen, die der aktuellen Codierung am ehesten entspricht.</summary>
        <value>Die Codepage des Betriebssystems Windows, die der aktuellen <see cref="T:System.Text.Encoding" /> am ehesten entspricht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird für die Kompatibilität mit der Windows-MultiLanguage (MLang)-APIs, z. B. zur Ermittlung der Schriftfamilien. Für die Globalisierung wird die Verwendung eines Unicode-Codierungen stattdessen empfohlen. Es empfiehlt sich auch mit <xref:System.Text.Encoding.WebName%2A> anstelle von <xref:System.Text.Encoding.WindowsCodePage%2A> um die Codepage zu identifizieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, die Windows-Codepage, die jeder Codierung am ehesten entspricht.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>