<Type Name="UnicodeEncoding" FullName="System.Text.UnicodeEncoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="722dc8e8d6e5f0909480ce2909c02add2ffb7ec9" /><Meta Name="ms.sourcegitcommit" Value="81ab118287bf69d10df7204c332592eac20b1b60" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/11/2019" /><Meta Name="ms.locfileid" Value="74236935" /></Metadata><TypeSignature Language="C#" Value="public class UnicodeEncoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnicodeEncoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UnicodeEncoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UnicodeEncoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnicodeEncoding : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UnicodeEncoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine UTF-16-Codierung von Unicode-Zeichen dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Kodieren werden Unicode-Zeichen in eine Bytefolge transformiert. Beim Decodieren wird eine Sequenz codierter Bytes in eine Gruppe von Unicode-Zeichen transformiert.  
  
 Gemäß [Unicode-Standard](https://go.microsoft.com/fwlink/?linkid=37123) werden jedem Zeichen aller unterstützten Skripts ein Codepunkt (eine Zahl) und ein Name zugewiesen. UTF (Unicode Transformation Format) ist eine Möglichkeit, diesen Codepunkt zu codieren. Der [Unicode-Standard](https://go.microsoft.com/fwlink/?linkid=37123) verwendet die folgenden UTFs:  
  
-   UTF-8, das die einzelnen Code Punkte als Sequenz von einem bis vier Bytes darstellt.  
  
-   UTF-16, das die einzelnen Code Punkte als Sequenz von einer bis zu 2 16-Bit-Ganzzahlen darstellt.  
  
-   UTF-32, das die einzelnen Code Punkte als 32-Bit-Ganzzahl darstellt.  
  
 Weitere Informationen zu den UTFs und anderen Codierungen, die von <xref:System.Text>unterstützt werden, finden Sie unter [Zeichencodierung in der .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Die <xref:System.Text.UnicodeEncoding>-Klasse stellt eine UTF-16-Codierung dar. Der Encoder kann entweder die Big-Endian-Byte Reihenfolge (Das signifikanteste Byte zuerst) oder die kleine Endian-Byte Reihenfolge (das am wenigsten signifikante Byte) Der lateinische Großbuchstabe A (Codepunkt U + 0041) wird z. b. wie folgt serialisiert (in Hexadezimal):  
  
-   Big-Endian-Byte Reihenfolge: 00 00 00 41  
  
-   Little-Endian-Byte Reihenfolge: 41 00 00 00  
  
 Es ist in der Regel effizienter, Unicode-Zeichen mithilfe der systemeigenen Byte Reihenfolge einer bestimmten Plattform zu speichern. Beispielsweise ist es besser, die Little-Endian-Byte Reihenfolge auf kleinen Endian-Plattformen wie z. b. Intel-Computern zu verwenden. Die <xref:System.Text.UnicodeEncoding>-Klasse entspricht den Windows-Codepages 1200 (Little-Endian-Byte Reihenfolge) und 1201 (Big Endian-Byte Reihenfolge). Sie können die "Einschreibung" einer bestimmten Architektur ermitteln, indem Sie die <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType>-Methode aufrufen.  
  
 Das <xref:System.Text.UnicodeEncoding>-Objekt stellt optional eine Byte Reihenfolge-Marke (Byte Order Mark, BOM) bereit, bei der es sich um ein Bytearray handelt, dem die Bytefolge des Codierungs Prozesses vorangestellt werden kann. Wenn die Präambel eine Byte Reihenfolge-Marke (BOM) enthält, unterstützt Sie der Decoder dabei, die Byte Reihenfolge und das Transformations Format oder UTF zu bestimmen.  
  
 Wenn die <xref:System.Text.UnicodeEncoding> Instanz so konfiguriert ist, dass Sie eine BOM bereitstellt, können Sie Sie abrufen, indem Sie die <xref:System.Text.UnicodeEncoding.GetPreamble%2A>-Methode aufrufen. Andernfalls gibt die Methode ein leeres Array zurück. Beachten Sie, dass Sie, selbst wenn ein <xref:System.Text.UnicodeEncoding> Objekt für die BOM-Unterstützung konfiguriert ist, die BOM nach Bedarf am Anfang des codierten Bytestreams einschließen müssen. die Codierungs Methoden der <xref:System.Text.UnicodeEncoding>-Klasse führen dies nicht automatisch aus.  

> [!CAUTION]
> Um die Fehlererkennung zu aktivieren und die Klasseninstanz sicherer zu machen, sollten Sie ein <xref:System.Text.UnicodeEncoding> Objekt instanziieren, indem Sie den <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29>-Konstruktor aufrufen und dessen `throwOnInvalidBytes` Argument auf `true`festlegen. Bei der Fehlererkennung löst eine Methode, die eine ungültige Sequenz von Zeichen oder Bytes erkennt, eine <xref:System.ArgumentException>aus. Ohne Fehlererkennung wird keine Ausnahme ausgelöst, und die ungültige Sequenz wird im Allgemeinen ignoriert.  
  
 Sie können ein <xref:System.Text.UnicodeEncoding> Objekt auf verschiedene Weise instanziieren, abhängig davon, ob Sie eine Byte Reihenfolge-Marke (BOM) bereitstellen möchten, ob Sie Big-Endian-oder Little-Endian-Codierung wünschen und ob Sie die Fehlererkennung aktivieren möchten. In der folgenden Tabelle werden die <xref:System.Text.UnicodeEncoding>-Konstruktoren und die <xref:System.Text.Encoding> Eigenschaften aufgelistet, die ein <xref:System.Text.UnicodeEncoding>-Objekt zurückgeben.  
  
|Member|Endianness|BOM|Fehlererkennung|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.BigEndianUnicode%2A>|Big-tedian|Ja|Nein (Ersatz Fall Back)|  
|<xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType>|Little-d|Ja|Nein (Ersatz Fall Back)|  
|<xref:System.Text.UnicodeEncoding.%23ctor?displayProperty=nameWithType>|Little-d|Ja|Nein (Ersatz Fall Back)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29>|Konfigurierbare|Konfigurierbare|Nein (Ersatz Fall Back)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Konfigurierbare|Konfigurierbare|Konfigurierbare|  
  
 Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.UnicodeEncoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.  
  
 Ebenso bestimmt die <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Methode, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die Methoden <xref:System.Text.UnicodeEncoding.GetChars%2A> und <xref:System.Text.UnicodeEncoding.GetString%2A> führen die eigentliche Decodierung aus.  
  
 Für einen Encoder oder Decoder, der zum Speichern von Zustandsinformationen, die beim Codieren oder Decodieren von Daten, die umfasst mehrere Blöcke (z. B. String von 1 Mio. Zeichen, die in Segmenten von 100.000 Zeichen codiert wird) verwenden, können die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> und <xref:System.Text.UnicodeEncoding.GetDecoder%2A> Eigenschaften bzw.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie eine Zeichenfolge von Unicode-Zeichen in ein Bytearray mithilfe eines <xref:System.Text.UnicodeEncoding>-Objekts codiert wird. Das Bytearray wird in eine Zeichenfolge decodiert, um zu veranschaulichen, dass kein Datenverlust vorliegt.  
  
 [!code-cpp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/snippet.vb#1)]  
  
 Im folgenden Beispiel wird dieselbe Zeichenfolge wie die vorherige verwendet, außer dass die codierten Bytes in eine Datei geschrieben und der Bytestream mit einer Byte Reihenfolge Markierung (BOM) vorangestellt wird. Anschließend wird die Datei auf zwei verschiedene Arten gelesen: als Textdatei mit einem <xref:System.IO.StreamReader> Objekt. und als Binärdatei. Erwartungsgemäß enthält weder die neu gelesene Zeichenfolge die BOM.  
  
 [!code-csharp[System.Text.UnicodeEncoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF32Encoding" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.UTF7Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.UnicodeEncoding" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.UnicodeEncoding" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt eine Instanz, die die Little-Endian-Byte Reihenfolge verwendet, eine Unicode-Byte Reihenfolge Markierung bereitstellt und keine Ausnahme auslöst, wenn eine ungültige Codierung erkannt wird.  
  
> [!CAUTION]
>  Aus Sicherheitsgründen sollten Sie die Fehlererkennung aktivieren, indem Sie den <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29>-Konstruktor aufrufen und das `throwOnInvalidBytes`-Argument auf `true`festlegen.
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie eine neue <xref:System.Text.UnicodeEncoding>-Instanz erstellt und der Name der Codierung angezeigt wird.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="F#" Value="new System.Text.UnicodeEncoding : bool * bool -&gt; System.Text.UnicodeEncoding" Usage="new System.Text.UnicodeEncoding (bigEndian, byteOrderMark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian"><see langword="true" />, um die Big-Endian-Bytereihenfolge (mit dem höchstwertigen Byte an erster Stelle) zu verwenden, oder <see langword="false" />, um die Little-Endian-Bytereihenfolge (mit dem niedrigstwertigen Byte an erster Stelle) zu verwenden.</param>
        <param name="byteOrderMark"><see langword="true" />, um anzugeben, dass die <see cref="M:System.Text.UnicodeEncoding.GetPreamble" />-Methode eine Unicode-Bytereihenfolgemarkierung zurückgibt; andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.UnicodeEncoding" />-Klasse. Parameter geben an, ob die Big-Endian-Bytereihenfolge verwendet werden soll und die <see cref="M:System.Text.UnicodeEncoding.GetPreamble" />-Methode eine Unicode-Bytereihenfolgemarkierung zurückgibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt eine-Instanz, die keine Ausnahme auslöst, wenn eine ungültige Codierung erkannt wird.  
  
> [!CAUTION]
>  Aus Sicherheitsgründen sollten Sie die Fehlererkennung aktivieren, indem Sie den <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29>-Konstruktor aufrufen und das `throwOnInvalidBytes`-Argument auf `true`festlegen.  
  
 Der `byteOrderMark`-Parameter steuert den Betrieb der <xref:System.Text.UnicodeEncoding.GetPreamble%2A> Methode. Wenn `true`, gibt die Methode ein Bytearray zurück, das die Unicode-Byte Reihenfolge-Marke (BOM) im UTF-16-Format enthält.  Wenn `false`, wird ein Bytearray der Länge 0 (null) zurückgegeben. Wenn Sie jedoch `byteOrderMark` auf `true` festlegen, bewirkt dies nicht, dass die <xref:System.Text.UnicodeEncoding.GetBytes%2A>-Methode der BOM am Anfang des Bytearrays vorangestellt wird. Außerdem bewirkt dies, dass die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode die Anzahl der Bytes in der BOM in der Byte Anzahl nicht einschließt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie eine neue <xref:System.Text.UnicodeEncoding>-Instanz erstellt wird, die angibt, ob Little-Endian oder Big-Endian-Byte Reihenfolge und die Unicode-Byte Reihenfolge  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="F#" Value="new System.Text.UnicodeEncoding : bool * bool * bool -&gt; System.Text.UnicodeEncoding" Usage="new System.Text.UnicodeEncoding (bigEndian, byteOrderMark, throwOnInvalidBytes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bigEndian"><see langword="true" />, um die Big-Endian-Bytereihenfolge (mit dem höchstwertigen Byte an erster Stelle) oder <see langword="false" />, um die Little-Endian-Bytereihenfolge (mit dem niedrigstwertigen Byte an erster Stelle) zu verwenden.</param>
        <param name="byteOrderMark"><see langword="true" />, um anzugeben, dass die <see cref="M:System.Text.UnicodeEncoding.GetPreamble" />-Methode eine Unicode-Bytereihenfolgemarkierung zurückgibt; andernfalls <see langword="false" />.</param>
        <param name="throwOnInvalidBytes"><see langword="true" /> um anzugeben, dass eine Ausnahme ausgelöst werden soll, wenn eine ungültige Codierung gefunden wird, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.UnicodeEncoding" />-Klasse. Parameter geben an, ob die Big-Endian-Bytereihenfolge verwendet, eine Unicode-Bytereihenfolgemarkierung bereitgestellt und beim Erkennen einer ungültigen Codierung eine Ausnahme ausgelöst werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `byteOrderMark`-Parameter steuert den Betrieb der <xref:System.Text.UnicodeEncoding.GetPreamble%2A> Methode. Wenn `true`, gibt die Methode ein Bytearray zurück, das die Unicode-Byte Reihenfolge-Marke (BOM) im UTF-16-Format enthält.  Wenn `false`, wird ein Bytearray der Länge 0 (null) zurückgegeben. Wenn Sie jedoch `byteOrderMark` auf `true` festlegen, bewirkt dies nicht, dass die <xref:System.Text.UnicodeEncoding.GetBytes%2A>-Methode der BOM am Anfang des Bytearrays vorangestellt wird. Außerdem bewirkt dies, dass die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode die Anzahl der Bytes in der BOM in der Byte Anzahl nicht einschließt.  
  
 Wenn der `throwOnInvalidBytes`-Parameter `true`ist, löst eine Methode, die eine ungültige Byte Sequenz erkennt, <xref:System.ArgumentException?displayProperty=nameWithType>aus. Andernfalls löst die Methode keine Ausnahme aus, und die ungültige Sequenz wird ignoriert.  
  
> [!CAUTION]
>  Aus Sicherheitsgründen sollten Sie diesen Konstruktor verwenden, um eine Instanz der <xref:System.Text.UnicodeEncoding>-Klasse zu erstellen und die Fehlererkennung zu aktivieren, indem Sie `throwOnInvalidBytes` auf `true`festlegen.  
  
## Examples  
 Im folgenden Beispiel wird das Verhalten von <xref:System.Text.UnicodeEncoding>mit aktivierter Fehlererkennung und ohne veranschaulicht.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/VB/errordetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="CharSize">
      <MemberSignature Language="C#" Value="public const int CharSize = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 CharSize = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Text.UnicodeEncoding.CharSize" />
      <MemberSignature Language="VB.NET" Value="Public Const CharSize As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int CharSize = 2;" />
      <MemberSignature Language="F#" Value="val mutable CharSize : int" Usage="System.Text.UnicodeEncoding.CharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Stellt die Unicode-Zeichengröße in Bytes dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieses Felds ist eine 32-Bit-Konstante mit Vorzeichen mit einem Wert von 2.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie der Wert von <xref:System.Text.UnicodeEncoding.CharSize> zurückgegeben und angezeigt wird.  
  
 [!code-cpp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CPP/charsize.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CS/charsize.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/VB/charsize.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="unicodeEncoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das mit dem aktuellen Objekt verglichen werden soll.</param>
        <summary>Bestimmt, ob das angegebene <see cref="T:System.Object" /> und das aktuelle <see cref="T:System.Text.UnicodeEncoding" />-Objekt gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="value" /> eine Instanz von <see cref="T:System.Text.UnicodeEncoding" /> und mit dem aktuellen Objekt identisch ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei <xref:System.Text.UnicodeEncoding> Objekte werden als gleich betrachtet, wenn alle der folgenden Bedingungen zutreffen:  
  
-   Beide Objekte verwenden die gleiche Byte Reihenfolge (Little-Endian oder Big-Endian).  
  
-   Beide-Objekte stellen die Byte Reihenfolge-Marke oder beides nicht bereit.  
  
-   Beide Objekte verwenden denselben EncoderFallback.  
  
-   Beide Objekte verwenden denselben Decoder-Fallback.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.Equals%2A>-Methode verwendet wird, um zu testen, ob das aktuelle <xref:System.Text.UnicodeEncoding>-Objekt gleich einem anderen <xref:System.Text.UnicodeEncoding>-Objekt ist. Fünf <xref:System.Text.UnicodeEncoding> Objekte werden erstellt und verglichen, und die Ergebnisse der Vergleiche werden angezeigt.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen erzeugt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="unicodeEncoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolge, die die Menge der angegebenen Zeichen enthält.</param>
        <summary>Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen in der angegebenen Zeichenfolge erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UnicodeEncoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
> [!IMPORTANT]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Bytefolge, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers, und die Anzahl der Bytes in der Präambel wird nicht in dem Wert widergespiegelt, der von der <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29>-Methode zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Methoden <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> und <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> aufgerufen, um die maximale und tatsächliche Anzahl von Bytes zu berechnen, die zum Codieren einer Zeichenfolge erforderlich sind. Es zeigt auch die tatsächliche Anzahl von Bytes an, die zum Speichern eines Bytestreams mit einer Byte Reihenfolge-Marke erforderlich ist.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die sich ergebende Anzahl von Bytes ist höher als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="s" /> enthält eine ungültige Folge von Zeichen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="unicodeEncoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">Ein Zeiger auf das erste zu codierende Zeichen.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen ab dem angegebenen Zeichenzeiger erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes erfordert, wird die <xref:System.Text.UnicodeEncoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
> [!IMPORTANT]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Bytefolge, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers, und die Anzahl der Bytes in der Präambel wird nicht in dem Wert widergespiegelt, der von der <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode zurückgegeben wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist kleiner als Null.  
  
- oder - 
Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Zeichenfolge.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="unicodeEncoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray, das die zu codierenden Zeichen enthält.</param>
        <param name="index">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen aus dem angegebenen Zeichenarray erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, verwendet die Anwendung <xref:System.Text.UnicodeEncoding.GetByteCount%2A>. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Wenn die Fehlererkennung aktiviert ist, bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Bytefolge, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers, und die Anzahl der Bytes in der Präambel wird nicht in dem Wert widergespiegelt, der von der <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Methode zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array mit einem lateinischen groß-und Kleinbuchstaben aufgefüllt und die <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Methode aufgerufen, um die Anzahl von Bytes zu bestimmen, die zum Codieren der Zeichen für Lateinische Kleinbuchstaben benötigt werden. Diese Informationen werden dann zusammen mit der Gesamtanzahl der benötigten Bytes angezeigt, wenn eine Byte Reihenfolge-Markierung hinzugefügt wird. Diese Zahl wird mit dem Wert verglichen, der von der <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode zurückgegeben wird, die die maximale Anzahl von Bytes angibt, die zum Codieren der lateinischen Kleinbuchstaben erforderlich sind. Im folgenden Beispiel wird ein Array mit einer Kombination aus griechischen und kyrillischen Zeichen aufgefüllt und die <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Methode aufgerufen, um die Anzahl von Bytes zu bestimmen, die zum Codieren der kyrillischen Zeichen benötigt werden. Diese Informationen werden dann zusammen mit der Gesamtanzahl der benötigten Bytes angezeigt, wenn eine Byte Reihenfolge-Markierung hinzugefügt wird. Diese Zahl wird mit dem Wert verglichen, der von der <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode zurückgegeben wird, die die maximale Anzahl von Bytes angibt, die zum Codieren der kyrillischen Zeichen benötigt werden.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> ist <see langword="null" />(<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0 (null).  
  
- oder - 
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="chars" />an.  
  
- oder - 
Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codiert Zeichen in eine Bytefolge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string -&gt; byte[]" Usage="unicodeEncoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="unicodeEncoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">Ein Zeiger auf das erste zu codierende Zeichen.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <param name="byteCount">Die maximale Anzahl der zu schreibenden Bytes.</param>
        <summary>Codiert Zeichen beginnend am angegebenen Zeichenzeiger in eine Bytefolge, die beginnend am angegebenen Bytezeiger gespeichert wird.</summary>
        <returns>Die tatsächliche Anzahl an Bytes, die an der durch den <paramref name="bytes" />-Parameter angegebenen Position geschrieben wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes erfordert, wird die <xref:System.Text.UnicodeEncoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> Objekt bereitgestellt werden, indem Sie die <xref:System.Text.UnicodeEncoding.GetDecoder%2A> oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> -Methode, bzw.  
  
> [!IMPORTANT]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Folge von Bytes, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers. Die <xref:System.Text.UnicodeEncoding.GetBytes%2A>-Methode stellt dem Anfang einer Sequenz codierter Bytes keine Präambel voran.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> ist <see langword="null" />(<see langword="Nothing" />).  
  
- oder - 
 <paramref name="bytes" /> ist <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> oder <paramref name="byteCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.  
  
- oder - 
 <paramref name="byteCount" /> ist niedriger als die sich ergebende Anzahl von Bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="unicodeEncoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray, das die zu codierenden Zeichen enthält.</param>
        <param name="charIndex">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</param>
        <param name="byteIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <summary>Codiert Zeichen aus dem angegebenen Zeichenarray in das angegebene Bytearray.</summary>
        <returns>Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UnicodeEncoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UnicodeEncoding.GetDecoder%2A> Methode oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> Methode bzw.  
  
> [!IMPORTANT]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Folge von Bytes, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers. Die <xref:System.Text.UnicodeEncoding.GetBytes%2A>-Methode stellt dem Anfang einer Sequenz codierter Bytes keine Präambel voran.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetBytes%2A>-Methode verwendet wird, um einen Bereich von Zeichen aus einem <xref:System.String> zu codieren und die codierten Bytes in einem Bereich von Elementen in einem Bytearray zu speichern.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> ist <see langword="null" />(<see langword="Nothing" />).  
  
- oder - 
 <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />, <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).  
  
- oder - 
 <paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" />an.  
  
- oder - 
 <paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.  
  
- oder - 
 <paramref name="bytes" /> hat von <paramref name="byteIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="unicodeEncoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolge mit den zu codierenden Zeichen.</param>
        <param name="charIndex">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</param>
        <param name="byteIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <summary>Codiert Zeichen aus der angegebenen <see cref="T:System.String" />-Klasse in das angegebene Bytearray.</summary>
        <returns>Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UnicodeEncoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UnicodeEncoding.GetDecoder%2A> Methode oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> Methode bzw.  
  
> [!IMPORTANT]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Folge von Bytes, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers. Die <xref:System.Text.UnicodeEncoding.GetBytes%2A>-Methode stellt dem Anfang einer Sequenz codierter Bytes keine Präambel voran.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Bereich von Elementen aus einem Array von Unicode-Zeichen codiert und die codierten Bytes in einem Bereich von Elementen in einem Bytearray gespeichert werden.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />, <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).  
  
- oder - 
 <paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" />an.  
  
- oder - 
 <paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="s" /> enthält eine ungültige Folge von Zeichen.  
  
- oder - 
 <paramref name="bytes" /> hat von <paramref name="byteIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge erzeugt werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="unicodeEncoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf das erste zu decodierende Byte.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge ab dem angegebenen Bytezeiger erzeugt werden.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UnicodeEncoding.GetChars%2A> zum Speichern der resultierenden Zeichen erfordert, verwendet die Anwendung <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Um die maximale Array Größe zu berechnen, sollte die Anwendung <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>verwenden. Die <xref:System.Text.UnicodeEncoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist kleiner als Null.  
  
- oder - 
Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="unicodeEncoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="index">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge aus dem angegebenen Bytearray erzeugt werden.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der exakten Array Größe, die <xref:System.Text.UnicodeEncoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, verwendet die Anwendung <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Um die maximale Array Größe zu berechnen, sollte die Anwendung <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>verwenden. Die <xref:System.Text.UnicodeEncoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetCharCount%2A>-Methode verwendet wird, um die Anzahl der Zeichen zurückzugeben, die beim Decodieren eines Bereichs von Elementen in einem Bytearray mit <xref:System.Text.UnicodeEncoding>erzeugt werden.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0 (null).  
  
- oder - 
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" />an.  
  
- oder - 
Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodiert eine Bytefolge in Zeichen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="unicodeEncoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf das erste zu decodierende Byte.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="chars">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</param>
        <param name="charCount">Die maximale Anzahl der zu schreibenden Zeichen.</param>
        <summary>Decodiert eine Bytefolge beginnend am angegebenen Bytezeiger in Zeichen, die beginnend am angegebenen Zeichenzeiger gespeichert werden.</summary>
        <returns>Die tatsächliche Anzahl der Zeichen, die an der durch den <paramref name="chars" />-Parameter angegebenen Position geschrieben wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UnicodeEncoding.GetChars%2A> zum Speichern der resultierenden Zeichen erfordert, verwendet die Anwendung <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Um die maximale Array Größe zu berechnen, sollte die Anwendung <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>verwenden. Die <xref:System.Text.UnicodeEncoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Wenn der zu decodierte Byte Bereich die Byte Reihenfolge-Marke (Byte Order Mark, BOM) einschließt und das Bytearray von einer Methode eines nicht-BOM-fähigen Typs zurückgegeben wurde, ist das Zeichen U + FFFE in dem von dieser Methode zurückgegebenen Zeichen Array enthalten. Sie können es entfernen, indem Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufrufen.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> Objekt bereitgestellt werden, indem Sie die <xref:System.Text.UnicodeEncoding.GetDecoder%2A> oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> -Methode, bzw.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).  
  
- oder - 
 <paramref name="chars" /> ist <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> oder <paramref name="charCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.  
  
- oder - 
 <paramref name="charCount" /> ist niedriger als die sich ergebende Anzahl von Zeichen.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="unicodeEncoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="byteIndex">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="chars">Das Zeichenarray, das die sich ergebenden Zeichen enthalten soll.</param>
        <param name="charIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</param>
        <summary>Decodiert eine Bytefolge aus dem angegebenen Bytearray in das angegebene Zeichenarray.</summary>
        <returns>Die tatsächliche Anzahl der Zeichen, die in <paramref name="chars" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der exakten Array Größe, die <xref:System.Text.UnicodeEncoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, verwendet die Anwendung <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Um die maximale Array Größe zu berechnen, sollte die Anwendung <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>verwenden. Die <xref:System.Text.UnicodeEncoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Wenn der zu decodierte Byte Bereich die Byte Reihenfolge-Marke (Byte Order Mark, BOM) einschließt und das Bytearray von einer Methode eines nicht-BOM-fähigen Typs zurückgegeben wurde, ist das Zeichen U + FFFE in dem von dieser Methode zurückgegebenen Zeichen Array enthalten. Sie können es entfernen, indem Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufrufen.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UnicodeEncoding.GetDecoder%2A> Methode oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> Methode bzw.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetChars%2A>-Methode verwendet wird, um einen Bereich von Elementen in einem Bytearray zu decodieren und das Ergebnis in einem Zeichen Array zu speichern.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).  
  
- oder - 
 <paramref name="chars" /> ist <see langword="null" />(<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" />, <paramref name="byteCount" /> oder <paramref name="charIndex" /> ist kleiner als 0 (null).  
  
- oder - 
 <paramref name="byteindex" /> und <paramref name="byteCount" /> geben keinen gültigen Bereich in <paramref name="bytes" />an.  
  
- oder - 
 <paramref name="charIndex" /> ist kein gültiger Index in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.  
  
- oder - 
 <paramref name="chars" /> hat von <paramref name="charIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Zeichen aufzunehmen.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="unicodeEncoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Decoder ab, der eine UTF-16-codierte Bytefolge in eine Unicode-Zeichenfolge konvertiert.</summary>
        <returns>Ein <see cref="T:System.Text.Decoder" />, der eine UTF-16-codierte Bytefolge in eine Unicode-Zeichenfolge konvertiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode konvertiert sequenzielle Block von Bytes ähnlich wie die <xref:System.Text.UnicodeEncoding.GetChars%2A>in sequenzielle Zeichenblöcke. Eine <xref:System.Text.Decoder> behält jedoch Zustandsinformationen zwischen Aufrufen bei, damit Byte Sequenzen, die Blöcke spannen, ordnungsgemäß decodiert werden können. Der <xref:System.Text.Decoder> behält auch nachfolgende Bytes am Ende der Datenblöcke bei und verwendet die nachfolgenden Bytes im nächsten Decodierungs Vorgang. Aus diesem Grund sind <xref:System.Text.UnicodeEncoding.GetDecoder%2A> und <xref:System.Text.UnicodeEncoding.GetEncoder%2A> für Netzwerkübertragungs-und Datei Vorgänge nützlich, da diese Vorgänge häufig Datenblöcke anstelle eines gesamten Datenstroms behandeln.  
  
 Wenn die Fehlererkennung aktiviert ist, d. h. der `throwOnInvalidBytes`-Parameter des Konstruktors auf `true`festgelegt ist, wird die Fehlererkennung auch in der <xref:System.Text.Decoder> aktiviert, die von dieser Methode zurückgegeben wird. Wenn die Fehlererkennung aktiviert ist und eine ungültige Sequenz gefunden wird, ist der Status des Decoders nicht definiert, und die Verarbeitung muss beendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Encoder und ein Decoder verwendet, um eine Zeichenfolge in ein Bytearray zu codieren und anschließend die Bytes in ein Zeichen Array zu decodieren.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="unicodeEncoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Encoder ab, der eine Unicode-Zeichenfolge in eine UTF-16-codierte Bytefolge konvertiert.</summary>
        <returns>Ein <see cref="T:System.Text.Encoder" />-Objekt, das eine Unicode-Zeichenfolge in eine UTF-16-codierte Bytefolge konvertiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode konvertiert sequenzielle Zeichenblöcke auf eine Weise, die der <xref:System.Text.UnicodeEncoding.GetBytes%2A>-Methode dieser Klasse ähnelt, in sequenzielle Byte Blöcke. Ein <xref:System.Text.Encoder>-Objekt behält jedoch Zustandsinformationen zwischen Aufrufen bei, sodass es Zeichen folgen, die Blöcke spannen, ordnungsgemäß codieren kann. Das <xref:System.Text.Encoder> Objekt behält auch nachfolgende Zeichen am Ende der Datenblöcke bei und verwendet die nachfolgenden Zeichen im nächsten Codierungs Vorgang. Beispielsweise kann ein Datenblock mit einem nicht übereinstimmenden hohen Ersatz Zeichen enden, und das entsprechende niedrige Ersatz Zeichen kann sich im nächsten Datenblock befinden. Aus diesem Grund sind <xref:System.Text.UnicodeEncoding.GetDecoder%2A> und <xref:System.Text.UnicodeEncoding.GetEncoder%2A> für Netzwerkübertragungs-und Datei Vorgänge nützlich, da diese Vorgänge häufig Datenblöcke anstelle eines gesamten Datenstroms behandeln.  
  
 Wenn die Fehlererkennung aktiviert ist, d. h. der `throwOnInvalidBytes`-Parameter des Konstruktors auf `true`festgelegt ist, wird die Fehlererkennung auch in dem <xref:System.Text.Encoder> Objekt aktiviert, das von dieser Methode zurückgegeben wird. Wenn die Fehlererkennung aktiviert ist und eine ungültige Sequenz gefunden wird, ist der Status des Encoders nicht definiert, und die Verarbeitung muss beendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Encoder und ein Decoder verwendet, um eine Zeichenfolge in ein Bytearray zu codieren und anschließend die Bytes in ein Zeichen Array zu decodieren.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="unicodeEncoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für die aktuelle Instanz zurück.</summary>
        <returns>Der Hashcode für das aktuelle <see cref="T:System.Text.UnicodeEncoding" />-Objekt.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="unicodeEncoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet die maximale Anzahl der Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt wird.</summary>
        <returns>Die maximale Anzahl an Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, verwendet die Anwendung <xref:System.Text.UnicodeEncoding.GetByteCount%2A>. Um die maximale Array Größe zu berechnen, sollte die Anwendung <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>verwenden. Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Ruft die Nummer des ungünstigsten Falls ab, einschließlich des ungünstigsten Falls für den aktuell ausgewählten <xref:System.Text.EncoderFallback>. Wenn ein Fall Back mit einer potenziell großen Zeichenfolge ausgewählt wird, können <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> große Werte zurückgeben.  
  
 In den meisten Fällen ruft diese Methode angemessene Zahlen für kleine Zeichen folgen ab. Bei großen Zeichen folgen müssen Sie möglicherweise zwischen der Verwendung sehr großer Puffer und dem Abfangen von Fehlern wählen, wenn ein sinnvoller Puffer überschritten wird. Möglicherweise möchten Sie auch einen anderen Ansatz mit <xref:System.Text.UnicodeEncoding.GetByteCount%2A> oder <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>in Erwägung gezogen.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> hat keine Beziehung zu <xref:System.Text.UnicodeEncoding.GetChars%2A>. Wenn Ihre Anwendung eine ähnliche Funktion benötigt, um mit <xref:System.Text.UnicodeEncoding.GetChars%2A>zu verwenden, sollte <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>verwendet werden.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` ist nicht notwendigerweise derselbe Wert wie `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode verwendet wird, um die maximale Anzahl von Bytes zurückzugeben, die zum Codieren einer angegebenen Anzahl von Zeichen erforderlich sind.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> ist kleiner als Null.  
  
- oder - 
Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
- und - 
 Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="unicodeEncoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet die maximale Anzahl der Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</summary>
        <returns>Die maximale Anzahl von Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der exakten Array Größe, die <xref:System.Text.UnicodeEncoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, verwendet die Anwendung <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Um die maximale Array Größe zu berechnen, sollte die Anwendung <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>verwenden. Die <xref:System.Text.UnicodeEncoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Ruft die Nummer des ungünstigsten Falls ab, einschließlich des ungünstigsten Falls für den aktuell ausgewählten <xref:System.Text.DecoderFallback>. Wenn ein Fall Back mit einer potenziell großen Zeichenfolge ausgewählt wird, ruft <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> große Werte ab.  
  
 In den meisten Fällen ruft diese Methode angemessene Zahlen für kleine Zeichen folgen ab. Bei großen Zeichen folgen müssen Sie möglicherweise zwischen der Verwendung sehr großer Puffer und dem Abfangen von Fehlern wählen, wenn ein sinnvoller Puffer überschritten wird. Möglicherweise möchten Sie auch einen anderen Ansatz mit <xref:System.Text.UnicodeEncoding.GetCharCount%2A> oder <xref:System.Text.Decoder.Convert%2A>in Erwägung gezogen.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> hat keine Beziehung zu <xref:System.Text.UnicodeEncoding.GetBytes%2A>. Wenn Ihre Anwendung eine ähnliche Funktion benötigt, um mit <xref:System.Text.UnicodeEncoding.GetBytes%2A>zu verwenden, sollte <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>verwendet werden.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` ist nicht notwendigerweise derselbe Wert wie `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>-Methode verwendet wird, um die maximale Anzahl von Zeichen zurückzugeben, die beim Decodieren einer angegebenen Anzahl von Bytes erzeugt werden.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> ist kleiner als Null.  
  
- oder - 
Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="unicodeEncoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine im UTF-16-Format codierte Unicode-Bytereihenfolgemarkierung zurück, wenn der Konstruktor für diese Instanz die Bereitstellung einer Bytereihenfolgemarkierung anfordert.</summary>
        <returns>Ein Bytearray, das die Unicode-Bytereihenfolgemarkierung enthält, wenn das <see cref="T:System.Text.UnicodeEncoding" /> -Objekt dafür konfiguriert ist, eine bereitzustellen. Andernfalls gibt diese Methode ein Bytearray mit der Länge Null zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Text.UnicodeEncoding>-Objekt kann eine Präambel bereitstellen, bei der es sich um ein Bytearray handelt, dem die Byte Sequenz vorangestellt werden kann, die sich aus dem Codierungsprozess ergibt. Wenn eine Sequenz codierter Bytes mit einer Byte Reihenfolge-Markierung (Codepunkt U + FEFF) vorangestellt ist, kann der Decoder die Byte Reihenfolge und das Transformations Format oder UTF festlegen. Die Unicode-Byte Reihenfolge Markierung (BOM) wird wie folgt serialisiert (in Hexadezimal):  
  
-   Big-Endian-Byte Reihenfolge: FE FF  
  
-   Little-Endian-Byte Reihenfolge: FF FE  
  
 Sie können ein <xref:System.Text.UnicodeEncoding> Objekt instanziieren, dessen <xref:System.Text.UnicodeEncoding.GetPreamble%2A> Methode eine gültige BOM auf folgende Weise zurückgibt:  
  
-   Durch Abrufen des <xref:System.Text.UnicodeEncoding> Objekts, das von der <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType>-oder <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird.  
  
-   Durch Aufrufen des Parameter losen <xref:System.Text.UnicodeEncoding.%23ctor> Konstruktors, um ein <xref:System.Text.UnicodeEncoding> Objekt zu instanziieren.  
  
-   Durch Bereitstellen von `true` als Wert des `byteOrderMark` Arguments für die <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> oder <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktoren.  
  
 Es wird empfohlen, die BOM zu verwenden, da Sie eine bestimmte Identifizierung einer Codierung für Dateien bereitstellt, die andernfalls einen Verweis auf ihre Codierung verloren haben, z. b. nicht markierte oder nicht ordnungsgemäß markierte Webdaten oder Zufalls Textdateien, die gespeichert wurden, wenn ein Unternehmen nicht über internationale Probleme. Häufig können Benutzer Probleme vermieden werden, wenn die Daten konsistent und ordnungsgemäß gekennzeichnet sind.  
  
 Bei Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant. Sie kann jedoch verwendet werden, um einem Server zu helfen, den richtigen Codierungs Header zu senden. Alternativ kann es als Fall Back für den Fall verwendet werden, dass die Codierung andernfalls verloren geht.  
  
 Es gibt einige Nachteile bei der Verwendung einer BOM. Beispielsweise kann das Einschränken der Datenbankfelder, die eine BOM verwenden, schwierig sein. Die Verkettung von Dateien kann auch ein Problem darstellen, z. b. wenn Dateien so zusammengeführt werden, dass ein unnötiges Zeichen in der Mitte der Daten enden kann. Trotz der wenigen Nachteile wird die Verwendung einer BOM dringend empfohlen.  
  
> [!IMPORTANT]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie dem Anfang eines Streams codierter Bytes eine Präambel vorangestellt sein. Beachten Sie, dass die <xref:System.Text.UnicodeEncoding.GetBytes%2A>-Methode einer Sequenz codierter Bytes keine BOM voranstellt. das Bereitstellen einer BOM am Anfang eines entsprechenden Bytestreams ist die Verantwortung des Entwicklers.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetPreamble%2A>-Methode verwendet wird, um die Unicode-Byte Reihenfolge-Markierung in Big Endian oder Little-Endian-Byte Reihenfolge für eine Instanz einer <xref:System.Text.UnicodeEncoding>abzurufen.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 Im folgenden Beispiel werden zwei <xref:System.Text.UnicodeEncoding>-Objekte instanziiert, wobei der erste keine BOM bereitstellt, und der zweite-Wert. Anschließend wird die <xref:System.Text.UnicodeEncoding.GetPreamble%2A>-Methode aufgerufen, um die BOM in eine Datei zu schreiben, bevor eine Unicode-codierte Zeichenfolge geschrieben wird. Wie die Konsolenausgabe aus dem Beispiel zeigt, hat die Datei, die die Bytes aus dem zweiten Encoder speichert, drei weitere Bytes als die erste.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/cs/GetPreamble1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/vb/GetPreamble1.vb#1)]  
  
 Sie können die Dateien auch mit dem `fc`-Befehl in einem Konsolenfenster vergleichen, oder Sie können die Dateien in einem Text-Editor untersuchen, der einen Hexadezimal Ansichtsmodus enthält. Beachten Sie, dass die BOM nicht angezeigt wird, wenn die Datei in einem Editor geöffnet wird, der UTF-16-Codierung unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="unicodeEncoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="index">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Decodiert einen Bytebereich aus einem Bytearray in eine Zeichenfolge.</summary>
        <returns>Ein <see cref="T:System.String" />-Objekt, das die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Wenn der zu decodierte Byte Bereich die Byte Reihenfolge-Marke (Byte Order Mark, BOM) einschließt und das Bytearray von einer Methode eines nicht-BOM-fähigen Typs zurückgegeben wurde, ist das Zeichen U + FFFE in dem von dieser Methode zurückgegebenen Zeichen Array enthalten. Sie können es entfernen, indem Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufrufen.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> Objekt bereitgestellt werden, indem Sie die <xref:System.Text.UnicodeEncoding.GetDecoder%2A> oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> -Methode, bzw.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array initialisiert, indem die <xref:System.Text.UnicodeEncoding.GetByteCount%2A>-Methode aufgerufen wird, um genau zu bestimmen, wie viele Bytes für eine codierte Zeichenfolge erforderlich sind, und dann die Größe der Byte Reihenfolge-Marke (BOM) hinzugefügt Im Beispiel wird dann die <xref:System.Text.UnicodeEncoding.GetPreamble%2A>-Methode aufgerufen, um die BOM im Array zu speichern, bevor die <xref:System.Text.Encoding.GetBytes%2A>-Methode aufgerufen wird, um die codierten Bytes im Array zu speichern. Im Beispiel wird dann die <xref:System.Text.UnicodeEncoding.GetString%2A>-Methode aufgerufen, um die Zeichenfolge zu decodieren.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Beachten Sie, dass die decodierte Zeichenfolge in diesem Fall von der ursprünglichen Zeichenfolge abweicht, da Sie mit einer 16-Bit-Byte Reihenfolge Markierung U + FFFD beginnt. Dies bedeutet, dass die beiden Zeichen folgen als ungleich verglichen werden und dass, wenn die Zeichenfolge ausgegeben wird, die BOM als Ersatz Zeichen "?" angezeigt wird. Um die BOM am Anfang der Zeichenfolge zu entfernen, können Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0 (null).  
  
- oder - 
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
- und - 
 Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public override ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.UnicodeEncoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.UnicodeEncoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Unicode-Bytereihenfolgemarkierung im UTF-16-Format ab, wenn dieses Objekt entsprechend konfiguriert ist.</summary>
        <value>Eine Byte Spanne, die die Unicode-Byte Reihenfolge Markierung enthält, wenn dieses Objekt für die Bereitstellung eines solchen konfiguriert ist. andernfalls die Standard Spanne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Text.UnicodeEncoding>-Objekt kann eine Präambel bereitstellen, bei der es sich um eine Byte Spanne handelt, die der Byte Sequenz vorangestellt werden kann, die sich aus dem Codierungsprozess ergibt. Wenn eine Sequenz codierter Bytes mit einer Byte Reihenfolge-Markierung (Codepunkt `U+FEFF`) vorangestellt ist, kann der Decoder die Byte Reihenfolge und das Transformations Format oder UTF festlegen. Die Unicode-Byte Reihenfolge Markierung (BOM) wird wie folgt serialisiert (in Hexadezimal):  
  
-   Big-Endian-Byte Reihenfolge: `FE FF`  
  
-   Little-Endian-Byte Reihenfolge: `FF FE`  
  
 Sie können ein <xref:System.Text.UnicodeEncoding> Objekt, dessen <xref:System.Text.UnicodeEncoding.Preamble> eine gültige BOM ist, auf folgende Weise instanziieren:  
  
-   Durch Abrufen des <xref:System.Text.UnicodeEncoding> Objekts, das von der <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType>-oder <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird.  
  
-   Durch Aufrufen des Parameter losen <xref:System.Text.UnicodeEncoding.%23ctor> Konstruktors, um ein <xref:System.Text.UnicodeEncoding> Objekt zu instanziieren.  
  
-   Durch Bereitstellen von `true` als Wert des `byteOrderMark` Arguments für die <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> oder <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktoren.  
  
 Es wird empfohlen, die BOM zu verwenden, da Sie eine bestimmte Identifizierung einer Codierung für Dateien bereitstellt, die andernfalls einen Verweis auf ihre Codierung verloren haben, z. b. nicht markierte oder nicht ordnungsgemäß markierte Webdaten oder Zufalls Textdateien, die gespeichert wurden, wenn ein Unternehmen nicht über internationale Probleme. Häufig können Benutzer Probleme vermieden werden, wenn die Daten konsistent und ordnungsgemäß gekennzeichnet sind.  
  
 Bei Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant. Sie kann jedoch verwendet werden, um einem Server zu helfen, den richtigen Codierungs Header zu senden. Alternativ kann es als Fall Back für den Fall verwendet werden, dass die Codierung andernfalls verloren geht.  
  
 Es gibt einige Nachteile bei der Verwendung einer BOM. Beispielsweise kann das Einschränken der Datenbankfelder, die eine BOM verwenden, schwierig sein. Die Verkettung von Dateien kann auch ein Problem darstellen, z. b. wenn Dateien so zusammengeführt werden, dass ein unnötiges Zeichen in der Mitte der Daten enden kann. Trotz der wenigen Nachteile wird die Verwendung einer BOM dringend empfohlen.  
  
> [!IMPORTANT]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie dem Anfang eines Streams codierter Bytes eine Präambel vorangestellt sein. Beachten Sie, dass die <xref:System.Text.UnicodeEncoding.GetBytes%2A>-Methode einer Sequenz codierter Bytes keine BOM voranstellt. das Bereitstellen einer BOM am Anfang eines entsprechenden Bytestreams ist die Verantwortung des Entwicklers.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
