<Type Name="UnicodeEncoding" FullName="System.Text.UnicodeEncoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="22ebf97fd5f5abb243ec2a9c45f66697f07852d6" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36408035" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UnicodeEncoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnicodeEncoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UnicodeEncoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UnicodeEncoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnicodeEncoding : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UnicodeEncoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a UTF-16 encoding of Unicode characters.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Kodieren werden Unicode-Zeichen in eine Bytefolge transformiert. Beim Decodieren wird transformiert eine codierte Bytefolge in einen Satz von Unicode-Zeichen.  
  
 Die [Unicode-Standard](http://go.microsoft.com/fwlink/?linkid=37123) jedes Zeichen aller unterstützten Skripts einen Codepunkt (eine Zahl) zugewiesen. Eine Transformation Format UTF (Unicode) ist eine Möglichkeit, diesen Codepunkt codieren. Die [Unicode-Standard](http://go.microsoft.com/fwlink/?linkid=37123) verwendet die folgenden UTFs:  
  
-   UTF-8, jeden Codepunkt als eine Folge von ein bis vier Bytes dar.  
  
-   UTF-16, die jeden Codepunkt als Folge von ein bis zwei 16-Bit-Ganzzahlen darstellt.  
  
-   UTF-32, jeden Codepunkt als 32-Bit-Ganzzahl dar.  
  
 Weitere Informationen zu den UTFs und andere von unterstützten Codierungen <xref:System.Text>, finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Die <xref:System.Text.UnicodeEncoding> Klasse stellt eine UTF-16-Codierung. Der Encoder können entweder big-endian-Bytereihenfolge (höchstwertigen Byte erste) oder die little-endian-Bytereihenfolge (am wenigsten signifikanten Byte zuerst). Beispielsweise folgt den lateinischen Großbuchstaben ein (Codepunkt U + 0041) als serialisiert wird (hexadezimal):  
  
-   Big-endian-Bytereihenfolge: 00 00 00 41  
  
-   Little-endian-Bytereihenfolge: 41 00 00 00  
  
 Es ist im Allgemeinen effizienter zum Speichern von Unicode-Zeichen, die mit systemeigenen Bytereihenfolge der jeweiligen Plattform. Beispielsweise ist es besser, die little-endian-Bytereihenfolge auf little-endian Plattformtypen, beispielsweise Intel Computer verwenden. Die <xref:System.Text.UnicodeEncoding> Klasse der Windows-Codepages 1200 (little-endian-Bytereihenfolge) und 1201 (big-endian-Bytereihenfolge) entspricht. Sie können den "Endian" an, der eine bestimmte Architektur bestimmen, durch Aufrufen der <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> Methode.  
  
 Optional können die <xref:System.Text.UnicodeEncoding> -Objekt bietet eine bytereihenfolgemarkierung (BOM), also ein Array von Bytes, die die Abfolge von Bytes, die aufgrund des Codierungsvorgangs vorangestellt werden kann. Die Präambel eine bytereihenfolgemarkierung (BOM) enthält, leichter den Decoder die Bytereihenfolge und die Transformationsformat oder im UTF zu bestimmen.  
  
 Wenn die <xref:System.Text.UnicodeEncoding> Instanz ist so konfiguriert, dass eine BOM enthalten, können Sie sie abrufen, durch Aufrufen der <xref:System.Text.UnicodeEncoding.GetPreamble%2A> Methode; andernfalls wird die Methode ein leeres Array zurückgegeben. Beachten Sie, dass selbst wenn eine <xref:System.Text.UnicodeEncoding> -Objekt konfiguriert ist, für die Bytereihenfolge-Marke unterstützen, müssen Sie die BOM am Anfang des codierten Datenstrom nach Bedarf; auch Codierungsmethoden von der <xref:System.Text.UnicodeEncoding> Klasse tun Sie dies automatisch.  
  
 So aktivieren Sie die fehlererkennung und die Klasseninstanz sicherer zu gestalten, instanziieren Sie ein <xref:System.Text.UnicodeEncoding> Objekt durch Aufrufen der <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor und die Einstellung seiner `throwOnInvalidBytes` Argument `true`. Mit fehlererkennung, eine Methode, die eine ungültige Folge von Zeichen oder Bytes erkennt löst eine <xref:System.ArgumentException>. Ohne Fehler erkannt wird keine Ausnahme ausgelöst und die ungültige Sequenz im Allgemeinen ignoriert.  
  
 Instanziieren Sie ein <xref:System.Text.UnicodeEncoding> Objekt in einer Reihe von Möglichkeiten, je nachdem, ob Sie darauf eine bytereihenfolgemarkierung (BOM) bereitstellen möchten, gibt an, ob Sie big-Endian oder little-Endian-Codierung wünschen und gibt an, ob Sie fehlererkennung aktivieren möchten. Die folgende Tabelle enthält die <xref:System.Text.UnicodeEncoding> Konstruktoren und der <xref:System.Text.Encoding> Eigenschaften, die Zurückgeben einer <xref:System.Text.UnicodeEncoding> Objekt.  
  
|Member|Endianness|BOM|Fehlererkennung|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.BigEndianUnicode%2A>|Big-endian|Ja|Keine (Ersatzfallback)|  
|<xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType>|Little-endian|Ja|Keine (Ersatzfallback)|  
|<xref:System.Text.UnicodeEncoding.%23ctor?displayProperty=nameWithType>|Little-endian|Ja|Keine (Ersatzfallback)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29>|Konfigurierbare|Konfigurierbare|Keine (Ersatzfallback)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Konfigurierbare|Konfigurierbare|Konfigurierbare|  
  
 Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.UnicodeEncoding.GetBytes%2A> -Methode führt die eigentliche Codierung.  
  
 Entsprechend der <xref:System.Text.UnicodeEncoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und <xref:System.Text.UnicodeEncoding.GetChars%2A> und <xref:System.Text.UnicodeEncoding.GetString%2A> Methoden führen die tatsächliche Decodierung aus.  
  
 Für einen Encoder oder Decoder, der zum Speichern von Zustandsinformationen, die beim Codieren oder Decodieren von Daten, die umfasst mehrere Blöcke (z. B. String von 1 Mio. Zeichen, die in Segmenten von 100.000 Zeichen codiert wird) verwenden, können die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> und <xref:System.Text.UnicodeEncoding.GetDecoder%2A> Eigenschaften bzw.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie eine Zeichenfolge von Unicode-Zeichen in ein Bytearray mit Codieren einer <xref:System.Text.UnicodeEncoding> Objekt. Das Bytearray wird in eine Zeichenfolge, die veranschaulichen, dass es kein Datenverlust Datenmenge entsteht decodiert.  
  
 [!code-cpp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/snippet.vb#1)]  
  
 Im folgenden Beispiel wird die gleiche Zeichenfolge als der vorherigen Abfrage, außer dass die codierten Bytes in eine Datei geschrieben und Präfixe Bytestream mit einem Byte-reihenfolgemarkierung (BOM). Dann liest die Datei auf zwei verschiedene Arten: als Textdatei mit einer <xref:System.IO.StreamReader> Objekt; und als eine Binärdatei. Wie zu erwarten, ist die BOM in keinem Fall in der neu schreibgeschützte Zeichenfolge enthalten.  
  
 [!code-csharp[System.Text.UnicodeEncoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF32Encoding" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.UTF7Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.UnicodeEncoding" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.UnicodeEncoding" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt eine Instanz, die die little-endian-Bytereihenfolge verwendet, bietet eine Unicode-bytereihenfolgemarkierung und löst keine Ausnahme aus, wenn eine ungültige Codierung gefunden wird.  
  
> [!NOTE]
>  Aus Gründen der Sicherheit sollten Sie Erkennung aktivieren, durch Aufrufen der <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor und die Einstellung der `throwOnInvalidBytes` Argument `true`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie zum Erstellen eines neuen <xref:System.Text.UnicodeEncoding> -Instanz und der Anzeigename der Codierung.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="F#" Value="new System.Text.UnicodeEncoding : bool * bool -&gt; System.Text.UnicodeEncoding" Usage="new System.Text.UnicodeEncoding (bigEndian, byteOrderMark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> to use the big endian byte order (most significant byte first), or <see langword="false" /> to use the little endian byte order (least significant byte first).</param>
        <param name="byteOrderMark">
          <see langword="true" /> to specify that the <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> method returns a Unicode byte order mark; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.UnicodeEncoding" /> class. Parameters specify whether to use the big endian byte order and whether the <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> method returns a Unicode byte order mark.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt eine Instanz, die keine Ausnahme auslöst, wenn eine ungültige Codierung gefunden wird.  
  
> [!NOTE]
>  Aus Gründen der Sicherheit sollten Sie Erkennung aktivieren, durch Aufrufen der <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor und die Einstellung der `throwOnInvalidBytes` Argument `true`.  
  
 Die `byteOrderMark` Parameter steuert die Ausführung von der <xref:System.Text.UnicodeEncoding.GetPreamble%2A> Methode. Wenn `true`, die Methode gibt ein Bytearray, das die Unicode-bytereihenfolgemarkierung (BOM) in UTF-16-Format enthält.  Wenn `false`, es gibt ein Bytearray der Länge 0 (null) zurück. Jedoch festlegen `byteOrderMark` auf `true` führt nicht dazu, dass die <xref:System.Text.UnicodeEncoding.GetBytes%2A> Methode, um die BOM am Anfang des Bytearrays, Präfix noch führt es dazu, dass die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode, um die Anzahl der Bytes in der Stückliste in die Anzahl der Bytes enthalten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie zum Erstellen eines neuen <xref:System.Text.UnicodeEncoding> Instanz angegeben wird, ob little-endian oder big-endian-Byte-Sortierreihenfolge unterstützen und das Unicode-Byte order Mark.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="F#" Value="new System.Text.UnicodeEncoding : bool * bool * bool -&gt; System.Text.UnicodeEncoding" Usage="new System.Text.UnicodeEncoding (bigEndian, byteOrderMark, throwOnInvalidBytes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> to use the big endian byte order (most significant byte first); <see langword="false" /> to use the little endian byte order (least significant byte first).</param>
        <param name="byteOrderMark">
          <see langword="true" /> to specify that the <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> method returns a Unicode byte order mark; otherwise, <see langword="false" />.</param>
        <param name="throwOnInvalidBytes">
          <see langword="true" /> to specify that an exception should be thrown when an invalid encoding is detected; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.UnicodeEncoding" /> class. Parameters specify whether to use the big endian byte order, whether to provide a Unicode byte order mark, and whether to throw an exception when an invalid encoding is detected.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `byteOrderMark` Parameter steuert die Ausführung von der <xref:System.Text.UnicodeEncoding.GetPreamble%2A> Methode. Wenn `true`, die Methode gibt ein Bytearray, das die Unicode-bytereihenfolgemarkierung (BOM) in UTF-16-Format enthält.  Wenn `false`, es gibt ein Bytearray der Länge 0 (null) zurück. Jedoch festlegen `byteOrderMark` auf `true` führt nicht dazu, dass die <xref:System.Text.UnicodeEncoding.GetBytes%2A> Methode, um die BOM am Anfang des Bytearrays, Präfix noch führt es dazu, dass die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode, um die Anzahl der Bytes in der Stückliste in die Anzahl der Bytes enthalten.  
  
 Wenn die `throwOnInvalidBytes` Parameter ist `true`, löst Sie eine Methode, die eine ungültige Bytesequenz erkennt <xref:System.ArgumentException?displayProperty=nameWithType>. Andernfalls wird die Methode löst eine Ausnahme, und die ungültige Sequenz wird ignoriert.  
  
> [!NOTE]
>  Aus Gründen der Sicherheit werden Ihre Anwendungen Verwendung dieses Konstruktors zum Erstellen einer Instanz des empfohlen die <xref:System.Text.UnicodeEncoding> Klasse, und schalten Sie fehlererkennung durch Festlegen `throwOnInvalidBytes` auf `true`.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Verhalten des <xref:System.Text.UnicodeEncoding>, mit der fehlererkennung aktiviert und ohne.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/VB/errordetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="CharSize">
      <MemberSignature Language="C#" Value="public const int CharSize = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 CharSize = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Text.UnicodeEncoding.CharSize" />
      <MemberSignature Language="VB.NET" Value="Public Const CharSize As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int CharSize = 2;" />
      <MemberSignature Language="F#" Value="val mutable CharSize : int" Usage="System.Text.UnicodeEncoding.CharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Represents the Unicode character size in bytes. This field is a constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieses Felds ist eine signierte 32-Bit-Konstante mit einem Wert von 2.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie den Wert des zurückzugebenden <xref:System.Text.UnicodeEncoding.CharSize> und angezeigt wird.  
  
 [!code-cpp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CPP/charsize.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CS/charsize.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/VB/charsize.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="unicodeEncoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The object to compare with the current object.</param>
        <summary>Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Text.UnicodeEncoding" /> object.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.UnicodeEncoding" /> and is equal to the current object; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei <xref:System.Text.UnicodeEncoding> Objekte werden als gleich betrachtet, wenn alle der folgenden Bedingungen erfüllt sind:  
  
-   Beide Objekte verwenden die gleiche Bytereihenfolge (little-Endian oder big-Endian).  
  
-   Beide Objekte bereitzustellen, Byte Order Mark, oder beide nicht der Fall ist.  
  
-   Beide Objekte verwenden die gleichen EncoderFallback.  
  
-   Beide Objekte verwenden die gleichen DecoderFallback.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.Equals%2A> Methode zum Testen, ob die aktuelle <xref:System.Text.UnicodeEncoding> -Objekt gleich einem anderen <xref:System.Text.UnicodeEncoding> Objekt. Fünf <xref:System.Text.UnicodeEncoding> Objekte erstellt und verglichen werden und die Ergebnisse der Vergleiche werden angezeigt.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calculates the number of bytes produced by encoding a set of characters.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="unicodeEncoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The string that contains the set of characters to encode.</param>
        <summary>Calculates the number of bytes produced by encoding the characters in the specified string.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes rufen Sie die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen Sie die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>. Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
> [!NOTE]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen. Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden sollen) ist Aufgabe des Entwicklers, und die Anzahl der Bytes in der Präambel ist nicht in den Rückgabewert von wiedergegeben, die <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> und <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> Methoden zum Berechnen der maximalen und den tatsächlichen Anzahl der Bytes, die erforderlich sind, um eine Zeichenfolge zu codieren. Es zeigt auch die tatsächliche Anzahl von Bytes, die zum Speichern eines Bytestreams mit einem Byte-reihenfolgemarkierung erforderlich.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="s" /> contains an invalid sequence of characters.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="unicodeEncoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A pointer to the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetBytes%2A> erfordert zum Speichern der resultierenden Bytes, rufen Sie die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen Sie die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>. Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
> [!NOTE]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen. Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden sollen) ist Aufgabe des Entwicklers, und die Anzahl der Bytes in der Präambel ist nicht in den Rückgabewert von wiedergegeben, die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is less than zero.  -or-  The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled and <paramref name="chars" /> contains an invalid sequence of characters.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="unicodeEncoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="index">The index of the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>Calculates the number of bytes produced by encoding a set of characters from the specified character array.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes verwendet die Anwendung <xref:System.Text.UnicodeEncoding.GetByteCount%2A>. Um die maximale Arraygröße zu berechnen, rufen Sie die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Eine ungültige Folge fehlererkennung ist aktiviert, führt diese Methode löst eine <xref:System.ArgumentException>. Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen. Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden sollen) ist Aufgabe des Entwicklers, und die Anzahl der Bytes in der Präambel ist nicht in den Rückgabewert von wiedergegeben, die <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array mit einem lateinischen Großbuchstaben und Kleinbuchstaben und ruft die <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Methode, um die Anzahl der Bytes, die zum Codieren der Zeichen des lateinischen Kleinbuchstaben erforderlich festzulegen. Es zeigt dann diese Informationen zusammen mit der Gesamtanzahl von Bytes erforderlich, wenn eine Bytereihenfolge-Marke hinzugefügt wird. Diese Zahl vergleicht Sie mit den Rückgabewert von der <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> -Methode, die maximale Anzahl von Bytes, die zum Codieren der Zeichen des lateinischen Kleinbuchstaben erforderlich angibt. Im folgenden Beispiel wird ein Array mit einer Kombination von Zeichen Griechisch und Kyrillisch und ruft die <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Methode, um zu bestimmen, die Anzahl der Bytes, die erforderlich sind, um die kyrillischen Zeichen zu codieren. Es zeigt dann diese Informationen zusammen mit der Gesamtanzahl von Bytes erforderlich, wenn eine Bytereihenfolge-Marke hinzugefügt wird. Diese Zahl vergleicht Sie mit den Rückgabewert von der <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> -Methode, die maximale Anzahl von Bytes erforderlich, um die kyrillischen Zeichen zu codieren angibt.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.  -or-  The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Encodes a set of characters into a sequence of bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="unicodeEncoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A pointer to the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">A pointer to the location at which to start writing the resulting sequence of bytes.</param>
        <param name="byteCount">The maximum number of bytes to write.</param>
        <summary>Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</summary>
        <returns>The actual number of bytes written at the location indicated by the <paramref name="bytes" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetBytes%2A> erfordert zum Speichern der resultierenden Bytes, rufen Sie die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen Sie die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>. Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> Objekt bereitgestellt werden, indem Sie die <xref:System.Text.UnicodeEncoding.GetDecoder%2A> oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> -Methode, bzw.  
  
> [!NOTE]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen. Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden) wird die Verantwortung des Entwicklers. Die <xref:System.Text.UnicodeEncoding.GetBytes%2A> Methode ist keine Präambel am Anfang eine codierte Bytefolge nicht voranstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).  -or-  <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.  -or-  <paramref name="byteCount" /> is less than the resulting number of bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="unicodeEncoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="charIndex">The index of the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
        <param name="byteIndex">The index at which to start writing the resulting sequence of bytes.</param>
        <summary>Encodes a set of characters from the specified character array into the specified byte array.</summary>
        <returns>The actual number of bytes written into <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes rufen Sie die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen Sie die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>. Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UnicodeEncoding.GetDecoder%2A> Methode oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> Methode bzw.  
  
> [!NOTE]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen. Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden) wird die Verantwortung des Entwicklers. Die <xref:System.Text.UnicodeEncoding.GetBytes%2A> Methode ist keine Präambel am Anfang eine codierte Bytefolge nicht voranstellen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetBytes%2A> Methode zum Codieren eines Bereichs von Zeichen aus einer <xref:System.String> und speichern Sie die codierten Bytes in einem Bereich von Elementen in ein Bytearray.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).  -or-  <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.  -or-  <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.  -or-  <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.  -or-  <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="unicodeEncoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">The string containing the set of characters to encode.</param>
        <param name="charIndex">The index of the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
        <param name="byteIndex">The index at which to start writing the resulting sequence of bytes.</param>
        <summary>Encodes a set of characters from the specified <see cref="T:System.String" /> into the specified byte array.</summary>
        <returns>The actual number of bytes written into <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes rufen Sie die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode. Um die maximale Arraygröße zu berechnen, rufen Sie die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>. Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UnicodeEncoding.GetDecoder%2A> Methode oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> Methode bzw.  
  
> [!NOTE]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen. Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden) wird die Verantwortung des Entwicklers. Die <xref:System.Text.UnicodeEncoding.GetBytes%2A> Methode ist keine Präambel am Anfang eine codierte Bytefolge nicht voranstellen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie auf einen Bereich von Elementen aus einem Array von Unicode-Zeichen zu codieren, und speichern die codierten Bytes in einem Bereich von Elementen in einem Bytearray.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.  -or-  <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.  -or-  <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.  -or-  <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="s" /> contains an invalid sequence of characters.  -or-  <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calculates the number of characters produced by decoding a sequence of bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="unicodeEncoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetChars%2A> erfordert zum Speichern der resultierenden Zeichen, die der Anwendung verwendeten <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Die <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>. Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is less than zero.  -or-  The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="unicodeEncoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetChars%2A> zum Speichern der resultierenden Zeichen, die Anwendung verwendet <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Die <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>. Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Methode, um die Anzahl von Zeichen zurückzugeben, die beim Decodieren Sie einen Bereich von Elementen in einem Byte-Array von erzeugt <xref:System.Text.UnicodeEncoding>.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.  -or-  The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodes a sequence of bytes into a set of characters.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="unicodeEncoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to the first byte to decode.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <param name="chars">A pointer to the location at which to start writing the resulting set of characters.</param>
        <param name="charCount">The maximum number of characters to write.</param>
        <summary>Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</summary>
        <returns>The actual number of characters written at the location indicated by the <paramref name="chars" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetChars%2A> erfordert zum Speichern der resultierenden Zeichen, die der Anwendung verwendeten <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Die <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>. Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 Wenn Sie der Bereich von Bytes, die zu decodierende enthält die Byte-reihenfolgemarkierung (BOM), und das Bytearray mit einer anderen Methode eines Typs nicht BOM beachten zurückgegeben wurde, ist das Zeichen U + FFFE im Zeichenarray, das von dieser Methode zurückgegebene enthalten. Sie können diesen entfernen, durch Aufrufen der <xref:System.String.TrimStart%2A?displayProperty=nameWithType> Methode.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> Objekt bereitgestellt werden, indem Sie die <xref:System.Text.UnicodeEncoding.GetDecoder%2A> oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> -Methode, bzw.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).  -or-  <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.  -or-  <paramref name="charCount" /> is less than the resulting number of characters.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="unicodeEncoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="byteIndex">The index of the first byte to decode.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <param name="chars">The character array to contain the resulting set of characters.</param>
        <param name="charIndex">The index at which to start writing the resulting set of characters.</param>
        <summary>Decodes a sequence of bytes from the specified byte array into the specified character array.</summary>
        <returns>The actual number of characters written into <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetChars%2A> zum Speichern der resultierenden Zeichen, die Anwendung verwendet <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Die <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>. Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 Wenn Sie der Bereich von Bytes, die zu decodierende enthält die Byte-reihenfolgemarkierung (BOM), und das Bytearray mit einer anderen Methode eines Typs nicht BOM beachten zurückgegeben wurde, ist das Zeichen U + FFFE im Zeichenarray, das von dieser Methode zurückgegebene enthalten. Sie können diesen entfernen, durch Aufrufen der <xref:System.String.TrimStart%2A?displayProperty=nameWithType> Methode.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UnicodeEncoding.GetDecoder%2A> Methode oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> Methode bzw.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetChars%2A> Methode, um einen Bereich von Elementen in einem Bytearray zu decodieren und Speichern des Ergebnisses in ein Zeichenarray.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).  -or-  <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.  -or-  <paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.  -or-  <paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.  -or-  <paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="unicodeEncoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtains a decoder that converts a UTF-16 encoded sequence of bytes into a sequence of Unicode characters.</summary>
        <returns>A <see cref="T:System.Text.Decoder" /> that converts a UTF-16 encoded sequence of bytes into a sequence of Unicode characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> konvertiert sequenzielle Blöcke von Bytes in sequenzielle Blöcke von Zeichen ähnlich wie die <xref:System.Text.UnicodeEncoding.GetChars%2A>. Allerdings eine <xref:System.Text.Decoder> verwaltet Zustandsinformationen zwischen aufrufen, damit Bytesequenzen, die Blöcke umfassen, ordnungsgemäß decodiert werden können. Die <xref:System.Text.Decoder> behält nachfolgende Bytes am Ende der Datenblöcke und die nachfolgenden Bytes im nächste Decodierungsvorgang verwendet. Aus diesem Grund <xref:System.Text.UnicodeEncoding.GetDecoder%2A> und <xref:System.Text.UnicodeEncoding.GetEncoder%2A> eignen sich für die netzwerkübertragung und Dateivorgänge, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.  
  
 Wenn Erkennung, d. h. aktiviert ist die `throwOnInvalidBytes` Parameter des Konstruktors festgelegt ist, um `true`, fehlererkennung ist auch aktiviert, der <xref:System.Text.Decoder> von dieser Methode zurückgegebene. Wenn fehlererkennung ist aktiviert, und eine ungültige Folge festgestellt wird, der Zustand des Decoders ist nicht definiert und Verarbeitung muss beendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Encoder und Decoder eine Zeichenfolge in ein Array von Bytes zu codieren, und klicken Sie dann die Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="unicodeEncoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtains an encoder that converts a sequence of Unicode characters into a UTF-16 encoded sequence of bytes.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> object that converts a sequence of Unicode characters into a UTF-16 encoded sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> konvertiert sequenzielle Blöcke von Zeichen in sequenzielle Blöcke von Bytes in auf ähnliche Weise die <xref:System.Text.UnicodeEncoding.GetBytes%2A> Methode dieser Klasse. Allerdings ein <xref:System.Text.Encoder> -Objekt verwaltet Zustandsinformationen zwischen aufrufen, damit Zeichensequenzen, die Blöcke umfassen, korrekt codiert werden können. Die <xref:System.Text.Encoder> Objekt behält nachfolgende Zeichen am Ende der Datenblöcke und das nachfolgenden Zeichen in der nächsten Codierungsvorgang verwendet. Z. B. ein Datenblock möglicherweise eine hohe Ersatzzeichen ohne Entsprechung enden, und die übereinstimmende niedrige Ersatzzeichen ist möglicherweise in den nächsten Datenblock. Aus diesem Grund <xref:System.Text.UnicodeEncoding.GetDecoder%2A> und <xref:System.Text.UnicodeEncoding.GetEncoder%2A> eignen sich für die netzwerkübertragung und Dateivorgänge, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.  
  
 Wenn Erkennung, d. h. aktiviert ist die `throwOnInvalidBytes` Parameter des Konstruktors festgelegt ist, um `true`, fehlererkennung ist auch aktiviert, der <xref:System.Text.Encoder> von dieser Methode zurückgegebene Objekt. Wenn die fehlererkennung ist aktiviert, und eine ungültige Folge festgestellt wird, der Zustand des Encoders ist nicht definiert und Verarbeitung muss beendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Encoder und Decoder eine Zeichenfolge in ein Array von Bytes zu codieren, und klicken Sie dann die Bytes in ein Array von Zeichen decodiert.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="unicodeEncoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for the current instance.</summary>
        <returns>The hash code for the current <see cref="T:System.Text.UnicodeEncoding" /> object.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="unicodeEncoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">The number of characters to encode.</param>
        <summary>Calculates the maximum number of bytes produced by encoding the specified number of characters.</summary>
        <returns>The maximum number of bytes produced by encoding the specified number of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes verwendet die Anwendung <xref:System.Text.UnicodeEncoding.GetByteCount%2A>. Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>. Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Ruft die Anzahl Worst-Case, einschließlich ungünstigsten Fall für das derzeit ausgewählte ab <xref:System.Text.EncoderFallback>. Wenn ein Fallback mit einer potenziell großen Zeichenfolge ausgewählt wird <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> große Werte zurückgeben können.  
  
 In den meisten Fällen ruft diese Methode geeignete Zahlen für kleine Zeichenfolgen ab. Für große Zeichenfolgen müssen Sie möglicherweise entscheiden sehr große Puffer und Erfassen von Fehlern in dem seltenen Fall, dass ein günstiger Puffer überschritten wird. Sie sollten auch einen anderen Ansatz erwägen <xref:System.Text.UnicodeEncoding.GetByteCount%2A> oder <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> hat keinen Bezug zu <xref:System.Text.UnicodeEncoding.GetChars%2A>. Wenn Ihre Anwendung eine ähnliche Funktion für die Verwendung mit benötigt <xref:System.Text.UnicodeEncoding.GetChars%2A>, sollte <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` ist nicht unbedingt der gleiche Wert wie `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode, um die maximale Anzahl von Bytes, die erforderlich sind, um eine angegebene Anzahl von Zeichen zu codieren zurückzugeben.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> is less than zero.  -or-  The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="unicodeEncoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">The number of bytes to decode.</param>
        <summary>Calculates the maximum number of characters produced by decoding the specified number of bytes.</summary>
        <returns>The maximum number of characters produced by decoding the specified number of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetChars%2A> zum Speichern der resultierenden Zeichen, die Anwendung verwendet <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Die <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Ruft die Anzahl Worst-Case, einschließlich ungünstigsten Fall für das derzeit ausgewählte ab <xref:System.Text.DecoderFallback>. Wenn ein Fallback mit einer potenziell großen Zeichenfolge ausgewählt wird <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> große Werte abgerufen.  
  
 In den meisten Fällen ruft diese Methode geeignete Zahlen für kleine Zeichenfolgen ab. Für große Zeichenfolgen müssen Sie möglicherweise entscheiden sehr große Puffer und Erfassen von Fehlern in dem seltenen Fall, dass ein günstiger Puffer überschritten wird. Sie sollten auch einen anderen Ansatz erwägen <xref:System.Text.UnicodeEncoding.GetCharCount%2A> oder <xref:System.Text.Decoder.Convert%2A>.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> hat keinen Bezug zu <xref:System.Text.UnicodeEncoding.GetBytes%2A>. Wenn Ihre Anwendung eine ähnliche Funktion für die Verwendung mit benötigt <xref:System.Text.UnicodeEncoding.GetBytes%2A>, sollte <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` ist nicht unbedingt der gleiche Wert wie `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Methode, um die maximale Anzahl von Zeichen zurückzugeben, die beim Decodieren von einer angegebenen Anzahl von Bytes erzeugt.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> is less than zero.  -or-  The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="unicodeEncoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a Unicode byte order mark encoded in UTF-16 format, if the constructor for this instance requests a byte order mark.</summary>
        <returns>A byte array containing the Unicode byte order mark, if the <see cref="T:System.Text.UnicodeEncoding" /> object is configured to supply one. Otherwise, this method returns a zero-length byte array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.UnicodeEncoding> Objekt bieten keine Präambel, also ein Byte-Array, das die Abfolge von Bytes, die aufgrund des Codierungsvorgangs vorangestellt werden kann. Eine Sequenz codierter Bytes mit einem Byte-reihenfolgemarkierung (Codepunkt U + FEFF) voran unterstützt den Decoder, der die Bytereihenfolge und die Transformationsformat oder im UTF zu bestimmen. Die Unicode-bytereihenfolgemarkierung (BOM) ist (im Hexadezimalformat) wie folgt serialisiert:  
  
-   Big-endian-Bytereihenfolge: FF FE  
  
-   Little-endian-Bytereihenfolge: FF FE  
  
 Instanziieren Sie ein <xref:System.Text.UnicodeEncoding> Objekt, dessen <xref:System.Text.UnicodeEncoding.GetPreamble%2A> Methodenrückgabe eine gültige BOM auf folgende Weise:  
  
-   Durch das Abrufen der <xref:System.Text.UnicodeEncoding> zurückgegebenes Objekt die <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> oder <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType> Eigenschaft.  
  
-   Durch Aufrufen der parameterlosen <xref:System.Text.UnicodeEncoding.%23ctor> Konstruktor zum Instanziieren einer <xref:System.Text.UnicodeEncoding> Objekt.  
  
-   Durch Angabe `true` als Wert für die `byteOrderMark` Argument an die <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> oder <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktoren.  
  
 Es wird empfohlen, Sie verwenden die BOM, da sie fast bestimmte Kennung für eine Codierung für Dateien, die andernfalls einen Verweis auf ihre Codierung, z. B. nicht gekennzeichnet oder nicht ordnungsgemäß markierten verloren bereitstellt Webdaten oder zufällige Dateien gespeichert, wenn ein Unternehmen keinen Internationale Aspekte. Häufig Benutzerprobleme können vermieden werden, wenn Daten einheitlich und ordnungsgemäß gekennzeichnet ist.  
  
 Für die Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant. Es kann jedoch verwendet werden, zu einem Server, den richtigen encoding-Header zu senden. Alternativ können sie als ein Fallback verwendet werden, für den Fall, dass die Codierung verloren gegangen ist.  
  
 Es gibt einige Nachteile mit einer BOM. Zu wissen, wie die Datenbankfelder zu beschränken, die eine BOM verwenden kann z. B. schwierig sein. Die Verkettung von Dateien, problematisch sein kann auch, beispielsweise beim Zusammenführen von Dateien in einem solchen eine Möglichkeit, die ein unnötige Zeichen in der Mitte Daten annehmen kann. Trotz der einige Nachteile wird jedoch dringend die Verwendung einer Stückliste empfohlen.  
  
> [!CAUTION]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie den Anfang eines Streams codierter Bytes mit einer Präambel voranstellen. Beachten Sie, dass die <xref:System.Text.UnicodeEncoding.GetBytes%2A> Methode ist eine BOM, um eine codierte Bytefolge nicht voranstellen; der Verantwortung des Entwicklers ist eine BOM am Anfang einer entsprechenden Bytedatenstrom bereitstellt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetPreamble%2A> Methode zum Abrufen der Unicode-bytereihenfolgemarkierung im big-Endian oder little endian-Bytereihenfolge für eine Instanz von einem <xref:System.Text.UnicodeEncoding>.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 Das folgende Beispiel instanziiert zwei <xref:System.Text.UnicodeEncoding> Objekte, die das erste keine BOM, während die zweite welche wird bietet. Er ruft dann die <xref:System.Text.UnicodeEncoding.GetPreamble%2A> -Methode, die BOM vor dem Schreiben einer Unicode-codierte Zeichenfolge in eine Datei zu schreiben. Wie die Konsolenausgabe aus dem Beispiel zeigt, wurde die Datei, die die Bytes aus dem zweiten Encoder speichert drei weitere Bytes als der erste.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/cs/GetPreamble1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/vb/GetPreamble1.vb#1)]  
  
 Sie können auch die Dateien vergleichen, mithilfe der `fc` Befehl in einem Konsolenfenster, oder Sie können die Dateien in einem Text-Editor, der einen Hex-Ansichtsmodus enthält überprüfen. Beachten Sie, dass die Datei in einem Editor geöffnet ist, die UTF-16-Codierung unterstützt, die BOM nicht angezeigt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="unicodeEncoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>Decodes a range of bytes from a byte array into a string.</summary>
        <returns>A <see cref="T:System.String" /> object containing the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>. Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 Wenn Sie der Bereich von Bytes, die zu decodierende enthält die Byte-reihenfolgemarkierung (BOM), und das Bytearray mit einer anderen Methode eines Typs nicht BOM beachten zurückgegeben wurde, ist das Zeichen U + FFFE im Zeichenarray, das von dieser Methode zurückgegebene enthalten. Sie können diesen entfernen, durch Aufrufen der <xref:System.String.TrimStart%2A?displayProperty=nameWithType> Methode.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> Objekt bereitgestellt werden, indem Sie die <xref:System.Text.UnicodeEncoding.GetDecoder%2A> oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> -Methode, bzw.  
  
   
  
## Examples  
 Im folgende Beispiel wird ein Array initialisiert, durch Aufrufen der <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode, um zu bestimmen, genau wie viele Bytes für eine codierte Zeichenfolge, und fügen die Größe des Byte-reihenfolgemarkierung (BOM) erforderlich sind. Das Beispiel ruft dann die <xref:System.Text.UnicodeEncoding.GetPreamble%2A> Methode zum Speichern der Stückliste für das Array vor dem Aufruf der <xref:System.Text.Encoding.GetBytes%2A> Methode zum Speichern der codierten Bytes in das Array. Das Beispiel ruft dann die <xref:System.Text.UnicodeEncoding.GetString%2A> Methode, um die Zeichenfolge zu decodieren.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Beachten Sie, dass in diesem Fall die decodierte Zeichenfolge aus der ursprünglichen Zeichenfolge abweicht, da er mit 16-Bit-Byte-reihenfolgemarkierung, U + FFFD beginnt. Dies bedeutet, dass die beiden Zeichenfolgen als ungleich verglichen werden und ist die Zeichenfolge Ausgabe, die BOM als das Ersatzzeichen angezeigt wird "?". Um die BOM am Anfang der Zeichenfolge zu entfernen, rufen Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>