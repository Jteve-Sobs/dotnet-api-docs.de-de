<Type Name="UnicodeEncoding" FullName="System.Text.UnicodeEncoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="37bb8ffd133cbb1ddd3c3fdd2f593086d39584aa" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UnicodeEncoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnicodeEncoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UnicodeEncoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UnicodeEncoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnicodeEncoding : System::Text::Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="dd63c-101">Stellt eine UTF-16-Codierung von Unicode-Zeichen dar.</span>
      <span class="sxs-lookup">
        <span data-stu-id="dd63c-101">Represents a UTF-16 encoding of Unicode characters.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-102">Beim Kodieren werden Unicode-Zeichen in eine Bytefolge transformiert.</span><span class="sxs-lookup"><span data-stu-id="dd63c-102">Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</span></span> <span data-ttu-id="dd63c-103">Beim Decodieren wird transformiert eine codierte Bytefolge in einen Satz von Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-103">Decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</span></span>  
  
 <span data-ttu-id="dd63c-104">Die [Unicode-Standard](http://go.microsoft.com/fwlink/?linkid=37123) jedes Zeichen aller unterstützten Skripts einen Codepunkt (eine Zahl) zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-104">The [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) assigns a code point (a number) to each character in every supported script.</span></span> <span data-ttu-id="dd63c-105">Eine Transformation Format UTF (Unicode) ist eine Möglichkeit, diesen Codepunkt codieren.</span><span class="sxs-lookup"><span data-stu-id="dd63c-105">A Unicode Transformation Format (UTF) is a way to encode that code point.</span></span> <span data-ttu-id="dd63c-106">Die [Unicode-Standard](http://go.microsoft.com/fwlink/?linkid=37123) verwendet die folgenden UTFs:</span><span class="sxs-lookup"><span data-stu-id="dd63c-106">The [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) uses the following UTFs:</span></span>  
  
-   <span data-ttu-id="dd63c-107">UTF-8, jeden Codepunkt als eine Folge von ein bis vier Bytes dar.</span><span class="sxs-lookup"><span data-stu-id="dd63c-107">UTF-8, which represents each code point as a sequence of one to four bytes.</span></span>  
  
-   <span data-ttu-id="dd63c-108">UTF-16, die jeden Codepunkt als Folge von ein bis zwei 16-Bit-Ganzzahlen darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd63c-108">UTF-16, which represents each code point as a sequence of one to two 16-bit integers.</span></span>  
  
-   <span data-ttu-id="dd63c-109">UTF-32, jeden Codepunkt als 32-Bit-Ganzzahl dar.</span><span class="sxs-lookup"><span data-stu-id="dd63c-109">UTF-32, which represents each code point as a 32-bit integer.</span></span>  
  
 <span data-ttu-id="dd63c-110">Weitere Informationen zu den UTFs und andere von unterstützten Codierungen <xref:System.Text>, finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="dd63c-110">For more information about the UTFs and other encodings supported by <xref:System.Text>, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
 <span data-ttu-id="dd63c-111">Die <xref:System.Text.UnicodeEncoding> Klasse stellt eine UTF-16-Codierung.</span><span class="sxs-lookup"><span data-stu-id="dd63c-111">The <xref:System.Text.UnicodeEncoding> class represents a UTF-16 encoding.</span></span> <span data-ttu-id="dd63c-112">Der Encoder können entweder big-endian-Bytereihenfolge (höchstwertigen Byte erste) oder die little-endian-Bytereihenfolge (am wenigsten signifikanten Byte zuerst).</span><span class="sxs-lookup"><span data-stu-id="dd63c-112">The encoder can use either big endian byte order (most significant byte first) or little endian byte order (least significant byte first).</span></span> <span data-ttu-id="dd63c-113">Beispielsweise folgt den lateinischen Großbuchstaben ein (Codepunkt U + 0041) als serialisiert wird (hexadezimal):</span><span class="sxs-lookup"><span data-stu-id="dd63c-113">For example, the Latin Capital Letter A (code point U+0041) is serialized as follows (in hexadecimal):</span></span>  
  
-   <span data-ttu-id="dd63c-114">Big-endian-Bytereihenfolge: 00 00 00 41</span><span class="sxs-lookup"><span data-stu-id="dd63c-114">Big endian byte order: 00 00 00 41</span></span>  
  
-   <span data-ttu-id="dd63c-115">Little-endian-Bytereihenfolge: 41 00 00 00</span><span class="sxs-lookup"><span data-stu-id="dd63c-115">Little endian byte order: 41 00 00 00</span></span>  
  
 <span data-ttu-id="dd63c-116">Es ist im Allgemeinen effizienter zum Speichern von Unicode-Zeichen, die mit systemeigenen Bytereihenfolge der jeweiligen Plattform.</span><span class="sxs-lookup"><span data-stu-id="dd63c-116">It is generally more efficient to store Unicode characters using the native byte order of a particular platform.</span></span> <span data-ttu-id="dd63c-117">Beispielsweise ist es besser, die little-endian-Bytereihenfolge auf little-endian Plattformtypen, beispielsweise Intel Computer verwenden.</span><span class="sxs-lookup"><span data-stu-id="dd63c-117">For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.</span></span> <span data-ttu-id="dd63c-118">Die <xref:System.Text.UnicodeEncoding> Klasse der Windows-Codepages 1200 (little-endian-Bytereihenfolge) und 1201 (big-endian-Bytereihenfolge) entspricht.</span><span class="sxs-lookup"><span data-stu-id="dd63c-118">The <xref:System.Text.UnicodeEncoding> class corresponds to the Windows code pages 1200 (little endian byte order) and 1201 (big endian byte order).</span></span> <span data-ttu-id="dd63c-119">Sie können den "Endian" an, der eine bestimmte Architektur bestimmen, durch Aufrufen der <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-119">You can determine the "endianness" of a particular architecture by calling the <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="dd63c-120">Optional können die <xref:System.Text.UnicodeEncoding> -Objekt bietet eine bytereihenfolgemarkierung (BOM), also ein Array von Bytes, die die Abfolge von Bytes, die aufgrund des Codierungsvorgangs vorangestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd63c-120">Optionally, the <xref:System.Text.UnicodeEncoding> object provides a byte order mark (BOM), which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.</span></span> <span data-ttu-id="dd63c-121">Die Präambel eine bytereihenfolgemarkierung (BOM) enthält, leichter den Decoder die Bytereihenfolge und die Transformationsformat oder im UTF zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-121">If the preamble contains a byte order mark (BOM), it helps the decoder determine the byte order and the transformation format or UTF.</span></span>  
  
 <span data-ttu-id="dd63c-122">Wenn die <xref:System.Text.UnicodeEncoding> Instanz ist so konfiguriert, dass eine BOM enthalten, können Sie sie abrufen, durch Aufrufen der <xref:System.Text.UnicodeEncoding.GetPreamble%2A> Methode; andernfalls wird die Methode ein leeres Array zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd63c-122">If the <xref:System.Text.UnicodeEncoding> instance is configured to provide a BOM, you can retrieve it by calling the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method; otherwise, the method returns an empty array.</span></span> <span data-ttu-id="dd63c-123">Beachten Sie, dass selbst wenn eine <xref:System.Text.UnicodeEncoding> -Objekt konfiguriert ist, für die Bytereihenfolge-Marke unterstützen, müssen Sie die BOM am Anfang des codierten Datenstrom nach Bedarf; auch Codierungsmethoden von der <xref:System.Text.UnicodeEncoding> Klasse tun Sie dies automatisch.</span><span class="sxs-lookup"><span data-stu-id="dd63c-123">Note that, even if a <xref:System.Text.UnicodeEncoding> object is configured for BOM support, you must include the BOM at the beginning of the encoded byte stream as appropriate; the encoding methods of the <xref:System.Text.UnicodeEncoding> class do not do this automatically.</span></span>  
  
 <span data-ttu-id="dd63c-124">So aktivieren Sie die fehlererkennung und die Klasseninstanz sicherer zu gestalten, instanziieren Sie ein <xref:System.Text.UnicodeEncoding> Objekt durch Aufrufen der <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor und die Einstellung seiner `throwOnInvalidBytes` Argument `true`.</span><span class="sxs-lookup"><span data-stu-id="dd63c-124">To enable error detection and to make the class instance more secure, you should instantiate a <xref:System.Text.UnicodeEncoding> object by calling the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidBytes` argument to `true`.</span></span> <span data-ttu-id="dd63c-125">Mit fehlererkennung, eine Methode, die eine ungültige Folge von Zeichen oder Bytes erkennt löst eine <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-125">With error detection, a method that detects an invalid sequence of characters or bytes throws a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="dd63c-126">Ohne Fehler erkannt wird keine Ausnahme ausgelöst und die ungültige Sequenz im Allgemeinen ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd63c-126">Without error detection, no exception is thrown, and the invalid sequence is generally ignored.</span></span>  
  
 <span data-ttu-id="dd63c-127">Instanziieren Sie ein <xref:System.Text.UnicodeEncoding> Objekt in einer Reihe von Möglichkeiten, je nachdem, ob Sie darauf eine bytereihenfolgemarkierung (BOM) bereitstellen möchten, gibt an, ob Sie big-Endian oder little-Endian-Codierung wünschen und gibt an, ob Sie fehlererkennung aktivieren möchten.</span><span class="sxs-lookup"><span data-stu-id="dd63c-127">You can instantiate a <xref:System.Text.UnicodeEncoding> object in a number of ways, depending on whether you want to it to provide a byte order mark (BOM), whether you want big-endian or little-endian encoding, and whether you want to enable error detection.</span></span> <span data-ttu-id="dd63c-128">Die folgende Tabelle enthält die <xref:System.Text.UnicodeEncoding> Konstruktoren und der <xref:System.Text.Encoding> Eigenschaften, die Zurückgeben einer <xref:System.Text.UnicodeEncoding> Objekt.</span><span class="sxs-lookup"><span data-stu-id="dd63c-128">The following table lists the <xref:System.Text.UnicodeEncoding> constructors and the <xref:System.Text.Encoding> properties that return a <xref:System.Text.UnicodeEncoding> object.</span></span>  
  
|<span data-ttu-id="dd63c-129">Member</span><span class="sxs-lookup"><span data-stu-id="dd63c-129">Member</span></span>|<span data-ttu-id="dd63c-130">Endianness</span><span class="sxs-lookup"><span data-stu-id="dd63c-130">Endianness</span></span>|<span data-ttu-id="dd63c-131">BOM</span><span class="sxs-lookup"><span data-stu-id="dd63c-131">BOM</span></span>|<span data-ttu-id="dd63c-132">Fehlererkennung</span><span class="sxs-lookup"><span data-stu-id="dd63c-132">Error detection</span></span>|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.BigEndianUnicode%2A>|<span data-ttu-id="dd63c-133">Big-endian</span><span class="sxs-lookup"><span data-stu-id="dd63c-133">Big-endian</span></span>|<span data-ttu-id="dd63c-134">Ja</span><span class="sxs-lookup"><span data-stu-id="dd63c-134">Yes</span></span>|<span data-ttu-id="dd63c-135">Keine (Ersatzfallback)</span><span class="sxs-lookup"><span data-stu-id="dd63c-135">No (Replacement fallback)</span></span>|  
|<xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType>|<span data-ttu-id="dd63c-136">Little-endian</span><span class="sxs-lookup"><span data-stu-id="dd63c-136">Little-endian</span></span>|<span data-ttu-id="dd63c-137">Ja</span><span class="sxs-lookup"><span data-stu-id="dd63c-137">Yes</span></span>|<span data-ttu-id="dd63c-138">Keine (Ersatzfallback)</span><span class="sxs-lookup"><span data-stu-id="dd63c-138">No (Replacement fallback)</span></span>|  
|<xref:System.Text.UnicodeEncoding.%23ctor?displayProperty=nameWithType>|<span data-ttu-id="dd63c-139">Little-endian</span><span class="sxs-lookup"><span data-stu-id="dd63c-139">Little-endian</span></span>|<span data-ttu-id="dd63c-140">Ja</span><span class="sxs-lookup"><span data-stu-id="dd63c-140">Yes</span></span>|<span data-ttu-id="dd63c-141">Keine (Ersatzfallback)</span><span class="sxs-lookup"><span data-stu-id="dd63c-141">No (Replacement fallback)</span></span>|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29>|<span data-ttu-id="dd63c-142">Konfigurierbare</span><span class="sxs-lookup"><span data-stu-id="dd63c-142">Configurable</span></span>|<span data-ttu-id="dd63c-143">Konfigurierbare</span><span class="sxs-lookup"><span data-stu-id="dd63c-143">Configurable</span></span>|<span data-ttu-id="dd63c-144">Keine (Ersatzfallback)</span><span class="sxs-lookup"><span data-stu-id="dd63c-144">No (Replacement fallback)</span></span>|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|<span data-ttu-id="dd63c-145">Konfigurierbare</span><span class="sxs-lookup"><span data-stu-id="dd63c-145">Configurable</span></span>|<span data-ttu-id="dd63c-146">Konfigurierbare</span><span class="sxs-lookup"><span data-stu-id="dd63c-146">Configurable</span></span>|<span data-ttu-id="dd63c-147">Konfigurierbare</span><span class="sxs-lookup"><span data-stu-id="dd63c-147">Configurable</span></span>|  
  
 <span data-ttu-id="dd63c-148">Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <xref:System.Text.UnicodeEncoding.GetBytes%2A> -Methode führt die eigentliche Codierung.</span><span class="sxs-lookup"><span data-stu-id="dd63c-148">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method performs the actual encoding.</span></span>  
  
 <span data-ttu-id="dd63c-149">Entsprechend der <xref:System.Text.UnicodeEncoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und <xref:System.Text.UnicodeEncoding.GetChars%2A> und <xref:System.Text.UnicodeEncoding.GetString%2A> Methoden führen die tatsächliche Decodierung aus.</span><span class="sxs-lookup"><span data-stu-id="dd63c-149">Likewise, the <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.UnicodeEncoding.GetChars%2A> and <xref:System.Text.UnicodeEncoding.GetString%2A> methods perform the actual decoding.</span></span>  
  
 <span data-ttu-id="dd63c-150">Für einen Encoder oder Decoder, der zum Speichern von Zustandsinformationen, die beim Codieren oder Decodieren von Daten, die umfasst mehrere Blöcke (z. B. String von 1 Mio. Zeichen, die in Segmenten von 100.000 Zeichen codiert wird) verwenden, können die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> und <xref:System.Text.UnicodeEncoding.GetDecoder%2A> Eigenschaften bzw.</span><span class="sxs-lookup"><span data-stu-id="dd63c-150">For an encoder or decoder that is able to save state information when encoding or decoding data that spans multiple blocks (such as string of 1 million characters that is encoded in 100,000-character segments), use the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> and <xref:System.Text.UnicodeEncoding.GetDecoder%2A> properties, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-151">Im folgenden Beispiel wird veranschaulicht, wie eine Zeichenfolge von Unicode-Zeichen in ein Bytearray mit Codieren einer <xref:System.Text.UnicodeEncoding> Objekt.</span><span class="sxs-lookup"><span data-stu-id="dd63c-151">The following example demonstrates how to encode a string of Unicode characters into a byte array by using a <xref:System.Text.UnicodeEncoding> object.</span></span> <span data-ttu-id="dd63c-152">Das Bytearray wird in eine Zeichenfolge, die veranschaulichen, dass es kein Datenverlust Datenmenge entsteht decodiert.</span><span class="sxs-lookup"><span data-stu-id="dd63c-152">The byte array is decoded into a string to demonstrate that there is no loss of data.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/snippet.vb#1)]  
  
 <span data-ttu-id="dd63c-153">Im folgenden Beispiel wird die gleiche Zeichenfolge als der vorherigen Abfrage, außer dass die codierten Bytes in eine Datei geschrieben und Präfixe Bytestream mit einem Byte-reihenfolgemarkierung (BOM).</span><span class="sxs-lookup"><span data-stu-id="dd63c-153">The following example uses the same string as the previous one, except that it writes the encoded bytes to a file and prefixes the byte stream with a byte order mark (BOM).</span></span> <span data-ttu-id="dd63c-154">Dann liest die Datei auf zwei verschiedene Arten: als Textdatei mit einer <xref:System.IO.StreamReader> Objekt; und als eine Binärdatei.</span><span class="sxs-lookup"><span data-stu-id="dd63c-154">It then reads the file in two different ways: as a text file by using a <xref:System.IO.StreamReader> object; and as a binary file.</span></span> <span data-ttu-id="dd63c-155">Wie zu erwarten, ist die BOM in keinem Fall in der neu schreibgeschützte Zeichenfolge enthalten.</span><span class="sxs-lookup"><span data-stu-id="dd63c-155">As you would expect, in neither case is the BOM included in the newly read string.</span></span>  
  
 [!code-csharp[System.Text.UnicodeEncoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF32Encoding" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.UTF7Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="dd63c-156">Initialisiert eine neue Instanz der <see cref="T:System.Text.UnicodeEncoding" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-156">Initializes a new instance of the <see cref="T:System.Text.UnicodeEncoding" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="dd63c-157">Initialisiert eine neue Instanz der <see cref="T:System.Text.UnicodeEncoding" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-157">Initializes a new instance of the <see cref="T:System.Text.UnicodeEncoding" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-158">Dieser Konstruktor erstellt eine Instanz, die die little-endian-Bytereihenfolge verwendet, bietet eine Unicode-bytereihenfolgemarkierung und löst keine Ausnahme aus, wenn eine ungültige Codierung gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-158">This constructor creates an instance that uses the little endian byte order, provides a Unicode byte order mark, and does not throw an exception when an invalid encoding is detected.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd63c-159">Aus Gründen der Sicherheit sollten Sie Erkennung aktivieren, durch Aufrufen der <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor und die Einstellung der `throwOnInvalidBytes` Argument `true`.</span><span class="sxs-lookup"><span data-stu-id="dd63c-159">For security reasons, you should enable error detection by calling the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidBytes` argument to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-160">Im folgenden Beispiel wird veranschaulicht, wie zum Erstellen eines neuen <xref:System.Text.UnicodeEncoding> -Instanz und der Anzeigename der Codierung.</span><span class="sxs-lookup"><span data-stu-id="dd63c-160">The following example demonstrates how to create a new <xref:System.Text.UnicodeEncoding> instance and display the name of the encoding.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <span data-ttu-id="dd63c-161">
            <see langword="true" />, um die Big-Endian-Bytereihenfolge (mit dem höchstwertigen Byte an erster Stelle) zu verwenden, oder <see langword="false" />, um die Little-Endian-Bytereihenfolge (mit dem niedrigstwertigen Byte an erster Stelle) zu verwenden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-161">
              <see langword="true" /> to use the big endian byte order (most significant byte first), or <see langword="false" /> to use the little endian byte order (least significant byte first).</span>
          </span>
        </param>
        <param name="byteOrderMark">
          <span data-ttu-id="dd63c-162">
            <see langword="true" />, um anzugeben, dass die <see cref="M:System.Text.UnicodeEncoding.GetPreamble" />-Methode eine Unicode-Bytereihenfolgemarkierung zurückgibt; andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-162">
              <see langword="true" /> to specify that the <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> method returns a Unicode byte order mark; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="dd63c-163">Initialisiert eine neue Instanz der <see cref="T:System.Text.UnicodeEncoding" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-163">Initializes a new instance of the <see cref="T:System.Text.UnicodeEncoding" /> class.</span>
          </span>
          <span data-ttu-id="dd63c-164">Parameter geben an, ob die Big-Endian-Bytereihenfolge verwendet werden soll und die <see cref="M:System.Text.UnicodeEncoding.GetPreamble" />-Methode eine Unicode-Bytereihenfolgemarkierung zurückgibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-164">Parameters specify whether to use the big endian byte order and whether the <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> method returns a Unicode byte order mark.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-165">Dieser Konstruktor erstellt eine Instanz, die keine Ausnahme auslöst, wenn eine ungültige Codierung gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-165">This constructor creates an instance that does not throw an exception when an invalid encoding is detected.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd63c-166">Aus Gründen der Sicherheit sollten Sie Erkennung aktivieren, durch Aufrufen der <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor und die Einstellung der `throwOnInvalidBytes` Argument `true`.</span><span class="sxs-lookup"><span data-stu-id="dd63c-166">For security reasons, you should enable error detection by calling the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidBytes` argument to `true`.</span></span>  
  
 <span data-ttu-id="dd63c-167">Die `byteOrderMark` Parameter steuert die Ausführung von der <xref:System.Text.UnicodeEncoding.GetPreamble%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-167">The `byteOrderMark` parameter controls the operation of the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method.</span></span> <span data-ttu-id="dd63c-168">Wenn `true`, die Methode gibt ein Bytearray, das die Unicode-bytereihenfolgemarkierung (BOM) in UTF-16-Format enthält.</span><span class="sxs-lookup"><span data-stu-id="dd63c-168">If `true`, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-16 format.</span></span>  <span data-ttu-id="dd63c-169">Wenn `false`, es gibt ein Bytearray der Länge 0 (null) zurück.</span><span class="sxs-lookup"><span data-stu-id="dd63c-169">If `false`, it returns a zero-length byte array.</span></span> <span data-ttu-id="dd63c-170">Jedoch festlegen `byteOrderMark` auf `true` führt nicht dazu, dass die <xref:System.Text.UnicodeEncoding.GetBytes%2A> Methode, um die BOM am Anfang des Bytearrays, Präfix noch führt es dazu, dass die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode, um die Anzahl der Bytes in der Stückliste in die Anzahl der Bytes enthalten.</span><span class="sxs-lookup"><span data-stu-id="dd63c-170">However, setting `byteOrderMark` to `true` does not cause the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method to prefix the BOM at the beginning of the byte array, nor does it cause the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method to include the number of bytes in the BOM in the byte count.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-171">Im folgenden Beispiel wird veranschaulicht, wie zum Erstellen eines neuen <xref:System.Text.UnicodeEncoding> Instanz angegeben wird, ob little-endian oder big-endian-Byte-Sortierreihenfolge unterstützen und das Unicode-Byte order Mark.</span><span class="sxs-lookup"><span data-stu-id="dd63c-171">The following example demonstrates how to create a new <xref:System.Text.UnicodeEncoding> instance specifying whether to support little endian or big endian byte ordering and the Unicode byte order mark.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <span data-ttu-id="dd63c-172">
            <see langword="true" />, um die Big-Endian-Bytereihenfolge (mit dem höchstwertigen Byte an erster Stelle) oder <see langword="false" />, um die Little-Endian-Bytereihenfolge (mit dem niedrigstwertigen Byte an erster Stelle) zu verwenden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-172">
              <see langword="true" /> to use the big endian byte order (most significant byte first); <see langword="false" /> to use the little endian byte order (least significant byte first).</span>
          </span>
        </param>
        <param name="byteOrderMark">
          <span data-ttu-id="dd63c-173">
            <see langword="true" />, um anzugeben, dass die <see cref="M:System.Text.UnicodeEncoding.GetPreamble" />-Methode eine Unicode-Bytereihenfolgemarkierung zurückgibt; andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-173">
              <see langword="true" /> to specify that the <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> method returns a Unicode byte order mark; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="throwOnInvalidBytes">
          <span data-ttu-id="dd63c-174">
            <see langword="true" /> um anzugeben, dass eine Ausnahme ausgelöst werden soll, wenn eine ungültige Codierung gefunden wird, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-174">
              <see langword="true" /> to specify that an exception should be thrown when an invalid encoding is detected; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="dd63c-175">Initialisiert eine neue Instanz der <see cref="T:System.Text.UnicodeEncoding" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-175">Initializes a new instance of the <see cref="T:System.Text.UnicodeEncoding" /> class.</span>
          </span>
          <span data-ttu-id="dd63c-176">Parameter geben an, ob die Big-Endian-Bytereihenfolge verwendet, eine Unicode-Bytereihenfolgemarkierung bereitgestellt und beim Erkennen einer ungültigen Codierung eine Ausnahme ausgelöst werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-176">Parameters specify whether to use the big endian byte order, whether to provide a Unicode byte order mark, and whether to throw an exception when an invalid encoding is detected.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-177">Die `byteOrderMark` Parameter steuert die Ausführung von der <xref:System.Text.UnicodeEncoding.GetPreamble%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-177">The `byteOrderMark` parameter controls the operation of the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method.</span></span> <span data-ttu-id="dd63c-178">Wenn `true`, die Methode gibt ein Bytearray, das die Unicode-bytereihenfolgemarkierung (BOM) in UTF-16-Format enthält.</span><span class="sxs-lookup"><span data-stu-id="dd63c-178">If `true`, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-16 format.</span></span>  <span data-ttu-id="dd63c-179">Wenn `false`, es gibt ein Bytearray der Länge 0 (null) zurück.</span><span class="sxs-lookup"><span data-stu-id="dd63c-179">If `false`, it returns a zero-length byte array.</span></span> <span data-ttu-id="dd63c-180">Jedoch festlegen `byteOrderMark` auf `true` führt nicht dazu, dass die <xref:System.Text.UnicodeEncoding.GetBytes%2A> Methode, um die BOM am Anfang des Bytearrays, Präfix noch führt es dazu, dass die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode, um die Anzahl der Bytes in der Stückliste in die Anzahl der Bytes enthalten.</span><span class="sxs-lookup"><span data-stu-id="dd63c-180">However, setting `byteOrderMark` to `true` does not cause the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method to prefix the BOM at the beginning of the byte array, nor does it cause the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method to include the number of bytes in the BOM in the byte count.</span></span>  
  
 <span data-ttu-id="dd63c-181">Wenn die `throwOnInvalidBytes` Parameter ist `true`, löst Sie eine Methode, die eine ungültige Bytesequenz erkennt <xref:System.ArgumentException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-181">If the `throwOnInvalidBytes` parameter is `true`, a method that detects an invalid byte sequence throws <xref:System.ArgumentException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dd63c-182">Andernfalls wird die Methode löst eine Ausnahme, und die ungültige Sequenz wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd63c-182">Otherwise, the method does not throw an exception, and the invalid sequence is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd63c-183">Aus Gründen der Sicherheit werden Ihre Anwendungen Verwendung dieses Konstruktors zum Erstellen einer Instanz des empfohlen die <xref:System.Text.UnicodeEncoding> Klasse, und schalten Sie fehlererkennung durch Festlegen `throwOnInvalidBytes` auf `true`.</span><span class="sxs-lookup"><span data-stu-id="dd63c-183">For security reasons, your applications are recommended to use this constructor to create an instance of the <xref:System.Text.UnicodeEncoding> class and turn on error detection by setting `throwOnInvalidBytes` to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-184">Das folgende Beispiel veranschaulicht das Verhalten des <xref:System.Text.UnicodeEncoding>, mit der fehlererkennung aktiviert und ohne.</span><span class="sxs-lookup"><span data-stu-id="dd63c-184">The following example demonstrates the behavior of <xref:System.Text.UnicodeEncoding>, both with error detection enabled and without.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/VB/errordetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="CharSize">
      <MemberSignature Language="C#" Value="public const int CharSize = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 CharSize = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Text.UnicodeEncoding.CharSize" />
      <MemberSignature Language="VB.NET" Value="Public Const CharSize As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int CharSize = 2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="dd63c-185">Stellt die Unicode-Zeichengröße in Bytes dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-185">Represents the Unicode character size in bytes.</span>
          </span>
          <span data-ttu-id="dd63c-186">Dieses Feld ist konstant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-186">This field is a constant.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-187">Der Wert dieses Felds ist eine signierte 32-Bit-Konstante mit einem Wert von 2.</span><span class="sxs-lookup"><span data-stu-id="dd63c-187">The value of this field is a 32-bit signed constant with a value of 2.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-188">Im folgenden Beispiel wird veranschaulicht, wie den Wert des zurückzugebenden <xref:System.Text.UnicodeEncoding.CharSize> und angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-188">The following example demonstrates how to return the value of <xref:System.Text.UnicodeEncoding.CharSize> and display it.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CPP/charsize.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CS/charsize.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/VB/charsize.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="dd63c-189">Das Objekt, das mit dem aktuellen Objekt verglichen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-189">The object to compare with the current object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="dd63c-190">Bestimmt, ob das angegebene <see cref="T:System.Object" /> und das aktuelle <see cref="T:System.Text.UnicodeEncoding" />-Objekt gleich sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-190">Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Text.UnicodeEncoding" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-191">
            <see langword="true" />, wenn <paramref name="value" /> eine Instanz von <see cref="T:System.Text.UnicodeEncoding" /> und mit dem aktuellen Objekt identisch ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-191">
              <see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.UnicodeEncoding" /> and is equal to the current object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-192">Zwei <xref:System.Text.UnicodeEncoding> Objekte werden als gleich betrachtet, wenn alle der folgenden Bedingungen erfüllt sind:</span><span class="sxs-lookup"><span data-stu-id="dd63c-192">Two <xref:System.Text.UnicodeEncoding> objects are considered equal if all of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="dd63c-193">Beide Objekte verwenden die gleiche Bytereihenfolge (little-Endian oder big-Endian).</span><span class="sxs-lookup"><span data-stu-id="dd63c-193">Both objects use the same byte order (little-endian or big-endian).</span></span>  
  
-   <span data-ttu-id="dd63c-194">Beide Objekte bereitzustellen, Byte Order Mark, oder beide nicht der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="dd63c-194">Both objects provide the byte order mark, or both do not.</span></span>  
  
-   <span data-ttu-id="dd63c-195">Beide Objekte verwenden die gleichen EncoderFallback.</span><span class="sxs-lookup"><span data-stu-id="dd63c-195">Both objects use the same encoder fallback.</span></span>  
  
-   <span data-ttu-id="dd63c-196">Beide Objekte verwenden die gleichen DecoderFallback.</span><span class="sxs-lookup"><span data-stu-id="dd63c-196">Both objects use the same decoder fallback.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-197">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.Equals%2A> Methode zum Testen, ob die aktuelle <xref:System.Text.UnicodeEncoding> -Objekt gleich einem anderen <xref:System.Text.UnicodeEncoding> Objekt.</span><span class="sxs-lookup"><span data-stu-id="dd63c-197">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.Equals%2A> method to test whether the current <xref:System.Text.UnicodeEncoding> object is equal to a different <xref:System.Text.UnicodeEncoding> object.</span></span> <span data-ttu-id="dd63c-198">Fünf <xref:System.Text.UnicodeEncoding> Objekte erstellt und verglichen werden und die Ergebnisse der Vergleiche werden angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd63c-198">Five <xref:System.Text.UnicodeEncoding> objects are created and compared, and the results of the comparisons are displayed.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="dd63c-199">Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen erzeugt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-199">Calculates the number of bytes produced by encoding a set of characters.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="dd63c-200">Die Zeichenfolge, die die Menge der angegebenen Zeichen enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-200">The string that contains the set of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="dd63c-201">Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen in der angegebenen Zeichenfolge erzeugt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-201">Calculates the number of bytes produced by encoding the characters in the specified string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-202">Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-202">The number of bytes produced by encoding the specified characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-203">Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes rufen Sie die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-203">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="dd63c-204">Um die maximale Arraygröße zu berechnen, rufen Sie die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-204">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="dd63c-205">Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-205">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="dd63c-206">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-206">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="dd63c-207">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-207">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd63c-208">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-208">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="dd63c-209">Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden sollen) ist Aufgabe des Entwicklers, und die Anzahl der Bytes in der Präambel ist nicht in den Rückgabewert von wiedergegeben, die <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-209">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-210">Im folgenden Beispiel wird die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> und <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> Methoden zum Berechnen der maximalen und den tatsächlichen Anzahl der Bytes, die erforderlich sind, um eine Zeichenfolge zu codieren.</span><span class="sxs-lookup"><span data-stu-id="dd63c-210">The following example calls the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> and <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> methods to calculate the maximum and actual number of bytes required to encode a string.</span></span> <span data-ttu-id="dd63c-211">Es zeigt auch die tatsächliche Anzahl von Bytes, die zum Speichern eines Bytestreams mit einem Byte-reihenfolgemarkierung erforderlich.</span><span class="sxs-lookup"><span data-stu-id="dd63c-211">It also displays the actual number of bytes required to store a byte stream with a byte order mark.</span></span>  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="dd63c-212">
            <paramref name="s" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-212">
              <paramref name="s" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="dd63c-213">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-213">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="dd63c-214">Die Fehlererkennung ist aktiviert, und <paramref name="s" /> enthält eine ungültige Folge von Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-214">Error detection is enabled, and <paramref name="s" /> contains an invalid sequence of characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="dd63c-215">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-215">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="dd63c-216">- und -</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-216">-and-</span>
          </span>
          <span data-ttu-id="dd63c-217">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-217">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="dd63c-218">Ein Zeiger auf das erste zu codierende Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-218">A pointer to the first character to encode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="dd63c-219">Die Anzahl der zu codierenden Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-219">The number of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="dd63c-220">Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen ab dem angegebenen Zeichenzeiger erzeugt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-220">Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-221">Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-221">The number of bytes produced by encoding the specified characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-222">Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetBytes%2A> erfordert zum Speichern der resultierenden Bytes, rufen Sie die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-222">To calculate the exact array size that <xref:System.Text.UnicodeEncoding.GetBytes%2A> requires to store the resulting bytes, you call the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="dd63c-223">Um die maximale Arraygröße zu berechnen, rufen Sie die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-223">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="dd63c-224">Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-224">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="dd63c-225">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-225">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="dd63c-226">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-226">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd63c-227">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-227">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="dd63c-228">Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden sollen) ist Aufgabe des Entwicklers, und die Anzahl der Bytes in der Präambel ist nicht in den Rückgabewert von wiedergegeben, die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-228">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="dd63c-229">
            <paramref name="chars" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-229">
              <paramref name="chars" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="dd63c-230">
            <paramref name="count" /> ist kleiner als Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-230">
              <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="dd63c-231">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-231">-or-</span>
          </span>
          <span data-ttu-id="dd63c-232">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-232">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="dd63c-233">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Zeichenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-233">Error detection is enabled and <paramref name="chars" /> contains an invalid sequence of characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="dd63c-234">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-234">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="dd63c-235">- und -</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-235">-and-</span>
          </span>
          <span data-ttu-id="dd63c-236">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-236">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="dd63c-237">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-237">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="dd63c-238">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-238">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="dd63c-239">Das Zeichenarray, das die zu codierenden Zeichen enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-239">The character array containing the set of characters to encode.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="dd63c-240">Der Index des ersten zu codierenden Zeichens.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-240">The index of the first character to encode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="dd63c-241">Die Anzahl der zu codierenden Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-241">The number of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="dd63c-242">Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen aus dem angegebenen Zeichenarray erzeugt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-242">Calculates the number of bytes produced by encoding a set of characters from the specified character array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-243">Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-243">The number of bytes produced by encoding the specified characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-244">Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes verwendet die Anwendung <xref:System.Text.UnicodeEncoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-244">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetBytes%2A> to store the resulting bytes, the application uses <xref:System.Text.UnicodeEncoding.GetByteCount%2A>.</span></span> <span data-ttu-id="dd63c-245">Um die maximale Arraygröße zu berechnen, rufen Sie die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-245">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="dd63c-246">Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-246">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="dd63c-247">Eine ungültige Folge fehlererkennung ist aktiviert, führt diese Methode löst eine <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-247">With error detection enabled, an invalid sequence causes this method to throw an <xref:System.ArgumentException>.</span></span> <span data-ttu-id="dd63c-248">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-248">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="dd63c-249">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-249">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="dd63c-250">Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden sollen) ist Aufgabe des Entwicklers, und die Anzahl der Bytes in der Präambel ist nicht in den Rückgabewert von wiedergegeben, die <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-250">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-251">Im folgenden Beispiel wird ein Array mit einem lateinischen Großbuchstaben und Kleinbuchstaben und ruft die <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Methode, um die Anzahl der Bytes, die zum Codieren der Zeichen des lateinischen Kleinbuchstaben erforderlich festzulegen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-251">The following example populates an array with a Latin uppercase and lowercase characters and calls the <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method to determine the number of bytes needed to encode the Latin lowercase characters.</span></span> <span data-ttu-id="dd63c-252">Es zeigt dann diese Informationen zusammen mit der Gesamtanzahl von Bytes erforderlich, wenn eine Bytereihenfolge-Marke hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-252">It then displays this information along with the total number of bytes needed if a byte order mark is added.</span></span> <span data-ttu-id="dd63c-253">Diese Zahl vergleicht Sie mit den Rückgabewert von der <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> -Methode, die maximale Anzahl von Bytes, die zum Codieren der Zeichen des lateinischen Kleinbuchstaben erforderlich angibt.</span><span class="sxs-lookup"><span data-stu-id="dd63c-253">It compares this number with the value returned by the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method, which indicates maximum number of bytes needed to encode the Latin lowercase characters.</span></span> <span data-ttu-id="dd63c-254">Im folgenden Beispiel wird ein Array mit einer Kombination von Zeichen Griechisch und Kyrillisch und ruft die <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Methode, um zu bestimmen, die Anzahl der Bytes, die erforderlich sind, um die kyrillischen Zeichen zu codieren.</span><span class="sxs-lookup"><span data-stu-id="dd63c-254">The following example populates an array with a combination of Greek and Cyrillic characters and calls the <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method to determine the number of bytes needed to encode the Cyrillic characters.</span></span> <span data-ttu-id="dd63c-255">Es zeigt dann diese Informationen zusammen mit der Gesamtanzahl von Bytes erforderlich, wenn eine Bytereihenfolge-Marke hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-255">It then displays this information along with the total number of bytes needed if a byte order mark is added.</span></span> <span data-ttu-id="dd63c-256">Diese Zahl vergleicht Sie mit den Rückgabewert von der <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> -Methode, die maximale Anzahl von Bytes erforderlich, um die kyrillischen Zeichen zu codieren angibt.</span><span class="sxs-lookup"><span data-stu-id="dd63c-256">It compares this number with the value returned by the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method, which indicates maximum number of bytes needed to encode the Cyrillic characters.</span></span>  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="dd63c-257">
            <paramref name="chars" /> ist <see langword="null" />(<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-257">
              <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="dd63c-258">
            <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-258">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="dd63c-259">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-259">-or-</span>
          </span>
          <span data-ttu-id="dd63c-260">
            <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-260">
              <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</span>
          </span>
          <span data-ttu-id="dd63c-261">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-261">-or-</span>
          </span>
          <span data-ttu-id="dd63c-262">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-262">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="dd63c-263">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-263">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="dd63c-264">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-264">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="dd63c-265">- und -</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-265">-and-</span>
          </span>
          <span data-ttu-id="dd63c-266">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-266">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="dd63c-267">Codiert Zeichen in eine Bytefolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-267">Encodes a set of characters into a sequence of bytes.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="dd63c-268">Ein Zeiger auf das erste zu codierende Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-268">A pointer to the first character to encode.</span>
          </span>
        </param>
        <param name="charCount">
          <span data-ttu-id="dd63c-269">Die Anzahl der zu codierenden Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-269">The number of characters to encode.</span>
          </span>
        </param>
        <param name="bytes">
          <span data-ttu-id="dd63c-270">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-270">A pointer to the location at which to start writing the resulting sequence of bytes.</span>
          </span>
        </param>
        <param name="byteCount">
          <span data-ttu-id="dd63c-271">Die maximale Anzahl der zu schreibenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-271">The maximum number of bytes to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="dd63c-272">Codiert Zeichen beginnend am angegebenen Zeichenzeiger in eine Bytefolge, die beginnend am angegebenen Bytezeiger gespeichert wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-272">Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-273">Die tatsächliche Anzahl an Bytes, die an der durch den <paramref name="bytes" />-Parameter angegebenen Position geschrieben wurden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-273">The actual number of bytes written at the location indicated by the <paramref name="bytes" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-274">Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetBytes%2A> erfordert zum Speichern der resultierenden Bytes, rufen Sie die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-274">To calculate the exact array size that <xref:System.Text.UnicodeEncoding.GetBytes%2A> requires to store the resulting bytes, you call the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="dd63c-275">Um die maximale Arraygröße zu berechnen, rufen Sie die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-275">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="dd63c-276">Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-276">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="dd63c-277">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-277">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="dd63c-278">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-278">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="dd63c-279">Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar.</span><span class="sxs-lookup"><span data-stu-id="dd63c-279">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="dd63c-280">In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> Objekt bereitgestellt werden, indem Sie die <xref:System.Text.UnicodeEncoding.GetDecoder%2A> oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> -Methode, bzw.</span><span class="sxs-lookup"><span data-stu-id="dd63c-280">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd63c-281">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-281">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="dd63c-282">Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden) wird die Verantwortung des Entwicklers.</span><span class="sxs-lookup"><span data-stu-id="dd63c-282">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</span></span> <span data-ttu-id="dd63c-283">Die <xref:System.Text.UnicodeEncoding.GetBytes%2A> Methode ist keine Präambel am Anfang eine codierte Bytefolge nicht voranstellen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-283">The <xref:System.Text.UnicodeEncoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="dd63c-284">
            <paramref name="chars" /> ist <see langword="null" />(<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-284">
              <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
          <span data-ttu-id="dd63c-285">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-285">-or-</span>
          </span>
          <span data-ttu-id="dd63c-286">
            <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-286">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="dd63c-287">
            <paramref name="charCount" /> oder <paramref name="byteCount" /> ist kleiner als 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-287">
              <paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="dd63c-288">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-288">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</span>
          </span>
          <span data-ttu-id="dd63c-289">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-289">-or-</span>
          </span>
          <span data-ttu-id="dd63c-290">
            <paramref name="byteCount" /> ist niedriger als die sich ergebende Anzahl von Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-290">
              <paramref name="byteCount" /> is less than the resulting number of bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="dd63c-291">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-291">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="dd63c-292">- und -</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-292">-and-</span>
          </span>
          <span data-ttu-id="dd63c-293">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-293">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="dd63c-294">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-294">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="dd63c-295">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-295">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="dd63c-296">Das Zeichenarray, das die zu codierenden Zeichen enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-296">The character array containing the set of characters to encode.</span>
          </span>
        </param>
        <param name="charIndex">
          <span data-ttu-id="dd63c-297">Der Index des ersten zu codierenden Zeichens.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-297">The index of the first character to encode.</span>
          </span>
        </param>
        <param name="charCount">
          <span data-ttu-id="dd63c-298">Die Anzahl der zu codierenden Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-298">The number of characters to encode.</span>
          </span>
        </param>
        <param name="bytes">
          <span data-ttu-id="dd63c-299">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-299">The byte array to contain the resulting sequence of bytes.</span>
          </span>
        </param>
        <param name="byteIndex">
          <span data-ttu-id="dd63c-300">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-300">The index at which to start writing the resulting sequence of bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="dd63c-301">Codiert Zeichen aus dem angegebenen Zeichenarray in das angegebene Bytearray.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-301">Encodes a set of characters from the specified character array into the specified byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-302">Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-302">The actual number of bytes written into <paramref name="bytes" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-303">Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes rufen Sie die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-303">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="dd63c-304">Um die maximale Arraygröße zu berechnen, rufen Sie die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-304">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="dd63c-305">Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-305">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="dd63c-306">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-306">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="dd63c-307">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-307">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="dd63c-308">Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar.</span><span class="sxs-lookup"><span data-stu-id="dd63c-308">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="dd63c-309">In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UnicodeEncoding.GetDecoder%2A> Methode oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> Methode bzw.</span><span class="sxs-lookup"><span data-stu-id="dd63c-309">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> method or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd63c-310">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-310">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="dd63c-311">Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden) wird die Verantwortung des Entwicklers.</span><span class="sxs-lookup"><span data-stu-id="dd63c-311">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</span></span> <span data-ttu-id="dd63c-312">Die <xref:System.Text.UnicodeEncoding.GetBytes%2A> Methode ist keine Präambel am Anfang eine codierte Bytefolge nicht voranstellen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-312">The <xref:System.Text.UnicodeEncoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-313">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetBytes%2A> Methode zum Codieren eines Bereichs von Zeichen aus einer <xref:System.String> und speichern Sie die codierten Bytes in einem Bereich von Elementen in ein Bytearray.</span><span class="sxs-lookup"><span data-stu-id="dd63c-313">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method to encode a range of characters from a <xref:System.String> and store the encoded bytes in a range of elements in a byte array.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="dd63c-314">
            <paramref name="chars" /> ist <see langword="null" />(<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-314">
              <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
          <span data-ttu-id="dd63c-315">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-315">-or-</span>
          </span>
          <span data-ttu-id="dd63c-316">
            <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-316">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="dd63c-317">
            <paramref name="charIndex" />, <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-317">
              <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span>
          </span>
          <span data-ttu-id="dd63c-318">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-318">-or-</span>
          </span>
          <span data-ttu-id="dd63c-319">
            <paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-319">
              <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span>
          </span>
          <span data-ttu-id="dd63c-320">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-320">-or-</span>
          </span>
          <span data-ttu-id="dd63c-321">
            <paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-321">
              <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="dd63c-322">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-322">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</span>
          </span>
          <span data-ttu-id="dd63c-323">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-323">-or-</span>
          </span>
          <span data-ttu-id="dd63c-324">
            <paramref name="bytes" /> hat von <paramref name="byteIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-324">
              <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="dd63c-325">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-325">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="dd63c-326">- und -</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-326">-and-</span>
          </span>
          <span data-ttu-id="dd63c-327">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-327">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="dd63c-328">Die Zeichenfolge mit den zu codierenden Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-328">The string containing the set of characters to encode.</span>
          </span>
        </param>
        <param name="charIndex">
          <span data-ttu-id="dd63c-329">Der Index des ersten zu codierenden Zeichens.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-329">The index of the first character to encode.</span>
          </span>
        </param>
        <param name="charCount">
          <span data-ttu-id="dd63c-330">Die Anzahl der zu codierenden Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-330">The number of characters to encode.</span>
          </span>
        </param>
        <param name="bytes">
          <span data-ttu-id="dd63c-331">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-331">The byte array to contain the resulting sequence of bytes.</span>
          </span>
        </param>
        <param name="byteIndex">
          <span data-ttu-id="dd63c-332">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-332">The index at which to start writing the resulting sequence of bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="dd63c-333">Codiert Zeichen aus der angegebenen <see cref="T:System.String" />-Klasse in das angegebene Bytearray.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-333">Encodes a set of characters from the specified <see cref="T:System.String" /> into the specified byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-334">Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-334">The actual number of bytes written into <paramref name="bytes" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-335">Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes rufen Sie die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-335">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="dd63c-336">Um die maximale Arraygröße zu berechnen, rufen Sie die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-336">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="dd63c-337">Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-337">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="dd63c-338">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-338">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="dd63c-339">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-339">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="dd63c-340">Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar.</span><span class="sxs-lookup"><span data-stu-id="dd63c-340">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="dd63c-341">In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UnicodeEncoding.GetDecoder%2A> Methode oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> Methode bzw.</span><span class="sxs-lookup"><span data-stu-id="dd63c-341">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> method or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd63c-342">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-342">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="dd63c-343">Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden) wird die Verantwortung des Entwicklers.</span><span class="sxs-lookup"><span data-stu-id="dd63c-343">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</span></span> <span data-ttu-id="dd63c-344">Die <xref:System.Text.UnicodeEncoding.GetBytes%2A> Methode ist keine Präambel am Anfang eine codierte Bytefolge nicht voranstellen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-344">The <xref:System.Text.UnicodeEncoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-345">Im folgenden Beispiel wird veranschaulicht, wie auf einen Bereich von Elementen aus einem Array von Unicode-Zeichen zu codieren, und speichern die codierten Bytes in einem Bereich von Elementen in einem Bytearray.</span><span class="sxs-lookup"><span data-stu-id="dd63c-345">The following example demonstrates how to encode a range of elements from a Unicode character array and store the encoded bytes in a range of elements in a byte array.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="dd63c-346">
            <paramref name="s" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-346">
              <paramref name="s" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="dd63c-347">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-347">-or-</span>
          </span>
          <span data-ttu-id="dd63c-348">
            <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-348">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="dd63c-349">
            <paramref name="charIndex" />, <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-349">
              <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span>
          </span>
          <span data-ttu-id="dd63c-350">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-350">-or-</span>
          </span>
          <span data-ttu-id="dd63c-351">
            <paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-351">
              <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span>
          </span>
          <span data-ttu-id="dd63c-352">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-352">-or-</span>
          </span>
          <span data-ttu-id="dd63c-353">
            <paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-353">
              <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="dd63c-354">Die Fehlererkennung ist aktiviert, und <paramref name="s" /> enthält eine ungültige Folge von Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-354">Error detection is enabled, and <paramref name="s" /> contains an invalid sequence of characters.</span>
          </span>
          <span data-ttu-id="dd63c-355">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-355">-or-</span>
          </span>
          <span data-ttu-id="dd63c-356">
            <paramref name="bytes" /> hat von <paramref name="byteIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-356">
              <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="dd63c-357">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-357">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="dd63c-358">- und -</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-358">-and-</span>
          </span>
          <span data-ttu-id="dd63c-359">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-359">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="dd63c-360">Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge erzeugt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-360">Calculates the number of characters produced by decoding a sequence of bytes.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="dd63c-361">Ein Zeiger auf das erste zu decodierende Byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-361">A pointer to the first byte to decode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="dd63c-362">Die Anzahl der zu decodierenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-362">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="dd63c-363">Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge ab dem angegebenen Bytezeiger erzeugt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-363">Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-364">Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-364">The number of characters produced by decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-365">Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetChars%2A> erfordert zum Speichern der resultierenden Zeichen, die der Anwendung verwendeten <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-365">To calculate the exact array size that <xref:System.Text.UnicodeEncoding.GetChars%2A> requires to store the resulting characters, the application uses <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span></span> <span data-ttu-id="dd63c-366">Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-366">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span> <span data-ttu-id="dd63c-367">Die <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-367">The <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="dd63c-368">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-368">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="dd63c-369">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-369">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="dd63c-370">
            <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-370">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="dd63c-371">
            <paramref name="count" /> ist kleiner als Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-371">
              <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="dd63c-372">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-372">-or-</span>
          </span>
          <span data-ttu-id="dd63c-373">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-373">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="dd63c-374">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-374">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="dd63c-375">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-375">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="dd63c-376">- und -</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-376">-and-</span>
          </span>
          <span data-ttu-id="dd63c-377">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-377">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="dd63c-378">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-378">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="dd63c-379">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-379">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="dd63c-380">Das Bytearray, das die zu decodierende Bytefolge enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-380">The byte array containing the sequence of bytes to decode.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="dd63c-381">Der Index des ersten zu decodierenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-381">The index of the first byte to decode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="dd63c-382">Die Anzahl der zu decodierenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-382">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="dd63c-383">Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge aus dem angegebenen Bytearray erzeugt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-383">Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-384">Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-384">The number of characters produced by decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-385">Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetChars%2A> zum Speichern der resultierenden Zeichen, die Anwendung verwendet <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-385">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetChars%2A> to store the resulting characters, the application uses <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span></span> <span data-ttu-id="dd63c-386">Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-386">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span> <span data-ttu-id="dd63c-387">Die <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-387">The <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="dd63c-388">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-388">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="dd63c-389">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-389">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-390">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Methode, um die Anzahl von Zeichen zurückzugeben, die beim Decodieren Sie einen Bereich von Elementen in einem Byte-Array von erzeugt <xref:System.Text.UnicodeEncoding>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-390">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method to return the number of characters produced by decoding a range of elements in a byte array using <xref:System.Text.UnicodeEncoding>.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="dd63c-391">
            <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-391">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="dd63c-392">
            <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-392">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="dd63c-393">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-393">-or-</span>
          </span>
          <span data-ttu-id="dd63c-394">
            <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-394">
              <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span>
          </span>
          <span data-ttu-id="dd63c-395">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-395">-or-</span>
          </span>
          <span data-ttu-id="dd63c-396">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-396">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="dd63c-397">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-397">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="dd63c-398">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-398">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="dd63c-399">- und -</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-399">-and-</span>
          </span>
          <span data-ttu-id="dd63c-400">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-400">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="dd63c-401">Decodiert eine Bytefolge in Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-401">Decodes a sequence of bytes into a set of characters.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="dd63c-402">Ein Zeiger auf das erste zu decodierende Byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-402">A pointer to the first byte to decode.</span>
          </span>
        </param>
        <param name="byteCount">
          <span data-ttu-id="dd63c-403">Die Anzahl der zu decodierenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-403">The number of bytes to decode.</span>
          </span>
        </param>
        <param name="chars">
          <span data-ttu-id="dd63c-404">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-404">A pointer to the location at which to start writing the resulting set of characters.</span>
          </span>
        </param>
        <param name="charCount">
          <span data-ttu-id="dd63c-405">Die maximale Anzahl der zu schreibenden Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-405">The maximum number of characters to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="dd63c-406">Decodiert eine Bytefolge beginnend am angegebenen Bytezeiger in Zeichen, die beginnend am angegebenen Zeichenzeiger gespeichert werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-406">Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-407">Die tatsächliche Anzahl der Zeichen, die an der durch den <paramref name="chars" />-Parameter angegebenen Position geschrieben wurden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-407">The actual number of characters written at the location indicated by the <paramref name="chars" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-408">Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetChars%2A> erfordert zum Speichern der resultierenden Zeichen, die der Anwendung verwendeten <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-408">To calculate the exact array size that <xref:System.Text.UnicodeEncoding.GetChars%2A> requires to store the resulting characters, the application uses <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span></span> <span data-ttu-id="dd63c-409">Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-409">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span> <span data-ttu-id="dd63c-410">Die <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-410">The <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="dd63c-411">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-411">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="dd63c-412">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-412">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="dd63c-413">Wenn Sie der Bereich von Bytes, die zu decodierende enthält die Byte-reihenfolgemarkierung (BOM), und das Bytearray mit einer anderen Methode eines Typs nicht BOM beachten zurückgegeben wurde, ist das Zeichen U + FFFE im Zeichenarray, das von dieser Methode zurückgegebene enthalten.</span><span class="sxs-lookup"><span data-stu-id="dd63c-413">If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</span></span> <span data-ttu-id="dd63c-414">Sie können diesen entfernen, durch Aufrufen der <xref:System.String.TrimStart%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-414">You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="dd63c-415">Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar.</span><span class="sxs-lookup"><span data-stu-id="dd63c-415">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="dd63c-416">In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> Objekt bereitgestellt werden, indem Sie die <xref:System.Text.UnicodeEncoding.GetDecoder%2A> oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> -Methode, bzw.</span><span class="sxs-lookup"><span data-stu-id="dd63c-416">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="dd63c-417">
            <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-417">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
          <span data-ttu-id="dd63c-418">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-418">-or-</span>
          </span>
          <span data-ttu-id="dd63c-419">
            <paramref name="chars" /> ist <see langword="null" />(<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-419">
              <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="dd63c-420">
            <paramref name="byteCount" /> oder <paramref name="charCount" /> ist kleiner als 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-420">
              <paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="dd63c-421">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-421">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span>
          </span>
          <span data-ttu-id="dd63c-422">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-422">-or-</span>
          </span>
          <span data-ttu-id="dd63c-423">
            <paramref name="charCount" /> ist niedriger als die sich ergebende Anzahl von Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-423">
              <paramref name="charCount" /> is less than the resulting number of characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="dd63c-424">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-424">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="dd63c-425">- und -</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-425">-and-</span>
          </span>
          <span data-ttu-id="dd63c-426">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-426">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="dd63c-427">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-427">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="dd63c-428">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-428">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="dd63c-429">Das Bytearray, das die zu decodierende Bytefolge enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-429">The byte array containing the sequence of bytes to decode.</span>
          </span>
        </param>
        <param name="byteIndex">
          <span data-ttu-id="dd63c-430">Der Index des ersten zu decodierenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-430">The index of the first byte to decode.</span>
          </span>
        </param>
        <param name="byteCount">
          <span data-ttu-id="dd63c-431">Die Anzahl der zu decodierenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-431">The number of bytes to decode.</span>
          </span>
        </param>
        <param name="chars">
          <span data-ttu-id="dd63c-432">Das Zeichenarray, das die sich ergebenden Zeichen enthalten soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-432">The character array to contain the resulting set of characters.</span>
          </span>
        </param>
        <param name="charIndex">
          <span data-ttu-id="dd63c-433">Der Index, an dem mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-433">The index at which to start writing the resulting set of characters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="dd63c-434">Decodiert eine Bytefolge aus dem angegebenen Bytearray in das angegebene Zeichenarray.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-434">Decodes a sequence of bytes from the specified byte array into the specified character array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-435">Die tatsächliche Anzahl der Zeichen, die in <paramref name="chars" /> geschrieben werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-435">The actual number of characters written into <paramref name="chars" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-436">Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetChars%2A> zum Speichern der resultierenden Zeichen, die Anwendung verwendet <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-436">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetChars%2A> to store the resulting characters, the application uses <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span></span> <span data-ttu-id="dd63c-437">Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-437">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span> <span data-ttu-id="dd63c-438">Die <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-438">The <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="dd63c-439">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-439">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="dd63c-440">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-440">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="dd63c-441">Wenn Sie der Bereich von Bytes, die zu decodierende enthält die Byte-reihenfolgemarkierung (BOM), und das Bytearray mit einer anderen Methode eines Typs nicht BOM beachten zurückgegeben wurde, ist das Zeichen U + FFFE im Zeichenarray, das von dieser Methode zurückgegebene enthalten.</span><span class="sxs-lookup"><span data-stu-id="dd63c-441">If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</span></span> <span data-ttu-id="dd63c-442">Sie können diesen entfernen, durch Aufrufen der <xref:System.String.TrimStart%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-442">You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="dd63c-443">Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar.</span><span class="sxs-lookup"><span data-stu-id="dd63c-443">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="dd63c-444">In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UnicodeEncoding.GetDecoder%2A> Methode oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> Methode bzw.</span><span class="sxs-lookup"><span data-stu-id="dd63c-444">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> method or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-445">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetChars%2A> Methode, um einen Bereich von Elementen in einem Bytearray zu decodieren und Speichern des Ergebnisses in ein Zeichenarray.</span><span class="sxs-lookup"><span data-stu-id="dd63c-445">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetChars%2A> method to decode a range of elements in a byte array and store the result in a character array.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="dd63c-446">
            <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-446">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
          <span data-ttu-id="dd63c-447">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-447">-or-</span>
          </span>
          <span data-ttu-id="dd63c-448">
            <paramref name="chars" /> ist <see langword="null" />(<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-448">
              <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="dd63c-449">
            <paramref name="byteIndex" />, <paramref name="byteCount" /> oder <paramref name="charIndex" /> ist kleiner als 0 (null).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-449">
              <paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.</span>
          </span>
          <span data-ttu-id="dd63c-450">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-450">-or-</span>
          </span>
          <span data-ttu-id="dd63c-451">
            <paramref name="byteindex" /> und <paramref name="byteCount" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-451">
              <paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.</span>
          </span>
          <span data-ttu-id="dd63c-452">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-452">-or-</span>
          </span>
          <span data-ttu-id="dd63c-453">
            <paramref name="charIndex" /> ist kein gültiger Index in <paramref name="chars" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-453">
              <paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="dd63c-454">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-454">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span>
          </span>
          <span data-ttu-id="dd63c-455">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-455">-or-</span>
          </span>
          <span data-ttu-id="dd63c-456">
            <paramref name="chars" /> hat von <paramref name="charIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Zeichen aufzunehmen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-456">
              <paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="dd63c-457">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-457">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="dd63c-458">- und -</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-458">-and-</span>
          </span>
          <span data-ttu-id="dd63c-459">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-459">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="dd63c-460">Ruft einen Decoder ab, der eine UTF-16-codierte Bytefolge in eine Unicode-Zeichenfolge konvertiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-460">Obtains a decoder that converts a UTF-16 encoded sequence of bytes into a sequence of Unicode characters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-461">Ein <see cref="T:System.Text.Decoder" />, der eine UTF-16-codierte Bytefolge in eine Unicode-Zeichenfolge konvertiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-461">A <see cref="T:System.Text.Decoder" /> that converts a UTF-16 encoded sequence of bytes into a sequence of Unicode characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-462">Die <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> konvertiert sequenzielle Blöcke von Bytes in sequenzielle Blöcke von Zeichen ähnlich wie die <xref:System.Text.UnicodeEncoding.GetChars%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-462">The <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.UnicodeEncoding.GetChars%2A>.</span></span> <span data-ttu-id="dd63c-463">Allerdings eine <xref:System.Text.Decoder> verwaltet Zustandsinformationen zwischen aufrufen, damit Bytesequenzen, die Blöcke umfassen, ordnungsgemäß decodiert werden können.</span><span class="sxs-lookup"><span data-stu-id="dd63c-463">However, a <xref:System.Text.Decoder> maintains state information between calls so it can correctly decode byte sequences that span blocks.</span></span> <span data-ttu-id="dd63c-464">Die <xref:System.Text.Decoder> behält nachfolgende Bytes am Ende der Datenblöcke und die nachfolgenden Bytes im nächste Decodierungsvorgang verwendet.</span><span class="sxs-lookup"><span data-stu-id="dd63c-464">The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</span></span> <span data-ttu-id="dd63c-465">Aus diesem Grund <xref:System.Text.UnicodeEncoding.GetDecoder%2A> und <xref:System.Text.UnicodeEncoding.GetEncoder%2A> eignen sich für die netzwerkübertragung und Dateivorgänge, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-465">Therefore, <xref:System.Text.UnicodeEncoding.GetDecoder%2A> and <xref:System.Text.UnicodeEncoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>  
  
 <span data-ttu-id="dd63c-466">Wenn Erkennung, d. h. aktiviert ist die `throwOnInvalidBytes` Parameter des Konstruktors festgelegt ist, um `true`, fehlererkennung ist auch aktiviert, der <xref:System.Text.Decoder> von dieser Methode zurückgegebene.</span><span class="sxs-lookup"><span data-stu-id="dd63c-466">If error detection is enabled, that is, the `throwOnInvalidBytes` parameter of the constructor is set to `true`, error detection is also enabled in the <xref:System.Text.Decoder> returned by this method.</span></span> <span data-ttu-id="dd63c-467">Wenn fehlererkennung ist aktiviert, und eine ungültige Folge festgestellt wird, der Zustand des Decoders ist nicht definiert und Verarbeitung muss beendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd63c-467">If error detection is enabled and an invalid sequence is encountered, the state of the decoder is undefined and processing must stop.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-468">Im folgenden Beispiel wird ein Encoder und Decoder eine Zeichenfolge in ein Array von Bytes zu codieren, und klicken Sie dann die Bytes in ein Array von Zeichen decodiert.</span><span class="sxs-lookup"><span data-stu-id="dd63c-468">The following example uses an encoder and a decoder to encode a string into an array of bytes, and then decode the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="dd63c-469">Ruft einen Encoder ab, der eine Unicode-Zeichenfolge in eine UTF-16-codierte Bytefolge konvertiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-469">Obtains an encoder that converts a sequence of Unicode characters into a UTF-16 encoded sequence of bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-470">Ein <see cref="T:System.Text.Encoder" />-Objekt, das eine Unicode-Zeichenfolge in eine UTF-16-codierte Bytefolge konvertiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-470">A <see cref="T:System.Text.Encoder" /> object that converts a sequence of Unicode characters into a UTF-16 encoded sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-471">Die <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> konvertiert sequenzielle Blöcke von Zeichen in sequenzielle Blöcke von Bytes in auf ähnliche Weise die <xref:System.Text.UnicodeEncoding.GetBytes%2A> Methode dieser Klasse.</span><span class="sxs-lookup"><span data-stu-id="dd63c-471">The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method converts sequential blocks of characters into sequential blocks of bytes in a manner similar to the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method of this class.</span></span> <span data-ttu-id="dd63c-472">Allerdings ein <xref:System.Text.Encoder> -Objekt verwaltet Zustandsinformationen zwischen aufrufen, damit Zeichensequenzen, die Blöcke umfassen, korrekt codiert werden können.</span><span class="sxs-lookup"><span data-stu-id="dd63c-472">However, a <xref:System.Text.Encoder> object maintains state information between calls so that it can correctly encode character sequences that span blocks.</span></span> <span data-ttu-id="dd63c-473">Die <xref:System.Text.Encoder> Objekt behält nachfolgende Zeichen am Ende der Datenblöcke und das nachfolgenden Zeichen in der nächsten Codierungsvorgang verwendet.</span><span class="sxs-lookup"><span data-stu-id="dd63c-473">The <xref:System.Text.Encoder> object also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</span></span> <span data-ttu-id="dd63c-474">Z. B. ein Datenblock möglicherweise eine hohe Ersatzzeichen ohne Entsprechung enden, und die übereinstimmende niedrige Ersatzzeichen ist möglicherweise in den nächsten Datenblock.</span><span class="sxs-lookup"><span data-stu-id="dd63c-474">For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</span></span> <span data-ttu-id="dd63c-475">Aus diesem Grund <xref:System.Text.UnicodeEncoding.GetDecoder%2A> und <xref:System.Text.UnicodeEncoding.GetEncoder%2A> eignen sich für die netzwerkübertragung und Dateivorgänge, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-475">Therefore, <xref:System.Text.UnicodeEncoding.GetDecoder%2A> and <xref:System.Text.UnicodeEncoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>  
  
 <span data-ttu-id="dd63c-476">Wenn Erkennung, d. h. aktiviert ist die `throwOnInvalidBytes` Parameter des Konstruktors festgelegt ist, um `true`, fehlererkennung ist auch aktiviert, der <xref:System.Text.Encoder> von dieser Methode zurückgegebene Objekt.</span><span class="sxs-lookup"><span data-stu-id="dd63c-476">If error detection is enabled, that is, the `throwOnInvalidBytes` parameter of the constructor is set to `true`, error detection is also enabled in the <xref:System.Text.Encoder> object returned by this method.</span></span> <span data-ttu-id="dd63c-477">Wenn die fehlererkennung ist aktiviert, und eine ungültige Folge festgestellt wird, der Zustand des Encoders ist nicht definiert und Verarbeitung muss beendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd63c-477">If error detection is enabled and an invalid sequence is encountered, the state of the encoder is undefined and processing must stop.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-478">Im folgenden Beispiel wird ein Encoder und Decoder eine Zeichenfolge in ein Array von Bytes zu codieren, und klicken Sie dann die Bytes in ein Array von Zeichen decodiert.</span><span class="sxs-lookup"><span data-stu-id="dd63c-478">The following example uses an encoder and a decoder to encode a string into an array of bytes, and then decode the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="dd63c-479">Gibt den Hashcode für die aktuelle Instanz zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-479">Returns the hash code for the current instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-480">Der Hashcode für das aktuelle <see cref="T:System.Text.UnicodeEncoding" />-Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-480">The hash code for the current <see cref="T:System.Text.UnicodeEncoding" /> object.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">
          <span data-ttu-id="dd63c-481">Die Anzahl der zu codierenden Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-481">The number of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="dd63c-482">Berechnet die maximale Anzahl der Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-482">Calculates the maximum number of bytes produced by encoding the specified number of characters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-483">Die maximale Anzahl an Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-483">The maximum number of bytes produced by encoding the specified number of characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-484">Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetBytes%2A> zum Speichern der resultierenden Bytes verwendet die Anwendung <xref:System.Text.UnicodeEncoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-484">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetBytes%2A> to store the resulting bytes, the application uses <xref:System.Text.UnicodeEncoding.GetByteCount%2A>.</span></span> <span data-ttu-id="dd63c-485">Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-485">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.</span></span> <span data-ttu-id="dd63c-486">Die <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-486">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="dd63c-487"><xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Ruft die Anzahl Worst-Case, einschließlich ungünstigsten Fall für das derzeit ausgewählte ab <xref:System.Text.EncoderFallback>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-487"><xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>.</span></span> <span data-ttu-id="dd63c-488">Wenn ein Fallback mit einer potenziell großen Zeichenfolge ausgewählt wird <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> große Werte zurückgeben können.</span><span class="sxs-lookup"><span data-stu-id="dd63c-488">If a fallback is chosen with a potentially large string, <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> can return large values.</span></span>  
  
 <span data-ttu-id="dd63c-489">In den meisten Fällen ruft diese Methode geeignete Zahlen für kleine Zeichenfolgen ab.</span><span class="sxs-lookup"><span data-stu-id="dd63c-489">In most cases, this method retrieves reasonable numbers for small strings.</span></span> <span data-ttu-id="dd63c-490">Für große Zeichenfolgen müssen Sie möglicherweise entscheiden sehr große Puffer und Erfassen von Fehlern in dem seltenen Fall, dass ein günstiger Puffer überschritten wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-490">For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</span></span> <span data-ttu-id="dd63c-491">Sie sollten auch einen anderen Ansatz erwägen <xref:System.Text.UnicodeEncoding.GetByteCount%2A> oder <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-491">You might also want to consider a different approach using <xref:System.Text.UnicodeEncoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="dd63c-492"><xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> hat keinen Bezug zu <xref:System.Text.UnicodeEncoding.GetChars%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-492"><xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> has no relation to <xref:System.Text.UnicodeEncoding.GetChars%2A>.</span></span> <span data-ttu-id="dd63c-493">Wenn Ihre Anwendung eine ähnliche Funktion für die Verwendung mit benötigt <xref:System.Text.UnicodeEncoding.GetChars%2A>, sollte <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-493">If your application needs a similar function to use with <xref:System.Text.UnicodeEncoding.GetChars%2A>, it should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd63c-494">`GetMaxByteCount(N)` ist nicht unbedingt der gleiche Wert wie `N* GetMaxByteCount(1)`.</span><span class="sxs-lookup"><span data-stu-id="dd63c-494">`GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-495">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Methode, um die maximale Anzahl von Bytes, die erforderlich sind, um eine angegebene Anzahl von Zeichen zu codieren zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="dd63c-495">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method to return the maximum number of bytes required to encode a specified number of characters.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="dd63c-496">
            <paramref name="charCount" /> ist kleiner als Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-496">
              <paramref name="charCount" /> is less than zero.</span>
          </span>
          <span data-ttu-id="dd63c-497">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-497">-or-</span>
          </span>
          <span data-ttu-id="dd63c-498">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-498">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="dd63c-499">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-499">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="dd63c-500">- und -</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-500">-and-</span>
          </span>
          <span data-ttu-id="dd63c-501">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-501">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">
          <span data-ttu-id="dd63c-502">Die Anzahl der zu decodierenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-502">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="dd63c-503">Berechnet die maximale Anzahl der Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-503">Calculates the maximum number of characters produced by decoding the specified number of bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-504">Die maximale Anzahl von Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-504">The maximum number of characters produced by decoding the specified number of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-505">Zum Berechnen der genauen Arraygröße <xref:System.Text.UnicodeEncoding.GetChars%2A> zum Speichern der resultierenden Zeichen, die Anwendung verwendet <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-505">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetChars%2A> to store the resulting characters, the application uses <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span></span> <span data-ttu-id="dd63c-506">Die Anwendung sollte zum Berechnen der maximalen verwenden <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-506">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span> <span data-ttu-id="dd63c-507">Die <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Methode weist im Allgemeinen weniger Speicher, während die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-507">The <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="dd63c-508"><xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Ruft die Anzahl Worst-Case, einschließlich ungünstigsten Fall für das derzeit ausgewählte ab <xref:System.Text.DecoderFallback>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-508"><xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>.</span></span> <span data-ttu-id="dd63c-509">Wenn ein Fallback mit einer potenziell großen Zeichenfolge ausgewählt wird <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> große Werte abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-509">If a fallback is chosen with a potentially large string, <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> retrieves large values.</span></span>  
  
 <span data-ttu-id="dd63c-510">In den meisten Fällen ruft diese Methode geeignete Zahlen für kleine Zeichenfolgen ab.</span><span class="sxs-lookup"><span data-stu-id="dd63c-510">In most cases, this method retrieves reasonable numbers for small strings.</span></span> <span data-ttu-id="dd63c-511">Für große Zeichenfolgen müssen Sie möglicherweise entscheiden sehr große Puffer und Erfassen von Fehlern in dem seltenen Fall, dass ein günstiger Puffer überschritten wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-511">For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</span></span> <span data-ttu-id="dd63c-512">Sie sollten auch einen anderen Ansatz erwägen <xref:System.Text.UnicodeEncoding.GetCharCount%2A> oder <xref:System.Text.Decoder.Convert%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-512">You might also want to consider a different approach using <xref:System.Text.UnicodeEncoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A>.</span></span>  
  
 <span data-ttu-id="dd63c-513"><xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> hat keinen Bezug zu <xref:System.Text.UnicodeEncoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-513"><xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> has no relation to <xref:System.Text.UnicodeEncoding.GetBytes%2A>.</span></span> <span data-ttu-id="dd63c-514">Wenn Ihre Anwendung eine ähnliche Funktion für die Verwendung mit benötigt <xref:System.Text.UnicodeEncoding.GetBytes%2A>, sollte <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-514">If your application needs a similar function to use with <xref:System.Text.UnicodeEncoding.GetBytes%2A>, it should use <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd63c-515">`GetMaxCharCount(N)` ist nicht unbedingt der gleiche Wert wie `N* GetMaxCharCount(1)`.</span><span class="sxs-lookup"><span data-stu-id="dd63c-515">`GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-516">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Methode, um die maximale Anzahl von Zeichen zurückzugeben, die beim Decodieren von einer angegebenen Anzahl von Bytes erzeugt.</span><span class="sxs-lookup"><span data-stu-id="dd63c-516">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method to return the maximum number of characters produced by decoding a specified number of bytes.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="dd63c-517">
            <paramref name="byteCount" /> ist kleiner als Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-517">
              <paramref name="byteCount" /> is less than zero.</span>
          </span>
          <span data-ttu-id="dd63c-518">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-518">-or-</span>
          </span>
          <span data-ttu-id="dd63c-519">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-519">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="dd63c-520">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-520">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="dd63c-521">- und -</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-521">-and-</span>
          </span>
          <span data-ttu-id="dd63c-522">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-522">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="dd63c-523">Gibt eine im UTF-16-Format codierte Unicode-Bytereihenfolgemarkierung zurück, wenn der Konstruktor für diese Instanz die Bereitstellung einer Bytereihenfolgemarkierung anfordert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-523">Returns a Unicode byte order mark encoded in UTF-16 format, if the constructor for this instance requests a byte order mark.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-524">Ein Bytearray, das die Unicode-Bytereihenfolgemarkierung enthält, wenn das <see cref="T:System.Text.UnicodeEncoding" />-Objekt dafür konfiguriert ist, eine bereitzustellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-524">A byte array containing the Unicode byte order mark, if the <see cref="T:System.Text.UnicodeEncoding" /> object is configured to supply one.</span>
          </span>
          <span data-ttu-id="dd63c-525">Andernfalls gibt diese Methode ein Bytearray mit der Länge Null zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-525">Otherwise, this method returns a zero-length byte array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-526">Die <xref:System.Text.UnicodeEncoding> Objekt bieten keine Präambel, also ein Byte-Array, das die Abfolge von Bytes, die aufgrund des Codierungsvorgangs vorangestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd63c-526">The <xref:System.Text.UnicodeEncoding> object can provide a preamble, which is a byte array that can be prefixed to the sequence of bytes resulting from the encoding process.</span></span> <span data-ttu-id="dd63c-527">Eine Sequenz codierter Bytes mit einem Byte-reihenfolgemarkierung (Codepunkt U + FEFF) voran unterstützt den Decoder, der die Bytereihenfolge und die Transformationsformat oder im UTF zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-527">Prefacing a sequence of encoded bytes with a byte order mark (code point U+FEFF) helps the decoder determine the byte order and the transformation format or UTF.</span></span> <span data-ttu-id="dd63c-528">Die Unicode-bytereihenfolgemarkierung (BOM) ist (im Hexadezimalformat) wie folgt serialisiert:</span><span class="sxs-lookup"><span data-stu-id="dd63c-528">The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</span></span>  
  
-   <span data-ttu-id="dd63c-529">Big-endian-Bytereihenfolge: FF FE</span><span class="sxs-lookup"><span data-stu-id="dd63c-529">Big endian byte order: FE FF</span></span>  
  
-   <span data-ttu-id="dd63c-530">Little-endian-Bytereihenfolge: FF FE</span><span class="sxs-lookup"><span data-stu-id="dd63c-530">Little endian byte order: FF FE</span></span>  
  
 <span data-ttu-id="dd63c-531">Instanziieren Sie ein <xref:System.Text.UnicodeEncoding> Objekt, dessen <xref:System.Text.UnicodeEncoding.GetPreamble%2A> Methodenrückgabe eine gültige BOM auf folgende Weise:</span><span class="sxs-lookup"><span data-stu-id="dd63c-531">You can instantiate a <xref:System.Text.UnicodeEncoding> object whose <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method returns a valid BOM in the following ways:</span></span>  
  
-   <span data-ttu-id="dd63c-532">Durch das Abrufen der <xref:System.Text.UnicodeEncoding> zurückgegebenes Objekt die <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> oder <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd63c-532">By retrieving the <xref:System.Text.UnicodeEncoding> object returned by the <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> or <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType> property.</span></span>  
  
-   <span data-ttu-id="dd63c-533">Durch Aufrufen der parameterlosen <xref:System.Text.UnicodeEncoding.%23ctor> Konstruktor zum Instanziieren einer <xref:System.Text.UnicodeEncoding> Objekt.</span><span class="sxs-lookup"><span data-stu-id="dd63c-533">By calling the parameterless <xref:System.Text.UnicodeEncoding.%23ctor> constructor to instantiate a <xref:System.Text.UnicodeEncoding> object.</span></span>  
  
-   <span data-ttu-id="dd63c-534">Durch Angabe `true` als Wert für die `byteOrderMark` Argument an die <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> oder <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktoren.</span><span class="sxs-lookup"><span data-stu-id="dd63c-534">By supplying `true` as the value of the `byteOrderMark` argument to the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> or <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructors.</span></span>  
  
 <span data-ttu-id="dd63c-535">Es wird empfohlen, Sie verwenden die BOM, da sie fast bestimmte Kennung für eine Codierung für Dateien, die andernfalls einen Verweis auf ihre Codierung, z. B. nicht gekennzeichnet oder nicht ordnungsgemäß markierten verloren bereitstellt Webdaten oder zufällige Dateien gespeichert, wenn ein Unternehmen keinen Internationale Aspekte.</span><span class="sxs-lookup"><span data-stu-id="dd63c-535">We recommended that you use the BOM, since it provides nearly certain identification of an encoding for files that otherwise have lost a reference to their encoding, such as untagged or improperly tagged web data or random text files stored when a business did not have international concerns.</span></span> <span data-ttu-id="dd63c-536">Häufig Benutzerprobleme können vermieden werden, wenn Daten einheitlich und ordnungsgemäß gekennzeichnet ist.</span><span class="sxs-lookup"><span data-stu-id="dd63c-536">Often user problems might be avoided if data is consistently and properly tagged.</span></span>  
  
 <span data-ttu-id="dd63c-537">Für die Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant.</span><span class="sxs-lookup"><span data-stu-id="dd63c-537">For standards that provide an encoding type, a BOM is somewhat redundant.</span></span> <span data-ttu-id="dd63c-538">Es kann jedoch verwendet werden, zu einem Server, den richtigen encoding-Header zu senden.</span><span class="sxs-lookup"><span data-stu-id="dd63c-538">However, it can be used to help a server send the correct encoding header.</span></span> <span data-ttu-id="dd63c-539">Alternativ können sie als ein Fallback verwendet werden, für den Fall, dass die Codierung verloren gegangen ist.</span><span class="sxs-lookup"><span data-stu-id="dd63c-539">Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</span></span>  
  
 <span data-ttu-id="dd63c-540">Es gibt einige Nachteile mit einer BOM.</span><span class="sxs-lookup"><span data-stu-id="dd63c-540">There are some disadvantages to using a BOM.</span></span> <span data-ttu-id="dd63c-541">Zu wissen, wie die Datenbankfelder zu beschränken, die eine BOM verwenden kann z. B. schwierig sein.</span><span class="sxs-lookup"><span data-stu-id="dd63c-541">For example, knowing how to limit the database fields that use a BOM can be difficult.</span></span> <span data-ttu-id="dd63c-542">Die Verkettung von Dateien, problematisch sein kann auch, beispielsweise beim Zusammenführen von Dateien in einem solchen eine Möglichkeit, die ein unnötige Zeichen in der Mitte Daten annehmen kann.</span><span class="sxs-lookup"><span data-stu-id="dd63c-542">Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</span></span> <span data-ttu-id="dd63c-543">Trotz der einige Nachteile wird jedoch dringend die Verwendung einer Stückliste empfohlen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-543">In spite of the few disadvantages, however, the use of a BOM is highly recommended.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="dd63c-544">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie den Anfang eines Streams codierter Bytes mit einer Präambel voranstellen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-544">To ensure that the encoded bytes are decoded properly, you should prefix the beginning of a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="dd63c-545">Beachten Sie, dass die <xref:System.Text.UnicodeEncoding.GetBytes%2A> Methode ist eine BOM, um eine codierte Bytefolge nicht voranstellen; der Verantwortung des Entwicklers ist eine BOM am Anfang einer entsprechenden Bytedatenstrom bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="dd63c-545">Note that the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method does not prepend a BOM to a sequence of encoded bytes; supplying a BOM at the beginning of an appropriate byte stream is the developer's responsibility.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-546">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Text.UnicodeEncoding.GetPreamble%2A> Methode zum Abrufen der Unicode-bytereihenfolgemarkierung im big-Endian oder little endian-Bytereihenfolge für eine Instanz von einem <xref:System.Text.UnicodeEncoding>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-546">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method to retrieve the Unicode byte order mark in big endian or little endian byte order for an instance of a <xref:System.Text.UnicodeEncoding>.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 <span data-ttu-id="dd63c-547">Das folgende Beispiel instanziiert zwei <xref:System.Text.UnicodeEncoding> Objekte, die das erste keine BOM, während die zweite welche wird bietet.</span><span class="sxs-lookup"><span data-stu-id="dd63c-547">The following example instantiates two <xref:System.Text.UnicodeEncoding> objects, the first of which does not provide a BOM, and the second of which does.</span></span> <span data-ttu-id="dd63c-548">Er ruft dann die <xref:System.Text.UnicodeEncoding.GetPreamble%2A> -Methode, die BOM vor dem Schreiben einer Unicode-codierte Zeichenfolge in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="dd63c-548">It then calls the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method to write the BOM to a file before writing a Unicode-encoded string.</span></span> <span data-ttu-id="dd63c-549">Wie die Konsolenausgabe aus dem Beispiel zeigt, wurde die Datei, die die Bytes aus dem zweiten Encoder speichert drei weitere Bytes als der erste.</span><span class="sxs-lookup"><span data-stu-id="dd63c-549">As the console output from the example shows, the file that saves the bytes from the second encoder has three more bytes than the first.</span></span>  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/cs/GetPreamble1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/vb/GetPreamble1.vb#1)]  
  
 <span data-ttu-id="dd63c-550">Sie können auch die Dateien vergleichen, mithilfe der `fc` Befehl in einem Konsolenfenster, oder Sie können die Dateien in einem Text-Editor, der einen Hex-Ansichtsmodus enthält überprüfen.</span><span class="sxs-lookup"><span data-stu-id="dd63c-550">You can also compare the files by using the `fc` command in a console window, or you can inspect the files in a text editor that includes a Hex View mode.</span></span> <span data-ttu-id="dd63c-551">Beachten Sie, dass die Datei in einem Editor geöffnet ist, die UTF-16-Codierung unterstützt, die BOM nicht angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-551">Note that when the file is opened in an editor that supports UTF-16 encoding, the BOM is not displayed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="dd63c-552">Das Bytearray, das die zu decodierende Bytefolge enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-552">The byte array containing the sequence of bytes to decode.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="dd63c-553">Der Index des ersten zu decodierenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-553">The index of the first byte to decode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="dd63c-554">Die Anzahl der zu decodierenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-554">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="dd63c-555">Decodiert einen Bytebereich aus einem Bytearray in eine Zeichenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-555">Decodes a range of bytes from a byte array into a string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="dd63c-556">Ein <see cref="T:System.String" />-Objekt, das die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-556">A <see cref="T:System.String" /> object containing the results of decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd63c-557">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="dd63c-557">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="dd63c-558">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="dd63c-558">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="dd63c-559">Wenn Sie der Bereich von Bytes, die zu decodierende enthält die Byte-reihenfolgemarkierung (BOM), und das Bytearray mit einer anderen Methode eines Typs nicht BOM beachten zurückgegeben wurde, ist das Zeichen U + FFFE im Zeichenarray, das von dieser Methode zurückgegebene enthalten.</span><span class="sxs-lookup"><span data-stu-id="dd63c-559">If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</span></span> <span data-ttu-id="dd63c-560">Sie können diesen entfernen, durch Aufrufen der <xref:System.String.TrimStart%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-560">You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="dd63c-561">Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar.</span><span class="sxs-lookup"><span data-stu-id="dd63c-561">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="dd63c-562">In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> Objekt bereitgestellt werden, indem Sie die <xref:System.Text.UnicodeEncoding.GetDecoder%2A> oder die <xref:System.Text.UnicodeEncoding.GetEncoder%2A> -Methode, bzw.</span><span class="sxs-lookup"><span data-stu-id="dd63c-562">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd63c-563">Im folgende Beispiel wird ein Array initialisiert, durch Aufrufen der <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Methode, um zu bestimmen, genau wie viele Bytes für eine codierte Zeichenfolge, und fügen die Größe des Byte-reihenfolgemarkierung (BOM) erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="dd63c-563">The following example initializes an array by calling the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method to determine exactly how many bytes are required for an encoded string and then adding the size of the byte order mark (BOM).</span></span> <span data-ttu-id="dd63c-564">Das Beispiel ruft dann die <xref:System.Text.UnicodeEncoding.GetPreamble%2A> Methode zum Speichern der Stückliste für das Array vor dem Aufruf der <xref:System.Text.Encoding.GetBytes%2A> Methode zum Speichern der codierten Bytes in das Array.</span><span class="sxs-lookup"><span data-stu-id="dd63c-564">The example then calls the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method to store the BOM to the array before calling the <xref:System.Text.Encoding.GetBytes%2A> method to store the encoded bytes to the array.</span></span> <span data-ttu-id="dd63c-565">Das Beispiel ruft dann die <xref:System.Text.UnicodeEncoding.GetString%2A> Methode, um die Zeichenfolge zu decodieren.</span><span class="sxs-lookup"><span data-stu-id="dd63c-565">The example then calls the <xref:System.Text.UnicodeEncoding.GetString%2A> method to decode the string.</span></span>  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 <span data-ttu-id="dd63c-566">Beachten Sie, dass in diesem Fall die decodierte Zeichenfolge aus der ursprünglichen Zeichenfolge abweicht, da er mit 16-Bit-Byte-reihenfolgemarkierung, U + FFFD beginnt.</span><span class="sxs-lookup"><span data-stu-id="dd63c-566">Note that in this case the decoded string differs from the original string, since it begins with a 16-bit byte order mark U+FFFD.</span></span> <span data-ttu-id="dd63c-567">Dies bedeutet, dass die beiden Zeichenfolgen als ungleich verglichen werden und ist die Zeichenfolge Ausgabe, die BOM als das Ersatzzeichen angezeigt wird "?".</span><span class="sxs-lookup"><span data-stu-id="dd63c-567">This means that the two strings will compare as unequal, and that if the string is output, the BOM will be displayed as the replacement character "?".</span></span> <span data-ttu-id="dd63c-568">Um die BOM am Anfang der Zeichenfolge zu entfernen, rufen Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="dd63c-568">To remove the BOM at the beginning of the string, you can call the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="dd63c-569">
            <paramref name="bytes" /> ist <see langword="null" />(<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-569">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="dd63c-570">
            <paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-570">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="dd63c-571">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-571">-or-</span>
          </span>
          <span data-ttu-id="dd63c-572">
            <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-572">
              <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="dd63c-573">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-573">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="dd63c-574">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-574">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="dd63c-575">- und -</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-575">-and-</span>
          </span>
          <span data-ttu-id="dd63c-576">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="dd63c-576">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>