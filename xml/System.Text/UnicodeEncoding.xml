<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="UnicodeEncoding.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac537bb8ffd133cbb1ddd3c3fdd2f593086d39584aa.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">37bb8ffd133cbb1ddd3c3fdd2f593086d39584aa</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.UnicodeEncoding">
          <source>Represents a UTF-16 encoding of Unicode characters.</source>
          <target state="translated">Stellt eine UTF-16-Codierung von Unicode-Zeichen dar.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</source>
          <target state="translated">Beim Kodieren werden Unicode-Zeichen in eine Bytefolge transformiert.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</source>
          <target state="translated">Beim Decodieren wird transformiert eine codierte Bytefolge in einen Satz von Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The <bpt id="p1">[</bpt>Unicode Standard<ept id="p1">](http://go.microsoft.com/fwlink/?linkid=37123)</ept> assigns a code point (a number) to each character in every supported script.</source>
          <target state="translated">Die <bpt id="p1">[</bpt>Unicode-Standard<ept id="p1">](http://go.microsoft.com/fwlink/?linkid=37123)</ept> jedes Zeichen aller unterstützten Skripts einen Codepunkt (eine Zahl) zugewiesen.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>A Unicode Transformation Format (UTF) is a way to encode that code point.</source>
          <target state="translated">Eine Transformation Format UTF (Unicode) ist eine Möglichkeit, diesen Codepunkt codieren.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The <bpt id="p1">[</bpt>Unicode Standard<ept id="p1">](http://go.microsoft.com/fwlink/?linkid=37123)</ept> uses the following UTFs:</source>
          <target state="translated">Die <bpt id="p1">[</bpt>Unicode-Standard<ept id="p1">](http://go.microsoft.com/fwlink/?linkid=37123)</ept> verwendet die folgenden UTFs:</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>UTF-8, which represents each code point as a sequence of one to four bytes.</source>
          <target state="translated">UTF-8, jeden Codepunkt als eine Folge von ein bis vier Bytes dar.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>UTF-16, which represents each code point as a sequence of one to two 16-bit integers.</source>
          <target state="translated">UTF-16, die jeden Codepunkt als Folge von ein bis zwei 16-Bit-Ganzzahlen darstellt.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>UTF-32, which represents each code point as a 32-bit integer.</source>
          <target state="translated">UTF-32, jeden Codepunkt als 32-Bit-Ganzzahl dar.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>For more information about the UTFs and other encodings supported by <ph id="ph1">&lt;xref:System.Text&gt;</ph>, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu den UTFs und andere von unterstützten Codierungen <ph id="ph1">&lt;xref:System.Text&gt;</ph>, finden Sie unter <bpt id="p1">[</bpt>Zeichencodierung in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> class represents a UTF-16 encoding.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Klasse stellt eine UTF-16-Codierung.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The encoder can use either big endian byte order (most significant byte first) or little endian byte order (least significant byte first).</source>
          <target state="translated">Der Encoder können entweder big-endian-Bytereihenfolge (höchstwertigen Byte erste) oder die little-endian-Bytereihenfolge (am wenigsten signifikanten Byte zuerst).</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>For example, the Latin Capital Letter A (code point U+0041) is serialized as follows (in hexadecimal):</source>
          <target state="translated">Beispielsweise folgt den lateinischen Großbuchstaben ein (Codepunkt U + 0041) als serialisiert wird (hexadezimal):</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Big endian byte order: 00 00 00 41</source>
          <target state="translated">Big-endian-Bytereihenfolge: 00 00 00 41</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Little endian byte order: 41 00 00 00</source>
          <target state="translated">Little-endian-Bytereihenfolge: 41 00 00 00</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>It is generally more efficient to store Unicode characters using the native byte order of a particular platform.</source>
          <target state="translated">Es ist im Allgemeinen effizienter zum Speichern von Unicode-Zeichen, die mit systemeigenen Bytereihenfolge der jeweiligen Plattform.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.</source>
          <target state="translated">Beispielsweise ist es besser, die little-endian-Bytereihenfolge auf little-endian Plattformtypen, beispielsweise Intel Computer verwenden.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> class corresponds to the Windows code pages 1200 (little endian byte order) and 1201 (big endian byte order).</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Klasse der Windows-Codepages 1200 (little-endian-Bytereihenfolge) und 1201 (big-endian-Bytereihenfolge) entspricht.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>You can determine the "endianness" of a particular architecture by calling the <ph id="ph1">&lt;xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Sie können den "Endian" an, der eine bestimmte Architektur bestimmen, durch Aufrufen der <ph id="ph1">&lt;xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Optionally, the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object provides a byte order mark (BOM), which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.</source>
          <target state="translated">Optional können die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> -Objekt bietet eine bytereihenfolgemarkierung (BOM), also ein Array von Bytes, die die Abfolge von Bytes, die aufgrund des Codierungsvorgangs vorangestellt werden kann.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>If the preamble contains a byte order mark (BOM), it helps the decoder determine the byte order and the transformation format or UTF.</source>
          <target state="translated">Die Präambel eine bytereihenfolgemarkierung (BOM) enthält, leichter den Decoder die Bytereihenfolge und die Transformationsformat oder im UTF zu bestimmen.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>If the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> instance is configured to provide a BOM, you can retrieve it by calling the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> method; otherwise, the method returns an empty array.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Instanz ist so konfiguriert, dass eine BOM enthalten, können Sie sie abrufen, durch Aufrufen der <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> Methode; andernfalls wird die Methode ein leeres Array zurückgegeben.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Note that, even if a <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object is configured for BOM support, you must include the BOM at the beginning of the encoded byte stream as appropriate; the encoding methods of the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> class do not do this automatically.</source>
          <target state="translated">Beachten Sie, dass selbst wenn eine <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> -Objekt konfiguriert ist, für die Bytereihenfolge-Marke unterstützen, müssen Sie die BOM am Anfang des codierten Datenstrom nach Bedarf; auch Codierungsmethoden von der <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Klasse tun Sie dies automatisch.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>To enable error detection and to make the class instance more secure, you should instantiate a <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object by calling the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> constructor and setting its <ph id="ph3">`throwOnInvalidBytes`</ph> argument to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">So aktivieren Sie die fehlererkennung und die Klasseninstanz sicherer zu gestalten, instanziieren Sie ein <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Objekt durch Aufrufen der <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> Konstruktor und die Einstellung seiner <ph id="ph3">`throwOnInvalidBytes`</ph> Argument <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>With error detection, a method that detects an invalid sequence of characters or bytes throws a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Mit fehlererkennung, eine Methode, die eine ungültige Folge von Zeichen oder Bytes erkennt löst eine <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Without error detection, no exception is thrown, and the invalid sequence is generally ignored.</source>
          <target state="translated">Ohne Fehler erkannt wird keine Ausnahme ausgelöst und die ungültige Sequenz im Allgemeinen ignoriert.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object in a number of ways, depending on whether you want to it to provide a byte order mark (BOM), whether you want big-endian or little-endian encoding, and whether you want to enable error detection.</source>
          <target state="translated">Instanziieren Sie ein <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Objekt in einer Reihe von Möglichkeiten, je nachdem, ob Sie darauf eine bytereihenfolgemarkierung (BOM) bereitstellen möchten, gibt an, ob Sie big-Endian oder little-Endian-Codierung wünschen und gibt an, ob Sie fehlererkennung aktivieren möchten.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The following table lists the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> constructors and the <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> properties that return a <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object.</source>
          <target state="translated">Die folgende Tabelle enthält die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Konstruktoren und der <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> Eigenschaften, die Zurückgeben einer <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Member</source>
          <target state="translated">Member</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Endianness</source>
          <target state="translated">Endianness</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>BOM</source>
          <target state="translated">BOM</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Error detection</source>
          <target state="translated">Fehlererkennung</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Big-endian</source>
          <target state="translated">Big-endian</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Yes</source>
          <target state="translated">Ja</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Keine (Ersatzfallback)</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Little-endian</source>
          <target state="translated">Little-endian</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Yes</source>
          <target state="translated">Ja</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Keine (Ersatzfallback)</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Little-endian</source>
          <target state="translated">Little-endian</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Yes</source>
          <target state="translated">Ja</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Keine (Ersatzfallback)</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Configurable</source>
          <target state="translated">Konfigurierbare</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Configurable</source>
          <target state="translated">Konfigurierbare</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Keine (Ersatzfallback)</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Configurable</source>
          <target state="translated">Konfigurierbare</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Configurable</source>
          <target state="translated">Konfigurierbare</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Configurable</source>
          <target state="translated">Konfigurierbare</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> -Methode bestimmt, wie viele Bytes zum Codieren von Unicode-Zeichen, und die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> -Methode führt die eigentliche Codierung.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>Likewise, the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetString%2A&gt;</ph> methods perform the actual decoding.</source>
          <target state="translated">Entsprechend der <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> -Methode bestimmt, wie viele Zeichen zum Decodieren einer Bytefolge und <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> und <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetString%2A&gt;</ph> Methoden führen die tatsächliche Decodierung aus.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>For an encoder or decoder that is able to save state information when encoding or decoding data that spans multiple blocks (such as string of 1 million characters that is encoded in 100,000-character segments), use the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> properties, respectively.</source>
          <target state="translated">Für einen Encoder oder Decoder, der zum Speichern von Zustandsinformationen, die beim Codieren oder Decodieren von Daten, die umfasst mehrere Blöcke (z. B. String von 1 Mio. Zeichen, die in Segmenten von 100.000 Zeichen codiert wird) verwenden, können die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> Eigenschaften bzw.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The following example demonstrates how to encode a string of Unicode characters into a byte array by using a <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie eine Zeichenfolge von Unicode-Zeichen in ein Bytearray mit Codieren einer <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The byte array is decoded into a string to demonstrate that there is no loss of data.</source>
          <target state="translated">Das Bytearray wird in eine Zeichenfolge, die veranschaulichen, dass es kein Datenverlust Datenmenge entsteht decodiert.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>The following example uses the same string as the previous one, except that it writes the encoded bytes to a file and prefixes the byte stream with a byte order mark (BOM).</source>
          <target state="translated">Im folgenden Beispiel wird die gleiche Zeichenfolge als der vorherigen Abfrage, außer dass die codierten Bytes in eine Datei geschrieben und Präfixe Bytestream mit einem Byte-reihenfolgemarkierung (BOM).</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>It then reads the file in two different ways: as a text file by using a <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> object; and as a binary file.</source>
          <target state="translated">Dann liest die Datei auf zwei verschiedene Arten: als Textdatei mit einer <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> Objekt; und als eine Binärdatei.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UnicodeEncoding">
          <source>As you would expect, in neither case is the BOM included in the newly read string.</source>
          <target state="translated">Wie zu erwarten, ist die BOM in keinem Fall in der neu schreibgeschützte Zeichenfolge enthalten.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="T:System.Text.UnicodeEncoding">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor">
          <source>This constructor creates an instance that uses the little endian byte order, provides a Unicode byte order mark, and does not throw an exception when an invalid encoding is detected.</source>
          <target state="translated">Dieser Konstruktor erstellt eine Instanz, die die little-endian-Bytereihenfolge verwendet, bietet eine Unicode-bytereihenfolgemarkierung und löst keine Ausnahme aus, wenn eine ungültige Codierung gefunden wird.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor">
          <source>For security reasons, you should enable error detection by calling the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> constructor and setting its <ph id="ph2">`throwOnInvalidBytes`</ph> argument to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Aus Gründen der Sicherheit sollten Sie Erkennung aktivieren, durch Aufrufen der <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> Konstruktor und die Einstellung der <ph id="ph2">`throwOnInvalidBytes`</ph> Argument <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor">
          <source>The following example demonstrates how to create a new <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> instance and display the name of the encoding.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie zum Erstellen eines neuen <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> -Instanz und der Anzeigename der Codierung.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to use the big endian byte order (most significant byte first), or <ph id="ph2">&lt;see langword="false" /&gt;</ph> to use the little endian byte order (least significant byte first).</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um die Big-Endian-Bytereihenfolge (mit dem höchstwertigen Byte an erster Stelle) zu verwenden, oder <ph id="ph2">&lt;see langword="false" /&gt;</ph>, um die Little-Endian-Bytereihenfolge (mit dem niedrigstwertigen Byte an erster Stelle) zu verwenden.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to specify that the <ph id="ph2">&lt;see cref="M:System.Text.UnicodeEncoding.GetPreamble" /&gt;</ph> method returns a Unicode byte order mark; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um anzugeben, dass die <ph id="ph2">&lt;see cref="M:System.Text.UnicodeEncoding.GetPreamble" /&gt;</ph>-Methode eine Unicode-Bytereihenfolgemarkierung zurückgibt; andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>Parameters specify whether to use the big endian byte order and whether the <ph id="ph1">&lt;see cref="M:System.Text.UnicodeEncoding.GetPreamble" /&gt;</ph> method returns a Unicode byte order mark.</source>
          <target state="translated">Parameter geben an, ob die Big-Endian-Bytereihenfolge verwendet werden soll und die <ph id="ph1">&lt;see cref="M:System.Text.UnicodeEncoding.GetPreamble" /&gt;</ph>-Methode eine Unicode-Bytereihenfolgemarkierung zurückgibt.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>This constructor creates an instance that does not throw an exception when an invalid encoding is detected.</source>
          <target state="translated">Dieser Konstruktor erstellt eine Instanz, die keine Ausnahme auslöst, wenn eine ungültige Codierung gefunden wird.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>For security reasons, you should enable error detection by calling the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> constructor and setting its <ph id="ph2">`throwOnInvalidBytes`</ph> argument to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Aus Gründen der Sicherheit sollten Sie Erkennung aktivieren, durch Aufrufen der <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> Konstruktor und die Einstellung der <ph id="ph2">`throwOnInvalidBytes`</ph> Argument <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`byteOrderMark`</ph> parameter controls the operation of the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">`byteOrderMark`</ph> Parameter steuert die Ausführung von der <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`true`</ph>, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-16 format.</source>
          <target state="translated">Wenn <ph id="ph1">`true`</ph>, die Methode gibt ein Bytearray, das die Unicode-bytereihenfolgemarkierung (BOM) in UTF-16-Format enthält.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`false`</ph>, it returns a zero-length byte array.</source>
          <target state="translated">Wenn <ph id="ph1">`false`</ph>, es gibt ein Bytearray der Länge 0 (null) zurück.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>However, setting <ph id="ph1">`byteOrderMark`</ph> to <ph id="ph2">`true`</ph> does not cause the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method to prefix the BOM at the beginning of the byte array, nor does it cause the <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method to include the number of bytes in the BOM in the byte count.</source>
          <target state="translated">Jedoch festlegen <ph id="ph1">`byteOrderMark`</ph> auf <ph id="ph2">`true`</ph> führt nicht dazu, dass die <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> Methode, um die BOM am Anfang des Bytearrays, Präfix noch führt es dazu, dass die <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> Methode, um die Anzahl der Bytes in der Stückliste in die Anzahl der Bytes enthalten.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)">
          <source>The following example demonstrates how to create a new <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> instance specifying whether to support little endian or big endian byte ordering and the Unicode byte order mark.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie zum Erstellen eines neuen <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Instanz angegeben wird, ob little-endian oder big-endian-Byte-Sortierreihenfolge unterstützen und das Unicode-Byte order Mark.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to use the big endian byte order (most significant byte first); <ph id="ph2">&lt;see langword="false" /&gt;</ph> to use the little endian byte order (least significant byte first).</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um die Big-Endian-Bytereihenfolge (mit dem höchstwertigen Byte an erster Stelle) oder <ph id="ph2">&lt;see langword="false" /&gt;</ph>, um die Little-Endian-Bytereihenfolge (mit dem niedrigstwertigen Byte an erster Stelle) zu verwenden.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to specify that the <ph id="ph2">&lt;see cref="M:System.Text.UnicodeEncoding.GetPreamble" /&gt;</ph> method returns a Unicode byte order mark; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um anzugeben, dass die <ph id="ph2">&lt;see cref="M:System.Text.UnicodeEncoding.GetPreamble" /&gt;</ph>-Methode eine Unicode-Bytereihenfolgemarkierung zurückgibt; andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to specify that an exception should be thrown when an invalid encoding is detected; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> um anzugeben, dass eine Ausnahme ausgelöst werden soll, wenn eine ungültige Codierung gefunden wird, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>Parameters specify whether to use the big endian byte order, whether to provide a Unicode byte order mark, and whether to throw an exception when an invalid encoding is detected.</source>
          <target state="translated">Parameter geben an, ob die Big-Endian-Bytereihenfolge verwendet, eine Unicode-Bytereihenfolgemarkierung bereitgestellt und beim Erkennen einer ungültigen Codierung eine Ausnahme ausgelöst werden soll.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`byteOrderMark`</ph> parameter controls the operation of the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">`byteOrderMark`</ph> Parameter steuert die Ausführung von der <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`true`</ph>, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-16 format.</source>
          <target state="translated">Wenn <ph id="ph1">`true`</ph>, die Methode gibt ein Bytearray, das die Unicode-bytereihenfolgemarkierung (BOM) in UTF-16-Format enthält.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`false`</ph>, it returns a zero-length byte array.</source>
          <target state="translated">Wenn <ph id="ph1">`false`</ph>, es gibt ein Bytearray der Länge 0 (null) zurück.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>However, setting <ph id="ph1">`byteOrderMark`</ph> to <ph id="ph2">`true`</ph> does not cause the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method to prefix the BOM at the beginning of the byte array, nor does it cause the <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method to include the number of bytes in the BOM in the byte count.</source>
          <target state="translated">Jedoch festlegen <ph id="ph1">`byteOrderMark`</ph> auf <ph id="ph2">`true`</ph> führt nicht dazu, dass die <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> Methode, um die BOM am Anfang des Bytearrays, Präfix noch führt es dazu, dass die <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> Methode, um die Anzahl der Bytes in der Stückliste in die Anzahl der Bytes enthalten.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>If the <ph id="ph1">`throwOnInvalidBytes`</ph> parameter is <ph id="ph2">`true`</ph>, a method that detects an invalid byte sequence throws <ph id="ph3">&lt;xref:System.ArgumentException?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn die <ph id="ph1">`throwOnInvalidBytes`</ph> Parameter ist <ph id="ph2">`true`</ph>, löst Sie eine Methode, die eine ungültige Bytesequenz erkennt <ph id="ph3">&lt;xref:System.ArgumentException?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>Otherwise, the method does not throw an exception, and the invalid sequence is ignored.</source>
          <target state="translated">Andernfalls wird die Methode löst eine Ausnahme, und die ungültige Sequenz wird ignoriert.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>For security reasons, your applications are recommended to use this constructor to create an instance of the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> class and turn on error detection by setting <ph id="ph2">`throwOnInvalidBytes`</ph> to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Aus Gründen der Sicherheit werden Ihre Anwendungen Verwendung dieses Konstruktors zum Erstellen einer Instanz des empfohlen die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Klasse, und schalten Sie fehlererkennung durch Festlegen <ph id="ph2">`throwOnInvalidBytes`</ph> auf <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)">
          <source>The following example demonstrates the behavior of <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>, both with error detection enabled and without.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht das Verhalten des <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>, mit der fehlererkennung aktiviert und ohne.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="F:System.Text.UnicodeEncoding.CharSize">
          <source>Represents the Unicode character size in bytes.</source>
          <target state="translated">Stellt die Unicode-Zeichengröße in Bytes dar.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="F:System.Text.UnicodeEncoding.CharSize">
          <source>This field is a constant.</source>
          <target state="translated">Dieses Feld ist konstant.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.UnicodeEncoding.CharSize">
          <source>The value of this field is a 32-bit signed constant with a value of 2.</source>
          <target state="translated">Der Wert dieses Felds ist eine signierte 32-Bit-Konstante mit einem Wert von 2.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.UnicodeEncoding.CharSize">
          <source>The following example demonstrates how to return the value of <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.CharSize&gt;</ph> and display it.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie den Wert des zurückzugebenden <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.CharSize&gt;</ph> und angezeigt wird.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>The object to compare with the current object.</source>
          <target state="translated">Das Objekt, das mit dem aktuellen Objekt verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> is equal to the current <ph id="ph2">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> object.</source>
          <target state="translated">Bestimmt, ob das angegebene <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> und das aktuelle <ph id="ph2">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph>-Objekt gleich sind.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is an instance of <ph id="ph3">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> and is equal to the current object; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="value" /&gt;</ph> eine Instanz von <ph id="ph3">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> und mit dem aktuellen Objekt identisch ist, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>Two <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objects are considered equal if all of the following conditions are true:</source>
          <target state="translated">Zwei <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Objekte werden als gleich betrachtet, wenn alle der folgenden Bedingungen erfüllt sind:</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>Both objects use the same byte order (little-endian or big-endian).</source>
          <target state="translated">Beide Objekte verwenden die gleiche Bytereihenfolge (little-Endian oder big-Endian).</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>Both objects provide the byte order mark, or both do not.</source>
          <target state="translated">Beide Objekte bereitzustellen, Byte Order Mark, oder beide nicht der Fall ist.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>Both objects use the same encoder fallback.</source>
          <target state="translated">Beide Objekte verwenden die gleichen EncoderFallback.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>Both objects use the same decoder fallback.</source>
          <target state="translated">Beide Objekte verwenden die gleichen DecoderFallback.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.Equals%2A&gt;</ph> method to test whether the current <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object is equal to a different <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.Equals%2A&gt;</ph> Methode zum Testen, ob die aktuelle <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> -Objekt gleich einem anderen <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.Equals(System.Object)">
          <source>Five <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objects are created and compared, and the results of the comparisons are displayed.</source>
          <target state="translated">Fünf <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Objekte erstellt und verglichen werden und die Ergebnisse der Vergleiche werden angezeigt.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="T:System.Text.UnicodeEncoding">
          <source>Calculates the number of bytes produced by encoding a set of characters.</source>
          <target state="translated">Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen erzeugt wird.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>The string that contains the set of characters to encode.</source>
          <target state="translated">Die Zeichenfolge, die die Menge der angegebenen Zeichen enthält.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>Calculates the number of bytes produced by encoding the characters in the specified string.</source>
          <target state="translated">Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen in der angegebenen Zeichenfolge erzeugt werden.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Zum Berechnen der genauen Arraygröße <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> zum Speichern der resultierenden Bytes rufen Sie die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Um die maximale Arraygröße zu berechnen, rufen Sie die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> Methode weist im Allgemeinen weniger Speicher, während die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> Methode in der Regel schneller ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden sollen) ist Aufgabe des Entwicklers, und die Anzahl der Bytes in der Präambel ist nicht in den Rückgabewert von wiedergegeben, die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29&gt;</ph> methods to calculate the maximum and actual number of bytes required to encode a string.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29&gt;</ph> Methoden zum Berechnen der maximalen und den tatsächlichen Anzahl der Bytes, die erforderlich sind, um eine Zeichenfolge zu codieren.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>It also displays the actual number of bytes required to store a byte stream with a byte order mark.</source>
          <target state="translated">Es zeigt auch die tatsächliche Anzahl von Bytes, die zum Speichern eines Bytestreams mit einem Byte-reihenfolgemarkierung erforderlich.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="s" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">Die Fehlererkennung ist aktiviert, und <ph id="ph1">&lt;paramref name="s" /&gt;</ph> enthält eine ungültige Folge von Zeichen.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter <bpt id="p1">[</bpt>Zeichencodierung in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>).</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source>-and-</source>
          <target state="translated">- und -</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.String)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">Für <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> ist <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>A pointer to the first character to encode.</source>
          <target state="translated">Ein Zeiger auf das erste zu codierende Zeichen.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Die Anzahl der zu codierenden Zeichen.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</source>
          <target state="translated">Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen ab dem angegebenen Zeichenzeiger erzeugt werden.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> requires to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Zum Berechnen der genauen Arraygröße <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> erfordert zum Speichern der resultierenden Bytes, rufen Sie die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Um die maximale Arraygröße zu berechnen, rufen Sie die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> Methode weist im Allgemeinen weniger Speicher, während die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> Methode in der Regel schneller ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden sollen) ist Aufgabe des Entwicklers, und die Anzahl der Bytes in der Präambel ist nicht in den Rückgabewert von wiedergegeben, die <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>Error detection is enabled and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">Die Fehlererkennung ist aktiviert, und <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> enthält eine ungültige Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter <bpt id="p1">[</bpt>Zeichencodierung in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>).</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>-and-</source>
          <target state="translated">- und -</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">Für <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> ist <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">Das Zeichenarray, das die zu codierenden Zeichen enthält.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">Der Index des ersten zu codierenden Zeichens.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Die Anzahl der zu codierenden Zeichen.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Calculates the number of bytes produced by encoding a set of characters from the specified character array.</source>
          <target state="translated">Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen aus dem angegebenen Zeichenarray erzeugt werden.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> to store the resulting bytes, the application uses <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Zum Berechnen der genauen Arraygröße <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> zum Speichern der resultierenden Bytes verwendet die Anwendung <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Um die maximale Arraygröße zu berechnen, rufen Sie die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> Methode weist im Allgemeinen weniger Speicher, während die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> Methode in der Regel schneller ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>With error detection enabled, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Eine ungültige Folge fehlererkennung ist aktiviert, führt diese Methode löst eine <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden sollen) ist Aufgabe des Entwicklers, und die Anzahl der Bytes in der Präambel ist nicht in den Rückgabewert von wiedergegeben, die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The following example populates an array with a Latin uppercase and lowercase characters and calls the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method to determine the number of bytes needed to encode the Latin lowercase characters.</source>
          <target state="translated">Im folgenden Beispiel wird ein Array mit einem lateinischen Großbuchstaben und Kleinbuchstaben und ruft die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Methode, um die Anzahl der Bytes, die zum Codieren der Zeichen des lateinischen Kleinbuchstaben erforderlich festzulegen.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>It then displays this information along with the total number of bytes needed if a byte order mark is added.</source>
          <target state="translated">Es zeigt dann diese Informationen zusammen mit der Gesamtanzahl von Bytes erforderlich, wenn eine Bytereihenfolge-Marke hinzugefügt wird.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>It compares this number with the value returned by the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method, which indicates maximum number of bytes needed to encode the Latin lowercase characters.</source>
          <target state="translated">Diese Zahl vergleicht Sie mit den Rückgabewert von der <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> -Methode, die maximale Anzahl von Bytes, die zum Codieren der Zeichen des lateinischen Kleinbuchstaben erforderlich angibt.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The following example populates an array with a combination of Greek and Cyrillic characters and calls the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method to determine the number of bytes needed to encode the Cyrillic characters.</source>
          <target state="translated">Im folgenden Beispiel wird ein Array mit einer Kombination von Zeichen Griechisch und Kyrillisch und ruft die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Methode, um zu bestimmen, die Anzahl der Bytes, die erforderlich sind, um die kyrillischen Zeichen zu codieren.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>It then displays this information along with the total number of bytes needed if a byte order mark is added.</source>
          <target state="translated">Es zeigt dann diese Informationen zusammen mit der Gesamtanzahl von Bytes erforderlich, wenn eine Bytereihenfolge-Marke hinzugefügt wird.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>It compares this number with the value returned by the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method, which indicates maximum number of bytes needed to encode the Cyrillic characters.</source>
          <target state="translated">Diese Zahl vergleicht Sie mit den Rückgabewert von der <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> -Methode, die maximale Anzahl von Bytes erforderlich, um die kyrillischen Zeichen zu codieren angibt.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>(<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="count" /&gt;</ph> geben keinen gültigen Bereich in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">Die Fehlererkennung ist aktiviert, und <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> enthält eine ungültige Folge von Zeichen.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter <bpt id="p1">[</bpt>Zeichencodierung in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>).</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">- und -</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">Für <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> ist <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="T:System.Text.UnicodeEncoding">
          <source>Encodes a set of characters into a sequence of bytes.</source>
          <target state="translated">Codiert Zeichen in eine Bytefolge.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A pointer to the first character to encode.</source>
          <target state="translated">Ein Zeiger auf das erste zu codierende Zeichen.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Die Anzahl der zu codierenden Zeichen.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A pointer to the location at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">Die maximale Anzahl der zu schreibenden Bytes.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</source>
          <target state="translated">Codiert Zeichen beginnend am angegebenen Zeichenzeiger in eine Bytefolge, die beginnend am angegebenen Bytezeiger gespeichert wird.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The actual number of bytes written at the location indicated by the <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> parameter.</source>
          <target state="translated">Die tatsächliche Anzahl an Bytes, die an der durch den <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>-Parameter angegebenen Position geschrieben wurden.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> requires to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Zum Berechnen der genauen Arraygröße <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> erfordert zum Speichern der resultierenden Bytes, rufen Sie die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Um die maximale Arraygröße zu berechnen, rufen Sie die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> Methode weist im Allgemeinen weniger Speicher, während die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> Methode in der Regel schneller ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> or the <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> oder <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> Objekt bereitgestellt werden, indem Sie die <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> oder die <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> -Methode, bzw.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</source>
          <target state="translated">Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden) wird die Verantwortung des Entwicklers.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> Methode ist keine Präambel am Anfang eine codierte Bytefolge nicht voranstellen.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>(<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>(<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">Die Fehlererkennung ist aktiviert, und <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> enthält eine ungültige Folge von Zeichen.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than the resulting number of bytes.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> ist niedriger als die sich ergebende Anzahl von Bytes.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter <bpt id="p1">[</bpt>Zeichencodierung in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>).</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-and-</source>
          <target state="translated">- und -</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">Für <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> ist <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">Das Zeichenarray, das die zu codierenden Zeichen enthält.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">Der Index des ersten zu codierenden Zeichens.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Die Anzahl der zu codierenden Zeichen.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The byte array to contain the resulting sequence of bytes.</source>
          <target state="translated">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Encodes a set of characters from the specified character array into the specified byte array.</source>
          <target state="translated">Codiert Zeichen aus dem angegebenen Zeichenarray in das angegebene Bytearray.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The actual number of bytes written into <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">Die tatsächliche Anzahl der Bytes, die in <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> geschrieben werden.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Zum Berechnen der genauen Arraygröße <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> zum Speichern der resultierenden Bytes rufen Sie die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Um die maximale Arraygröße zu berechnen, rufen Sie die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> Methode weist im Allgemeinen weniger Speicher, während die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> Methode in der Regel schneller ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> oder die <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> gebotenen der <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> Methode oder die <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> Methode bzw.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</source>
          <target state="translated">Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden) wird die Verantwortung des Entwicklers.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> Methode ist keine Präambel am Anfang eine codierte Bytefolge nicht voranstellen.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method to encode a range of characters from a <ph id="ph2">&lt;xref:System.String&gt;</ph> and store the encoded bytes in a range of elements in a byte array.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> Methode zum Codieren eines Bereichs von Zeichen aus einer <ph id="ph2">&lt;xref:System.String&gt;</ph> und speichern Sie die codierten Bytes in einem Bereich von Elementen in ein Bytearray.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>(<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>(<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> ist kleiner als 0 (null).</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> und <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> geben keinen gültigen Bereich in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> ist kein gültiger Index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">Die Fehlererkennung ist aktiviert, und <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> enthält eine ungültige Folge von Zeichen.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> hat von <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter <bpt id="p1">[</bpt>Zeichencodierung in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>).</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-and-</source>
          <target state="translated">- und -</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">Für <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> ist <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The string containing the set of characters to encode.</source>
          <target state="translated">Die Zeichenfolge mit den zu codierenden Zeichen.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">Der Index des ersten zu codierenden Zeichens.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Die Anzahl der zu codierenden Zeichen.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The byte array to contain the resulting sequence of bytes.</source>
          <target state="translated">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Encodes a set of characters from the specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> into the specified byte array.</source>
          <target state="translated">Codiert Zeichen aus der angegebenen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Klasse in das angegebene Bytearray.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The actual number of bytes written into <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">Die tatsächliche Anzahl der Bytes, die in <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> geschrieben werden.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Zum Berechnen der genauen Arraygröße <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> zum Speichern der resultierenden Bytes rufen Sie die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Um die maximale Arraygröße zu berechnen, rufen Sie die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> Methode weist im Allgemeinen weniger Speicher, während die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> Methode in der Regel schneller ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> oder die <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> gebotenen der <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> Methode oder die <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> Methode bzw.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</source>
          <target state="translated">Die Präambel am Anfang eines Bytestreams einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden) wird die Verantwortung des Entwicklers.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> Methode ist keine Präambel am Anfang eine codierte Bytefolge nicht voranstellen.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following example demonstrates how to encode a range of elements from a Unicode character array and store the encoded bytes in a range of elements in a byte array.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie auf einen Bereich von Elementen aus einem Array von Unicode-Zeichen zu codieren, und speichern die codierten Bytes in einem Bereich von Elementen in einem Bytearray.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>(<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> ist kleiner als 0 (null).</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> und <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> geben keinen gültigen Bereich in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> ist kein gültiger Index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="s" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">Die Fehlererkennung ist aktiviert, und <ph id="ph1">&lt;paramref name="s" /&gt;</ph> enthält eine ungültige Folge von Zeichen.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> hat von <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter <bpt id="p1">[</bpt>Zeichencodierung in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>).</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-and-</source>
          <target state="translated">- und -</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">Für <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> ist <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="T:System.Text.UnicodeEncoding">
          <source>Calculates the number of characters produced by decoding a sequence of bytes.</source>
          <target state="translated">Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge erzeugt werden.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>A pointer to the first byte to decode.</source>
          <target state="translated">Ein Zeiger auf das erste zu decodierende Byte.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Die Anzahl der zu decodierenden Bytes.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</source>
          <target state="translated">Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge ab dem angegebenen Bytezeiger erzeugt werden.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
          <target state="translated">Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> requires to store the resulting characters, the application uses <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Zum Berechnen der genauen Arraygröße <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> erfordert zum Speichern der resultierenden Zeichen, die der Anwendung verwendeten <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>To calculate the maximum array size, the application should use <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</source>
          <target state="translated">Die Anwendung sollte zum Berechnen der maximalen verwenden <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> Methode weist im Allgemeinen weniger Speicher, während die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> Methode in der Regel schneller ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>(<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">Die Fehlererkennung ist aktiviert, und <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> enthält eine ungültige Folge von Bytes.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter <bpt id="p1">[</bpt>Zeichencodierung in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>).</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>-and-</source>
          <target state="translated">- und -</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">Für <ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> ist <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">Das Bytearray, das die zu decodierende Bytefolge enthält.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">Der Index des ersten zu decodierenden Bytes.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Die Anzahl der zu decodierenden Bytes.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</source>
          <target state="translated">Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge aus dem angegebenen Bytearray erzeugt werden.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
          <target state="translated">Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> to store the resulting characters, the application uses <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Zum Berechnen der genauen Arraygröße <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> zum Speichern der resultierenden Zeichen, die Anwendung verwendet <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>To calculate the maximum array size, the application should use <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</source>
          <target state="translated">Die Anwendung sollte zum Berechnen der maximalen verwenden <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> Methode weist im Allgemeinen weniger Speicher, während die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> Methode in der Regel schneller ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> method to return the number of characters produced by decoding a range of elements in a byte array using <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> Methode, um die Anzahl von Zeichen zurückzugeben, die beim Decodieren Sie einen Bereich von Elementen in einem Byte-Array von erzeugt <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>(<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="count" /&gt;</ph> geben keinen gültigen Bereich in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">Die Fehlererkennung ist aktiviert, und <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> enthält eine ungültige Folge von Bytes.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter <bpt id="p1">[</bpt>Zeichencodierung in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>).</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">- und -</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">Für <ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> ist <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="T:System.Text.UnicodeEncoding">
          <source>Decodes a sequence of bytes into a set of characters.</source>
          <target state="translated">Decodiert eine Bytefolge in Zeichen.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A pointer to the first byte to decode.</source>
          <target state="translated">Ein Zeiger auf das erste zu decodierende Byte.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Die Anzahl der zu decodierenden Bytes.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A pointer to the location at which to start writing the resulting set of characters.</source>
          <target state="translated">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The maximum number of characters to write.</source>
          <target state="translated">Die maximale Anzahl der zu schreibenden Zeichen.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</source>
          <target state="translated">Decodiert eine Bytefolge beginnend am angegebenen Bytezeiger in Zeichen, die beginnend am angegebenen Zeichenzeiger gespeichert werden.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The actual number of characters written at the location indicated by the <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> parameter.</source>
          <target state="translated">Die tatsächliche Anzahl der Zeichen, die an der durch den <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>-Parameter angegebenen Position geschrieben wurden.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> requires to store the resulting characters, the application uses <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Zum Berechnen der genauen Arraygröße <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> erfordert zum Speichern der resultierenden Zeichen, die der Anwendung verwendeten <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>To calculate the maximum array size, the application should use <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</source>
          <target state="translated">Die Anwendung sollte zum Berechnen der maximalen verwenden <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> Methode weist im Allgemeinen weniger Speicher, während die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> Methode in der Regel schneller ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</source>
          <target state="translated">Wenn Sie der Bereich von Bytes, die zu decodierende enthält die Byte-reihenfolgemarkierung (BOM), und das Bytearray mit einer anderen Methode eines Typs nicht BOM beachten zurückgegeben wurde, ist das Zeichen U + FFFE im Zeichenarray, das von dieser Methode zurückgegebene enthalten.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>You can remove it by calling the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Sie können diesen entfernen, durch Aufrufen der <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> or the <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> oder <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> Objekt bereitgestellt werden, indem Sie die <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> oder die <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> -Methode, bzw.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>(<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>(<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">Die Fehlererkennung ist aktiviert, und <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> enthält eine ungültige Folge von Bytes.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> is less than the resulting number of characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> ist niedriger als die sich ergebende Anzahl von Zeichen.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter <bpt id="p1">[</bpt>Zeichencodierung in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>).</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-and-</source>
          <target state="translated">- und -</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">Für <ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> ist <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">Das Bytearray, das die zu decodierende Bytefolge enthält.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">Der Index des ersten zu decodierenden Bytes.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Die Anzahl der zu decodierenden Bytes.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The character array to contain the resulting set of characters.</source>
          <target state="translated">Das Zeichenarray, das die sich ergebenden Zeichen enthalten soll.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The index at which to start writing the resulting set of characters.</source>
          <target state="translated">Der Index, an dem mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Decodes a sequence of bytes from the specified byte array into the specified character array.</source>
          <target state="translated">Decodiert eine Bytefolge aus dem angegebenen Bytearray in das angegebene Zeichenarray.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The actual number of characters written into <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated">Die tatsächliche Anzahl der Zeichen, die in <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> geschrieben werden.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> to store the resulting characters, the application uses <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Zum Berechnen der genauen Arraygröße <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> zum Speichern der resultierenden Zeichen, die Anwendung verwendet <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>To calculate the maximum array size, the application should use <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</source>
          <target state="translated">Die Anwendung sollte zum Berechnen der maximalen verwenden <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> Methode weist im Allgemeinen weniger Speicher, während die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> Methode in der Regel schneller ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</source>
          <target state="translated">Wenn Sie der Bereich von Bytes, die zu decodierende enthält die Byte-reihenfolgemarkierung (BOM), und das Bytearray mit einer anderen Methode eines Typs nicht BOM beachten zurückgegeben wurde, ist das Zeichen U + FFFE im Zeichenarray, das von dieser Methode zurückgegebene enthalten.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>You can remove it by calling the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Sie können diesen entfernen, durch Aufrufen der <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> oder die <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> gebotenen der <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> Methode oder die <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> Methode bzw.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> method to decode a range of elements in a byte array and store the result in a character array.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> Methode, um einen Bereich von Elementen in einem Bytearray zu decodieren und Speichern des Ergebnisses in ein Zeichenarray.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>(<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>(<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="charIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="charIndex" /&gt;</ph> ist kleiner als 0 (null).</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteindex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteindex" /&gt;</ph> und <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> geben keinen gültigen Bereich in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> ist kein gültiger Index in <ph id="ph2">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">Die Fehlererkennung ist aktiviert, und <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> enthält eine ungültige Folge von Bytes.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="charIndex" /&gt;</ph> to the end of the array to accommodate the resulting characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> hat von <ph id="ph2">&lt;paramref name="charIndex" /&gt;</ph> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Zeichen aufzunehmen.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter <bpt id="p1">[</bpt>Zeichencodierung in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>).</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-and-</source>
          <target state="translated">- und -</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">Für <ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> ist <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>Obtains a decoder that converts a UTF-16 encoded sequence of bytes into a sequence of Unicode characters.</source>
          <target state="translated">Ruft einen Decoder ab, der eine UTF-16-codierte Bytefolge in eine Unicode-Zeichenfolge konvertiert.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>A <ph id="ph1">&lt;see cref="T:System.Text.Decoder" /&gt;</ph> that converts a UTF-16 encoded sequence of bytes into a sequence of Unicode characters.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Text.Decoder" /&gt;</ph>, der eine UTF-16-codierte Bytefolge in eine Unicode-Zeichenfolge konvertiert.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> konvertiert sequenzielle Blöcke von Bytes in sequenzielle Blöcke von Zeichen ähnlich wie die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>However, a <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> maintains state information between calls so it can correctly decode byte sequences that span blocks.</source>
          <target state="translated">Allerdings eine <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> verwaltet Zustandsinformationen zwischen aufrufen, damit Bytesequenzen, die Blöcke umfassen, ordnungsgemäß decodiert werden können.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> behält nachfolgende Bytes am Ende der Datenblöcke und die nachfolgenden Bytes im nächste Decodierungsvorgang verwendet.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
          <target state="translated">Aus diesem Grund <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> eignen sich für die netzwerkübertragung und Dateivorgänge, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>If error detection is enabled, that is, the <ph id="ph1">`throwOnInvalidBytes`</ph> parameter of the constructor is set to <ph id="ph2">`true`</ph>, error detection is also enabled in the <ph id="ph3">&lt;xref:System.Text.Decoder&gt;</ph> returned by this method.</source>
          <target state="translated">Wenn Erkennung, d. h. aktiviert ist die <ph id="ph1">`throwOnInvalidBytes`</ph> Parameter des Konstruktors festgelegt ist, um <ph id="ph2">`true`</ph>, fehlererkennung ist auch aktiviert, der <ph id="ph3">&lt;xref:System.Text.Decoder&gt;</ph> von dieser Methode zurückgegebene.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>If error detection is enabled and an invalid sequence is encountered, the state of the decoder is undefined and processing must stop.</source>
          <target state="translated">Wenn fehlererkennung ist aktiviert, und eine ungültige Folge festgestellt wird, der Zustand des Decoders ist nicht definiert und Verarbeitung muss beendet werden.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetDecoder">
          <source>The following example uses an encoder and a decoder to encode a string into an array of bytes, and then decode the bytes into an array of characters.</source>
          <target state="translated">Im folgenden Beispiel wird ein Encoder und Decoder eine Zeichenfolge in ein Array von Bytes zu codieren, und klicken Sie dann die Bytes in ein Array von Zeichen decodiert.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>Obtains an encoder that converts a sequence of Unicode characters into a UTF-16 encoded sequence of bytes.</source>
          <target state="translated">Ruft einen Encoder ab, der eine Unicode-Zeichenfolge in eine UTF-16-codierte Bytefolge konvertiert.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>A <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> object that converts a sequence of Unicode characters into a UTF-16 encoded sequence of bytes.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph>-Objekt, das eine Unicode-Zeichenfolge in eine UTF-16-codierte Bytefolge konvertiert.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method converts sequential blocks of characters into sequential blocks of bytes in a manner similar to the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method of this class.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> konvertiert sequenzielle Blöcke von Zeichen in sequenzielle Blöcke von Bytes in auf ähnliche Weise die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> Methode dieser Klasse.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>However, a <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object maintains state information between calls so that it can correctly encode character sequences that span blocks.</source>
          <target state="translated">Allerdings ein <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> -Objekt verwaltet Zustandsinformationen zwischen aufrufen, damit Zeichensequenzen, die Blöcke umfassen, korrekt codiert werden können.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> Objekt behält nachfolgende Zeichen am Ende der Datenblöcke und das nachfolgenden Zeichen in der nächsten Codierungsvorgang verwendet.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</source>
          <target state="translated">Z. B. ein Datenblock möglicherweise eine hohe Ersatzzeichen ohne Entsprechung enden, und die übereinstimmende niedrige Ersatzzeichen ist möglicherweise in den nächsten Datenblock.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
          <target state="translated">Aus diesem Grund <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> eignen sich für die netzwerkübertragung und Dateivorgänge, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>If error detection is enabled, that is, the <ph id="ph1">`throwOnInvalidBytes`</ph> parameter of the constructor is set to <ph id="ph2">`true`</ph>, error detection is also enabled in the <ph id="ph3">&lt;xref:System.Text.Encoder&gt;</ph> object returned by this method.</source>
          <target state="translated">Wenn Erkennung, d. h. aktiviert ist die <ph id="ph1">`throwOnInvalidBytes`</ph> Parameter des Konstruktors festgelegt ist, um <ph id="ph2">`true`</ph>, fehlererkennung ist auch aktiviert, der <ph id="ph3">&lt;xref:System.Text.Encoder&gt;</ph> von dieser Methode zurückgegebene Objekt.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>If error detection is enabled and an invalid sequence is encountered, the state of the encoder is undefined and processing must stop.</source>
          <target state="translated">Wenn die fehlererkennung ist aktiviert, und eine ungültige Folge festgestellt wird, der Zustand des Encoders ist nicht definiert und Verarbeitung muss beendet werden.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetEncoder">
          <source>The following example uses an encoder and a decoder to encode a string into an array of bytes, and then decode the bytes into an array of characters.</source>
          <target state="translated">Im folgenden Beispiel wird ein Encoder und Decoder eine Zeichenfolge in ein Array von Bytes zu codieren, und klicken Sie dann die Bytes in ein Array von Zeichen decodiert.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetHashCode">
          <source>Returns the hash code for the current instance.</source>
          <target state="translated">Gibt den Hashcode für die aktuelle Instanz zurück.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetHashCode">
          <source>The hash code for the current <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> object.</source>
          <target state="translated">Der Hashcode für das aktuelle <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Die Anzahl der zu codierenden Zeichen.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>Calculates the maximum number of bytes produced by encoding the specified number of characters.</source>
          <target state="translated">Berechnet die maximale Anzahl der Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt wird.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>The maximum number of bytes produced by encoding the specified number of characters.</source>
          <target state="translated">Die maximale Anzahl an Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt werden.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> to store the resulting bytes, the application uses <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Zum Berechnen der genauen Arraygröße <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> zum Speichern der resultierenden Bytes verwendet die Anwendung <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>To calculate the maximum array size, the application should use <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph>.</source>
          <target state="translated">Die Anwendung sollte zum Berechnen der maximalen verwenden <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> Methode weist im Allgemeinen weniger Speicher, während die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> Methode in der Regel schneller ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> retrieves a worst-case number, including the worst case for the currently selected <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> Ruft die Anzahl Worst-Case, einschließlich ungünstigsten Fall für das derzeit ausgewählte ab <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>If a fallback is chosen with a potentially large string, <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> can return large values.</source>
          <target state="translated">Wenn ein Fallback mit einer potenziell großen Zeichenfolge ausgewählt wird <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> große Werte zurückgeben können.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>In most cases, this method retrieves reasonable numbers for small strings.</source>
          <target state="translated">In den meisten Fällen ruft diese Methode geeignete Zahlen für kleine Zeichenfolgen ab.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</source>
          <target state="translated">Für große Zeichenfolgen müssen Sie möglicherweise entscheiden sehr große Puffer und Erfassen von Fehlern in dem seltenen Fall, dass ein günstiger Puffer überschritten wird.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>You might also want to consider a different approach using <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Sie sollten auch einen anderen Ansatz erwägen <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> has no relation to <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> hat keinen Bezug zu <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>If your application needs a similar function to use with <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph>, it should use <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</source>
          <target state="translated">Wenn Ihre Anwendung eine ähnliche Funktion für die Verwendung mit benötigt <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph>, sollte <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">`GetMaxByteCount(N)`</ph> is not necessarily the same value as <ph id="ph2">`N* GetMaxByteCount(1)`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetMaxByteCount(N)`</ph> ist nicht unbedingt der gleiche Wert wie <ph id="ph2">`N* GetMaxByteCount(1)`</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> method to return the maximum number of bytes required to encode a specified number of characters.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph> Methode, um die maximale Anzahl von Bytes, die erforderlich sind, um eine angegebene Anzahl von Zeichen zu codieren zurückzugeben.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter <bpt id="p1">[</bpt>Zeichencodierung in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>).</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source>-and-</source>
          <target state="translated">- und -</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">Für <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> ist <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Die Anzahl der zu decodierenden Bytes.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>Calculates the maximum number of characters produced by decoding the specified number of bytes.</source>
          <target state="translated">Berechnet die maximale Anzahl der Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>The maximum number of characters produced by decoding the specified number of bytes.</source>
          <target state="translated">Die maximale Anzahl von Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> to store the resulting characters, the application uses <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Zum Berechnen der genauen Arraygröße <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetChars%2A&gt;</ph> zum Speichern der resultierenden Zeichen, die Anwendung verwendet <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>To calculate the maximum array size, the application should use <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</source>
          <target state="translated">Die Anwendung sollte zum Berechnen der maximalen verwenden <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> Methode weist im Allgemeinen weniger Speicher, während die <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> Methode in der Regel schneller ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> retrieves a worst-case number, including the worst case for the currently selected <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> Ruft die Anzahl Worst-Case, einschließlich ungünstigsten Fall für das derzeit ausgewählte ab <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>If a fallback is chosen with a potentially large string, <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> retrieves large values.</source>
          <target state="translated">Wenn ein Fallback mit einer potenziell großen Zeichenfolge ausgewählt wird <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> große Werte abgerufen.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>In most cases, this method retrieves reasonable numbers for small strings.</source>
          <target state="translated">In den meisten Fällen ruft diese Methode geeignete Zahlen für kleine Zeichenfolgen ab.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</source>
          <target state="translated">Für große Zeichenfolgen müssen Sie möglicherweise entscheiden sehr große Puffer und Erfassen von Fehlern in dem seltenen Fall, dass ein günstiger Puffer überschritten wird.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>You might also want to consider a different approach using <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Decoder.Convert%2A&gt;</ph>.</source>
          <target state="translated">Sie sollten auch einen anderen Ansatz erwägen <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetCharCount%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Text.Decoder.Convert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> has no relation to <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> hat keinen Bezug zu <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>If your application needs a similar function to use with <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph>, it should use <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph>.</source>
          <target state="translated">Wenn Ihre Anwendung eine ähnliche Funktion für die Verwendung mit benötigt <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph>, sollte <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">`GetMaxCharCount(N)`</ph> is not necessarily the same value as <ph id="ph2">`N* GetMaxCharCount(1)`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetMaxCharCount(N)`</ph> ist nicht unbedingt der gleiche Wert wie <ph id="ph2">`N* GetMaxCharCount(1)`</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> method to return the maximum number of characters produced by decoding a specified number of bytes.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A&gt;</ph> Methode, um die maximale Anzahl von Zeichen zurückzugeben, die beim Decodieren von einer angegebenen Anzahl von Bytes erzeugt.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter <bpt id="p1">[</bpt>Zeichencodierung in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>).</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source>-and-</source>
          <target state="translated">- und -</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">Für <ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> ist <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Returns a Unicode byte order mark encoded in UTF-16 format, if the constructor for this instance requests a byte order mark.</source>
          <target state="translated">Gibt eine im UTF-16-Format codierte Unicode-Bytereihenfolgemarkierung zurück, wenn der Konstruktor für diese Instanz die Bereitstellung einer Bytereihenfolgemarkierung anfordert.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>A byte array containing the Unicode byte order mark, if the <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph> object is configured to supply one.</source>
          <target state="translated">Ein Bytearray, das die Unicode-Bytereihenfolgemarkierung enthält, wenn das <ph id="ph1">&lt;see cref="T:System.Text.UnicodeEncoding" /&gt;</ph>-Objekt dafür konfiguriert ist, eine bereitzustellen.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Otherwise, this method returns a zero-length byte array.</source>
          <target state="translated">Andernfalls gibt diese Methode ein Bytearray mit der Länge Null zurück.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object can provide a preamble, which is a byte array that can be prefixed to the sequence of bytes resulting from the encoding process.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Objekt bieten keine Präambel, also ein Byte-Array, das die Abfolge von Bytes, die aufgrund des Codierungsvorgangs vorangestellt werden kann.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Prefacing a sequence of encoded bytes with a byte order mark (code point U+FEFF) helps the decoder determine the byte order and the transformation format or UTF.</source>
          <target state="translated">Eine Sequenz codierter Bytes mit einem Byte-reihenfolgemarkierung (Codepunkt U + FEFF) voran unterstützt den Decoder, der die Bytereihenfolge und die Transformationsformat oder im UTF zu bestimmen.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</source>
          <target state="translated">Die Unicode-bytereihenfolgemarkierung (BOM) ist (im Hexadezimalformat) wie folgt serialisiert:</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Big endian byte order: FE FF</source>
          <target state="translated">Big-endian-Bytereihenfolge: FF FE</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Little endian byte order: FF FE</source>
          <target state="translated">Little-endian-Bytereihenfolge: FF FE</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> method returns a valid BOM in the following ways:</source>
          <target state="translated">Instanziieren Sie ein <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Objekt, dessen <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> Methodenrückgabe eine gültige BOM auf folgende Weise:</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>By retrieving the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Durch das Abrufen der <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> zurückgegebenes Objekt die <ph id="ph2">&lt;xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph3">&lt;xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>By calling the parameterless <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object.</source>
          <target state="translated">Durch Aufrufen der parameterlosen <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor&gt;</ph> Konstruktor zum Instanziieren einer <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>By supplying <ph id="ph1">`true`</ph> as the value of the <ph id="ph2">`byteOrderMark`</ph> argument to the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29&gt;</ph> or <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> constructors.</source>
          <target state="translated">Durch Angabe <ph id="ph1">`true`</ph> als Wert für die <ph id="ph2">`byteOrderMark`</ph> Argument an die <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29&gt;</ph> oder <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> Konstruktoren.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>We recommended that you use the BOM, since it provides nearly certain identification of an encoding for files that otherwise have lost a reference to their encoding, such as untagged or improperly tagged web data or random text files stored when a business did not have international concerns.</source>
          <target state="translated">Es wird empfohlen, Sie verwenden die BOM, da sie fast bestimmte Kennung für eine Codierung für Dateien, die andernfalls einen Verweis auf ihre Codierung, z. B. nicht gekennzeichnet oder nicht ordnungsgemäß markierten verloren bereitstellt Webdaten oder zufällige Dateien gespeichert, wenn ein Unternehmen keinen Internationale Aspekte.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Often user problems might be avoided if data is consistently and properly tagged.</source>
          <target state="translated">Häufig Benutzerprobleme können vermieden werden, wenn Daten einheitlich und ordnungsgemäß gekennzeichnet ist.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>For standards that provide an encoding type, a BOM is somewhat redundant.</source>
          <target state="translated">Für die Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>However, it can be used to help a server send the correct encoding header.</source>
          <target state="translated">Es kann jedoch verwendet werden, zu einem Server, den richtigen encoding-Header zu senden.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</source>
          <target state="translated">Alternativ können sie als ein Fallback verwendet werden, für den Fall, dass die Codierung verloren gegangen ist.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>There are some disadvantages to using a BOM.</source>
          <target state="translated">Es gibt einige Nachteile mit einer BOM.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>For example, knowing how to limit the database fields that use a BOM can be difficult.</source>
          <target state="translated">Zu wissen, wie die Datenbankfelder zu beschränken, die eine BOM verwenden kann z. B. schwierig sein.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</source>
          <target state="translated">Die Verkettung von Dateien, problematisch sein kann auch, beispielsweise beim Zusammenführen von Dateien in einem solchen eine Möglichkeit, die ein unnötige Zeichen in der Mitte Daten annehmen kann.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>In spite of the few disadvantages, however, the use of a BOM is highly recommended.</source>
          <target state="translated">Trotz der einige Nachteile wird jedoch dringend die Verwendung einer Stückliste empfohlen.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>To ensure that the encoded bytes are decoded properly, you should prefix the beginning of a stream of encoded bytes with a preamble.</source>
          <target state="translated">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie den Anfang eines Streams codierter Bytes mit einer Präambel voranstellen.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Note that the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> method does not prepend a BOM to a sequence of encoded bytes; supplying a BOM at the beginning of an appropriate byte stream is the developer's responsibility.</source>
          <target state="translated">Beachten Sie, dass die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetBytes%2A&gt;</ph> Methode ist eine BOM, um eine codierte Bytefolge nicht voranstellen; der Verantwortung des Entwicklers ist eine BOM am Anfang einer entsprechenden Bytedatenstrom bereitstellt.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> method to retrieve the Unicode byte order mark in big endian or little endian byte order for an instance of a <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> Methode zum Abrufen der Unicode-bytereihenfolgemarkierung im big-Endian oder little endian-Bytereihenfolge für eine Instanz von einem <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>The following example instantiates two <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objects, the first of which does not provide a BOM, and the second of which does.</source>
          <target state="translated">Das folgende Beispiel instanziiert zwei <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> Objekte, die das erste keine BOM, während die zweite welche wird bietet.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> method to write the BOM to a file before writing a Unicode-encoded string.</source>
          <target state="translated">Er ruft dann die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> -Methode, die BOM vor dem Schreiben einer Unicode-codierte Zeichenfolge in eine Datei zu schreiben.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>As the console output from the example shows, the file that saves the bytes from the second encoder has three more bytes than the first.</source>
          <target state="translated">Wie die Konsolenausgabe aus dem Beispiel zeigt, wurde die Datei, die die Bytes aus dem zweiten Encoder speichert drei weitere Bytes als der erste.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>You can also compare the files by using the <ph id="ph1">`fc`</ph> command in a console window, or you can inspect the files in a text editor that includes a Hex View mode.</source>
          <target state="translated">Sie können auch die Dateien vergleichen, mithilfe der <ph id="ph1">`fc`</ph> Befehl in einem Konsolenfenster, oder Sie können die Dateien in einem Text-Editor, der einen Hex-Ansichtsmodus enthält überprüfen.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetPreamble">
          <source>Note that when the file is opened in an editor that supports UTF-16 encoding, the BOM is not displayed.</source>
          <target state="translated">Beachten Sie, dass die Datei in einem Editor geöffnet ist, die UTF-16-Codierung unterstützt, die BOM nicht angezeigt wird.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">Das Bytearray, das die zu decodierende Bytefolge enthält.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">Der Index des ersten zu decodierenden Bytes.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Die Anzahl der zu decodierenden Bytes.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Decodes a range of bytes from a byte array into a string.</source>
          <target state="translated">Decodiert einen Bytebereich aus einem Bytearray in eine Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object containing the results of decoding the specified sequence of bytes.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt, das die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw a <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Fehlererkennung, eine ungültige Folge führt diese Methode löst eine <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Ohne fehlererkennung ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</source>
          <target state="translated">Wenn Sie der Bereich von Bytes, die zu decodierende enthält die Byte-reihenfolgemarkierung (BOM), und das Bytearray mit einer anderen Methode eines Typs nicht BOM beachten zurückgegeben wurde, ist das Zeichen U + FFFE im Zeichenarray, das von dieser Methode zurückgegebene enthalten.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>You can remove it by calling the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Sie können diesen entfernen, durch Aufrufen der <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Daten konvertiert werden, z. B. aus einem Stream gelesenen Daten möglicherweise nur in sequenzielle Blöcke verfügbar.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> or the <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> oder <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> Objekt bereitgestellt werden, indem Sie die <ph id="ph3">&lt;xref:System.Text.UnicodeEncoding.GetDecoder%2A&gt;</ph> oder die <ph id="ph4">&lt;xref:System.Text.UnicodeEncoding.GetEncoder%2A&gt;</ph> -Methode, bzw.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The following example initializes an array by calling the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> method to determine exactly how many bytes are required for an encoded string and then adding the size of the byte order mark (BOM).</source>
          <target state="translated">Im folgende Beispiel wird ein Array initialisiert, durch Aufrufen der <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetByteCount%2A&gt;</ph> Methode, um zu bestimmen, genau wie viele Bytes für eine codierte Zeichenfolge, und fügen die Größe des Byte-reihenfolgemarkierung (BOM) erforderlich sind.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> method to store the BOM to the array before calling the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method to store the encoded bytes to the array.</source>
          <target state="translated">Das Beispiel ruft dann die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetPreamble%2A&gt;</ph> Methode zum Speichern der Stückliste für das Array vor dem Aufruf der <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> Methode zum Speichern der codierten Bytes in das Array.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetString%2A&gt;</ph> method to decode the string.</source>
          <target state="translated">Das Beispiel ruft dann die <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.GetString%2A&gt;</ph> Methode, um die Zeichenfolge zu decodieren.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Note that in this case the decoded string differs from the original string, since it begins with a 16-bit byte order mark U+FFFD.</source>
          <target state="translated">Beachten Sie, dass in diesem Fall die decodierte Zeichenfolge aus der ursprünglichen Zeichenfolge abweicht, da er mit 16-Bit-Byte-reihenfolgemarkierung, U + FFFD beginnt.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>This means that the two strings will compare as unequal, and that if the string is output, the BOM will be displayed as the replacement character "?".</source>
          <target state="translated">Dies bedeutet, dass die beiden Zeichenfolgen als ungleich verglichen werden und ist die Zeichenfolge Ausgabe, die BOM als das Ersatzzeichen angezeigt wird "?".</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>To remove the BOM at the beginning of the string, you can call the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Um die BOM am Anfang der Zeichenfolge zu entfernen, rufen Sie die <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>(<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="count" /&gt;</ph> geben keinen gültigen Bereich in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">Die Fehlererkennung ist aktiviert, und <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> enthält eine ungültige Folge von Bytes.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter <bpt id="p1">[</bpt>Zeichencodierung in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>).</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">- und -</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">Für <ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> ist <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph> festgelegt.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>