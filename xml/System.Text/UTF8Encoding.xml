<Type Name="UTF8Encoding" FullName="System.Text.UTF8Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cc344fca55b4fb75d1cbd93b0606fe719d4d0584" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82432124" /></Metadata><TypeSignature Language="C#" Value="public class UTF8Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UTF8Encoding extends System.Text.Encoding" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF8Encoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UTF8Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF8Encoding : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UTF8Encoding = class&#xA;    inherit Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UTF8Encoding extends System.Text.Encoding" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Text.Encoding.Extensions" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine UTF-8-Codierung von Unicode-Zeichen dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Kodieren werden Unicode-Zeichen in eine Bytefolge transformiert. Beim Decodieren wird eine Sequenz codierter Bytes in eine Gruppe von Unicode-Zeichen transformiert.  
  
 UTF-8 ist eine Unicode-Codierung, die die einzelnen Code Punkte als Sequenz von einem bis vier Bytes darstellt. Im Gegensatz zu den UTF-16-und UTF-32-Codierungen ist für die UTF-8-Codierung keine ""-Anmerkung erforderlich. das Codierungsschema ist unabhängig davon, ob der Prozessor Big-Endian oder Little-Endian ist, identisch. <xref:System.Text.UTF8Encoding> entspricht der Windows-Codepage 65001. Weitere Informationen zu den UTFs und anderen Codierungen, die von <xref:System.Text>unterstützt werden, finden Sie unter [Zeichencodierung in der .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Sie können ein <xref:System.Text.UTF8Encoding> Objekt auf verschiedene Weise instanziieren, abhängig davon, ob Sie eine Byte Reihenfolge-Marke (BOM) bereitstellen möchten und ob Sie die Fehlererkennung aktivieren möchten. In der folgenden Tabelle werden die-Konstruktoren und die <xref:System.Text.Encoding>-Eigenschaft aufgelistet, die ein <xref:System.Text.UTF8Encoding>-Objekt zurückgeben.  
  
|Member|BOM|Fehlererkennung|  
|------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>|Ja|Nein (Ersatz Fall Back)|  
|<xref:System.Text.UTF8Encoding.%23ctor?displayProperty=nameWithType>|Nein|Nein (Ersatz Fall Back)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29?displayProperty=nameWithType>|Konfigurierbar|Nein (Ersatz Fall Back)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Konfigurierbar|Konfigurierbar|  
  
 Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.  
  
 Ebenso bestimmt die <xref:System.Text.UTF8Encoding.GetCharCount%2A> Methode, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die Methoden <xref:System.Text.UTF8Encoding.GetChars%2A> und <xref:System.Text.UTF8Encoding.GetString%2A> führen die eigentliche Decodierung aus.  
  
 Für einen Encoder oder Decoder, der zum Speichern von Zustandsinformationen, die beim Codieren oder Decodieren von Daten, die umfasst mehrere Blöcke (z. B. String von 1 Mio. Zeichen, die in Segmenten von 100.000 Zeichen codiert wird) verwenden, können die <xref:System.Text.UTF8Encoding.GetEncoder%2A> und <xref:System.Text.UTF8Encoding.GetDecoder%2A> Eigenschaften bzw.  
  
 Das <xref:System.Text.UTF8Encoding>-Objekt stellt optional eine Byte Reihenfolge-Marke (Byte Order Mark, BOM) bereit, bei der es sich um ein Bytearray handelt, dem der Anfang des Bytestreams vorangestellt werden kann Wenn einem UTF-8-codierten Bytestream eine Byte Reihenfolge-Marke (Byte Order Mark, BOM) vorangestellt wird, unterstützt der Decoder die Byte Reihenfolge und das Transformations Format oder UTF. Beachten Sie jedoch, dass der Unicode-Standard weder eine BOM in UTF-8-codierten Streams erfordert noch empfiehlt. Weitere Informationen zur Byte Reihenfolge und zur Byte Reihenfolge-Markierung finden Sie im Unicode-Standard auf der [Unicode-Homepage](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Wenn der Encoder für die Bereitstellung einer BOM konfiguriert ist, können Sie Sie abrufen, indem Sie die <xref:System.Text.UTF8Encoding.GetPreamble%2A>-Methode aufrufen. Andernfalls gibt die Methode ein leeres Array zurück. Beachten Sie, dass Sie, selbst wenn ein <xref:System.Text.UTF8Encoding> Objekt für die BOM-Unterstützung konfiguriert ist, die BOM nach Bedarf am Anfang des codierten Bytestreams einschließen müssen. die Codierungs Methoden der <xref:System.Text.UTF8Encoding>-Klasse führen dies nicht automatisch aus.  
  
> [!CAUTION]
>  Um die Fehlererkennung zu aktivieren und die Klasseninstanz sicherer zu machen, sollten Sie den <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29>-Konstruktor aufrufen und den `throwOnInvalidBytes`-Parameter auf `true`festlegen. Wenn die Fehlererkennung aktiviert ist, löst eine Methode, die eine ungültige Sequenz von Zeichen oder Bytes erkennt, eine <xref:System.ArgumentException> Ausnahme aus. Ohne Fehlererkennung wird keine Ausnahme ausgelöst, und die ungültige Sequenz wird im Allgemeinen ignoriert.  
  
> [!NOTE]
>  Der Status eines UTF-8-codierten Objekts wird nicht beibehalten, wenn das Objekt mit unterschiedlichen .NET Framework Versionen serialisiert und deserialisiert wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Text.UTF8Encoding> Objekt verwendet, um eine Zeichenfolge von Unicode-Zeichen zu codieren und in einem Bytearray zu speichern. Die Unicode-Zeichenfolge enthält zwei Zeichen, Pi (u + 03a0) und Sigma (u + 03a3), die außerhalb des ASCII-Zeichen Bereichs liegen. Wenn das codierte Bytearray zurück in eine Zeichenfolge decodiert wird, sind die Zeichen Pi und Sigma weiterhin vorhanden.  
  
 [!code-cpp[System.Text.UTF8Encoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UTF8Encoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/snippet.vb#1)]  
  
 Im folgenden Beispiel wird die gleiche Zeichenfolge wie im vorherigen Beispiel verwendet, mit der Ausnahme, dass die codierten Bytes in eine Datei geschrieben und der Bytestream mit einer Byte Reihenfolge Markierung (BOM) vorangestellt wird. Anschließend wird die Datei auf zwei verschiedene Arten gelesen: als Textdatei mit einem <xref:System.IO.StreamReader> Objekt. und als Binärdatei. Erwartungsgemäß enthält weder die neu gelesene Zeichenfolge die BOM.  
  
 [!code-csharp[System.Text.UTF8Encoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UTF8Encoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoder" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.UTF8Encoding" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.UTF8Encoding" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt eine Instanz, die keine Unicode-Byte Reihenfolge Markierung bereitstellt und keine Ausnahme auslöst, wenn eine ungültige Codierung erkannt wird.  
  
> [!CAUTION]
>  Aus Sicherheitsgründen wird empfohlen, die Fehlererkennung zu aktivieren, indem Sie einen Konstruktor mit einem `throwOnInvalidBytes`-Parameter aufrufen und dessen Wert auf `true`festlegen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine neue <xref:System.Text.UTF8Encoding>-Instanz erstellt und deren Name angezeigt.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF8Encoding : bool -&gt; System.Text.UTF8Encoding" Usage="new System.Text.UTF8Encoding encoderShouldEmitUTF8Identifier" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier"><see langword="true" />, um anzugeben, dass die <see cref="M:System.Text.UTF8Encoding.GetPreamble" />-Methode eine Unicode-Bytereihenfolgemarkierung zurückgibt; andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.UTF8Encoding" />-Klasse. Ein Parameter gibt an, ob eine Unicode-Bytereihenfolgemarkierung bereitgestellt werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt eine-Instanz, die keine Ausnahme auslöst, wenn eine ungültige Codierung erkannt wird.  
  
> [!CAUTION]
>  Aus Sicherheitsgründen sollten Sie die Fehlererkennung aktivieren, indem Sie einen Konstruktor aufrufen, der einen `throwOnInvalidBytes`-Parameter enthält, und dessen Wert auf `true`festlegen.  
  
 Der `encoderShouldEmitUTF8Identifier`-Parameter steuert den Betrieb der <xref:System.Text.UTF8Encoding.GetPreamble%2A> Methode. Wenn `true`, gibt die Methode ein Bytearray zurück, das die Unicode-Byte Reihenfolge-Marke (BOM) im UTF-8-Format enthält.  Wenn `false`, wird ein Bytearray der Länge 0 (null) zurückgegeben. Wenn Sie jedoch `encoderShouldEmitUTF8Identifier` auf `true` festlegen, bewirkt dies nicht, dass die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode der BOM am Anfang des Bytearrays vorangestellt wird. Außerdem bewirkt dies, dass die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode die Anzahl der Bytes in der BOM in der Byte Anzahl nicht einschließt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine neue <xref:System.Text.UTF8Encoding>-Instanz erstellt und angegeben, dass ein Unicode-Byte Reihenfolge-Präfix von der <xref:System.Text.UTF8Encoding.GetPreamble%2A>-Methode ausgegeben werden soll. Die <xref:System.Text.UTF8Encoding.GetPreamble%2A>-Methode gibt dann das Unicode-Byte Reihenfolge Markierung-Präfix zurück.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CPP/ctor-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CS/ctor-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/VB/ctor-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF8Encoding : bool * bool -&gt; System.Text.UTF8Encoding" Usage="new System.Text.UTF8Encoding (encoderShouldEmitUTF8Identifier, throwOnInvalidBytes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier"><see langword="true" />, um anzugeben, dass die <see cref="M:System.Text.UTF8Encoding.GetPreamble" />-Methode eine Unicode-Bytereihenfolgemarkierung zurückgeben sollte; andernfalls <see langword="false" />.</param>
        <param name="throwOnInvalidBytes"><see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn eine ungültige Codierung gefunden wird, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.UTF8Encoding" />-Klasse. Parameter geben an, ob eine Unicode-Bytereihenfolgemarkierung bereitgestellt werden soll und ob eine Ausnahme ausgelöst werden soll, wenn eine ungültige Codierung gefunden wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `encoderShouldEmitUTF8Identifier`-Parameter steuert den Betrieb der <xref:System.Text.UTF8Encoding.GetPreamble%2A> Methode. Wenn `true`, gibt die Methode ein Bytearray zurück, das die Unicode-Byte Reihenfolge-Marke (BOM) im UTF-8-Format enthält.  Wenn `false`, wird ein Bytearray der Länge 0 (null) zurückgegeben. Wenn Sie jedoch `encoderShouldEmitUTF8Identifier` auf `true` festlegen, bewirkt dies nicht, dass die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode der BOM am Anfang des Bytearrays vorangestellt wird. Außerdem bewirkt dies, dass die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode die Anzahl der Bytes in der BOM in der Byte Anzahl nicht einschließt.  
  
 Wenn `throwOnInvalidBytes` `true`ist, löst eine Methode, die eine ungültige Byte Sequenz erkennt, eine <xref:System.ArgumentException?displayProperty=nameWithType> Ausnahme aus. Andernfalls löst die Methode keine Ausnahme aus, und die ungültige Sequenz wird ignoriert.  
  
> [!CAUTION]
>  Aus Sicherheitsgründen sollten Sie die Fehlererkennung aktivieren, indem Sie einen Konstruktor aufrufen, der einen `throwOnInvalidBytes`-Parameter enthält, und diesen Parameter auf `true`festlegen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine neue <xref:System.Text.UTF8Encoding> Instanz erstellt, die angibt, dass die <xref:System.Text.UTF8Encoding.GetPreamble%2A>-Methode kein Unicode-Byte Reihenfolge-Präfix ausgeben soll, und eine Ausnahme ausgelöst werden soll, wenn eine ungültige Codierung erkannt wird. Das Verhalten dieses Konstruktors wird mit dem Standardkonstruktor <xref:System.Text.UTF8Encoding.%23ctor> verglichen, der keine Ausnahme auslöst, wenn eine ungültige Codierung erkannt wird. Die beiden <xref:System.Text.UTF8Encoding> Instanzen Codieren ein Zeichen Array, das zwei hohe Ersatz Zeichen (u + D801 und u + D802) in einer Zeile enthält. Dies ist eine ungültige Zeichenfolge. auf ein hohes Ersatz Zeichen sollte immer ein niedriges Ersatz Zeichen folgen.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uTF8Encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob das angegebene Objekt und das aktuelle <see cref="T:System.Text.UTF8Encoding" />-Objekt gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="value" /> eine Instanz von <see cref="T:System.Text.UTF8Encoding" /> und mit dem aktuellen Objekt identisch ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei <xref:System.Text.UTF8Encoding> Objekte werden als gleich betrachtet, wenn alle der folgenden Bedingungen zutreffen:  
  
-   Beide-Objekte stellen die Byte Reihenfolge-Marke oder beides nicht bereit.  
  
-   Beide Objekte verwenden denselben EncoderFallback.  
  
-   Beide Objekte verwenden denselben Decoder-Fallback.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.Equals%2A>-Methode verwendet, um zu testen, ob das aktuelle <xref:System.Text.UTF8Encoding>-Objekt gleich einem anderen <xref:System.Text.UTF8Encoding>-Objekt ist. Vier <xref:System.Text.UTF8Encoding> Objekte werden erstellt und verglichen, und die Ergebnisse der Vergleiche werden angezeigt.  
  
 [!code-cpp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CPP/equals-object.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CS/equals-object.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/VB/equals-object.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen erzeugt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="uTF8Encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="chars">Der Bereich, der die zu codierenden Zeichen enthält.</param>
        <summary>Berechnet die Anzahl von Bytes, die durch das Codieren des angegebenen Zeichenbereichs erzeugt werden.</summary>
        <returns>Die Anzahl von Bytes, die beim Codieren des angegebenen Zeichenbereichs erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Bytefolge, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers, und die Anzahl der Bytes in der Präambel wird nicht in dem Wert widergespiegelt, der von der <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode zurückgegeben wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>)
  
-und- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ist auf <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ chars);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="uTF8Encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="chars">Die <see cref="T:System.String" />-Klasse mit den zu codierenden Zeichen.</param>
        <summary>Berechnet die Anzahl der Bytes, die durch das Codieren der Zeichen in der angegebenen <see cref="T:System.String" />-Klasse erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Bytefolge, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers, und die Anzahl der Bytes in der Präambel wird nicht in dem Wert widergespiegelt, der von der <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Methoden <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> und <xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29> aufgerufen, um die maximale und tatsächliche Anzahl von Bytes zu berechnen, die zum Codieren einer Zeichenfolge erforderlich sind. Es zeigt auch die tatsächliche Anzahl von Bytes an, die zum Speichern eines Bytestreams mit einer Byte Reihenfolge-Marke erforderlich ist.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
-und- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ist auf <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF8Encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">Ein Zeiger auf das erste zu codierende Zeichen.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen ab dem angegebenen Zeichenzeiger erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die für die <xref:System.Text.UTF8Encoding.GetBytes%2A> Methode zum Speichern der resultierenden Bytes erforderlich ist, wird die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Bytefolge, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers, und die Anzahl der Bytes in der Präambel wird nicht in dem Wert widergespiegelt, der von der <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode zurückgegeben wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist kleiner als 0 (null).  
  
- oder - 
Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ein Fallback ist aufgetreten (eine ausführliche Erläuterung finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>)
  
-und- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ist auf <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="uTF8Encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray, das die zu codierenden Zeichen enthält.</param>
        <param name="index">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="count">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen aus dem angegebenen Zeichenarray erzeugt werden.</summary>
        <returns>Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die Verwendung <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Bytefolge, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers, und die Anzahl der Bytes in der Präambel wird nicht in dem Wert widergespiegelt, der von der <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array mit einem lateinischen groß-und Kleinbuchstaben aufgefüllt und die <xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Methode aufgerufen, um die Anzahl von Bytes zu bestimmen, die zum Codieren der Zeichen für Lateinische Kleinbuchstaben benötigt werden. Diese Informationen werden dann zusammen mit der Gesamtanzahl der benötigten Bytes angezeigt, wenn eine Byte Reihenfolge-Markierung hinzugefügt wird. Diese Zahl wird mit dem Wert verglichen, der von der <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode zurückgegeben wird, die die maximale Anzahl von Bytes angibt, die zum Codieren der lateinischen Kleinbuchstaben erforderlich sind.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.  
  
- oder - 
Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
-und- 
Die <see cref="P:System.Text.Encoding.EncoderFallback" />-Eigenschaft ist auf <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codiert eine Reihe von Zeichen in eine Folge von Bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string -&gt; byte[]" Usage="uTF8Encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolge, die codiert werden soll.</param>
        <summary>Codiert die Zeichen in einem angegebenen <see cref="T:System.String" />-Objekt in eine Bytefolge.</summary>
        <returns>Ein Bytearray, das die codierten Zeichen in der vom s-Parameter angegebenen Zeichenfolge enthält.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="uTF8Encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="chars">Der zu codierende Zeichenbereich.</param>
        <param name="bytes">Der Bereich, der die sich ergebenden Bytes enthält.</param>
        <summary>Codiert den angegebenen Zeichenbereich in den angegebenen Bytebereich.</summary>
        <returns>Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> zurückgegebenes der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Folge von Bytes, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers. Die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode stellt dem Anfang einer Sequenz codierter Bytes keine Präambel voran.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF8Encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">Ein Zeiger auf das erste zu codierende Zeichen.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <param name="byteCount">Die maximal zu schreibende Anzahl von Byte.</param>
        <summary>Codiert Zeichen beginnend am angegebenen Zeichenzeiger in eine Bytefolge, die beginnend am angegebenen Bytezeiger gespeichert wird.</summary>
        <returns>Die durch <paramref name="bytes" /> angegebene tatsächliche Anzahl von Bytes, die am Speicherort geschrieben wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> zurückgegebenes der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Folge von Bytes, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers. Die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode stellt dem Anfang einer Sequenz codierter Bytes keine Präambel voran.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> ist <see langword="null" />  
  
- oder - 
 <paramref name="bytes" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> oder <paramref name="byteCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.  
  
- oder - 
 <paramref name="byteCount" /> ist niedriger als die sich ergebende Anzahl von Bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
-und- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ist auf <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="uTF8Encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Das Zeichenarray, das die zu codierenden Zeichen enthält.</param>
        <param name="charIndex">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</param>
        <param name="byteIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <summary>Codiert Zeichen aus dem angegebenen Zeichenarray in das angegebene Bytearray.</summary>
        <returns>Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Folge von Bytes, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers. Die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode stellt dem Anfang einer Sequenz codierter Bytes keine Präambel voran.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode verwendet, um einen Bereich von Zeichen aus einer Zeichenfolge zu codieren und die codierten Bytes in einem Bereich von Elementen in einem Bytearray zu speichern.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> ist <see langword="null" />  
  
- oder - 
 <paramref name="bytes" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" /> oder <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).  
  
- oder - 
 <paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.  
  
- oder - 
 <paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.  
  
- oder - 
 <paramref name="bytes" /> hat von <paramref name="byteIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
-und- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ist auf <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="uTF8Encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Die <see cref="T:System.String" />-Klasse mit den zu codierenden Zeichen.</param>
        <param name="charIndex">Der Index des ersten zu codierenden Zeichens.</param>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <param name="bytes">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</param>
        <param name="byteIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</param>
        <summary>Codiert Zeichen aus der angegebenen <see cref="T:System.String" />-Klasse in das angegebene Bytearray.</summary>
        <returns>Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Folge von Bytes, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers. Die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode stellt dem Anfang einer Sequenz codierter Bytes keine Präambel voran.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode verwendet, um einen Bereich von Elementen aus einem Array von Unicode-Zeichen zu codieren und die codierten Bytes in einem Bereich von Elementen in einem Bytearray zu speichern.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />  
  
- oder - 
 <paramref name="bytes" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" /> oder <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).  
  
- oder - 
 <paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" /> an.  
  
- oder - 
 <paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="s" /> enthält eine ungültige Folge von Zeichen.  
  
- oder - 
 <paramref name="bytes" /> hat von <paramref name="byteIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
-und- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ist auf <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge erzeugt werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="uTF8Encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Der Bereich, der die zu decodierenden Bytes enthält.</param>
        <summary>Berechnet die Anzahl von Zeichen, die beim Decodieren des angegebenen Bytebereichs erzeugt werden.</summary>
        <returns>Die Anzahl von Zeichen, die beim Decodieren des angegebenen Bytebereichs erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, können Sie die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode aufzurufen. Um die maximale Größe zu berechnen, müssen Sie die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode aufzurufen. Die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF8Encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf das erste zu decodierende Byte.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge ab dem angegebenen Bytezeiger erzeugt werden.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, müssen Sie die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode aufzurufen. Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode aufzurufen. Die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist kleiner als 0 (null).  
  
- oder - 
Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
-und- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ist auf <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="uTF8Encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="index">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge aus dem angegebenen Bytearray erzeugt werden.</summary>
        <returns>Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, müssen Sie die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode aufzurufen. Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode aufzurufen. Die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode verwendet, um die Anzahl der Zeichen zurückzugeben, die beim Decodieren eines Bereichs von Elementen in einem Bytearray erzeugt werden.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.  
  
- oder - 
Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
-und- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ist auf <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodiert eine Bytefolge in Zeichen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="uTF8Encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Der Bereich, der die zu decodierenden Bytes enthält.</param>
        <param name="chars">Der Bereich, der die sich ergebenden Zeichen enthalten soll.</param>
        <summary>Decodiert den angegebenen Bytebereich in den angegebenen Zeichenbereich.</summary>
        <returns>Die tatsächliche Anzahl der Zeichen, die in <paramref name="chars" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, können Sie die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode aufzurufen. Um die maximale Größe zu berechnen, müssen Sie die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode aufzurufen. Die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Wenn der zu decodende Satz von Bytes die Byte Reihenfolge-Marke (Byte Order Mark, BOM) einschließt und der Byte Abschnitt von einer Methode eines nicht-BOM-fähigen Typs zurückgegeben wurde, ist das Zeichen `U+FFFE` in der von dieser Methode zurückgegebenen Zeichen Spanne enthalten. Sie können es entfernen, indem Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufrufen.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. Und in diesem Fall, wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> Objekt bereitgestellt werden, indem Sie die <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF8Encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Zeiger auf das erste zu decodierende Byte.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="chars">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</param>
        <param name="charCount">Die maximale Anzahl der zu schreibenden Zeichen.</param>
        <summary>Decodiert eine Bytefolge beginnend am angegebenen Bytezeiger in Zeichen, die beginnend am angegebenen Zeichenzeiger gespeichert werden.</summary>
        <returns>Die durch <paramref name="chars" /> angegebene tatsächliche Anzahl der Zeichen, die am Speicherort geschrieben wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, müssen Sie die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode aufzurufen. Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode aufzurufen. Die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Wenn der zu decodierte Byte Bereich die Byte Reihenfolge-Marke (Byte Order Mark, BOM) einschließt und das Bytearray von einer Methode eines nicht-BOM-fähigen Typs zurückgegeben wurde, ist das Zeichen U + FFFE in dem von dieser Methode zurückgegebenen Zeichen Array enthalten. Sie können es entfernen, indem Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufrufen.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. Und in diesem Fall, wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> Objekt bereitgestellt werden, indem Sie die <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" />  
  
- oder - 
 <paramref name="chars" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> oder <paramref name="charCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.  
  
- oder - 
 <paramref name="charCount" /> ist niedriger als die sich ergebende Anzahl von Zeichen.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
-und- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ist auf <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="uTF8Encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="byteIndex">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <param name="chars">Das Zeichenarray, das die sich ergebenden Zeichen enthalten soll.</param>
        <param name="charIndex">Der Index, an dem mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</param>
        <summary>Decodiert eine Bytefolge aus dem angegebenen Bytearray in das angegebene Zeichenarray.</summary>
        <returns>Die tatsächliche Anzahl der Zeichen, die in <paramref name="chars" /> geschrieben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, müssen Sie die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode aufzurufen. Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode aufzurufen. Die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Wenn der zu decodierte Byte Bereich die Byte Reihenfolge-Marke (Byte Order Mark, BOM) einschließt und das Bytearray von einer Methode eines nicht-BOM-fähigen Typs zurückgegeben wurde, ist das Zeichen U + FFFE in dem von dieser Methode zurückgegebenen Zeichen Array enthalten. Sie können es entfernen, indem Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufrufen.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetChars%2A>-Methode verwendet, um einen Bereich von Elementen in einem Bytearray zu decodieren und das Ergebnis in einem Zeichen Array zu speichern.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" />  
  
- oder - 
 <paramref name="chars" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" /> oder <paramref name="byteCount" /> oder <paramref name="charIndex" /> ist kleiner als 0 (null).  
  
- oder - 
 <paramref name="byteindex" /> und <paramref name="byteCount" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.  
  
- oder - 
 <paramref name="charIndex" /> ist kein gültiger Index in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.  
  
- oder - 
 <paramref name="chars" /> hat von <paramref name="charIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Zeichen aufzunehmen.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
-und- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ist auf <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="uTF8Encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Decoder ab, der eine UTF-8-codierte Bytefolge in eine Unicode-Zeichenfolge konvertiert.</summary>
        <returns>Ein Decoder, der eine UTF-8-codierte Bytefolge in eine Unicode-Zeichenfolge konvertiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode konvertiert sequenzielle Blöcke von Bytes in sequenzielle Zeichenblöcke, ähnlich wie bei der <xref:System.Text.UTF8Encoding.GetChars%2A>-Methode dieser Klasse. Eine <xref:System.Text.Decoder> behält jedoch Zustandsinformationen zwischen Aufrufen bei, damit Byte Sequenzen, die Blöcke spannen, ordnungsgemäß decodiert werden können. Der <xref:System.Text.Decoder> behält auch nachfolgende Bytes am Ende der Datenblöcke bei und verwendet die nachfolgenden Bytes im nächsten Decodierungs Vorgang. Aus diesem Grund sind <xref:System.Text.UTF8Encoding.GetDecoder%2A> und <xref:System.Text.UTF8Encoding.GetEncoder%2A> für Netzwerkübertragungs-und Datei Vorgänge nützlich, da diese Vorgänge häufig Datenblöcke anstelle eines gesamten Datenstroms behandeln.  
  
 Wenn die Fehlererkennung aktiviert ist, d. h. der `throwOnInvalidCharacters`-Parameter des Konstruktors auf `true`festgelegt ist, wird die Fehlererkennung auch in der <xref:System.Text.Decoder> aktiviert, die von dieser Methode zurückgegeben wird. Wenn die Fehlererkennung aktiviert ist und eine ungültige Sequenz gefunden wird, ist der Status des Decoders nicht definiert, und die Verarbeitung muss beendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetDecoder%2A>-Methode verwendet, um einen UTF-8-Decoder abzurufen. Der Decoder konvertiert eine Bytefolge in eine Zeichenfolge.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CPP/getdecoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CS/getdecoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/VB/getdecoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="uTF8Encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Encoder ab, der eine Unicode-Zeichenfolge in eine UTF-8-codierte Bytefolge konvertiert.</summary>
        <returns>Ein <see cref="T:System.Text.Encoder" />, der eine Unicode-Zeichenfolge in eine UTF-8-codierte Bytefolge konvertiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode konvertiert sequenzielle Zeichenblöcke in eine Weise, die der <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode ähnelt. Eine <xref:System.Text.Encoder> verwaltet jedoch Zustandsinformationen zwischen aufrufen, sodass Sie Zeichen folgen, die Blöcke spannen, ordnungsgemäß codieren können. Der <xref:System.Text.Encoder> behält auch nachfolgende Zeichen am Ende der Datenblöcke bei und verwendet die nachfolgenden Zeichen im nächsten Codierungs Vorgang. Beispielsweise kann ein Datenblock mit einem nicht übereinstimmenden hohen Ersatz Zeichen enden, und das entsprechende niedrige Ersatz Zeichen kann sich im nächsten Datenblock befinden. Aus diesem Grund sind <xref:System.Text.UTF8Encoding.GetDecoder%2A> und <xref:System.Text.UTF8Encoding.GetEncoder%2A> für Netzwerkübertragungs-und Datei Vorgänge nützlich, da diese Vorgänge häufig Datenblöcke anstelle eines gesamten Datenstroms behandeln.  
  
 Wenn die Fehlererkennung aktiviert ist, d. h. der `throwOnInvalidCharacters`-Parameter des Konstruktors auf `true`festgelegt ist, wird die Fehlererkennung auch in der <xref:System.Text.Encoder> aktiviert, die von dieser Methode zurückgegeben wird. Wenn die Fehlererkennung aktiviert ist und eine ungültige Sequenz gefunden wird, ist der Status des Encoders nicht definiert, und die Verarbeitung muss beendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetEncoder%2A>-Methode verwendet, um einen Encoder zum Konvertieren einer Zeichenfolge in eine UTF-8-codierte Bytefolge zu erhalten.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CPP/getencoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CS/getencoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/VB/getencoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uTF8Encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für die aktuelle Instanz zurück.</summary>
        <returns>Der Hashcode für die aktuelle Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetHashCode%2A>-Methode verwendet, um einen Hashcode für <xref:System.Text.UTF8Encoding>-Instanzen zurückzugeben. Beachten Sie, dass der von dieser Methode zurückgegebene Hashcode von dem Konstruktor abhängt, der zum Erstellen des <xref:System.Text.UTF8Encoding> Objekts verwendet wurde.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CPP/gethashcode-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CS/gethashcode-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/VB/gethashcode-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="uTF8Encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Die Anzahl der zu codierenden Zeichen.</param>
        <summary>Berechnet die maximale Anzahl der Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt wird.</summary>
        <returns>Die maximale Anzahl an Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> ist eine Zahl mit dem ungünstigsten Fall, einschließlich des ungünstigsten Falls für den aktuell ausgewählten <xref:System.Text.EncoderFallback>. Wenn ein Fall Back mit einer potenziell großen Zeichenfolge ausgewählt wird, können <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> große Werte zurückgeben.  
  
 In den meisten Fällen gibt diese Methode für kleine Zeichen folgen angemessene Zahlen zurück. Bei großen Zeichen folgen müssen Sie möglicherweise zwischen der Verwendung sehr großer Puffer und dem Abfangen von Fehlern wählen, wenn ein sinnvoller Puffer überschritten wird. Möglicherweise möchten Sie auch einen anderen Ansatz mit <xref:System.Text.UTF8Encoding.GetByteCount%2A> oder <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>in Erwägung gezogen. Beispielsweise benötigt Text in englischer Sprache und vielen anderen Sprachen oft nur ein UTF-8-Byte, um ein Zeichen darzustellen, aber die von <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> zurückgegebene Zahl muss die Möglichkeit haben, dass die zu konvertierende Zeichenfolge vollständig aus Zeichen besteht, die jeweils vier Bytes benötigen.  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> hat keine Beziehung zu <xref:System.Text.UTF8Encoding.GetChars%2A>. Wenn Ihre Anwendung eine ähnliche Funktion benötigt, um mit <xref:System.Text.UTF8Encoding.GetChars%2A>zu verwenden, sollte <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>verwendet werden.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` ist nicht notwendigerweise derselbe Wert wie `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode verwendet, um die maximale Anzahl von Bytes zurückzugeben, die erforderlich sind, um eine angegebene Anzahl von Zeichen zu codieren.  
  
 [!code-cpp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> ist kleiner als 0 (null).  
  
- oder - 
Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
-und- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ist auf <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="uTF8Encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Berechnet die maximale Anzahl der Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</summary>
        <returns>Die maximale Anzahl von Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, wird die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> ist eine Zahl mit dem ungünstigsten Fall, einschließlich des ungünstigsten Falls für den aktuell ausgewählten <xref:System.Text.DecoderFallback>. Wenn ein Fall Back mit einer potenziell großen Zeichenfolge ausgewählt wird, können <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> große Werte zurückgeben.  
  
 In den meisten Fällen gibt diese Methode für kleine Zeichen folgen angemessene Zahlen zurück. Bei großen Zeichen folgen müssen Sie möglicherweise zwischen der Verwendung sehr großer Puffer und dem Abfangen von Fehlern wählen, wenn ein sinnvoller Puffer überschritten wird.  Möglicherweise möchten Sie auch einen anderen Ansatz mit <xref:System.Text.UTF8Encoding.GetCharCount%2A> oder <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>in Erwägung gezogen.  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> hat keine Beziehung zu <xref:System.Text.UTF8Encoding.GetBytes%2A>. Wenn Ihre Anwendung eine ähnliche Funktion benötigt, um mit <xref:System.Text.UTF8Encoding.GetBytes%2A>zu verwenden, sollte <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>verwendet werden.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` ist nicht notwendigerweise derselbe Wert wie `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode verwendet, um die maximale Anzahl von Zeichen zurückzugeben, die beim Decodieren einer angegebenen Anzahl von Bytes erzeugt werden.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> ist kleiner als 0 (null).  
  
- oder - 
Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
-und- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ist auf <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="uTF8Encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Unicode-Bytereihenfolgemarkierung im UTF-8-Format zurück, wenn das <see cref="T:System.Text.UTF8Encoding" />-Codierungsobjekt dafür konfiguriert ist, eine bereitzustellen.</summary>
        <returns>Ein Bytearray, das die Unicode-Bytereihenfolgemarkierung enthält, wenn das <see cref="T:System.Text.UTF8Encoding" />-Codierungsobjekt dafür konfiguriert ist, eine bereitzustellen. Andernfalls gibt diese Methode ein Bytearray mit der Länge Null zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Text.UTF8Encoding>-Objekt kann eine Präambel bereitstellen, bei der es sich um ein Bytearray handelt, dem die Byte Sequenz vorangestellt werden kann, die sich aus dem Codierungsprozess ergibt. Wenn eine Sequenz codierter Bytes mit einer Byte Reihenfolge-Markierung (Codepunkt U + FEFF) vorangestellt ist, kann der Decoder die Byte Reihenfolge und das Transformations Format (UTF) bestimmen. Die Unicode-Byte Reihenfolge Markierung (BOM) wird als 0xEF 0xBB 0xBF serialisiert. Beachten Sie, dass der Unicode-Standard weder erfordert noch die Verwendung einer BOM für UTF-8-codierte Streams empfiehlt.  
  
 Sie können ein <xref:System.Text.UTF8Encoding> Objekt instanziieren, dessen <xref:System.Text.UTF8Encoding.GetPreamble%2A> Methode eine gültige BOM auf folgende Weise zurückgibt:  
  
-   Durch Abrufen des <xref:System.Text.UTF8Encoding> Objekts, das von der <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird.  
  
-   Durch Aufrufen eines <xref:System.Text.UTF8Encoding> Konstruktors mit einem `encoderShouldEmitUTF8Identifier`-Parameter und Festlegen seines Werts auf `true`.  
  
 Alle anderen <xref:System.Text.UTF8Encoding> Objekte werden so konfiguriert, dass Sie ein leeres Array anstelle einer gültigen BOM zurückgeben.  
  
 Die BOM bietet fast eine bestimmte Identifizierung einer Codierung für Dateien, die andernfalls einen Verweis auf ihre Codierung verloren haben, z. b. nicht markierte oder nicht ordnungsgemäß markierte Webdaten oder zufällige Textdateien, die gespeichert wurden, wenn ein Unternehmen nicht über internationale Belange verfügte. Häufig können Benutzer Probleme vermieden werden, wenn die Daten konsistent und ordnungsgemäß gekennzeichnet sind.  
  
 Bei Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant. Sie kann jedoch verwendet werden, um einem Server zu helfen, den richtigen Codierungs Header zu senden. Alternativ kann es als Fall Back für den Fall verwendet werden, dass die Codierung andernfalls verloren geht.  
  
 Es gibt einige Nachteile bei der Verwendung einer BOM. Beispielsweise kann das Einschränken der Datenbankfelder, die eine BOM verwenden, schwierig sein. Die Verkettung von Dateien kann auch ein Problem darstellen, z. b. wenn Dateien so zusammengeführt werden, dass ein unnötiges Zeichen in der Mitte der Daten enden kann. Trotz der wenigen Nachteile wird die Verwendung einer BOM dringend empfohlen.  
  
 Weitere Informationen zur Byte Reihenfolge und zur Byte Reihenfolge-Markierung finden Sie im Unicode-Standard auf der [Unicode-Homepage](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!IMPORTANT]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie dem Anfang eines Streams codierter Bytes eine Präambel als Präfix voranstellen. Beachten Sie, dass die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode einer Sequenz codierter Bytes keine BOM voranstellt. das Bereitstellen einer BOM am Anfang eines entsprechenden Bytestreams ist die Verantwortung des Entwicklers.
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetPreamble%2A>-Methode verwendet, um die im UTF-8-Format codierte Unicode-Byte Reihenfolge Markierung zurückzugeben. Beachten Sie, dass der Parameter lose Konstruktor für <xref:System.Text.UTF8Encoding> keine Präambel bereitstellt.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 Im folgenden Beispiel werden zwei <xref:System.Text.UTF8Encoding> Objekte instanziiert, der erste durch Aufrufen des Parameter losen <xref:System.Text.UTF8Encoding.%23ctor> Konstruktors, der keine BOM bereitstellt, und der zweite, indem der <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29>-Konstruktor aufgerufen wird, dessen `encoderShouldEmitUTF8Identifier` Argument auf `true`festgelegt ist. Anschließend wird die <xref:System.Text.UTF8Encoding.GetPreamble%2A>-Methode aufgerufen, um die BOM in eine Datei zu schreiben, bevor eine UF8-codierte Zeichenfolge geschrieben wird. Wie die Konsolenausgabe aus dem Beispiel zeigt, hat die Datei, die die Bytes aus dem zweiten Encoder speichert, drei weitere Bytes als die erste.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/cs/getpreamble1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/vb/getpreamble1.vb#1)]  
  
 Sie können die Dateien auch mit dem `fc`-Befehl in einem Konsolenfenster vergleichen, oder Sie können die Dateien in einem Text-Editor untersuchen, der einen Hexadezimal Ansichtsmodus enthält. Beachten Sie, dass die BOM nicht angezeigt wird, wenn die Datei in einem Editor geöffnet wird, der UTF-8 unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="uTF8Encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Das Bytearray, das die zu decodierende Bytefolge enthält.</param>
        <param name="index">Der Index des ersten zu decodierenden Bytes.</param>
        <param name="count">Die Anzahl der zu decodierenden Bytes.</param>
        <summary>Decodiert einen Bytebereich aus einem Bytearray in eine Zeichenfolge.</summary>
        <returns>Eine <see cref="T:System.String" />-Klasse, die die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Wenn der zu decodierte Byte Bereich die Byte Reihenfolge-Marke (Byte Order Mark, BOM) einschließt und das Bytearray von einer Methode eines nicht-BOM-fähigen Typs zurückgegeben wurde, ist das Zeichen U + FFFE in dem von dieser Methode zurückgegebenen Zeichen Array enthalten. Sie können es entfernen, indem Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufrufen.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array initialisiert, indem die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen wird, um genau zu bestimmen, wie viele Bytes für eine codierte Zeichenfolge erforderlich sind, und dann die Größe der Byte Reihenfolge-Marke (BOM) hinzugefügt Im Beispiel wird dann die <xref:System.Text.UTF8Encoding.GetPreamble%2A>-Methode aufgerufen, um die BOM im Array zu speichern, bevor die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode aufgerufen wird, um die codierten Bytes im Array zu speichern. Im Beispiel wird dann die <xref:System.Text.UTF8Encoding.GetString%2A>-Methode aufgerufen, um die Zeichenfolge zu decodieren.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Beachten Sie, dass die decodierte Zeichenfolge in diesem Fall von der ursprünglichen Zeichenfolge abweicht, da Sie mit einer 16-Bit-Byte Reihenfolge Markierung U + FFFD beginnt. Dies bedeutet, dass die beiden Zeichen folgen als ungleich verglichen werden und dass, wenn die Zeichenfolge ausgegeben wird, die BOM als Ersatz Zeichen "?" angezeigt wird. Um die BOM am Anfang der Zeichenfolge zu entfernen, können Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</exception>
        <exception cref="T:System.ArgumentException">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>). 
-und- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ist auf <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public override ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.UTF8Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.UTF8Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Unicode-Bytereihenfolgemarkierung im UTF-8-Format ab, wenn dieses Objekt entsprechend konfiguriert ist.</summary>
        <value>Eine Byte Spanne, die die Unicode-Byte Reihenfolge Markierung enthält, wenn dieses Objekt für die Bereitstellung eines solchen konfiguriert ist. andernfalls die Standard Spanne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Text.UTF8Encoding>-Objekt kann eine Präambel bereitstellen, bei der es sich um einen Byte Bereich handelt, dem die Byte Sequenz vorangestellt werden kann, die sich aus dem Codierungsprozess ergeben. Wenn eine Sequenz codierter Bytes mit einer Byte Reihenfolge-Markierung (Codepunkt-`U+FEFF`) vorangestellt ist, kann der Decoder die Byte Reihenfolge und das Transformations Format (UTF) bestimmen. Die Unicode-Byte Reihenfolge Markierung (BOM) wird als 0xEF 0xBB 0xBF serialisiert. Beachten Sie, dass der Unicode-Standard weder erfordert noch die Verwendung einer BOM für UTF-8-codierte Streams empfiehlt.  
  
 Sie können ein <xref:System.Text.UTF8Encoding> Objekt, dessen `Preamble` eine gültige BOM ist, auf folgende Weise instanziieren:  
  
-   Durch Abrufen des <xref:System.Text.UTF8Encoding> Objekts, das von der <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird.  
  
-   Durch Aufrufen eines <xref:System.Text.UTF8Encoding> Konstruktors mit einem `encoderShouldEmitUTF8Identifier`-Parameter und Festlegen seines Werts auf `true`.  
  
 Alle anderen <xref:System.Text.UTF8Encoding> Objekte werden so konfiguriert, dass Sie eine Standard Spanne und keine gültige BOM zurückgeben.  
  
 Die BOM bietet fast eine bestimmte Identifizierung einer Codierung für Dateien, die andernfalls einen Verweis auf ihre Codierung verloren haben, z. b. nicht markierte oder nicht ordnungsgemäß markierte Webdaten oder zufällige Textdateien, die gespeichert wurden, wenn ein Unternehmen nicht über internationale Belange verfügte. Häufig können Benutzer Probleme vermieden werden, wenn die Daten konsistent und ordnungsgemäß gekennzeichnet sind.  
  
 Bei Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant. Sie kann jedoch verwendet werden, um einem Server zu helfen, den richtigen Codierungs Header zu senden. Alternativ kann es als Fall Back für den Fall verwendet werden, dass die Codierung andernfalls verloren geht.  
  
 Es gibt einige Nachteile bei der Verwendung einer BOM. Beispielsweise kann das Einschränken der Datenbankfelder, die eine BOM verwenden, schwierig sein. Die Verkettung von Dateien kann auch ein Problem darstellen, z. b. wenn Dateien so zusammengeführt werden, dass ein unnötiges Zeichen in der Mitte der Daten enden kann. Trotz der wenigen Nachteile wird die Verwendung einer BOM dringend empfohlen.  
  
 Weitere Informationen zur Byte Reihenfolge und zur Byte Reihenfolge-Markierung finden Sie im Unicode-Standard auf der [Unicode-Homepage](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!IMPORTANT]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie dem Anfang eines Streams codierter Bytes eine Präambel als Präfix voranstellen. Beachten Sie, dass die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode einer Sequenz codierter Bytes keine BOM voranstellt. das Bereitstellen einer BOM am Anfang eines entsprechenden Bytestreams ist die Verantwortung des Entwicklers.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
