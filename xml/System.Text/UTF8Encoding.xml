<Type Name="UTF8Encoding" FullName="System.Text.UTF8Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2554c28970debe16f2926bf5e4fba4fcdcaec1f0" /><Meta Name="ms.sourcegitcommit" Value="6c0b6310824199ff476e4a9eec6e9ed0bd1a51c9" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/06/2019" /><Meta Name="ms.locfileid" Value="74388015" /></Metadata><TypeSignature Language="C#" Value="public class UTF8Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UTF8Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF8Encoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UTF8Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF8Encoding : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UTF8Encoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="1955e-101">Stellt eine UTF-8-Codierung von Unicode-Zeichen dar.</span><span class="sxs-lookup"><span data-stu-id="1955e-101">Represents a UTF-8 encoding of Unicode characters.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-102">Beim Kodieren werden Unicode-Zeichen in eine Bytefolge transformiert.</span><span class="sxs-lookup"><span data-stu-id="1955e-102">Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</span></span> <span data-ttu-id="1955e-103">Beim Decodieren wird eine Sequenz codierter Bytes in eine Gruppe von Unicode-Zeichen transformiert.</span><span class="sxs-lookup"><span data-stu-id="1955e-103">Decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</span></span>  
  
 <span data-ttu-id="1955e-104">UTF-8 ist eine Unicode-Codierung, die die einzelnen Code Punkte als Sequenz von einem bis vier Bytes darstellt.</span><span class="sxs-lookup"><span data-stu-id="1955e-104">UTF-8 is a Unicode encoding that represents each code point as a sequence of one to four bytes.</span></span> <span data-ttu-id="1955e-105">Im Gegensatz zu den UTF-16-und UTF-32-Codierungen ist für die UTF-8-Codierung keine ""-Anmerkung erforderlich. das Codierungsschema ist unabhängig davon, ob der Prozessor Big-Endian oder Little-Endian ist, identisch.</span><span class="sxs-lookup"><span data-stu-id="1955e-105">Unlike the UTF-16 and UTF-32 encodings, the UTF-8 encoding does not require "endianness"; the encoding scheme is the same regardless of whether the processor is big-endian or little-endian.</span></span> <span data-ttu-id="1955e-106"><xref:System.Text.UTF8Encoding> entspricht der Windows-Codepage 65001.</span><span class="sxs-lookup"><span data-stu-id="1955e-106"><xref:System.Text.UTF8Encoding> corresponds to the Windows code page 65001.</span></span> <span data-ttu-id="1955e-107">Weitere Informationen zu den UTFs und anderen Codierungen, die von <xref:System.Text>unterstützt werden, finden Sie unter [Zeichencodierung in der .NET Framework](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="1955e-107">For more information about the UTFs and other encodings supported by <xref:System.Text>, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
 <span data-ttu-id="1955e-108">Sie können ein <xref:System.Text.UTF8Encoding> Objekt auf verschiedene Weise instanziieren, abhängig davon, ob Sie eine Byte Reihenfolge-Marke (BOM) bereitstellen möchten und ob Sie die Fehlererkennung aktivieren möchten.</span><span class="sxs-lookup"><span data-stu-id="1955e-108">You can instantiate a <xref:System.Text.UTF8Encoding> object in a number of ways, depending on whether you want to it to provide a byte order mark (BOM) and whether you want to enable error detection.</span></span> <span data-ttu-id="1955e-109">In der folgenden Tabelle werden die-Konstruktoren und die <xref:System.Text.Encoding>-Eigenschaft aufgelistet, die ein <xref:System.Text.UTF8Encoding>-Objekt zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="1955e-109">The following table lists the constructors and the <xref:System.Text.Encoding> property that return a <xref:System.Text.UTF8Encoding> object.</span></span>  
  
|<span data-ttu-id="1955e-110">Member</span><span class="sxs-lookup"><span data-stu-id="1955e-110">Member</span></span>|<span data-ttu-id="1955e-111">BOM</span><span class="sxs-lookup"><span data-stu-id="1955e-111">BOM</span></span>|<span data-ttu-id="1955e-112">Fehlererkennung</span><span class="sxs-lookup"><span data-stu-id="1955e-112">Error detection</span></span>|  
|------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>|<span data-ttu-id="1955e-113">Ja</span><span class="sxs-lookup"><span data-stu-id="1955e-113">Yes</span></span>|<span data-ttu-id="1955e-114">Nein (Ersatz Fall Back)</span><span class="sxs-lookup"><span data-stu-id="1955e-114">No (Replacement fallback)</span></span>|  
|<xref:System.Text.UTF8Encoding.%23ctor?displayProperty=nameWithType>|<span data-ttu-id="1955e-115">Nein</span><span class="sxs-lookup"><span data-stu-id="1955e-115">No</span></span>|<span data-ttu-id="1955e-116">Nein (Ersatz Fall Back)</span><span class="sxs-lookup"><span data-stu-id="1955e-116">No (Replacement fallback)</span></span>|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29?displayProperty=nameWithType>|<span data-ttu-id="1955e-117">Konfigurierbare</span><span class="sxs-lookup"><span data-stu-id="1955e-117">Configurable</span></span>|<span data-ttu-id="1955e-118">Nein (Ersatz Fall Back)</span><span class="sxs-lookup"><span data-stu-id="1955e-118">No (Replacement fallback)</span></span>|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|<span data-ttu-id="1955e-119">Konfigurierbare</span><span class="sxs-lookup"><span data-stu-id="1955e-119">Configurable</span></span>|<span data-ttu-id="1955e-120">Konfigurierbare</span><span class="sxs-lookup"><span data-stu-id="1955e-120">Configurable</span></span>|  
  
 <span data-ttu-id="1955e-121">Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.</span><span class="sxs-lookup"><span data-stu-id="1955e-121">The <xref:System.Text.UTF8Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.UTF8Encoding.GetBytes%2A> method performs the actual encoding.</span></span>  
  
 <span data-ttu-id="1955e-122">Ebenso bestimmt die <xref:System.Text.UTF8Encoding.GetCharCount%2A> Methode, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die Methoden <xref:System.Text.UTF8Encoding.GetChars%2A> und <xref:System.Text.UTF8Encoding.GetString%2A> führen die eigentliche Decodierung aus.</span><span class="sxs-lookup"><span data-stu-id="1955e-122">Likewise, the <xref:System.Text.UTF8Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.UTF8Encoding.GetChars%2A> and <xref:System.Text.UTF8Encoding.GetString%2A> methods perform the actual decoding.</span></span>  
  
 <span data-ttu-id="1955e-123">Für einen Encoder oder Decoder, der zum Speichern von Zustandsinformationen, die beim Codieren oder Decodieren von Daten, die umfasst mehrere Blöcke (z. B. String von 1 Mio. Zeichen, die in Segmenten von 100.000 Zeichen codiert wird) verwenden, können die <xref:System.Text.UTF8Encoding.GetEncoder%2A> und <xref:System.Text.UTF8Encoding.GetDecoder%2A> Eigenschaften bzw.</span><span class="sxs-lookup"><span data-stu-id="1955e-123">For an encoder or decoder that is able to save state information when encoding or decoding data that spans multiple blocks (such as string of 1 million characters that is encoded in 100,000-character segments), use the <xref:System.Text.UTF8Encoding.GetEncoder%2A> and <xref:System.Text.UTF8Encoding.GetDecoder%2A> properties, respectively.</span></span>  
  
 <span data-ttu-id="1955e-124">Das <xref:System.Text.UTF8Encoding>-Objekt stellt optional eine Byte Reihenfolge-Marke (Byte Order Mark, BOM) bereit, bei der es sich um ein Bytearray handelt, dem der Anfang des Bytestreams vorangestellt werden kann</span><span class="sxs-lookup"><span data-stu-id="1955e-124">Optionally, the <xref:System.Text.UTF8Encoding> object provides a byte order mark (BOM), which is an array of bytes that can be prefixed to the beginning of the byte stream that results from the encoding process.</span></span> <span data-ttu-id="1955e-125">Wenn einem UTF-8-codierten Bytestream eine Byte Reihenfolge-Marke (Byte Order Mark, BOM) vorangestellt wird, unterstützt der Decoder die Byte Reihenfolge und das Transformations Format oder UTF.</span><span class="sxs-lookup"><span data-stu-id="1955e-125">If a UTF-8 encoded byte stream is prefaced with a byte order mark (BOM), it helps the decoder determine the byte order and the transformation format or UTF.</span></span> <span data-ttu-id="1955e-126">Beachten Sie jedoch, dass der Unicode-Standard weder eine BOM in UTF-8-codierten Streams erfordert noch empfiehlt.</span><span class="sxs-lookup"><span data-stu-id="1955e-126">Note, however, that the Unicode Standard neither requires nor recommends a BOM in UTF-8 encoded streams.</span></span> <span data-ttu-id="1955e-127">Weitere Informationen zur Byte Reihenfolge und zur Byte Reihenfolge-Markierung finden Sie im Unicode-Standard auf der [Unicode-Homepage](https://go.microsoft.com/fwlink/?LinkId=37123).</span><span class="sxs-lookup"><span data-stu-id="1955e-127">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](https://go.microsoft.com/fwlink/?LinkId=37123).</span></span>  
  
 <span data-ttu-id="1955e-128">Wenn der Encoder für die Bereitstellung einer BOM konfiguriert ist, können Sie Sie abrufen, indem Sie die <xref:System.Text.UTF8Encoding.GetPreamble%2A>-Methode aufrufen. Andernfalls gibt die Methode ein leeres Array zurück.</span><span class="sxs-lookup"><span data-stu-id="1955e-128">If the encoder is configured to provide a BOM, you can retrieve it by calling the <xref:System.Text.UTF8Encoding.GetPreamble%2A> method; otherwise, the method returns an empty array.</span></span> <span data-ttu-id="1955e-129">Beachten Sie, dass Sie, selbst wenn ein <xref:System.Text.UTF8Encoding> Objekt für die BOM-Unterstützung konfiguriert ist, die BOM nach Bedarf am Anfang des codierten Bytestreams einschließen müssen. die Codierungs Methoden der <xref:System.Text.UTF8Encoding>-Klasse führen dies nicht automatisch aus.</span><span class="sxs-lookup"><span data-stu-id="1955e-129">Note that, even if a <xref:System.Text.UTF8Encoding> object is configured for BOM support, you must include the BOM at the beginning of the encoded byte stream as appropriate; the encoding methods of the <xref:System.Text.UTF8Encoding> class do not do this automatically.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="1955e-130">Um die Fehlererkennung zu aktivieren und die Klasseninstanz sicherer zu machen, sollten Sie den <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29>-Konstruktor aufrufen und den `throwOnInvalidBytes`-Parameter auf `true`festlegen.</span><span class="sxs-lookup"><span data-stu-id="1955e-130">To enable error detection and to make the class instance more secure, you should call the <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> constructor and set the `throwOnInvalidBytes` parameter to `true`.</span></span> <span data-ttu-id="1955e-131">Wenn die Fehlererkennung aktiviert ist, löst eine Methode, die eine ungültige Sequenz von Zeichen oder Bytes erkennt, eine <xref:System.ArgumentException> Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="1955e-131">With error detection enabled, a method that detects an invalid sequence of characters or bytes throws an <xref:System.ArgumentException> exception.</span></span> <span data-ttu-id="1955e-132">Ohne Fehlererkennung wird keine Ausnahme ausgelöst, und die ungültige Sequenz wird im Allgemeinen ignoriert.</span><span class="sxs-lookup"><span data-stu-id="1955e-132">Without error detection, no exception is thrown, and the invalid sequence is generally ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1955e-133">Der Status eines UTF-8-codierten Objekts wird nicht beibehalten, wenn das Objekt mit unterschiedlichen .NET Framework Versionen serialisiert und deserialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-133">The state of a UTF-8 encoded object is not preserved if the object is serialized and deserialized using different .NET Framework versions.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1955e-134">Im folgenden Beispiel wird ein <xref:System.Text.UTF8Encoding> Objekt verwendet, um eine Zeichenfolge von Unicode-Zeichen zu codieren und in einem Bytearray zu speichern.</span><span class="sxs-lookup"><span data-stu-id="1955e-134">The following example uses a <xref:System.Text.UTF8Encoding> object to encode a string of Unicode characters and store them in a byte array.</span></span> <span data-ttu-id="1955e-135">Die Unicode-Zeichenfolge enthält zwei Zeichen, Pi (u + 03a0) und Sigma (u + 03a3), die außerhalb des ASCII-Zeichen Bereichs liegen.</span><span class="sxs-lookup"><span data-stu-id="1955e-135">The Unicode string includes two characters, Pi (U+03A0) and Sigma (U+03A3), that are outside the ASCII character range.</span></span> <span data-ttu-id="1955e-136">Wenn das codierte Bytearray zurück in eine Zeichenfolge decodiert wird, sind die Zeichen Pi und Sigma weiterhin vorhanden.</span><span class="sxs-lookup"><span data-stu-id="1955e-136">When the encoded byte array is decoded back to a string, the Pi and Sigma characters are still present.</span></span>  
  
 [!code-cpp[System.Text.UTF8Encoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UTF8Encoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/snippet.vb#1)]  
  
 <span data-ttu-id="1955e-137">Im folgenden Beispiel wird die gleiche Zeichenfolge wie im vorherigen Beispiel verwendet, mit der Ausnahme, dass die codierten Bytes in eine Datei geschrieben und der Bytestream mit einer Byte Reihenfolge Markierung (BOM) vorangestellt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-137">The following example uses the same string as the previous example, except that it writes the encoded bytes to a file and prefixes the byte stream with a byte order mark (BOM).</span></span> <span data-ttu-id="1955e-138">Anschließend wird die Datei auf zwei verschiedene Arten gelesen: als Textdatei mit einem <xref:System.IO.StreamReader> Objekt. und als Binärdatei.</span><span class="sxs-lookup"><span data-stu-id="1955e-138">It then reads the file in two different ways: as a text file by using a <xref:System.IO.StreamReader> object; and as a binary file.</span></span> <span data-ttu-id="1955e-139">Erwartungsgemäß enthält weder die neu gelesene Zeichenfolge die BOM.</span><span class="sxs-lookup"><span data-stu-id="1955e-139">As you would expect, neither newly-read string includes the BOM.</span></span>  
  
 [!code-csharp[System.Text.UTF8Encoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UTF8Encoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoder" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1955e-140">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1955e-140">Understanding Encodings</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1955e-141">Initialisiert eine neue Instanz der <see cref="T:System.Text.UTF8Encoding" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1955e-141">Initializes a new instance of the <see cref="T:System.Text.UTF8Encoding" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1955e-142">Initialisiert eine neue Instanz der <see cref="T:System.Text.UTF8Encoding" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1955e-142">Initializes a new instance of the <see cref="T:System.Text.UTF8Encoding" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-143">Dieser Konstruktor erstellt eine Instanz, die keine Unicode-Byte Reihenfolge Markierung bereitstellt und keine Ausnahme auslöst, wenn eine ungültige Codierung erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-143">This constructor creates an instance that does not provide a Unicode byte order mark and does not throw an exception when an invalid encoding is detected.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="1955e-144">Aus Sicherheitsgründen wird empfohlen, die Fehlererkennung zu aktivieren, indem Sie einen Konstruktor mit einem `throwOnInvalidBytes`-Parameter aufrufen und dessen Wert auf `true`festlegen.</span><span class="sxs-lookup"><span data-stu-id="1955e-144">For security reasons, we recommend that you enable error detection by calling a constructor with a `throwOnInvalidBytes` parameter and setting its value to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1955e-145">Im folgenden Beispiel wird eine neue <xref:System.Text.UTF8Encoding>-Instanz erstellt und deren Name angezeigt.</span><span class="sxs-lookup"><span data-stu-id="1955e-145">The following example creates a new <xref:System.Text.UTF8Encoding> instance and displays its name.</span></span>  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF8Encoding : bool -&gt; System.Text.UTF8Encoding" Usage="new System.Text.UTF8Encoding encoderShouldEmitUTF8Identifier" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier"><span data-ttu-id="1955e-146"><see langword="true" />, um anzugeben, dass die <see cref="M:System.Text.UTF8Encoding.GetPreamble" />-Methode eine Unicode-Bytereihenfolgemarkierung zurückgibt; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-146"><see langword="true" /> to specify that the <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> method returns a Unicode byte order mark; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1955e-147">Initialisiert eine neue Instanz der <see cref="T:System.Text.UTF8Encoding" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1955e-147">Initializes a new instance of the <see cref="T:System.Text.UTF8Encoding" /> class.</span></span> <span data-ttu-id="1955e-148">Ein Parameter gibt an, ob eine Unicode-Bytereihenfolgemarkierung bereitgestellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="1955e-148">A parameter specifies whether to provide a Unicode byte order mark.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-149">Dieser Konstruktor erstellt eine-Instanz, die keine Ausnahme auslöst, wenn eine ungültige Codierung erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-149">This constructor creates an instance that does not throw an exception when an invalid encoding is detected.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="1955e-150">Aus Sicherheitsgründen sollten Sie die Fehlererkennung aktivieren, indem Sie einen Konstruktor aufrufen, der einen `throwOnInvalidBytes`-Parameter enthält, und dessen Wert auf `true`festlegen.</span><span class="sxs-lookup"><span data-stu-id="1955e-150">For security reasons, you should enable error detection by calling a constructor that includes a `throwOnInvalidBytes` parameter and setting its value to `true`.</span></span>  
  
 <span data-ttu-id="1955e-151">Der `encoderShouldEmitUTF8Identifier`-Parameter steuert den Betrieb der <xref:System.Text.UTF8Encoding.GetPreamble%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="1955e-151">The `encoderShouldEmitUTF8Identifier` parameter controls the operation of the <xref:System.Text.UTF8Encoding.GetPreamble%2A> method.</span></span> <span data-ttu-id="1955e-152">Wenn `true`, gibt die Methode ein Bytearray zurück, das die Unicode-Byte Reihenfolge-Marke (BOM) im UTF-8-Format enthält.</span><span class="sxs-lookup"><span data-stu-id="1955e-152">If `true`, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-8 format.</span></span>  <span data-ttu-id="1955e-153">Wenn `false`, wird ein Bytearray der Länge 0 (null) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="1955e-153">If `false`, it returns a zero-length byte array.</span></span> <span data-ttu-id="1955e-154">Wenn Sie jedoch `encoderShouldEmitUTF8Identifier` auf `true` festlegen, bewirkt dies nicht, dass die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode der BOM am Anfang des Bytearrays vorangestellt wird. Außerdem bewirkt dies, dass die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode die Anzahl der Bytes in der BOM in der Byte Anzahl nicht einschließt.</span><span class="sxs-lookup"><span data-stu-id="1955e-154">However, setting `encoderShouldEmitUTF8Identifier` to `true` does not cause the <xref:System.Text.UTF8Encoding.GetBytes%2A> method to prefix the BOM at the beginning of the byte array, nor does it cause the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method to include the number of bytes in the BOM in the byte count.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1955e-155">Im folgenden Beispiel wird eine neue <xref:System.Text.UTF8Encoding>-Instanz erstellt und angegeben, dass ein Unicode-Byte Reihenfolge-Präfix von der <xref:System.Text.UTF8Encoding.GetPreamble%2A>-Methode ausgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="1955e-155">The following example creates a new <xref:System.Text.UTF8Encoding> instance and specifies that a Unicode byte order mark prefix should be emitted by the <xref:System.Text.UTF8Encoding.GetPreamble%2A> method.</span></span> <span data-ttu-id="1955e-156">Die <xref:System.Text.UTF8Encoding.GetPreamble%2A>-Methode gibt dann das Unicode-Byte Reihenfolge Markierung-Präfix zurück.</span><span class="sxs-lookup"><span data-stu-id="1955e-156">The <xref:System.Text.UTF8Encoding.GetPreamble%2A> method then returns the Unicode byte order mark prefix.</span></span>  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CPP/ctor-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CS/ctor-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/VB/ctor-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF8Encoding : bool * bool -&gt; System.Text.UTF8Encoding" Usage="new System.Text.UTF8Encoding (encoderShouldEmitUTF8Identifier, throwOnInvalidBytes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier"><span data-ttu-id="1955e-157"><see langword="true" />, um anzugeben, dass die <see cref="M:System.Text.UTF8Encoding.GetPreamble" />-Methode eine Unicode-Bytereihenfolgemarkierung zurückgeben sollte; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-157"><see langword="true" /> to specify that the <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> method should return a Unicode byte order mark; otherwise, <see langword="false" />.</span></span></param>
        <param name="throwOnInvalidBytes"><span data-ttu-id="1955e-158"><see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn eine ungültige Codierung gefunden wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-158"><see langword="true" /> to throw an exception when an invalid encoding is detected; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1955e-159">Initialisiert eine neue Instanz der <see cref="T:System.Text.UTF8Encoding" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1955e-159">Initializes a new instance of the <see cref="T:System.Text.UTF8Encoding" /> class.</span></span> <span data-ttu-id="1955e-160">Parameter geben an, ob eine Unicode-Bytereihenfolgemarkierung bereitgestellt werden soll und ob eine Ausnahme ausgelöst werden soll, wenn eine ungültige Codierung gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-160">Parameters specify whether to provide a Unicode byte order mark and whether to throw an exception when an invalid encoding is detected.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-161">Der `encoderShouldEmitUTF8Identifier`-Parameter steuert den Betrieb der <xref:System.Text.UTF8Encoding.GetPreamble%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="1955e-161">The `encoderShouldEmitUTF8Identifier` parameter controls the operation of the <xref:System.Text.UTF8Encoding.GetPreamble%2A> method.</span></span> <span data-ttu-id="1955e-162">Wenn `true`, gibt die Methode ein Bytearray zurück, das die Unicode-Byte Reihenfolge-Marke (BOM) im UTF-8-Format enthält.</span><span class="sxs-lookup"><span data-stu-id="1955e-162">If `true`, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-8 format.</span></span>  <span data-ttu-id="1955e-163">Wenn `false`, wird ein Bytearray der Länge 0 (null) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="1955e-163">If `false`, it returns a zero-length byte array.</span></span> <span data-ttu-id="1955e-164">Wenn Sie jedoch `encoderShouldEmitUTF8Identifier` auf `true` festlegen, bewirkt dies nicht, dass die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode der BOM am Anfang des Bytearrays vorangestellt wird. Außerdem bewirkt dies, dass die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode die Anzahl der Bytes in der BOM in der Byte Anzahl nicht einschließt.</span><span class="sxs-lookup"><span data-stu-id="1955e-164">However, setting `encoderShouldEmitUTF8Identifier` to `true` does not cause the <xref:System.Text.UTF8Encoding.GetBytes%2A> method to prefix the BOM at the beginning of the byte array, nor does it cause the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method to include the number of bytes in the BOM in the byte count.</span></span>  
  
 <span data-ttu-id="1955e-165">Wenn `throwOnInvalidBytes` `true`ist, löst eine Methode, die eine ungültige Byte Sequenz erkennt, eine <xref:System.ArgumentException?displayProperty=nameWithType> Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="1955e-165">If `throwOnInvalidBytes` is `true`, a method that detects an invalid byte sequence throws an <xref:System.ArgumentException?displayProperty=nameWithType> exception.</span></span> <span data-ttu-id="1955e-166">Andernfalls löst die Methode keine Ausnahme aus, und die ungültige Sequenz wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="1955e-166">Otherwise, the method does not throw an exception, and the invalid sequence is ignored.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="1955e-167">Aus Sicherheitsgründen sollten Sie die Fehlererkennung aktivieren, indem Sie einen Konstruktor aufrufen, der einen `throwOnInvalidBytes`-Parameter enthält, und diesen Parameter auf `true`festlegen.</span><span class="sxs-lookup"><span data-stu-id="1955e-167">For security reasons, you should enable error detection by calling a constructor that includes a `throwOnInvalidBytes` parameter and setting that parameter to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1955e-168">Im folgenden Beispiel wird eine neue <xref:System.Text.UTF8Encoding> Instanz erstellt, die angibt, dass die <xref:System.Text.UTF8Encoding.GetPreamble%2A>-Methode kein Unicode-Byte Reihenfolge-Präfix ausgeben soll, und eine Ausnahme ausgelöst werden soll, wenn eine ungültige Codierung erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-168">The following example creates a new <xref:System.Text.UTF8Encoding> instance, specifying that the <xref:System.Text.UTF8Encoding.GetPreamble%2A> method should not emit a Unicode byte order mark prefix, and an exception should be thrown when an invalid encoding is detected.</span></span> <span data-ttu-id="1955e-169">Das Verhalten dieses Konstruktors wird mit dem Standardkonstruktor <xref:System.Text.UTF8Encoding.%23ctor> verglichen, der keine Ausnahme auslöst, wenn eine ungültige Codierung erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-169">The behavior of this constructor is compared to the default <xref:System.Text.UTF8Encoding.%23ctor> constructor, which does not throw an exception when an invalid encoding is detected.</span></span> <span data-ttu-id="1955e-170">Die beiden <xref:System.Text.UTF8Encoding> Instanzen Codieren ein Zeichen Array, das zwei hohe Ersatz Zeichen (u + D801 und u + D802) in einer Zeile enthält. Dies ist eine ungültige Zeichenfolge. auf ein hohes Ersatz Zeichen sollte immer ein niedriges Ersatz Zeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="1955e-170">The two <xref:System.Text.UTF8Encoding> instances encode a character array that contains two high surrogates (U+D801 and U+D802) in a row, which is an invalid character sequence; a high surrogate should always be followed by a low surrogate.</span></span>  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uTF8Encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="1955e-171">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1955e-171">The object to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="1955e-172">Bestimmt, ob das angegebene Objekt und das aktuelle <see cref="T:System.Text.UTF8Encoding" />-Objekt gleich sind.</span><span class="sxs-lookup"><span data-stu-id="1955e-172">Determines whether the specified object is equal to the current <see cref="T:System.Text.UTF8Encoding" /> object.</span></span></summary>
        <returns><span data-ttu-id="1955e-173"><see langword="true" />, wenn <paramref name="value" /> eine Instanz von <see cref="T:System.Text.UTF8Encoding" /> und mit dem aktuellen Objekt identisch ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-173"><see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.UTF8Encoding" /> and is equal to the current object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-174">Zwei <xref:System.Text.UTF8Encoding> Objekte werden als gleich betrachtet, wenn alle der folgenden Bedingungen zutreffen:</span><span class="sxs-lookup"><span data-stu-id="1955e-174">Two <xref:System.Text.UTF8Encoding> objects are considered equal if all of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="1955e-175">Beide-Objekte stellen die Byte Reihenfolge-Marke oder beides nicht bereit.</span><span class="sxs-lookup"><span data-stu-id="1955e-175">Both objects provide the byte order mark, or both do not.</span></span>  
  
-   <span data-ttu-id="1955e-176">Beide Objekte verwenden denselben EncoderFallback.</span><span class="sxs-lookup"><span data-stu-id="1955e-176">Both objects use the same encoder fallback.</span></span>  
  
-   <span data-ttu-id="1955e-177">Beide Objekte verwenden denselben Decoder-Fallback.</span><span class="sxs-lookup"><span data-stu-id="1955e-177">Both objects use the same decoder fallback.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1955e-178">Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.Equals%2A>-Methode verwendet, um zu testen, ob das aktuelle <xref:System.Text.UTF8Encoding>-Objekt gleich einem anderen <xref:System.Text.UTF8Encoding>-Objekt ist.</span><span class="sxs-lookup"><span data-stu-id="1955e-178">The following example uses the <xref:System.Text.UTF8Encoding.Equals%2A> method to test whether the current <xref:System.Text.UTF8Encoding> object is equal to a different <xref:System.Text.UTF8Encoding> object.</span></span> <span data-ttu-id="1955e-179">Vier <xref:System.Text.UTF8Encoding> Objekte werden erstellt und verglichen, und die Ergebnisse der Vergleiche werden angezeigt.</span><span class="sxs-lookup"><span data-stu-id="1955e-179">Four <xref:System.Text.UTF8Encoding> objects are created and compared and the results of the comparisons are displayed.</span></span>  
  
 [!code-cpp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CPP/equals-object.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CS/equals-object.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/VB/equals-object.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1955e-180">Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen erzeugt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-180">Calculates the number of bytes produced by encoding a set of characters.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="uTF8Encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1955e-181">Der Bereich, der die zu codierenden Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="1955e-181">The span that contains the set of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1955e-182">Berechnet die Anzahl von Bytes, die durch das Codieren des angegebenen Zeichenbereichs erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-182">Calculates the number of bytes produced by encoding the specified character span.</span></span></summary>
        <returns><span data-ttu-id="1955e-183">Die Anzahl von Bytes, die beim Codieren des angegebenen Zeichenbereichs erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-183">The number of bytes produced by encoding the specified character span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-184">Um die genaue Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-184">To calculate the exact size required by <xref:System.Text.UTF8Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1955e-185">Um die maximale Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-185">To calculate the maximum size, you call the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1955e-186">Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-186">The <xref:System.Text.UTF8Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1955e-187">Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-187">With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException> exception.</span></span> <span data-ttu-id="1955e-188">Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-188">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1955e-189">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen.</span><span class="sxs-lookup"><span data-stu-id="1955e-189">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1955e-190">Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Bytefolge, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers, und die Anzahl der Bytes in der Präambel wird nicht in dem Wert widergespiegelt, der von der <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-190">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1955e-191">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-191">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1955e-192">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).</span><span class="sxs-lookup"><span data-stu-id="1955e-192">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="1955e-193">- und -</span><span class="sxs-lookup"><span data-stu-id="1955e-193">-and-</span></span> 
 <span data-ttu-id="1955e-194">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1955e-194"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ chars);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="uTF8Encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1955e-195">Die <see cref="T:System.String" />-Klasse mit den zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-195">The <see cref="T:System.String" /> containing the set of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1955e-196">Berechnet die Anzahl der Bytes, die durch das Codieren der Zeichen in der angegebenen <see cref="T:System.String" />-Klasse erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-196">Calculates the number of bytes produced by encoding the characters in the specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="1955e-197">Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-197">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-198">Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-198">To calculate the exact array size required by <xref:System.Text.UTF8Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1955e-199">Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-199">To calculate the maximum array size, you call the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1955e-200">Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-200">The <xref:System.Text.UTF8Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1955e-201">Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-201">With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException> exception.</span></span> <span data-ttu-id="1955e-202">Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-202">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1955e-203">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen.</span><span class="sxs-lookup"><span data-stu-id="1955e-203">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1955e-204">Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Bytefolge, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers, und die Anzahl der Bytes in der Präambel wird nicht in dem Wert widergespiegelt, der von der <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-204">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1955e-205">Im folgenden Beispiel werden die Methoden <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> und <xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29> aufgerufen, um die maximale und tatsächliche Anzahl von Bytes zu berechnen, die zum Codieren einer Zeichenfolge erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1955e-205">The following example calls the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> and <xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29> methods to calculate the maximum and actual number of bytes required to encode a string.</span></span> <span data-ttu-id="1955e-206">Es zeigt auch die tatsächliche Anzahl von Bytes an, die zum Speichern eines Bytestreams mit einer Byte Reihenfolge-Marke erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="1955e-206">It also displays the actual number of bytes required to store a byte stream with a byte order mark.</span></span>  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1955e-207"><paramref name="chars" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-207"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1955e-208">Die sich ergebende Anzahl von Bytes ist höher als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="1955e-208">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1955e-209">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-209">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1955e-210">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1955e-210">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span> 
<span data-ttu-id="1955e-211">- und -</span><span class="sxs-lookup"><span data-stu-id="1955e-211">-and-</span></span> 
 <span data-ttu-id="1955e-212">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1955e-212"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF8Encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1955e-213">Ein Zeiger auf das erste zu codierende Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-213">A pointer to the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="1955e-214">Die Anzahl der zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-214">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1955e-215">Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen ab dem angegebenen Zeichenzeiger erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-215">Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</span></span></summary>
        <returns><span data-ttu-id="1955e-216">Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-216">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-217">Um die genaue Array Größe zu berechnen, die für die <xref:System.Text.UTF8Encoding.GetBytes%2A> Methode zum Speichern der resultierenden Bytes erforderlich ist, wird die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-217">To calculate the exact array size required by the <xref:System.Text.UTF8Encoding.GetBytes%2A> method to store the resulting bytes, you call the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1955e-218">Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-218">To calculate the maximum array size, you call the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1955e-219">Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-219">The <xref:System.Text.UTF8Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1955e-220">Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-220">With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException> exception.</span></span> <span data-ttu-id="1955e-221">Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-221">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1955e-222">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen.</span><span class="sxs-lookup"><span data-stu-id="1955e-222">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1955e-223">Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Bytefolge, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers, und die Anzahl der Bytes in der Präambel wird nicht in dem Wert widergespiegelt, der von der <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-223">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1955e-224"><paramref name="chars" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-224"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1955e-225"><paramref name="count" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="1955e-225"><paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="1955e-226">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-226">-or-</span></span> 
<span data-ttu-id="1955e-227">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="1955e-227">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1955e-228">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-228">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1955e-229">Es ist ein Fallback aufgetreten (eine ausführliche Erläuterung finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md)).</span><span class="sxs-lookup"><span data-stu-id="1955e-229">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for a complete explanation)</span></span> 
<span data-ttu-id="1955e-230">- und -</span><span class="sxs-lookup"><span data-stu-id="1955e-230">-and-</span></span> 
 <span data-ttu-id="1955e-231">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1955e-231"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="1955e-232">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="1955e-232">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="1955e-233">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-233">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="uTF8Encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1955e-234">Das Zeichenarray, das die zu codierenden Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="1955e-234">The character array containing the set of characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="1955e-235">Der Index des ersten zu codierenden Zeichens.</span><span class="sxs-lookup"><span data-stu-id="1955e-235">The index of the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="1955e-236">Die Anzahl der zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-236">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1955e-237">Berechnet die Anzahl der Bytes, die beim Codieren der Zeichen aus dem angegebenen Zeichenarray erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-237">Calculates the number of bytes produced by encoding a set of characters from the specified character array.</span></span></summary>
        <returns><span data-ttu-id="1955e-238">Die Anzahl der Bytes, die beim Codieren der angegebenen Zeichen erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-238">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-239">Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die Verwendung <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-239">To calculate the exact array size required by <xref:System.Text.UTF8Encoding.GetBytes%2A> to store the resulting bytes, you call the uses <xref:System.Text.UTF8Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1955e-240">Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-240">To calculate the maximum array size, you call the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1955e-241">Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-241">The <xref:System.Text.UTF8Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1955e-242">Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-242">With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException> exception.</span></span> <span data-ttu-id="1955e-243">Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-243">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1955e-244">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen.</span><span class="sxs-lookup"><span data-stu-id="1955e-244">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1955e-245">Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Bytefolge, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers, und die Anzahl der Bytes in der Präambel wird nicht in dem Wert widergespiegelt, der von der <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-245">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1955e-246">Im folgenden Beispiel wird ein Array mit einem lateinischen groß-und Kleinbuchstaben aufgefüllt und die <xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Methode aufgerufen, um die Anzahl von Bytes zu bestimmen, die zum Codieren der Zeichen für Lateinische Kleinbuchstaben benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-246">The following example populates an array with a Latin uppercase and lowercase characters and calls the <xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method to determine the number of bytes needed to encode the Latin lowercase characters.</span></span> <span data-ttu-id="1955e-247">Diese Informationen werden dann zusammen mit der Gesamtanzahl der benötigten Bytes angezeigt, wenn eine Byte Reihenfolge-Markierung hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-247">It then displays this information along with the total number of bytes needed if a byte order mark is added.</span></span> <span data-ttu-id="1955e-248">Diese Zahl wird mit dem Wert verglichen, der von der <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode zurückgegeben wird, die die maximale Anzahl von Bytes angibt, die zum Codieren der lateinischen Kleinbuchstaben erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="1955e-248">It compares this number with the value returned by the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method, which indicates maximum number of bytes needed to encode the Latin lowercase characters.</span></span>  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1955e-249"><paramref name="chars" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-249"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1955e-250"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="1955e-250"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="1955e-251">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-251">-or-</span></span> 
 <span data-ttu-id="1955e-252"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="chars" />an.</span><span class="sxs-lookup"><span data-stu-id="1955e-252"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</span></span>  
  
<span data-ttu-id="1955e-253">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-253">-or-</span></span> 
<span data-ttu-id="1955e-254">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="1955e-254">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1955e-255">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-255">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1955e-256">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1955e-256">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span> 
<span data-ttu-id="1955e-257">- und -</span><span class="sxs-lookup"><span data-stu-id="1955e-257">-and-</span></span> 
<span data-ttu-id="1955e-258">Die <see cref="P:System.Text.Encoding.EncoderFallback" />-Eigenschaft ist auf <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1955e-258">The <see cref="P:System.Text.Encoding.EncoderFallback" /> property is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1955e-259">Codiert Zeichen in eine Bytefolge.</span><span class="sxs-lookup"><span data-stu-id="1955e-259">Encodes a set of characters into a sequence of bytes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string -&gt; byte[]" Usage="uTF8Encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="1955e-260">Die Zeichenfolge, die codiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="1955e-260">The character string to encode.</span></span></param>
        <summary><span data-ttu-id="1955e-261">Codiert die Zeichen in einem angegebenen <see cref="T:System.String" />-Objekt in eine Bytesequenz.</span><span class="sxs-lookup"><span data-stu-id="1955e-261">Encodes the characters in a specified <see cref="T:System.String" /> object into a sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="1955e-262">Ein Bytearray, das die codierten Zeichen in der vom s-Parameter angegebenen Zeichenfolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1955e-262">A byte array that contains the encoded characters in the string specified by the s parameter.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="uTF8Encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1955e-263">Der zu codierende Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="1955e-263">The character span to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="1955e-264">Der Bereich, der die sich ergebenden Bytes enthält.</span><span class="sxs-lookup"><span data-stu-id="1955e-264">The span to contain the resulting set of bytes.</span></span></param>
        <summary><span data-ttu-id="1955e-265">Codiert den angegebenen Zeichenbereich in den angegebenen Bytebereich.</span><span class="sxs-lookup"><span data-stu-id="1955e-265">Encodes the specified character span into the specified byte span.</span></span></summary>
        <returns><span data-ttu-id="1955e-266">Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-266">The actual number of bytes written into <paramref name="bytes" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-267">Um die genaue Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-267">To calculate the exact size required by <xref:System.Text.UTF8Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1955e-268">Um die maximale Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-268">To calculate the maximum size, you call the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1955e-269">Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-269">The <xref:System.Text.UTF8Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1955e-270">Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-270">With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException> exception.</span></span> <span data-ttu-id="1955e-271">Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-271">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1955e-272">Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar.</span><span class="sxs-lookup"><span data-stu-id="1955e-272">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="1955e-273">In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> zurückgegebenes der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.</span><span class="sxs-lookup"><span data-stu-id="1955e-273">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> returned by the <xref:System.Text.UTF8Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF8Encoding.GetEncoder%2A> method, respectively.</span></span>  
  
 <span data-ttu-id="1955e-274">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen.</span><span class="sxs-lookup"><span data-stu-id="1955e-274">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1955e-275">Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Folge von Bytes, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers.</span><span class="sxs-lookup"><span data-stu-id="1955e-275">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</span></span> <span data-ttu-id="1955e-276">Die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode stellt dem Anfang einer Sequenz codierter Bytes keine Präambel voran.</span><span class="sxs-lookup"><span data-stu-id="1955e-276">The <xref:System.Text.UTF8Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF8Encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1955e-277">Ein Zeiger auf das erste zu codierende Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-277">A pointer to the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="1955e-278">Die Anzahl der zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-278">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="1955e-279">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1955e-279">A pointer to the location at which to start writing the resulting sequence of bytes.</span></span></param>
        <param name="byteCount"><span data-ttu-id="1955e-280">Die maximale Anzahl der zu schreibenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1955e-280">The maximum number of bytes to write.</span></span></param>
        <summary><span data-ttu-id="1955e-281">Codiert Zeichen beginnend am angegebenen Zeichenzeiger in eine Bytefolge, die beginnend am angegebenen Bytezeiger gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-281">Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</span></span></summary>
        <returns><span data-ttu-id="1955e-282">Die durch <paramref name="bytes" /> angegebene tatsächliche Anzahl von Bytes, die am Speicherort geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="1955e-282">The actual number of bytes written at the location indicated by <paramref name="bytes" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-283">Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-283">To calculate the exact array size required by <xref:System.Text.UTF8Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1955e-284">Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-284">To calculate the maximum array size, you call the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1955e-285">Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-285">The <xref:System.Text.UTF8Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1955e-286">Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-286">With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException> exception.</span></span> <span data-ttu-id="1955e-287">Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-287">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1955e-288">Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar.</span><span class="sxs-lookup"><span data-stu-id="1955e-288">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="1955e-289">In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> zurückgegebenes der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.</span><span class="sxs-lookup"><span data-stu-id="1955e-289">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> returned by the <xref:System.Text.UTF8Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF8Encoding.GetEncoder%2A> method, respectively.</span></span>  
  
 <span data-ttu-id="1955e-290">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen.</span><span class="sxs-lookup"><span data-stu-id="1955e-290">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1955e-291">Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Folge von Bytes, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers.</span><span class="sxs-lookup"><span data-stu-id="1955e-291">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</span></span> <span data-ttu-id="1955e-292">Die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode stellt dem Anfang einer Sequenz codierter Bytes keine Präambel voran.</span><span class="sxs-lookup"><span data-stu-id="1955e-292">The <xref:System.Text.UTF8Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1955e-293"><paramref name="chars" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-293"><paramref name="chars" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1955e-294">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-294">-or-</span></span> 
 <span data-ttu-id="1955e-295"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-295"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1955e-296"><paramref name="charCount" /> oder <paramref name="byteCount" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="1955e-296"><paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1955e-297">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-297">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</span></span>  
  
<span data-ttu-id="1955e-298">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-298">-or-</span></span> 
 <span data-ttu-id="1955e-299"><paramref name="byteCount" /> ist niedriger als die sich ergebende Anzahl von Bytes.</span><span class="sxs-lookup"><span data-stu-id="1955e-299"><paramref name="byteCount" /> is less than the resulting number of bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1955e-300">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1955e-300">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span> 
<span data-ttu-id="1955e-301">- und -</span><span class="sxs-lookup"><span data-stu-id="1955e-301">-and-</span></span> 
 <span data-ttu-id="1955e-302">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1955e-302"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="1955e-303">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="1955e-303">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="1955e-304">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-304">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="uTF8Encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="1955e-305">Das Zeichenarray, das die zu codierenden Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="1955e-305">The character array containing the set of characters to encode.</span></span></param>
        <param name="charIndex"><span data-ttu-id="1955e-306">Der Index des ersten zu codierenden Zeichens.</span><span class="sxs-lookup"><span data-stu-id="1955e-306">The index of the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="1955e-307">Die Anzahl der zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-307">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="1955e-308">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="1955e-308">The byte array to contain the resulting sequence of bytes.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="1955e-309">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1955e-309">The index at which to start writing the resulting sequence of bytes.</span></span></param>
        <summary><span data-ttu-id="1955e-310">Codiert Zeichen aus dem angegebenen Zeichenarray in das angegebene Bytearray.</span><span class="sxs-lookup"><span data-stu-id="1955e-310">Encodes a set of characters from the specified character array into the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="1955e-311">Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-311">The actual number of bytes written into <paramref name="bytes" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-312">Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-312">To calculate the exact array size required by <xref:System.Text.UTF8Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1955e-313">Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-313">To calculate the maximum array size, you call the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1955e-314">Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-314">The <xref:System.Text.UTF8Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1955e-315">Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-315">With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException> exception.</span></span> <span data-ttu-id="1955e-316">Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-316">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1955e-317">Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar.</span><span class="sxs-lookup"><span data-stu-id="1955e-317">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="1955e-318">In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.</span><span class="sxs-lookup"><span data-stu-id="1955e-318">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF8Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF8Encoding.GetEncoder%2A> method, respectively.</span></span>  
  
 <span data-ttu-id="1955e-319">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen.</span><span class="sxs-lookup"><span data-stu-id="1955e-319">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1955e-320">Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Folge von Bytes, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers.</span><span class="sxs-lookup"><span data-stu-id="1955e-320">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</span></span> <span data-ttu-id="1955e-321">Die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode stellt dem Anfang einer Sequenz codierter Bytes keine Präambel voran.</span><span class="sxs-lookup"><span data-stu-id="1955e-321">The <xref:System.Text.UTF8Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1955e-322">Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode verwendet, um einen Bereich von Zeichen aus einer Zeichenfolge zu codieren und die codierten Bytes in einem Bereich von Elementen in einem Bytearray zu speichern.</span><span class="sxs-lookup"><span data-stu-id="1955e-322">The following example uses the <xref:System.Text.UTF8Encoding.GetBytes%2A> method to encode a range of characters from a string and stores the encoded bytes in a range of elements in a byte array.</span></span>  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1955e-323"><paramref name="chars" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-323"><paramref name="chars" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1955e-324">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-324">-or-</span></span> 
 <span data-ttu-id="1955e-325"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-325"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1955e-326"><paramref name="charIndex" />, <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="1955e-326"><paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span></span>  
  
<span data-ttu-id="1955e-327">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-327">-or-</span></span> 
 <span data-ttu-id="1955e-328"><paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" />an.</span><span class="sxs-lookup"><span data-stu-id="1955e-328"><paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span></span>  
  
<span data-ttu-id="1955e-329">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-329">-or-</span></span> 
 <span data-ttu-id="1955e-330"><paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-330"><paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1955e-331">Die Fehlererkennung ist aktiviert, und <paramref name="chars" /> enthält eine ungültige Folge von Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-331">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</span></span>  
  
<span data-ttu-id="1955e-332">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-332">-or-</span></span> 
 <span data-ttu-id="1955e-333"><paramref name="bytes" /> hat von <paramref name="byteIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</span><span class="sxs-lookup"><span data-stu-id="1955e-333"><paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1955e-334">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1955e-334">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span> 
<span data-ttu-id="1955e-335">- und -</span><span class="sxs-lookup"><span data-stu-id="1955e-335">-and-</span></span> 
 <span data-ttu-id="1955e-336">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1955e-336"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="uTF8Encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="1955e-337">Die <see cref="T:System.String" />-Klasse mit den zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-337">The <see cref="T:System.String" /> containing the set of characters to encode.</span></span></param>
        <param name="charIndex"><span data-ttu-id="1955e-338">Der Index des ersten zu codierenden Zeichens.</span><span class="sxs-lookup"><span data-stu-id="1955e-338">The index of the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="1955e-339">Die Anzahl der zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-339">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="1955e-340">Das Bytearray, das die sich ergebende Bytefolge enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="1955e-340">The byte array to contain the resulting sequence of bytes.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="1955e-341">Der Index, an dem mit dem Schreiben der sich ergebenden Bytefolge begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1955e-341">The index at which to start writing the resulting sequence of bytes.</span></span></param>
        <summary><span data-ttu-id="1955e-342">Codiert Zeichen aus der angegebenen <see cref="T:System.String" />-Klasse in das angegebene Bytearray.</span><span class="sxs-lookup"><span data-stu-id="1955e-342">Encodes a set of characters from the specified <see cref="T:System.String" /> into the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="1955e-343">Die tatsächliche Anzahl der Bytes, die in <paramref name="bytes" /> geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-343">The actual number of bytes written into <paramref name="bytes" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-344">Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-344">To calculate the exact array size required by <xref:System.Text.UTF8Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1955e-345">Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-345">To calculate the maximum array size, you call the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1955e-346">Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-346">The <xref:System.Text.UTF8Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1955e-347">Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-347">With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException> exception.</span></span> <span data-ttu-id="1955e-348">Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-348">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1955e-349">Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar.</span><span class="sxs-lookup"><span data-stu-id="1955e-349">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="1955e-350">In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.</span><span class="sxs-lookup"><span data-stu-id="1955e-350">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF8Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF8Encoding.GetEncoder%2A> method, respectively.</span></span>  
  
 <span data-ttu-id="1955e-351">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen.</span><span class="sxs-lookup"><span data-stu-id="1955e-351">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1955e-352">Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Folge von Bytes, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers.</span><span class="sxs-lookup"><span data-stu-id="1955e-352">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</span></span> <span data-ttu-id="1955e-353">Die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode stellt dem Anfang einer Sequenz codierter Bytes keine Präambel voran.</span><span class="sxs-lookup"><span data-stu-id="1955e-353">The <xref:System.Text.UTF8Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1955e-354">Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode verwendet, um einen Bereich von Elementen aus einem Array von Unicode-Zeichen zu codieren und die codierten Bytes in einem Bereich von Elementen in einem Bytearray zu speichern.</span><span class="sxs-lookup"><span data-stu-id="1955e-354">The following example uses the <xref:System.Text.UTF8Encoding.GetBytes%2A> method to encode a range of elements from a Unicode character array and store the encoded bytes in a range of elements in a byte array.</span></span>  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1955e-355"><paramref name="s" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-355"><paramref name="s" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1955e-356">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-356">-or-</span></span> 
 <span data-ttu-id="1955e-357"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-357"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1955e-358"><paramref name="charIndex" />, <paramref name="charCount" /> oder <paramref name="byteIndex" /> ist kleiner als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="1955e-358"><paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span></span>  
  
<span data-ttu-id="1955e-359">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-359">-or-</span></span> 
 <span data-ttu-id="1955e-360"><paramref name="charIndex" /> und <paramref name="charCount" /> geben keinen gültigen Bereich in <paramref name="chars" />an.</span><span class="sxs-lookup"><span data-stu-id="1955e-360"><paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span></span>  
  
<span data-ttu-id="1955e-361">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-361">-or-</span></span> 
 <span data-ttu-id="1955e-362"><paramref name="byteIndex" /> ist kein gültiger Index in <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-362"><paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1955e-363">Die Fehlererkennung ist aktiviert, und <paramref name="s" /> enthält eine ungültige Folge von Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-363">Error detection is enabled, and <paramref name="s" /> contains an invalid sequence of characters.</span></span>  
  
<span data-ttu-id="1955e-364">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-364">-or-</span></span> 
 <span data-ttu-id="1955e-365"><paramref name="bytes" /> hat von <paramref name="byteIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Bytes aufzunehmen.</span><span class="sxs-lookup"><span data-stu-id="1955e-365"><paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1955e-366">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1955e-366">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span> 
<span data-ttu-id="1955e-367">- und -</span><span class="sxs-lookup"><span data-stu-id="1955e-367">-and-</span></span> 
 <span data-ttu-id="1955e-368">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1955e-368"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1955e-369">Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-369">Calculates the number of characters produced by decoding a sequence of bytes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="uTF8Encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1955e-370">Der Bereich, der die zu decodierenden Bytes enthält.</span><span class="sxs-lookup"><span data-stu-id="1955e-370">The span containing the set of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1955e-371">Berechnet die Anzahl von Zeichen, die beim Decodieren des angegebenen Bytebereichs erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-371">Calculates the number of characters produced by decoding the specified byte span.</span></span></summary>
        <returns><span data-ttu-id="1955e-372">Die Anzahl von Zeichen, die beim Decodieren des angegebenen Bytebereichs erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-372">The number of characters produced by decoding the specified byte span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-373">Um die genaue Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, können Sie die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-373">To calculate the exact size required by <xref:System.Text.UTF8Encoding.GetChars%2A> to store the resulting characters, call the <xref:System.Text.UTF8Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1955e-374">Um die maximale Größe zu berechnen, müssen Sie die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-374">To calculate the maximum size, call the <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1955e-375">Die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-375">The <xref:System.Text.UTF8Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1955e-376">Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-376">With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException> exception.</span></span> <span data-ttu-id="1955e-377">Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-377">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF8Encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1955e-378">Ein Zeiger auf das erste zu decodierende Byte.</span><span class="sxs-lookup"><span data-stu-id="1955e-378">A pointer to the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="1955e-379">Die Anzahl der zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1955e-379">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1955e-380">Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge ab dem angegebenen Bytezeiger erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-380">Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</span></span></summary>
        <returns><span data-ttu-id="1955e-381">Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-381">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-382">Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, müssen Sie die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-382">To calculate the exact array size required by <xref:System.Text.UTF8Encoding.GetChars%2A> to store the resulting characters, call the <xref:System.Text.UTF8Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1955e-383">Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-383">To calculate the maximum array size, call the <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1955e-384">Die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-384">The <xref:System.Text.UTF8Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1955e-385">Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-385">With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException> exception.</span></span> <span data-ttu-id="1955e-386">Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-386">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1955e-387"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-387"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1955e-388"><paramref name="count" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="1955e-388"><paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="1955e-389">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-389">-or-</span></span> 
<span data-ttu-id="1955e-390">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="1955e-390">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1955e-391">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.</span><span class="sxs-lookup"><span data-stu-id="1955e-391">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1955e-392">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1955e-392">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span> 
<span data-ttu-id="1955e-393">- und -</span><span class="sxs-lookup"><span data-stu-id="1955e-393">-and-</span></span> 
 <span data-ttu-id="1955e-394">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1955e-394"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="1955e-395">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="1955e-395">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="1955e-396">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-396">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="uTF8Encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1955e-397">Das Bytearray, das die zu decodierende Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1955e-397">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="1955e-398">Der Index des ersten zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1955e-398">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="1955e-399">Die Anzahl der zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1955e-399">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1955e-400">Berechnet die Anzahl der Zeichen, die beim Decodieren einer Bytefolge aus dem angegebenen Bytearray erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-400">Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="1955e-401">Die Anzahl der Zeichen, die beim Decodieren der angegebenen Bytefolge erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-401">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-402">Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, müssen Sie die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-402">To calculate the exact array size required by <xref:System.Text.UTF8Encoding.GetChars%2A> to store the resulting characters, call the <xref:System.Text.UTF8Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1955e-403">Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-403">To calculate the maximum array size, call the <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1955e-404">Die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-404">The <xref:System.Text.UTF8Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1955e-405">Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-405">With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException> exception.</span></span> <span data-ttu-id="1955e-406">Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-406">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1955e-407">Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode verwendet, um die Anzahl der Zeichen zurückzugeben, die beim Decodieren eines Bereichs von Elementen in einem Bytearray erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-407">The following example uses the <xref:System.Text.UTF8Encoding.GetCharCount%2A> method to return the number of characters produced by decoding a range of elements in a byte array.</span></span>  
  
 [!code-cpp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1955e-408"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-408"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1955e-409"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="1955e-409"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="1955e-410">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-410">-or-</span></span> 
 <span data-ttu-id="1955e-411"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" />an.</span><span class="sxs-lookup"><span data-stu-id="1955e-411"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span>  
  
<span data-ttu-id="1955e-412">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-412">-or-</span></span> 
<span data-ttu-id="1955e-413">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="1955e-413">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1955e-414">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.</span><span class="sxs-lookup"><span data-stu-id="1955e-414">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1955e-415">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1955e-415">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span> 
<span data-ttu-id="1955e-416">- und -</span><span class="sxs-lookup"><span data-stu-id="1955e-416">-and-</span></span> 
 <span data-ttu-id="1955e-417">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1955e-417"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1955e-418">Decodiert eine Bytefolge in Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-418">Decodes a sequence of bytes into a set of characters.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="uTF8Encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1955e-419">Der Bereich, der die zu decodierenden Bytes enthält.</span><span class="sxs-lookup"><span data-stu-id="1955e-419">The span containing the bytes to decode.</span></span></param>
        <param name="chars"><span data-ttu-id="1955e-420">Der Bereich, der die sich ergebenden Zeichen enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="1955e-420">The span to contain the resulting set of characters.</span></span></param>
        <summary><span data-ttu-id="1955e-421">Decodiert den angegebenen Bytebereich in den angegebenen Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="1955e-421">Decodes the specified byte span into the specified character span.</span></span></summary>
        <returns><span data-ttu-id="1955e-422">Die tatsächliche Anzahl der Zeichen, die in <paramref name="chars" /> geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-422">The actual number of characters written into <paramref name="chars" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-423">Um die genaue Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, können Sie die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-423">To calculate the exact size required by <xref:System.Text.UTF8Encoding.GetChars%2A> to store the resulting characters, call the <xref:System.Text.UTF8Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1955e-424">Um die maximale Größe zu berechnen, müssen Sie die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-424">To calculate the maximum size, call the <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1955e-425">Die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-425">The <xref:System.Text.UTF8Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1955e-426">Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-426">With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException> exception.</span></span> <span data-ttu-id="1955e-427">Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-427">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1955e-428">Wenn der zu decodende Satz von Bytes die Byte Reihenfolge-Marke (Byte Order Mark, BOM) einschließt und der Byte Abschnitt von einer Methode eines nicht-BOM-fähigen Typs zurückgegeben wurde, ist das Zeichen `U+FFFE` in der von dieser Methode zurückgegebenen Zeichen Spanne enthalten.</span><span class="sxs-lookup"><span data-stu-id="1955e-428">If the set of bytes to be decoded includes the byte order mark (BOM) and the span of bytes was returned by a method of a non-BOM aware type, the character `U+FFFE` is included in the span of characters returned by this method.</span></span> <span data-ttu-id="1955e-429">Sie können es entfernen, indem Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-429">You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="1955e-430">Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar.</span><span class="sxs-lookup"><span data-stu-id="1955e-430">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="1955e-431">Und in diesem Fall, wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> Objekt bereitgestellt werden, indem Sie die <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.</span><span class="sxs-lookup"><span data-stu-id="1955e-431">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.UTF8Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF8Encoding.GetEncoder%2A> method, respectively.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF8Encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1955e-432">Ein Zeiger auf das erste zu decodierende Byte.</span><span class="sxs-lookup"><span data-stu-id="1955e-432">A pointer to the first byte to decode.</span></span></param>
        <param name="byteCount"><span data-ttu-id="1955e-433">Die Anzahl der zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1955e-433">The number of bytes to decode.</span></span></param>
        <param name="chars"><span data-ttu-id="1955e-434">Ein Zeiger auf die Position, an der mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1955e-434">A pointer to the location at which to start writing the resulting set of characters.</span></span></param>
        <param name="charCount"><span data-ttu-id="1955e-435">Die maximale Anzahl der zu schreibenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-435">The maximum number of characters to write.</span></span></param>
        <summary><span data-ttu-id="1955e-436">Decodiert eine Bytefolge beginnend am angegebenen Bytezeiger in Zeichen, die beginnend am angegebenen Zeichenzeiger gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-436">Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</span></span></summary>
        <returns><span data-ttu-id="1955e-437">Die durch <paramref name="chars" /> angegebene tatsächliche Anzahl der Zeichen, die am Speicherort geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="1955e-437">The actual number of characters written at the location indicated by <paramref name="chars" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-438">Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, müssen Sie die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-438">To calculate the exact array size required by <xref:System.Text.UTF8Encoding.GetChars%2A> to store the resulting characters, call the <xref:System.Text.UTF8Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1955e-439">Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-439">To calculate the maximum array size, call the <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1955e-440">Die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-440">The <xref:System.Text.UTF8Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1955e-441">Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-441">With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException> exception.</span></span> <span data-ttu-id="1955e-442">Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-442">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1955e-443">Wenn der zu decodierte Byte Bereich die Byte Reihenfolge-Marke (Byte Order Mark, BOM) einschließt und das Bytearray von einer Methode eines nicht-BOM-fähigen Typs zurückgegeben wurde, ist das Zeichen U + FFFE in dem von dieser Methode zurückgegebenen Zeichen Array enthalten.</span><span class="sxs-lookup"><span data-stu-id="1955e-443">If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</span></span> <span data-ttu-id="1955e-444">Sie können es entfernen, indem Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-444">You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="1955e-445">Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar.</span><span class="sxs-lookup"><span data-stu-id="1955e-445">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="1955e-446">Und in diesem Fall, wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> Objekt bereitgestellt werden, indem Sie die <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.</span><span class="sxs-lookup"><span data-stu-id="1955e-446">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.UTF8Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF8Encoding.GetEncoder%2A> method, respectively.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1955e-447"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-447"><paramref name="bytes" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1955e-448">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-448">-or-</span></span> 
 <span data-ttu-id="1955e-449"><paramref name="chars" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-449"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1955e-450"><paramref name="byteCount" /> oder <paramref name="charCount" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="1955e-450"><paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1955e-451">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.</span><span class="sxs-lookup"><span data-stu-id="1955e-451">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span></span>  
  
<span data-ttu-id="1955e-452">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-452">-or-</span></span> 
 <span data-ttu-id="1955e-453"><paramref name="charCount" /> ist niedriger als die sich ergebende Anzahl von Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-453"><paramref name="charCount" /> is less than the resulting number of characters.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1955e-454">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1955e-454">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span> 
<span data-ttu-id="1955e-455">- und -</span><span class="sxs-lookup"><span data-stu-id="1955e-455">-and-</span></span> 
 <span data-ttu-id="1955e-456">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1955e-456"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="1955e-457">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="1955e-457">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="1955e-458">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-458">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="uTF8Encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1955e-459">Das Bytearray, das die zu decodierende Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1955e-459">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="1955e-460">Der Index des ersten zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1955e-460">The index of the first byte to decode.</span></span></param>
        <param name="byteCount"><span data-ttu-id="1955e-461">Die Anzahl der zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1955e-461">The number of bytes to decode.</span></span></param>
        <param name="chars"><span data-ttu-id="1955e-462">Das Zeichenarray, das die sich ergebenden Zeichen enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="1955e-462">The character array to contain the resulting set of characters.</span></span></param>
        <param name="charIndex"><span data-ttu-id="1955e-463">Der Index, an dem mit dem Schreiben der sich ergebenden Zeichen begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1955e-463">The index at which to start writing the resulting set of characters.</span></span></param>
        <summary><span data-ttu-id="1955e-464">Decodiert eine Bytefolge aus dem angegebenen Bytearray in das angegebene Zeichenarray.</span><span class="sxs-lookup"><span data-stu-id="1955e-464">Decodes a sequence of bytes from the specified byte array into the specified character array.</span></span></summary>
        <returns><span data-ttu-id="1955e-465">Die tatsächliche Anzahl der Zeichen, die in <paramref name="chars" /> geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-465">The actual number of characters written into <paramref name="chars" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-466">Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, müssen Sie die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-466">To calculate the exact array size required by <xref:System.Text.UTF8Encoding.GetChars%2A> to store the resulting characters, call the <xref:System.Text.UTF8Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1955e-467">Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-467">To calculate the maximum array size, call the <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1955e-468">Die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-468">The <xref:System.Text.UTF8Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1955e-469">Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-469">With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException> exception.</span></span> <span data-ttu-id="1955e-470">Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-470">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1955e-471">Wenn der zu decodierte Byte Bereich die Byte Reihenfolge-Marke (Byte Order Mark, BOM) einschließt und das Bytearray von einer Methode eines nicht-BOM-fähigen Typs zurückgegeben wurde, ist das Zeichen U + FFFE in dem von dieser Methode zurückgegebenen Zeichen Array enthalten.</span><span class="sxs-lookup"><span data-stu-id="1955e-471">If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</span></span> <span data-ttu-id="1955e-472">Sie können es entfernen, indem Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-472">You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="1955e-473">Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar.</span><span class="sxs-lookup"><span data-stu-id="1955e-473">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="1955e-474">In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.</span><span class="sxs-lookup"><span data-stu-id="1955e-474">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF8Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF8Encoding.GetEncoder%2A> method, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1955e-475">Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetChars%2A>-Methode verwendet, um einen Bereich von Elementen in einem Bytearray zu decodieren und das Ergebnis in einem Zeichen Array zu speichern.</span><span class="sxs-lookup"><span data-stu-id="1955e-475">The following example uses the <xref:System.Text.UTF8Encoding.GetChars%2A> method to decode a range of elements in a byte array and store the result in a character array.</span></span>  
  
 [!code-cpp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1955e-476"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-476"><paramref name="bytes" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1955e-477">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-477">-or-</span></span> 
 <span data-ttu-id="1955e-478"><paramref name="chars" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-478"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1955e-479"><paramref name="byteIndex" />, <paramref name="byteCount" /> oder <paramref name="charIndex" /> ist kleiner als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="1955e-479"><paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.</span></span>  
  
<span data-ttu-id="1955e-480">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-480">-or-</span></span> 
 <span data-ttu-id="1955e-481"><paramref name="byteindex" /> und <paramref name="byteCount" /> geben keinen gültigen Bereich in <paramref name="bytes" />an.</span><span class="sxs-lookup"><span data-stu-id="1955e-481"><paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.</span></span>  
  
<span data-ttu-id="1955e-482">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-482">-or-</span></span> 
 <span data-ttu-id="1955e-483"><paramref name="charIndex" /> ist kein gültiger Index in <paramref name="chars" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-483"><paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1955e-484">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.</span><span class="sxs-lookup"><span data-stu-id="1955e-484">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span></span>  
  
<span data-ttu-id="1955e-485">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-485">-or-</span></span> 
 <span data-ttu-id="1955e-486"><paramref name="chars" /> hat von <paramref name="charIndex" /> bis zum Ende des Arrays nicht genügend Kapazität, um die sich ergebenden Zeichen aufzunehmen.</span><span class="sxs-lookup"><span data-stu-id="1955e-486"><paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1955e-487">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1955e-487">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span> 
<span data-ttu-id="1955e-488">- und -</span><span class="sxs-lookup"><span data-stu-id="1955e-488">-and-</span></span> 
 <span data-ttu-id="1955e-489">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1955e-489"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="uTF8Encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1955e-490">Ruft einen Decoder ab, der eine UTF-8-codierte Bytefolge in eine Unicode-Zeichenfolge konvertiert.</span><span class="sxs-lookup"><span data-stu-id="1955e-490">Obtains a decoder that converts a UTF-8 encoded sequence of bytes into a sequence of Unicode characters.</span></span></summary>
        <returns><span data-ttu-id="1955e-491">Ein Decoder, der eine UTF-8-codierte Bytefolge in eine Unicode-Zeichenfolge konvertiert.</span><span class="sxs-lookup"><span data-stu-id="1955e-491">A decoder that converts a UTF-8 encoded sequence of bytes into a sequence of Unicode characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-492">Die <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode konvertiert sequenzielle Blöcke von Bytes in sequenzielle Zeichenblöcke, ähnlich wie bei der <xref:System.Text.UTF8Encoding.GetChars%2A>-Methode dieser Klasse.</span><span class="sxs-lookup"><span data-stu-id="1955e-492">The <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.UTF8Encoding.GetChars%2A> method of this class.</span></span> <span data-ttu-id="1955e-493">Eine <xref:System.Text.Decoder> behält jedoch Zustandsinformationen zwischen Aufrufen bei, damit Byte Sequenzen, die Blöcke spannen, ordnungsgemäß decodiert werden können.</span><span class="sxs-lookup"><span data-stu-id="1955e-493">However, a <xref:System.Text.Decoder> maintains state information between calls so it can correctly decode byte sequences that span blocks.</span></span> <span data-ttu-id="1955e-494">Der <xref:System.Text.Decoder> behält auch nachfolgende Bytes am Ende der Datenblöcke bei und verwendet die nachfolgenden Bytes im nächsten Decodierungs Vorgang.</span><span class="sxs-lookup"><span data-stu-id="1955e-494">The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</span></span> <span data-ttu-id="1955e-495">Aus diesem Grund sind <xref:System.Text.UTF8Encoding.GetDecoder%2A> und <xref:System.Text.UTF8Encoding.GetEncoder%2A> für Netzwerkübertragungs-und Datei Vorgänge nützlich, da diese Vorgänge häufig Datenblöcke anstelle eines gesamten Datenstroms behandeln.</span><span class="sxs-lookup"><span data-stu-id="1955e-495">Therefore, <xref:System.Text.UTF8Encoding.GetDecoder%2A> and <xref:System.Text.UTF8Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>  
  
 <span data-ttu-id="1955e-496">Wenn die Fehlererkennung aktiviert ist, d. h. der `throwOnInvalidCharacters`-Parameter des Konstruktors auf `true`festgelegt ist, wird die Fehlererkennung auch in der <xref:System.Text.Decoder> aktiviert, die von dieser Methode zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-496">If error detection is enabled, that is, the `throwOnInvalidCharacters` parameter of the constructor is set to `true`, error detection is also enabled in the <xref:System.Text.Decoder> returned by this method.</span></span> <span data-ttu-id="1955e-497">Wenn die Fehlererkennung aktiviert ist und eine ungültige Sequenz gefunden wird, ist der Status des Decoders nicht definiert, und die Verarbeitung muss beendet werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-497">If error detection is enabled and an invalid sequence is encountered, the state of the decoder is undefined and processing must stop.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1955e-498">Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetDecoder%2A>-Methode verwendet, um einen UTF-8-Decoder abzurufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-498">The following example uses the <xref:System.Text.UTF8Encoding.GetDecoder%2A> method to obtain a UTF-8 decoder.</span></span> <span data-ttu-id="1955e-499">Der Decoder konvertiert eine Bytefolge in eine Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1955e-499">The decoder converts a sequence of bytes into a sequence of characters.</span></span>  
  
 [!code-cpp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CPP/getdecoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CS/getdecoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/VB/getdecoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1955e-500">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1955e-500">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="uTF8Encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1955e-501">Ruft einen Encoder ab, der eine Unicode-Zeichenfolge in eine UTF-8-codierte Bytefolge konvertiert.</span><span class="sxs-lookup"><span data-stu-id="1955e-501">Obtains an encoder that converts a sequence of Unicode characters into a UTF-8 encoded sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="1955e-502">Ein <see cref="T:System.Text.Encoder" />, der eine Unicode-Zeichenfolge in eine UTF-8-codierte Bytefolge konvertiert.</span><span class="sxs-lookup"><span data-stu-id="1955e-502">A <see cref="T:System.Text.Encoder" /> that converts a sequence of Unicode characters into a UTF-8 encoded sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-503">Die <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode konvertiert sequenzielle Zeichenblöcke in eine Weise, die der <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode ähnelt.</span><span class="sxs-lookup"><span data-stu-id="1955e-503">The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.UTF8Encoding.GetBytes%2A> method.</span></span> <span data-ttu-id="1955e-504">Eine <xref:System.Text.Encoder> verwaltet jedoch Zustandsinformationen zwischen aufrufen, sodass Sie Zeichen folgen, die Blöcke spannen, ordnungsgemäß codieren können.</span><span class="sxs-lookup"><span data-stu-id="1955e-504">However, a <xref:System.Text.Encoder> maintains state information between calls so it can correctly encode character sequences that span blocks.</span></span> <span data-ttu-id="1955e-505">Der <xref:System.Text.Encoder> behält auch nachfolgende Zeichen am Ende der Datenblöcke bei und verwendet die nachfolgenden Zeichen im nächsten Codierungs Vorgang.</span><span class="sxs-lookup"><span data-stu-id="1955e-505">The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</span></span> <span data-ttu-id="1955e-506">Beispielsweise kann ein Datenblock mit einem nicht übereinstimmenden hohen Ersatz Zeichen enden, und das entsprechende niedrige Ersatz Zeichen kann sich im nächsten Datenblock befinden.</span><span class="sxs-lookup"><span data-stu-id="1955e-506">For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</span></span> <span data-ttu-id="1955e-507">Aus diesem Grund sind <xref:System.Text.UTF8Encoding.GetDecoder%2A> und <xref:System.Text.UTF8Encoding.GetEncoder%2A> für Netzwerkübertragungs-und Datei Vorgänge nützlich, da diese Vorgänge häufig Datenblöcke anstelle eines gesamten Datenstroms behandeln.</span><span class="sxs-lookup"><span data-stu-id="1955e-507">Therefore, <xref:System.Text.UTF8Encoding.GetDecoder%2A> and <xref:System.Text.UTF8Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>  
  
 <span data-ttu-id="1955e-508">Wenn die Fehlererkennung aktiviert ist, d. h. der `throwOnInvalidCharacters`-Parameter des Konstruktors auf `true`festgelegt ist, wird die Fehlererkennung auch in der <xref:System.Text.Encoder> aktiviert, die von dieser Methode zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-508">If error detection is enabled, that is, the `throwOnInvalidCharacters` parameter of the constructor is set to `true`, error detection is also enabled in the <xref:System.Text.Encoder> returned by this method.</span></span> <span data-ttu-id="1955e-509">Wenn die Fehlererkennung aktiviert ist und eine ungültige Sequenz gefunden wird, ist der Status des Encoders nicht definiert, und die Verarbeitung muss beendet werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-509">If error detection is enabled and an invalid sequence is encountered, the state of the encoder is undefined and processing must stop.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1955e-510">Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetEncoder%2A>-Methode verwendet, um einen Encoder zum Konvertieren einer Zeichenfolge in eine UTF-8-codierte Bytefolge zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="1955e-510">The following example uses the <xref:System.Text.UTF8Encoding.GetEncoder%2A> method to obtain an encoder to convert a sequence of characters into a UTF-8 encoded sequence of bytes.</span></span>  
  
 [!code-cpp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CPP/getencoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CS/getencoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/VB/getencoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="1955e-511">Grundlegendes zu Codierungen</span><span class="sxs-lookup"><span data-stu-id="1955e-511">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uTF8Encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1955e-512">Gibt den Hashcode für die aktuelle Instanz zurück.</span><span class="sxs-lookup"><span data-stu-id="1955e-512">Returns the hash code for the current instance.</span></span></summary>
        <returns><span data-ttu-id="1955e-513">Der Hashcode für die aktuelle Instanz.</span><span class="sxs-lookup"><span data-stu-id="1955e-513">The hash code for the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1955e-514">Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetHashCode%2A>-Methode verwendet, um einen Hashcode für <xref:System.Text.UTF8Encoding>-Instanzen zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="1955e-514">The following example uses the <xref:System.Text.UTF8Encoding.GetHashCode%2A> method to return a hash code for <xref:System.Text.UTF8Encoding> instances.</span></span> <span data-ttu-id="1955e-515">Beachten Sie, dass der von dieser Methode zurückgegebene Hashcode von dem Konstruktor abhängt, der zum Erstellen des <xref:System.Text.UTF8Encoding> Objekts verwendet wurde.</span><span class="sxs-lookup"><span data-stu-id="1955e-515">Notice that the hash code returned by this method depends on the constructor used to create the <xref:System.Text.UTF8Encoding> object.</span></span>  
  
 [!code-cpp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CPP/gethashcode-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CS/gethashcode-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/VB/gethashcode-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="uTF8Encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount"><span data-ttu-id="1955e-516">Die Anzahl der zu codierenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="1955e-516">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="1955e-517">Berechnet die maximale Anzahl der Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-517">Calculates the maximum number of bytes produced by encoding the specified number of characters.</span></span></summary>
        <returns><span data-ttu-id="1955e-518">Die maximale Anzahl an Bytes, die beim Codieren der angegebenen Anzahl von Zeichen erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-518">The maximum number of bytes produced by encoding the specified number of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-519">Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-519">To calculate the exact array size required by <xref:System.Text.UTF8Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1955e-520">Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-520">To calculate the maximum array size, you call the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1955e-521">Die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-521">The <xref:System.Text.UTF8Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1955e-522"><xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> ist eine Zahl mit dem ungünstigsten Fall, einschließlich des ungünstigsten Falls für den aktuell ausgewählten <xref:System.Text.EncoderFallback>.</span><span class="sxs-lookup"><span data-stu-id="1955e-522"><xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> is a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>.</span></span> <span data-ttu-id="1955e-523">Wenn ein Fall Back mit einer potenziell großen Zeichenfolge ausgewählt wird, können <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> große Werte zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="1955e-523">If a fallback is chosen with a potentially large string, <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> can return large values.</span></span>  
  
 <span data-ttu-id="1955e-524">In den meisten Fällen gibt diese Methode für kleine Zeichen folgen angemessene Zahlen zurück.</span><span class="sxs-lookup"><span data-stu-id="1955e-524">In most cases, this method returns reasonable numbers for small strings.</span></span> <span data-ttu-id="1955e-525">Bei großen Zeichen folgen müssen Sie möglicherweise zwischen der Verwendung sehr großer Puffer und dem Abfangen von Fehlern wählen, wenn ein sinnvoller Puffer überschritten wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-525">For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</span></span> <span data-ttu-id="1955e-526">Möglicherweise möchten Sie auch einen anderen Ansatz mit <xref:System.Text.UTF8Encoding.GetByteCount%2A> oder <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>in Erwägung gezogen.</span><span class="sxs-lookup"><span data-stu-id="1955e-526">You might also want to consider a different approach using <xref:System.Text.UTF8Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1955e-527">Beispielsweise benötigt Text in englischer Sprache und vielen anderen Sprachen oft nur ein UTF-8-Byte, um ein Zeichen darzustellen, aber die von <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> zurückgegebene Zahl muss die Möglichkeit haben, dass die zu konvertierende Zeichenfolge vollständig aus Zeichen besteht, die jeweils vier Bytes benötigen.</span><span class="sxs-lookup"><span data-stu-id="1955e-527">For example, text in English and many other languages often needs only one UTF-8 byte to represent a character, but the number returned by <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> has to allow for the possibility that the string to be converted will consist entirely of characters that each require four bytes.</span></span>  
  
 <span data-ttu-id="1955e-528"><xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> hat keine Beziehung zu <xref:System.Text.UTF8Encoding.GetChars%2A>.</span><span class="sxs-lookup"><span data-stu-id="1955e-528"><xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> has no relation to <xref:System.Text.UTF8Encoding.GetChars%2A>.</span></span> <span data-ttu-id="1955e-529">Wenn Ihre Anwendung eine ähnliche Funktion benötigt, um mit <xref:System.Text.UTF8Encoding.GetChars%2A>zu verwenden, sollte <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-529">If your application needs a similar function to use with <xref:System.Text.UTF8Encoding.GetChars%2A>, it should use <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1955e-530">`GetMaxByteCount(N)` ist nicht notwendigerweise derselbe Wert wie `N* GetMaxByteCount(1)`.</span><span class="sxs-lookup"><span data-stu-id="1955e-530">`GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1955e-531">Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>-Methode verwendet, um die maximale Anzahl von Bytes zurückzugeben, die erforderlich sind, um eine angegebene Anzahl von Zeichen zu codieren.</span><span class="sxs-lookup"><span data-stu-id="1955e-531">The following example uses the <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> method to return the maximum number of bytes required to encode a specified number of characters.</span></span>  
  
 [!code-cpp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1955e-532"><paramref name="charCount" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="1955e-532"><paramref name="charCount" /> is less than zero.</span></span>  
  
<span data-ttu-id="1955e-533">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-533">-or-</span></span> 
<span data-ttu-id="1955e-534">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="1955e-534">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="1955e-535">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1955e-535">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span> 
<span data-ttu-id="1955e-536">- und -</span><span class="sxs-lookup"><span data-stu-id="1955e-536">-and-</span></span> 
 <span data-ttu-id="1955e-537">Für <see cref="P:System.Text.Encoding.EncoderFallback" /> ist <see cref="T:System.Text.EncoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1955e-537"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="uTF8Encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount"><span data-ttu-id="1955e-538">Die Anzahl der zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1955e-538">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1955e-539">Berechnet die maximale Anzahl der Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-539">Calculates the maximum number of characters produced by decoding the specified number of bytes.</span></span></summary>
        <returns><span data-ttu-id="1955e-540">Die maximale Anzahl von Zeichen, die beim Decodieren der angegebenen Anzahl von Bytes erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-540">The maximum number of characters produced by decoding the specified number of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-541">Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF8Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, wird die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-541">To calculate the exact array size required by <xref:System.Text.UTF8Encoding.GetChars%2A> to store the resulting characters, you call the <xref:System.Text.UTF8Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="1955e-542">Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-542">To calculate the maximum array size, you call the <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="1955e-543">Die <xref:System.Text.UTF8Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-543">The <xref:System.Text.UTF8Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1955e-544"><xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> ist eine Zahl mit dem ungünstigsten Fall, einschließlich des ungünstigsten Falls für den aktuell ausgewählten <xref:System.Text.DecoderFallback>.</span><span class="sxs-lookup"><span data-stu-id="1955e-544"><xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> is a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>.</span></span> <span data-ttu-id="1955e-545">Wenn ein Fall Back mit einer potenziell großen Zeichenfolge ausgewählt wird, können <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> große Werte zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="1955e-545">If a fallback is chosen with a potentially large string, <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> can return large values.</span></span>  
  
 <span data-ttu-id="1955e-546">In den meisten Fällen gibt diese Methode für kleine Zeichen folgen angemessene Zahlen zurück.</span><span class="sxs-lookup"><span data-stu-id="1955e-546">In most cases, this method returns reasonable numbers for small strings.</span></span> <span data-ttu-id="1955e-547">Bei großen Zeichen folgen müssen Sie möglicherweise zwischen der Verwendung sehr großer Puffer und dem Abfangen von Fehlern wählen, wenn ein sinnvoller Puffer überschritten wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-547">For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</span></span>  <span data-ttu-id="1955e-548">Möglicherweise möchten Sie auch einen anderen Ansatz mit <xref:System.Text.UTF8Encoding.GetCharCount%2A> oder <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>in Erwägung gezogen.</span><span class="sxs-lookup"><span data-stu-id="1955e-548">You might also want to consider a different approach using <xref:System.Text.UTF8Encoding.GetCharCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1955e-549"><xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> hat keine Beziehung zu <xref:System.Text.UTF8Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="1955e-549"><xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> has no relation to <xref:System.Text.UTF8Encoding.GetBytes%2A>.</span></span> <span data-ttu-id="1955e-550">Wenn Ihre Anwendung eine ähnliche Funktion benötigt, um mit <xref:System.Text.UTF8Encoding.GetBytes%2A>zu verwenden, sollte <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-550">If your application needs a similar function to use with <xref:System.Text.UTF8Encoding.GetBytes%2A>, it should use <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1955e-551">`GetMaxCharCount(N)` ist nicht notwendigerweise derselbe Wert wie `N* GetMaxCharCount(1)`.</span><span class="sxs-lookup"><span data-stu-id="1955e-551">`GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1955e-552">Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>-Methode verwendet, um die maximale Anzahl von Zeichen zurückzugeben, die beim Decodieren einer angegebenen Anzahl von Bytes erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="1955e-552">The following example uses the <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> method to return the maximum number of characters produced by decoding a specified number of bytes.</span></span>  
  
 [!code-cpp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1955e-553"><paramref name="byteCount" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="1955e-553"><paramref name="byteCount" /> is less than zero.</span></span>  
  
<span data-ttu-id="1955e-554">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-554">-or-</span></span> 
<span data-ttu-id="1955e-555">Die daraus resultierende Byteanzahl ist größer als die maximale Anzahl, die als ganze Zahl zurückgegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="1955e-555">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1955e-556">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1955e-556">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span> 
<span data-ttu-id="1955e-557">- und -</span><span class="sxs-lookup"><span data-stu-id="1955e-557">-and-</span></span> 
 <span data-ttu-id="1955e-558">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1955e-558"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="uTF8Encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1955e-559">Gibt eine Unicode-Bytereihenfolgemarkierung im UTF-8-Format zurück, wenn das <see cref="T:System.Text.UTF8Encoding" />-Codierungsobjekt dafür konfiguriert ist, eine bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="1955e-559">Returns a Unicode byte order mark encoded in UTF-8 format, if the <see cref="T:System.Text.UTF8Encoding" /> encoding object is configured to supply one.</span></span></summary>
        <returns><span data-ttu-id="1955e-560">Ein Bytearray, das die Unicode-Bytereihenfolgemarkierung enthält, wenn das <see cref="T:System.Text.UTF8Encoding" />-Codierungsobjekt dafür konfiguriert ist, eine bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="1955e-560">A byte array containing the Unicode byte order mark, if the <see cref="T:System.Text.UTF8Encoding" /> encoding object is configured to supply one.</span></span> <span data-ttu-id="1955e-561">Andernfalls gibt diese Methode ein Bytearray mit der Länge Null zurück.</span><span class="sxs-lookup"><span data-stu-id="1955e-561">Otherwise, this method returns a zero-length byte array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-562">Das <xref:System.Text.UTF8Encoding>-Objekt kann eine Präambel bereitstellen, bei der es sich um ein Bytearray handelt, dem die Byte Sequenz vorangestellt werden kann, die sich aus dem Codierungsprozess ergibt.</span><span class="sxs-lookup"><span data-stu-id="1955e-562">The <xref:System.Text.UTF8Encoding> object can provide a preamble, which is a byte array that can be prefixed to the sequence of bytes that result from the encoding process.</span></span> <span data-ttu-id="1955e-563">Wenn eine Sequenz codierter Bytes mit einer Byte Reihenfolge-Markierung (Codepunkt U + FEFF) vorangestellt ist, kann der Decoder die Byte Reihenfolge und das Transformations Format (UTF) bestimmen.</span><span class="sxs-lookup"><span data-stu-id="1955e-563">Prefacing a sequence of encoded bytes with a byte order mark (code point U+FEFF) helps the decoder determine the byte order and the transformation format, or UTF.</span></span> <span data-ttu-id="1955e-564">Die Unicode-Byte Reihenfolge Markierung (BOM) wird als 0xEF 0xBB 0xBF serialisiert.</span><span class="sxs-lookup"><span data-stu-id="1955e-564">The Unicode byte order mark (BOM) is serialized as 0xEF 0xBB 0xBF.</span></span> <span data-ttu-id="1955e-565">Beachten Sie, dass der Unicode-Standard weder erfordert noch die Verwendung einer BOM für UTF-8-codierte Streams empfiehlt.</span><span class="sxs-lookup"><span data-stu-id="1955e-565">Note that the Unicode Standard neither requires nor recommends the use of a BOM for UTF-8 encoded streams.</span></span>  
  
 <span data-ttu-id="1955e-566">Sie können ein <xref:System.Text.UTF8Encoding> Objekt instanziieren, dessen <xref:System.Text.UTF8Encoding.GetPreamble%2A> Methode eine gültige BOM auf folgende Weise zurückgibt:</span><span class="sxs-lookup"><span data-stu-id="1955e-566">You can instantiate a <xref:System.Text.UTF8Encoding> object whose <xref:System.Text.UTF8Encoding.GetPreamble%2A> method returns a valid BOM in the following ways:</span></span>  
  
-   <span data-ttu-id="1955e-567">Durch Abrufen des <xref:System.Text.UTF8Encoding> Objekts, das von der <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-567">By retrieving the <xref:System.Text.UTF8Encoding> object returned by the <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> property.</span></span>  
  
-   <span data-ttu-id="1955e-568">Durch Aufrufen eines <xref:System.Text.UTF8Encoding> Konstruktors mit einem `encoderShouldEmitUTF8Identifier`-Parameter und Festlegen seines Werts auf `true`.</span><span class="sxs-lookup"><span data-stu-id="1955e-568">By calling a <xref:System.Text.UTF8Encoding> constructor with a `encoderShouldEmitUTF8Identifier` parameter and setting its value set to `true`.</span></span>  
  
 <span data-ttu-id="1955e-569">Alle anderen <xref:System.Text.UTF8Encoding> Objekte werden so konfiguriert, dass Sie ein leeres Array anstelle einer gültigen BOM zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="1955e-569">All other <xref:System.Text.UTF8Encoding> objects are configured to return an empty array rather than a valid BOM.</span></span>  
  
 <span data-ttu-id="1955e-570">Die BOM bietet fast eine bestimmte Identifizierung einer Codierung für Dateien, die andernfalls einen Verweis auf ihre Codierung verloren haben, z. b. nicht markierte oder nicht ordnungsgemäß markierte Webdaten oder zufällige Textdateien, die gespeichert wurden, wenn ein Unternehmen nicht über internationale Belange verfügte.</span><span class="sxs-lookup"><span data-stu-id="1955e-570">The BOM provide nearly certain identification of an encoding for files that otherwise have lost a reference to their encoding, such as untagged or improperly tagged web data or random text files stored when a business did not have international concerns.</span></span> <span data-ttu-id="1955e-571">Häufig können Benutzer Probleme vermieden werden, wenn die Daten konsistent und ordnungsgemäß gekennzeichnet sind.</span><span class="sxs-lookup"><span data-stu-id="1955e-571">Often user problems might be avoided if data is consistently and properly tagged.</span></span>  
  
 <span data-ttu-id="1955e-572">Bei Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant.</span><span class="sxs-lookup"><span data-stu-id="1955e-572">For standards that provide an encoding type, a BOM is somewhat redundant.</span></span> <span data-ttu-id="1955e-573">Sie kann jedoch verwendet werden, um einem Server zu helfen, den richtigen Codierungs Header zu senden.</span><span class="sxs-lookup"><span data-stu-id="1955e-573">However, it can be used to help a server send the correct encoding header.</span></span> <span data-ttu-id="1955e-574">Alternativ kann es als Fall Back für den Fall verwendet werden, dass die Codierung andernfalls verloren geht.</span><span class="sxs-lookup"><span data-stu-id="1955e-574">Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</span></span>  
  
 <span data-ttu-id="1955e-575">Es gibt einige Nachteile bei der Verwendung einer BOM.</span><span class="sxs-lookup"><span data-stu-id="1955e-575">There are some disadvantages to using a BOM.</span></span> <span data-ttu-id="1955e-576">Beispielsweise kann das Einschränken der Datenbankfelder, die eine BOM verwenden, schwierig sein.</span><span class="sxs-lookup"><span data-stu-id="1955e-576">For example, knowing how to limit the database fields that use a BOM can be difficult.</span></span> <span data-ttu-id="1955e-577">Die Verkettung von Dateien kann auch ein Problem darstellen, z. b. wenn Dateien so zusammengeführt werden, dass ein unnötiges Zeichen in der Mitte der Daten enden kann.</span><span class="sxs-lookup"><span data-stu-id="1955e-577">Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</span></span> <span data-ttu-id="1955e-578">Trotz der wenigen Nachteile wird die Verwendung einer BOM dringend empfohlen.</span><span class="sxs-lookup"><span data-stu-id="1955e-578">In spite of the few disadvantages, however, the use of a BOM is highly recommended.</span></span>  
  
 <span data-ttu-id="1955e-579">Weitere Informationen zur Byte Reihenfolge und zur Byte Reihenfolge-Markierung finden Sie im Unicode-Standard auf der [Unicode-Homepage](https://go.microsoft.com/fwlink/?LinkId=37123).</span><span class="sxs-lookup"><span data-stu-id="1955e-579">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](https://go.microsoft.com/fwlink/?LinkId=37123).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1955e-580">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie dem Anfang eines Streams codierter Bytes eine Präambel als Präfix voranstellen.</span><span class="sxs-lookup"><span data-stu-id="1955e-580">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix the beginning of a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1955e-581">Beachten Sie, dass die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode einer Sequenz codierter Bytes keine BOM voranstellt. das Bereitstellen einer BOM am Anfang eines entsprechenden Bytestreams ist die Verantwortung des Entwicklers.</span><span class="sxs-lookup"><span data-stu-id="1955e-581">Note that the <xref:System.Text.UTF8Encoding.GetBytes%2A> method does not prepend a BOM to a sequence of encoded bytes; supplying a BOM at the beginning of an appropriate byte stream is the developer's responsibility.</span></span>
  
## Examples  
 <span data-ttu-id="1955e-582">Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetPreamble%2A>-Methode verwendet, um die im UTF-8-Format codierte Unicode-Byte Reihenfolge Markierung zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="1955e-582">The following example uses the <xref:System.Text.UTF8Encoding.GetPreamble%2A> method to return the Unicode byte order mark encoded in UTF-8 format.</span></span> <span data-ttu-id="1955e-583">Beachten Sie, dass der Parameter lose Konstruktor für <xref:System.Text.UTF8Encoding> keine Präambel bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="1955e-583">Notice that the parameterless constructor for <xref:System.Text.UTF8Encoding> does not provide a preamble.</span></span>  
  
 [!code-cpp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 <span data-ttu-id="1955e-584">Im folgenden Beispiel werden zwei <xref:System.Text.UTF8Encoding> Objekte instanziiert, der erste durch Aufrufen des Parameter losen <xref:System.Text.UTF8Encoding.%23ctor> Konstruktors, der keine BOM bereitstellt, und der zweite, indem der <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29>-Konstruktor aufgerufen wird, dessen `encoderShouldEmitUTF8Identifier` Argument auf `true`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="1955e-584">The following example instantiates two <xref:System.Text.UTF8Encoding> objects, the first by calling the parameterless <xref:System.Text.UTF8Encoding.%23ctor> constructor, which does not provide a BOM, and the second by calling the <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29> constructor with its `encoderShouldEmitUTF8Identifier` argument set to `true`.</span></span> <span data-ttu-id="1955e-585">Anschließend wird die <xref:System.Text.UTF8Encoding.GetPreamble%2A>-Methode aufgerufen, um die BOM in eine Datei zu schreiben, bevor eine UF8-codierte Zeichenfolge geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-585">It then calls the <xref:System.Text.UTF8Encoding.GetPreamble%2A> method to write the BOM to a file before writing a UF8-encoded string.</span></span> <span data-ttu-id="1955e-586">Wie die Konsolenausgabe aus dem Beispiel zeigt, hat die Datei, die die Bytes aus dem zweiten Encoder speichert, drei weitere Bytes als die erste.</span><span class="sxs-lookup"><span data-stu-id="1955e-586">As the console output from the example shows, the file that saves the bytes from the second encoder has three more bytes than the first.</span></span>  
  
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/cs/getpreamble1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/vb/getpreamble1.vb#1)]  
  
 <span data-ttu-id="1955e-587">Sie können die Dateien auch mit dem `fc`-Befehl in einem Konsolenfenster vergleichen, oder Sie können die Dateien in einem Text-Editor untersuchen, der einen Hexadezimal Ansichtsmodus enthält.</span><span class="sxs-lookup"><span data-stu-id="1955e-587">You can also compare the files by using the `fc` command in a console window, or you can inspect the files in a text editor that includes a Hex View mode.</span></span> <span data-ttu-id="1955e-588">Beachten Sie, dass die BOM nicht angezeigt wird, wenn die Datei in einem Editor geöffnet wird, der UTF-8 unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1955e-588">Note that when the file is opened in an editor that supports UTF-8, the BOM is not displayed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="uTF8Encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="1955e-589">Das Bytearray, das die zu decodierende Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1955e-589">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="1955e-590">Der Index des ersten zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1955e-590">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="1955e-591">Die Anzahl der zu decodierenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="1955e-591">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="1955e-592">Decodiert einen Bytebereich aus einem Bytearray in eine Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1955e-592">Decodes a range of bytes from a byte array into a string.</span></span></summary>
        <returns><span data-ttu-id="1955e-593">Eine <see cref="T:System.String" />-Klasse, die die Ergebnisse der Decodierung der angegebenen Bytefolge enthält.</span><span class="sxs-lookup"><span data-stu-id="1955e-593">A <see cref="T:System.String" /> containing the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-594">Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException> Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-594">With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException> exception.</span></span> <span data-ttu-id="1955e-595">Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1955e-595">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1955e-596">Wenn der zu decodierte Byte Bereich die Byte Reihenfolge-Marke (Byte Order Mark, BOM) einschließt und das Bytearray von einer Methode eines nicht-BOM-fähigen Typs zurückgegeben wurde, ist das Zeichen U + FFFE in dem von dieser Methode zurückgegebenen Zeichen Array enthalten.</span><span class="sxs-lookup"><span data-stu-id="1955e-596">If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</span></span> <span data-ttu-id="1955e-597">Sie können es entfernen, indem Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-597">You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="1955e-598">Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar.</span><span class="sxs-lookup"><span data-stu-id="1955e-598">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="1955e-599">In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.</span><span class="sxs-lookup"><span data-stu-id="1955e-599">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF8Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF8Encoding.GetEncoder%2A> method, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1955e-600">Im folgenden Beispiel wird ein Array initialisiert, indem die <xref:System.Text.UTF8Encoding.GetByteCount%2A>-Methode aufgerufen wird, um genau zu bestimmen, wie viele Bytes für eine codierte Zeichenfolge erforderlich sind, und dann die Größe der Byte Reihenfolge-Marke (BOM) hinzugefügt</span><span class="sxs-lookup"><span data-stu-id="1955e-600">The following example initializes an array by calling the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method to determine exactly how many bytes are required for an encoded string and then adding the size of the byte order mark (BOM).</span></span> <span data-ttu-id="1955e-601">Im Beispiel wird dann die <xref:System.Text.UTF8Encoding.GetPreamble%2A>-Methode aufgerufen, um die BOM im Array zu speichern, bevor die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode aufgerufen wird, um die codierten Bytes im Array zu speichern.</span><span class="sxs-lookup"><span data-stu-id="1955e-601">The example then calls the <xref:System.Text.UTF8Encoding.GetPreamble%2A> method to store the BOM to the array before calling the <xref:System.Text.UTF8Encoding.GetBytes%2A> method to store the encoded bytes to the array.</span></span> <span data-ttu-id="1955e-602">Im Beispiel wird dann die <xref:System.Text.UTF8Encoding.GetString%2A>-Methode aufgerufen, um die Zeichenfolge zu decodieren.</span><span class="sxs-lookup"><span data-stu-id="1955e-602">The example then calls the <xref:System.Text.UTF8Encoding.GetString%2A> method to decode the string.</span></span>  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 <span data-ttu-id="1955e-603">Beachten Sie, dass die decodierte Zeichenfolge in diesem Fall von der ursprünglichen Zeichenfolge abweicht, da Sie mit einer 16-Bit-Byte Reihenfolge Markierung U + FFFD beginnt.</span><span class="sxs-lookup"><span data-stu-id="1955e-603">Note that in this case the decoded string differs from the original string, since it begins with a 16-bit byte order mark U+FFFD.</span></span> <span data-ttu-id="1955e-604">Dies bedeutet, dass die beiden Zeichen folgen als ungleich verglichen werden und dass, wenn die Zeichenfolge ausgegeben wird, die BOM als Ersatz Zeichen "?" angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-604">This means that the two strings will compare as unequal, and that if the string is output, the BOM will be displayed as the replacement character "?".</span></span> <span data-ttu-id="1955e-605">Um die BOM am Anfang der Zeichenfolge zu entfernen, können Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1955e-605">To remove the BOM at the beginning of the string, you can call the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1955e-606"><paramref name="bytes" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1955e-606"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1955e-607"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="1955e-607"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="1955e-608">- oder -</span><span class="sxs-lookup"><span data-stu-id="1955e-608">-or-</span></span> 
 <span data-ttu-id="1955e-609"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in <paramref name="bytes" /> an.</span><span class="sxs-lookup"><span data-stu-id="1955e-609"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1955e-610">Die Fehlererkennung ist aktiviert, und <paramref name="bytes" /> enthält eine ungültige Folge von Bytes.</span><span class="sxs-lookup"><span data-stu-id="1955e-610">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="1955e-611">Es ist ein Fallback aufgetreten (weitere Informationen finden Sie unter <see href="~/docs/standard/base-types/character-encoding.md">Zeichencodierung in .NET</see>).</span><span class="sxs-lookup"><span data-stu-id="1955e-611">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span> 
<span data-ttu-id="1955e-612">- und -</span><span class="sxs-lookup"><span data-stu-id="1955e-612">-and-</span></span> 
 <span data-ttu-id="1955e-613">Für <see cref="P:System.Text.Encoding.DecoderFallback" /> ist <see cref="T:System.Text.DecoderExceptionFallback" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="1955e-613"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public override ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.UTF8Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.UTF8Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1955e-614">Ruft eine Unicode-Bytereihenfolgemarkierung im UTF-8-Format ab, wenn dieses Objekt entsprechend konfiguriert ist.</span><span class="sxs-lookup"><span data-stu-id="1955e-614">Gets a Unicode byte order mark encoded in UTF-8 format, if this object is configured to supply one.</span></span></summary>
        <value><span data-ttu-id="1955e-615">Eine Byte Spanne, die die Unicode-Byte Reihenfolge Markierung enthält, wenn dieses Objekt für die Bereitstellung eines solchen konfiguriert ist. andernfalls die Standard Spanne.</span><span class="sxs-lookup"><span data-stu-id="1955e-615">A byte span containing the Unicode byte order mark, if this object is configured to supply one; otherwise, the default span.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1955e-616">Das <xref:System.Text.UTF8Encoding>-Objekt kann eine Präambel bereitstellen, bei der es sich um einen Byte Bereich handelt, dem die Byte Sequenz vorangestellt werden kann, die sich aus dem Codierungsprozess ergeben.</span><span class="sxs-lookup"><span data-stu-id="1955e-616">The <xref:System.Text.UTF8Encoding> object can provide a preamble, which is a span of bytes that can be prefixed to the sequence of bytes that result from the encoding process.</span></span> <span data-ttu-id="1955e-617">Wenn eine Sequenz codierter Bytes mit einer Byte Reihenfolge-Markierung (Codepunkt-`U+FEFF`) vorangestellt ist, kann der Decoder die Byte Reihenfolge und das Transformations Format (UTF) bestimmen.</span><span class="sxs-lookup"><span data-stu-id="1955e-617">Prefacing a sequence of encoded bytes with a byte order mark (code point `U+FEFF`) helps the decoder determine the byte order and the transformation format, or UTF.</span></span> <span data-ttu-id="1955e-618">Die Unicode-Byte Reihenfolge Markierung (BOM) wird als 0xEF 0xBB 0xBF serialisiert.</span><span class="sxs-lookup"><span data-stu-id="1955e-618">The Unicode byte order mark (BOM) is serialized as 0xEF 0xBB 0xBF.</span></span> <span data-ttu-id="1955e-619">Beachten Sie, dass der Unicode-Standard weder erfordert noch die Verwendung einer BOM für UTF-8-codierte Streams empfiehlt.</span><span class="sxs-lookup"><span data-stu-id="1955e-619">Note that the Unicode Standard neither requires nor recommends the use of a BOM for UTF-8 encoded streams.</span></span>  
  
 <span data-ttu-id="1955e-620">Sie können ein <xref:System.Text.UTF8Encoding> Objekt, dessen `Preamble` eine gültige BOM ist, auf folgende Weise instanziieren:</span><span class="sxs-lookup"><span data-stu-id="1955e-620">You can instantiate a <xref:System.Text.UTF8Encoding> object whose `Preamble` is a valid BOM in the following ways:</span></span>  
  
-   <span data-ttu-id="1955e-621">Durch Abrufen des <xref:System.Text.UTF8Encoding> Objekts, das von der <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="1955e-621">By retrieving the <xref:System.Text.UTF8Encoding> object returned by the <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> property.</span></span>  
  
-   <span data-ttu-id="1955e-622">Durch Aufrufen eines <xref:System.Text.UTF8Encoding> Konstruktors mit einem `encoderShouldEmitUTF8Identifier`-Parameter und Festlegen seines Werts auf `true`.</span><span class="sxs-lookup"><span data-stu-id="1955e-622">By calling a <xref:System.Text.UTF8Encoding> constructor with an `encoderShouldEmitUTF8Identifier` parameter and setting its value set to `true`.</span></span>  
  
 <span data-ttu-id="1955e-623">Alle anderen <xref:System.Text.UTF8Encoding> Objekte werden so konfiguriert, dass Sie eine Standard Spanne und keine gültige BOM zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="1955e-623">All other <xref:System.Text.UTF8Encoding> objects are configured to return a default span rather than a valid BOM.</span></span>  
  
 <span data-ttu-id="1955e-624">Die BOM bietet fast eine bestimmte Identifizierung einer Codierung für Dateien, die andernfalls einen Verweis auf ihre Codierung verloren haben, z. b. nicht markierte oder nicht ordnungsgemäß markierte Webdaten oder zufällige Textdateien, die gespeichert wurden, wenn ein Unternehmen nicht über internationale Belange verfügte.</span><span class="sxs-lookup"><span data-stu-id="1955e-624">The BOM provides nearly certain identification of an encoding for files that otherwise have lost a reference to their encoding, such as untagged or improperly tagged web data or random text files stored when a business did not have international concerns.</span></span> <span data-ttu-id="1955e-625">Häufig können Benutzer Probleme vermieden werden, wenn die Daten konsistent und ordnungsgemäß gekennzeichnet sind.</span><span class="sxs-lookup"><span data-stu-id="1955e-625">Often user problems might be avoided if data is consistently and properly tagged.</span></span>  
  
 <span data-ttu-id="1955e-626">Bei Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant.</span><span class="sxs-lookup"><span data-stu-id="1955e-626">For standards that provide an encoding type, a BOM is somewhat redundant.</span></span> <span data-ttu-id="1955e-627">Sie kann jedoch verwendet werden, um einem Server zu helfen, den richtigen Codierungs Header zu senden.</span><span class="sxs-lookup"><span data-stu-id="1955e-627">However, it can be used to help a server send the correct encoding header.</span></span> <span data-ttu-id="1955e-628">Alternativ kann es als Fall Back für den Fall verwendet werden, dass die Codierung andernfalls verloren geht.</span><span class="sxs-lookup"><span data-stu-id="1955e-628">Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</span></span>  
  
 <span data-ttu-id="1955e-629">Es gibt einige Nachteile bei der Verwendung einer BOM.</span><span class="sxs-lookup"><span data-stu-id="1955e-629">There are some disadvantages to using a BOM.</span></span> <span data-ttu-id="1955e-630">Beispielsweise kann das Einschränken der Datenbankfelder, die eine BOM verwenden, schwierig sein.</span><span class="sxs-lookup"><span data-stu-id="1955e-630">For example, knowing how to limit the database fields that use a BOM can be difficult.</span></span> <span data-ttu-id="1955e-631">Die Verkettung von Dateien kann auch ein Problem darstellen, z. b. wenn Dateien so zusammengeführt werden, dass ein unnötiges Zeichen in der Mitte der Daten enden kann.</span><span class="sxs-lookup"><span data-stu-id="1955e-631">Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</span></span> <span data-ttu-id="1955e-632">Trotz der wenigen Nachteile wird die Verwendung einer BOM dringend empfohlen.</span><span class="sxs-lookup"><span data-stu-id="1955e-632">In spite of the few disadvantages, however, the use of a BOM is highly recommended.</span></span>  
  
 <span data-ttu-id="1955e-633">Weitere Informationen zur Byte Reihenfolge und zur Byte Reihenfolge-Markierung finden Sie im Unicode-Standard auf der [Unicode-Homepage](https://go.microsoft.com/fwlink/?LinkId=37123).</span><span class="sxs-lookup"><span data-stu-id="1955e-633">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](https://go.microsoft.com/fwlink/?LinkId=37123).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1955e-634">Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie dem Anfang eines Streams codierter Bytes eine Präambel als Präfix voranstellen.</span><span class="sxs-lookup"><span data-stu-id="1955e-634">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix the beginning of a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1955e-635">Beachten Sie, dass die <xref:System.Text.UTF8Encoding.GetBytes%2A>-Methode einer Sequenz codierter Bytes keine BOM voranstellt. das Bereitstellen einer BOM am Anfang eines entsprechenden Bytestreams ist die Verantwortung des Entwicklers.</span><span class="sxs-lookup"><span data-stu-id="1955e-635">Note that the <xref:System.Text.UTF8Encoding.GetBytes%2A> method does not prepend a BOM to a sequence of encoded bytes; supplying a BOM at the beginning of an appropriate byte stream is the developer's responsibility.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
