<Type Name="UTF8Encoding" FullName="System.Text.UTF8Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a4479fa38164193605c512f6d00f5ce9ca7f726b" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609692" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UTF8Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UTF8Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF8Encoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UTF8Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF8Encoding : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UTF8Encoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a UTF-8 encoding of Unicode characters.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Kodieren werden Unicode-Zeichen in eine Bytefolge transformiert. Beim Decodieren wird transformiert eine codierte Bytefolge in eine Reihe von Unicode-Zeichen.  
  
 UTF-8 ist, dass eine Unicode-Codierung, die jeden-Codepunkt als eine Folge von ein bis vier Bytes darstellt. Im Gegensatz zu den UTF-16 und UTF-32-Codierungen erfordert die UTF-8-Codierung "endiancharakteristik"; keine das Codierungsschema ist unabhängig davon, ob der Prozessor big-Endian oder little-Endian-identisch. <xref:System.Text.UTF8Encoding> die Windows-Codepage 65001 entspricht. Weitere Informationen zu den UTFs und andere Codierungen, die von unterstützt <xref:System.Text>, finden Sie unter [Zeichencodierung in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Instanziieren Sie ein <xref:System.Text.UTF8Encoding> Objekt in eine Reihe von Möglichkeiten, je nachdem, ob Sie darauf eine bytereihenfolgemarkierung (BOM) bereitstellen möchten, und gibt an, ob Sie fehlererkennung aktivieren möchten. Die folgende Tabelle enthält die Konstruktoren und die <xref:System.Text.Encoding> Eigenschaft, die Zurückgeben einer <xref:System.Text.UTF8Encoding> Objekt.  
  
|Member|BYTEREIHENFOLGE-MARKE|Fehlererkennung|  
|------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>|Ja|Keine (Ersatzfallback)|  
|<xref:System.Text.UTF8Encoding.%23ctor?displayProperty=nameWithType>|Nein|Keine (Ersatzfallback)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29?displayProperty=nameWithType>|Konfigurierbare|Keine (Ersatzfallback)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Konfigurierbare|Konfigurierbare|  
  
 Die <xref:System.Text.UTF8Encoding.GetByteCount%2A> -Methode bestimmt, wie viele Bytes in einen Satz von Unicode-Zeichen, Codierung und die <xref:System.Text.UTF8Encoding.GetBytes%2A> Methode führt die eigentliche Codierung.  
  
 Ebenso die <xref:System.Text.UTF8Encoding.GetCharCount%2A> -Methode bestimmt, wie viele Zeichen in eine Folge von Bytes, Decodierung und die <xref:System.Text.UTF8Encoding.GetChars%2A> und <xref:System.Text.UTF8Encoding.GetString%2A> Methoden führen die eigentliche Decodierung.  
  
 Für einen Encoder oder Decoder, der zum Speichern von Zustandsinformationen, die beim Codieren oder Decodieren von Daten, die umfasst mehrere Blöcke (z. B. String von 1 Mio. Zeichen, die in Segmenten von 100.000 Zeichen codiert wird) verwenden, können die <xref:System.Text.UTF8Encoding.GetEncoder%2A> und <xref:System.Text.UTF8Encoding.GetDecoder%2A> Eigenschaften bzw.  
  
 Optional können die <xref:System.Text.UTF8Encoding> -Objekt ermöglicht eine bytereihenfolgemarkierung (BOM), wird ein Array von Bytes, die auf den Anfang des Datenstroms als Präfix verwendet werden können, der aufgrund des Codierungsvorgangs entsteht. Wenn UTF-8 codierte Byte-Stream eine bytereihenfolgemarkierung (BOM) vorangestellt ist, wird den Decoder bestimmt die Bytereihenfolge und die Transformationsformat oder UTF leichter. Beachten Sie jedoch, dass der Unicode-Standard ist weder erforderlich noch empfiehlt eine Bytereihenfolge-Marke in UTF-8 Streams codierte. Weitere Informationen zu Byte-Reihenfolge und die Bytereihenfolge-Marke, finden Sie im Unicode-Standard auf die [Unicode-Homepage](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Wenn der Encoder für die Bereitstellung einer Bytereihenfolge-Marke konfiguriert ist, können Sie es durch Aufrufen von Abrufen der <xref:System.Text.UTF8Encoding.GetPreamble%2A> Methode; andernfalls gibt die Methode ein leeres Array. Beachten Sie, dass selbst wenn eine <xref:System.Text.UTF8Encoding> Objekt konfiguriert ist, für die Bytereihenfolge-Marke unterstützen, müssen Sie die Bytereihenfolge-Marke am Anfang des codierten Datenstroms nach Bedarf; einschließen Codierungsmethoden von der <xref:System.Text.UTF8Encoding> Klasse nicht tun Sie dies automatisch.  
  
> [!NOTE]
>  Um Erkennung zu aktivieren und die Instanz der Klasse sicherer zu machen, rufen Sie die <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> Konstruktor, und legen die `throwOnInvalidBytes` Parameter `true`. Mit der fehlererkennung ist aktiviert, eine Methode, die eine ungültige Folge von Bytes oder Zeichen erkennt, löst eine <xref:System.ArgumentException> Ausnahme. Ohne die fehlererkennung wird keine Ausnahme ausgelöst und die ungültige Sequenz ist in der Regel ignoriert.  
  
> [!NOTE]
>  Der Zustand eines UTF-8 codierte-Objekts wird nicht beibehalten, wenn das Objekt serialisiert wird und deserialisiert mithilfe der verschiedene Versionen von .NET Framework.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Text.UTF8Encoding> Objekt, das eine Zeichenfolge von Unicode-Zeichen zu codieren und speichern sie in einem Bytearray. Die Unicode-Zeichenfolge enthält zwei Zeichen, Pi (U + 03A0) und Sigma (U + 03A3), die außerhalb des ASCII-Zeichenbereichs liegen. Wenn das codierte Bytearray zurück in eine Zeichenfolge decodiert wird, sind die Pi und Sigma-Zeichen weiterhin vorhanden.  
  
 [!code-cpp[System.Text.UTF8Encoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UTF8Encoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/snippet.vb#1)]  
  
 Im folgenden Beispiel wird die gleiche Zeichenfolge wie im vorherigen Beispiel, mit dem Unterschied, dass die codierten Bytes in eine Datei geschrieben, und den Bytestream mit einem Byte-reihenfolgemarkierung (BOM) als Präfix voran. Es liest die Datei klicken Sie dann auf zwei verschiedene Arten: als Textdatei mit einer <xref:System.IO.StreamReader> -Objekt sowie eine binäre Datei. Wie zu erwarten ist, ist in keinem Fall Bytereihenfolge-Marke in der neu gelesenen Zeichenfolge enthalten.  
  
 [!code-csharp[System.Text.UTF8Encoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UTF8Encoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoder" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.UTF8Encoding" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.UTF8Encoding" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt eine Instanz, die bietet keine Unicode-Bytereihenfolge-Marke, und löst keine Ausnahme aus, wenn eine ungültige Codierung gefunden wird.  
  
> [!NOTE]
>  Aus Sicherheitsgründen wird empfohlen, dass Sie die Erkennung aktivieren, durch den Aufruf eines Konstruktors mit einem `throwOnInvalidBytes` Parameter und legt deren Wert auf `true`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.Text.UTF8Encoding> -Instanz und zeigt seinen Namen.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF8Encoding : bool -&gt; System.Text.UTF8Encoding" Usage="new System.Text.UTF8Encoding encoderShouldEmitUTF8Identifier" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier">
          <see langword="true" /> to specify that the <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> method returns a Unicode byte order mark; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.UTF8Encoding" /> class. A parameter specifies whether to provide a Unicode byte order mark.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt eine Instanz, die keine Ausnahme auslöst, wenn eine ungültige Codierung gefunden wird.  
  
> [!NOTE]
>  Aus Sicherheitsgründen sollten Sie Erkennung aktivieren, indem Aufruf eines Konstruktors, der enthält eine `throwOnInvalidBytes` Parameter und legt deren Wert auf `true`.  
  
 Die `encoderShouldEmitUTF8Identifier` Parameter steuert, den Betrieb der <xref:System.Text.UTF8Encoding.GetPreamble%2A> Methode. Wenn `true`, die Methode gibt ein Bytearray, das die Unicode-bytereihenfolgemarkierung (BOM) in UTF-8-Format zurück.  Wenn `false`, es gibt ein Bytearray der Länge 0 (null) zurück. Allerdings festlegen `encoderShouldEmitUTF8Identifier` zu `true` führt nicht dazu, dass der <xref:System.Text.UTF8Encoding.GetBytes%2A> Methode, um die Bytereihenfolge-Marke am Anfang des Bytearrays, Präfix und führt es dazu, dass der <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode, um die Anzahl der Bytes in Bytereihenfolge-Marke in die Anzahl der Bytes einzufügen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.Text.UTF8Encoding> -Instanz und gibt an, dass ein Unicode-Byte Order Mark Präfix sollen, durch ausgegeben werden die <xref:System.Text.UTF8Encoding.GetPreamble%2A> Methode. Die <xref:System.Text.UTF8Encoding.GetPreamble%2A> Methode gibt dann das Unicode-Byte Order Mark-Präfix zurück.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CPP/ctor-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CS/ctor-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/VB/ctor-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF8Encoding : bool * bool -&gt; System.Text.UTF8Encoding" Usage="new System.Text.UTF8Encoding (encoderShouldEmitUTF8Identifier, throwOnInvalidBytes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier">
          <see langword="true" /> to specify that the <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> method should return a Unicode byte order mark; otherwise, <see langword="false" />.</param>
        <param name="throwOnInvalidBytes">
          <see langword="true" /> to throw an exception when an invalid encoding is detected; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.UTF8Encoding" /> class. Parameters specify whether to provide a Unicode byte order mark and whether to throw an exception when an invalid encoding is detected.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `encoderShouldEmitUTF8Identifier` Parameter steuert, den Betrieb der <xref:System.Text.UTF8Encoding.GetPreamble%2A> Methode. Wenn `true`, die Methode gibt ein Bytearray, das die Unicode-bytereihenfolgemarkierung (BOM) in UTF-8-Format zurück.  Wenn `false`, es gibt ein Bytearray der Länge 0 (null) zurück. Allerdings festlegen `encoderShouldEmitUTF8Identifier` zu `true` führt nicht dazu, dass der <xref:System.Text.UTF8Encoding.GetBytes%2A> Methode, um die Bytereihenfolge-Marke am Anfang des Bytearrays, Präfix und führt es dazu, dass der <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode, um die Anzahl der Bytes in Bytereihenfolge-Marke in die Anzahl der Bytes einzufügen.  
  
 Wenn `throwOnInvalidBytes` ist `true`, löst Sie eine Methode, eine ungültige Bytesequenz erkennt, eine <xref:System.ArgumentException?displayProperty=nameWithType> Ausnahme. Andernfalls die Methode löst keine Ausnahme aus, und die ungültige Sequenz wird ignoriert.  
  
> [!NOTE]
>  Aus Sicherheitsgründen sollten Sie Erkennung aktivieren, indem Aufruf eines Konstruktors, der enthält eine `throwOnInvalidBytes` Parameter und die Festlegung dieses Parameters auf `true`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.Text.UTF8Encoding> -Instanz angeben, dass die <xref:System.Text.UTF8Encoding.GetPreamble%2A> Methode sollte keine Unicode-Byte Order Mark Präfix ausgeben, und eine Ausnahme ausgelöst werden soll, wenn eine ungültige Codierung gefunden wird. Das Verhalten dieses Konstruktors wird verglichen, auf den Standardwert <xref:System.Text.UTF8Encoding.%23ctor> -Konstruktor, der keine Ausnahme auslöst, wenn eine ungültige Codierung gefunden wird. Die beiden <xref:System.Text.UTF8Encoding> Instanzen codiert ein Array von Zeichen, die zwei hohe Ersatzzeichen (U + D801 und U + D802) enthält, in der Zeile, die eine ungültige Zeichenfolge ist, ein hohes Ersatzzeichen muss immer ein niedriges Ersatzzeichen folgen.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uTF8Encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The object to compare with the current instance.</param>
        <summary>Determines whether the specified object is equal to the current <see cref="T:System.Text.UTF8Encoding" /> object.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.UTF8Encoding" /> and is equal to the current object; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei <xref:System.Text.UTF8Encoding> Objekte werden als gleich betrachtet, wenn alle der folgenden Bedingungen erfüllt sind:  
  
-   Beide Objekte bereitstellen, Byte Order Mark, oder beide nicht.  
  
-   Beide Objekte verwenden die gleichen EncoderFallback.  
  
-   Beide Objekte verwenden die gleichen DecoderFallback.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.Equals%2A> Methode zum Testen, ob die aktuelle <xref:System.Text.UTF8Encoding> -Objekt gleich einem anderen <xref:System.Text.UTF8Encoding> Objekt. Vier <xref:System.Text.UTF8Encoding> Objekte werden erstellt und verglichen, und die Ergebnisse dieser Vergleiche werden angezeigt.  
  
 [!code-cpp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CPP/equals-object.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CS/equals-object.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/VB/equals-object.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calculates the number of bytes produced by encoding a set of characters.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ chars);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="uTF8Encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="chars">The <see cref="T:System.String" /> containing the set of characters to encode.</param>
        <summary>Calculates the number of bytes produced by encoding the characters in the specified <see cref="T:System.String" />.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.UTF8Encoding.GetBytes%2A> um die resultierenden Bytes zu speichern, rufen Sie die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode. Um die maximale Größe zu berechnen, rufen Sie die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode belegt in der Regel weniger Speicher, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Mit der fehlererkennung, eine ungültige Sequenz verursacht, löst diese Methode eine <xref:System.ArgumentException> Ausnahme. Fehler unbemerkt ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen. Die Präambel am Anfang des Byte-Stream einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden) die Verantwortung des Entwicklers ist und die Anzahl der Bytes in der Präambel ist nicht in den Rückgabewert von wiedergegeben, die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> und <xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29> Methoden zum Berechnen der maximalen und die tatsächliche Anzahl der Bytes, die zum Codieren einer Zeichenfolge erforderlich. Es zeigt auch die tatsächliche Anzahl von Bytes erforderlich, um ein Bytestream mit einer Bytereihenfolge-Marke zu speichern.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF8Encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A pointer to the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Arraygröße Berechnen der <xref:System.Text.UTF8Encoding.GetBytes%2A> Methode zum Speichern der resultierenden Bytes, rufen Sie die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode. Um die maximale Größe zu berechnen, rufen Sie die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode belegt in der Regel weniger Speicher, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Mit der fehlererkennung, eine ungültige Sequenz verursacht, löst diese Methode eine <xref:System.ArgumentException> Ausnahme. Fehler unbemerkt ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen. Die Präambel am Anfang des Byte-Stream einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden) die Verantwortung des Entwicklers ist und die Anzahl der Bytes in der Präambel ist nicht in den Rückgabewert von wiedergegeben, die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is less than zero.  -or-  The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for a complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="uTF8Encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="index">The index of the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>Calculates the number of bytes produced by encoding a set of characters from the specified character array.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.UTF8Encoding.GetBytes%2A> um die resultierenden Bytes zu speichern, rufen Sie die Verwendungen <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode. Um die maximale Größe zu berechnen, rufen Sie die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode belegt in der Regel weniger Speicher, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Mit der fehlererkennung, eine ungültige Sequenz verursacht, löst diese Methode eine <xref:System.ArgumentException> Ausnahme. Fehler unbemerkt ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen. Die Präambel am Anfang des Byte-Stream einfügen (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden) die Verantwortung des Entwicklers ist und die Anzahl der Bytes in der Präambel ist nicht in den Rückgabewert von wiedergegeben, die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel füllt ein Array mit einen lateinischen Großbuchstaben und Kleinbuchstaben und ruft die <xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Methode, um die Anzahl der Bytes, die zum Codieren der Zeichen des lateinischen Kleinbuchstaben erforderlich festzulegen. Anschließend werden diese Informationen zusammen mit der Gesamtanzahl von Bytes erforderlich, wenn eine Bytereihenfolge-Marke hinzugefügt wird angezeigt. Verglichen mit den Rückgabewert von dieser Zahl der <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> -Methode, die maximale Anzahl von Bytes, die zum Codieren der Zeichen des lateinischen Kleinbuchstaben erforderlich angibt.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.  -or-  The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  The <see cref="P:System.Text.Encoding.EncoderFallback" /> property is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Encodes a set of characters into a sequence of bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string -&gt; byte[]" Usage="uTF8Encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF8Encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A pointer to the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">A pointer to the location at which to start writing the resulting sequence of bytes.</param>
        <param name="byteCount">The maximum number of bytes to write.</param>
        <summary>Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</summary>
        <returns>The actual number of bytes written at the location indicated by <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.UTF8Encoding.GetBytes%2A> um die resultierenden Bytes zu speichern, rufen Sie die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode. Um die maximale Größe zu berechnen, rufen Sie die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode belegt in der Regel weniger Speicher, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Mit der fehlererkennung, eine ungültige Sequenz verursacht, löst diese Methode eine <xref:System.ArgumentException> Ausnahme. Fehler unbemerkt ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesene Daten möglicherweise nur in sequenzielle Blöcke verfügbar. In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> zurückgegebenes der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen. Die Präambel am Anfang des Byte-Stream einfügt (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden) wird die Verantwortung des Entwicklers. Die <xref:System.Text.UTF8Encoding.GetBytes%2A> Methode ist keine Präambel an den Anfang eine codierte Bytefolge voranstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.  -or-  <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.  -or-  <paramref name="byteCount" /> is less than the resulting number of bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="uTF8Encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="charIndex">The index of the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
        <param name="byteIndex">The index at which to start writing the resulting sequence of bytes.</param>
        <summary>Encodes a set of characters from the specified character array into the specified byte array.</summary>
        <returns>The actual number of bytes written into <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.UTF8Encoding.GetBytes%2A> um die resultierenden Bytes zu speichern, rufen Sie die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode. Um die maximale Größe zu berechnen, rufen Sie die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode belegt in der Regel weniger Speicher, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Mit der fehlererkennung, eine ungültige Sequenz verursacht, löst diese Methode eine <xref:System.ArgumentException> Ausnahme. Fehler unbemerkt ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesene Daten möglicherweise nur in sequenzielle Blöcke verfügbar. In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen. Die Präambel am Anfang des Byte-Stream einfügt (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden) wird die Verantwortung des Entwicklers. Die <xref:System.Text.UTF8Encoding.GetBytes%2A> Methode ist keine Präambel an den Anfang eine codierte Bytefolge voranstellen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetBytes%2A> Methode, um einen Bereich von Zeichen aus einer Zeichenfolge und speichert die codierten Bytes in einem Bereich von Elementen in einem Bytearray codiert.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.  -or-  <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.  -or-  <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.  -or-  <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.  -or-  <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="uTF8Encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">The <see cref="T:System.String" /> containing the set of characters to encode.</param>
        <param name="charIndex">The index of the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
        <param name="byteIndex">The index at which to start writing the resulting sequence of bytes.</param>
        <summary>Encodes a set of characters from the specified <see cref="T:System.String" /> into the specified byte array.</summary>
        <returns>The actual number of bytes written into <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.UTF8Encoding.GetBytes%2A> um die resultierenden Bytes zu speichern, rufen Sie die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode. Um die maximale Größe zu berechnen, rufen Sie die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode belegt in der Regel weniger Speicher, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Mit der fehlererkennung, eine ungültige Sequenz verursacht, löst diese Methode eine <xref:System.ArgumentException> Ausnahme. Fehler unbemerkt ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesene Daten möglicherweise nur in sequenzielle Blöcke verfügbar. In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie einen Datenstrom von codierten Bytes mit einer Präambel voranstellen. Die Präambel am Anfang des Byte-Stream einfügt (z. B. am Anfang einer Folge von Bytes in eine Datei geschrieben werden) wird die Verantwortung des Entwicklers. Die <xref:System.Text.UTF8Encoding.GetBytes%2A> Methode ist keine Präambel an den Anfang eine codierte Bytefolge voranstellen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetBytes%2A> Methode, um einen Bereich von Elementen aus einem Array von Unicode-Zeichen zu codieren und speichern die codierten Bytes in einen Bereich von Elementen in einem Bytearray.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.  -or-  <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.  -or-  <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.  -or-  <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="s" /> contains an invalid sequence of characters.  -or-  <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calculates the number of characters produced by decoding a sequence of bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF8Encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.UTF8Encoding.GetChars%2A> aufrufen, um die sich ergebenden Zeichen speichern zu können, die <xref:System.Text.UTF8Encoding.GetCharCount%2A> Methode. Um die maximale Größe zu berechnen, rufen die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.UTF8Encoding.GetCharCount%2A> Methode belegt in der Regel weniger Speicher, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Mit der fehlererkennung, eine ungültige Sequenz verursacht, löst diese Methode eine <xref:System.ArgumentException> Ausnahme. Fehler unbemerkt ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is less than zero.  -or-  The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="uTF8Encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.UTF8Encoding.GetChars%2A> aufrufen, um die sich ergebenden Zeichen speichern zu können, die <xref:System.Text.UTF8Encoding.GetCharCount%2A> Methode. Um die maximale Größe zu berechnen, rufen die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.UTF8Encoding.GetCharCount%2A> Methode belegt in der Regel weniger Speicher, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Mit der fehlererkennung, eine ungültige Sequenz verursacht, löst diese Methode eine <xref:System.ArgumentException> Ausnahme. Fehler unbemerkt ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetCharCount%2A> Methode, um die Anzahl der Zeichen zurückzugeben, die beim Decodieren eines Bereichs von Elementen in einem Bytearray erstellt.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.  -or-  The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodes a sequence of bytes into a set of characters.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF8Encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to the first byte to decode.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <param name="chars">A pointer to the location at which to start writing the resulting set of characters.</param>
        <param name="charCount">The maximum number of characters to write.</param>
        <summary>Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</summary>
        <returns>The actual number of characters written at the location indicated by <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.UTF8Encoding.GetChars%2A> aufrufen, um die sich ergebenden Zeichen speichern zu können, die <xref:System.Text.UTF8Encoding.GetCharCount%2A> Methode. Um die maximale Größe zu berechnen, rufen die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.UTF8Encoding.GetCharCount%2A> Methode belegt in der Regel weniger Speicher, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Mit der fehlererkennung, eine ungültige Sequenz verursacht, löst diese Methode eine <xref:System.ArgumentException> Ausnahme. Fehler unbemerkt ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 Wenn der Bereich der zu decodierenden Bytes die Bytereihenfolge-Marke (BOM umfasst), und die Byte-Array von einer Methode eines nicht-BOM bewusst-Typs zurückgegeben wurde, ist das Zeichen, U + FFFE in der von dieser Methode zurückgegebene Array von Zeichen enthalten. Sie können diese entfernen, durch den Aufruf der <xref:System.String.TrimStart%2A?displayProperty=nameWithType> Methode.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesene Daten möglicherweise nur in sequenzielle Blöcke verfügbar. Und in diesem Fall, wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder <xref:System.Text.Encoder> Objekt bereitgestellt werden, indem Sie die <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.  -or-  <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.  -or-  <paramref name="charCount" /> is less than the resulting number of characters.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="uTF8Encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="byteIndex">The index of the first byte to decode.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <param name="chars">The character array to contain the resulting set of characters.</param>
        <param name="charIndex">The index at which to start writing the resulting set of characters.</param>
        <summary>Decodes a sequence of bytes from the specified byte array into the specified character array.</summary>
        <returns>The actual number of characters written into <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.UTF8Encoding.GetChars%2A> aufrufen, um die sich ergebenden Zeichen speichern zu können, die <xref:System.Text.UTF8Encoding.GetCharCount%2A> Methode. Um die maximale Größe zu berechnen, rufen die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.UTF8Encoding.GetCharCount%2A> Methode belegt in der Regel weniger Speicher, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 Mit der fehlererkennung, eine ungültige Sequenz verursacht, löst diese Methode eine <xref:System.ArgumentException> Ausnahme. Fehler unbemerkt ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 Wenn der Bereich der zu decodierenden Bytes die Bytereihenfolge-Marke (BOM umfasst), und die Byte-Array von einer Methode eines nicht-BOM bewusst-Typs zurückgegeben wurde, ist das Zeichen, U + FFFE in der von dieser Methode zurückgegebene Array von Zeichen enthalten. Sie können diese entfernen, durch den Aufruf der <xref:System.String.TrimStart%2A?displayProperty=nameWithType> Methode.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesene Daten möglicherweise nur in sequenzielle Blöcke verfügbar. In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetChars%2A> Methode, um einen Bereich von Elementen in einem Bytearray zu decodieren, und Speichern des Ergebnisses in ein Array von Zeichen.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.  -or-  <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.  -or-  <paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.  -or-  <paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.  -or-  <paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="uTF8Encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtains a decoder that converts a UTF-8 encoded sequence of bytes into a sequence of Unicode characters.</summary>
        <returns>A decoder that converts a UTF-8 encoded sequence of bytes into a sequence of Unicode characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Methode konvertiert die Blöcke von Bytes in sequenzielle Blöcke von Zeichen, ähnlich wie die <xref:System.Text.UTF8Encoding.GetChars%2A> Methode dieser Klasse. Allerdings eine <xref:System.Text.Decoder> verwaltet Zustandsinformationen zwischen den aufrufen, damit es ordnungsgemäß decodiert werden können, die Blöcke umfassen. Die <xref:System.Text.Decoder> behält nachfolgende Bytes am Ende der Datenblöcke und verwendet Sie im nächsten Decodierungsvorgang. Aus diesem Grund <xref:System.Text.UTF8Encoding.GetDecoder%2A> und <xref:System.Text.UTF8Encoding.GetEncoder%2A> eignen sich für die Übertragung im Netzwerk und Dateivorgänge, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.  
  
 Wenn Erkennung, d. h. aktiviert ist die `throwOnInvalidCharacters` Parameter des Konstruktors nastaven NA hodnotu `true`, fehlererkennung ist ebenfalls aktiviert, der <xref:System.Text.Decoder> von dieser Methode zurückgegebene. Wenn die fehlererkennung ist aktiviert, und eine ungültige Sequenz festgestellt wird, der Zustand des Decoders ist nicht definiert und Verarbeitung muss beendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode, um eine UTF-8-Decoder abzurufen. Der Decoder konvertiert eine Bytefolge in eine Folge von Zeichen an.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CPP/getdecoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CS/getdecoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/VB/getdecoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="uTF8Encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtains an encoder that converts a sequence of Unicode characters into a UTF-8 encoded sequence of bytes.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> that converts a sequence of Unicode characters into a UTF-8 encoded sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> konvertiert sequenzielle Blöcke von Zeichen in sequenzielle Blöcke von Bytes, ähnlich wie die <xref:System.Text.UTF8Encoding.GetBytes%2A> Methode. Allerdings eine <xref:System.Text.Encoder> verwaltet Zustandsinformationen zwischen den aufrufen, damit es ordnungsgemäß codiert werden können, die Blöcke umfassen. Die <xref:System.Text.Encoder> auch behält nachfolgende Zeichen am Ende der Datenblöcke und die nachgestellten Zeichen in den nächsten Vorgang für die Codierung verwendet. Z. B. ein Datenblock kann eine hohe Ersatzzeichen ohne Entsprechung enden, und das entsprechende niedrige Ersatzzeichen möglicherweise der nächste Datenblock. Aus diesem Grund <xref:System.Text.UTF8Encoding.GetDecoder%2A> und <xref:System.Text.UTF8Encoding.GetEncoder%2A> eignen sich für die Übertragung im Netzwerk und Dateivorgänge, da diese Vorgänge Datenblöcke anstelle einer vollständigen Datenstrom oft verarbeiten müssen.  
  
 Wenn Erkennung, d. h. aktiviert ist die `throwOnInvalidCharacters` Parameter des Konstruktors nastaven NA hodnotu `true`, fehlererkennung ist ebenfalls aktiviert, der <xref:System.Text.Encoder> von dieser Methode zurückgegebene. Wenn die fehlererkennung ist aktiviert, und eine ungültige Sequenz festgestellt wird, den Zustand des Encoders ist nicht definiert und Verarbeitung muss beendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetEncoder%2A> Methode zum Abrufen von eines Encoders eine Folge von Zeichen in eine UTF-8-codierte Bytefolge.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CPP/getencoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CS/getencoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/VB/getencoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uTF8Encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for the current instance.</summary>
        <returns>The hash code for the current instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetHashCode%2A> Methode, um einen Hashcode für zurückzugeben <xref:System.Text.UTF8Encoding> Instanzen. Beachten Sie, dass der Konstruktor zur Erstellung verwendet der Hashcode, der von dieser Methode zurückgegebene abhängt, dass die <xref:System.Text.UTF8Encoding> Objekt.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CPP/gethashcode-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CS/gethashcode-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/VB/gethashcode-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="uTF8Encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">The number of characters to encode.</param>
        <summary>Calculates the maximum number of bytes produced by encoding the specified number of characters.</summary>
        <returns>The maximum number of bytes produced by encoding the specified number of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.UTF8Encoding.GetBytes%2A> um die resultierenden Bytes zu speichern, rufen Sie die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode. Um die maximale Größe zu berechnen, rufen Sie die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Methode. Die <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode belegt in der Regel weniger Speicher, während die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> ein Worst-Case Zahl ist, einschließlich den schlimmsten Fall für das derzeit ausgewählte <xref:System.Text.EncoderFallback>. Wenn ein Fallback, eine potenziell große Zeichenfolge ausgewählt wird <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> große Werte zurückgeben können.  
  
 In den meisten Fällen gibt diese Methode geeignete Zahlen für kurze Zeichenfolgen. Für lange Zeichenfolgen müssen Sie möglicherweise entscheiden Sie sehr große Puffer und Abfangen von Fehlern in dem seltenen Fall, dass ein geeigneteren Puffer überschritten wird. Sie sollten auch einen anderen Ansatz erwägen <xref:System.Text.UTF8Encoding.GetByteCount%2A> oder <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>. Z. B. Text auf Englisch und viele weitere Sprachen werden häufig nur eine UTF-8-Byte zur Darstellung eines Zeichens benötigt, aber die Anzahl von zurückgegebenen <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> muss, können die Möglichkeit, dass die Zeichenfolge, die konvertiert werden vollständig aus Zeichen, die jeweils enthalten soll vier Bytes erforderlich sind.  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> hat keinen Bezug zu <xref:System.Text.UTF8Encoding.GetChars%2A>. Wenn Ihre Anwendung eine ähnliche Funktion für die Verwendung mit <xref:System.Text.UTF8Encoding.GetChars%2A>, muss bei Verwendung <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` ist nicht unbedingt der gleiche Wert wie `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Methode, um die maximale Anzahl von Bytes erforderlich, um eine angegebene Anzahl von Zeichen codiert zurückgegeben.  
  
 [!code-cpp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> is less than zero.  -or-  The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="uTF8Encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">The number of bytes to decode.</param>
        <summary>Calculates the maximum number of characters produced by decoding the specified number of bytes.</summary>
        <returns>The maximum number of characters produced by decoding the specified number of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Berechnen Sie die genaue Arraygröße <xref:System.Text.UTF8Encoding.GetChars%2A> um die sich ergebenden Zeichen zu speichern, rufen Sie die <xref:System.Text.UTF8Encoding.GetCharCount%2A> Methode. Um die maximale Größe zu berechnen, rufen Sie die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> Methode. Die <xref:System.Text.UTF8Encoding.GetCharCount%2A> Methode belegt in der Regel weniger Speicher, während die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> Methode in der Regel schneller ausgeführt wird.  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> ein Worst-Case Zahl ist, einschließlich den schlimmsten Fall für das derzeit ausgewählte <xref:System.Text.DecoderFallback>. Wenn ein Fallback, eine potenziell große Zeichenfolge ausgewählt wird <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> große Werte zurückgeben können.  
  
 In den meisten Fällen gibt diese Methode geeignete Zahlen für kurze Zeichenfolgen. Für lange Zeichenfolgen müssen Sie möglicherweise entscheiden Sie sehr große Puffer und Abfangen von Fehlern in dem seltenen Fall, dass ein geeigneteren Puffer überschritten wird.  Sie sollten auch einen anderen Ansatz erwägen <xref:System.Text.UTF8Encoding.GetCharCount%2A> oder <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> hat keinen Bezug zu <xref:System.Text.UTF8Encoding.GetBytes%2A>. Wenn Ihre Anwendung eine ähnliche Funktion für die Verwendung mit <xref:System.Text.UTF8Encoding.GetBytes%2A>, muss bei Verwendung <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` ist nicht unbedingt der gleiche Wert wie `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> Methode, um die maximale Anzahl von Zeichen zurückzugeben, die beim Decodieren einer angegebenen Anzahl von Bytes erzeugt.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> is less than zero.  -or-  The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="uTF8Encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a Unicode byte order mark encoded in UTF-8 format, if the <see cref="T:System.Text.UTF8Encoding" /> encoding object is configured to supply one.</summary>
        <returns>A byte array containing the Unicode byte order mark, if the <see cref="T:System.Text.UTF8Encoding" /> encoding object is configured to supply one. Otherwise, this method returns a zero-length byte array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.UTF8Encoding> Objekt kann eine Präambel ein Byte-Array ist, die an die Sequenz von Bytes als Präfix verwendet werden können, die aus des Codierungsvorgangs bereitstellen. Voranstellen einer Sequenz codierter Bytes mit einer Bytereihenfolge-Marke (Codepunkt U + FEFF) unterstützt den Decoder, der bestimmt die Bytereihenfolge und die Transformationsformat oder UTF. Die Unicode-bytereihenfolgemarkierung (BOM) als 0xEF serialisiert 0xBB 0xBF. Beachten Sie, dass der Unicode-Standard erfordert und keine empfiehlt die Verwendung der BOM für UTF-8-Streams codiert.  
  
 Instanziieren Sie ein <xref:System.Text.UTF8Encoding> Objekt, dessen <xref:System.Text.UTF8Encoding.GetPreamble%2A> Methode gibt eine gültige BOM zurück, es gibt folgende Möglichkeiten:  
  
-   Durch Abrufen der <xref:System.Text.UTF8Encoding> zurückgegebenes Objekt der <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> Eigenschaft.  
  
-   Durch Aufrufen einer <xref:System.Text.UTF8Encoding> Konstruktor mit einem `encoderShouldEmitUTF8Identifier` Parameter und legt deren Wert festgelegt `true`.  
  
 Alle anderen <xref:System.Text.UTF8Encoding> Objekte sind so konfiguriert, dass eine gültige BOM, anstatt ein leeres Array zurückgegeben.  
  
 Die BOM enthalten fast bestimmte Identifikation einer Codierung für Dateien, die andernfalls einen Verweis auf ihre Codierung verloren haben, wie z. B. nicht markierten oder nicht ordnungsgemäß mit Tags Web Daten oder zufälligen Text-Dateien gespeichert, wenn ein Unternehmen keine internationale Aspekte. Häufig Probleme der Benutzer können vermieden werden, wenn Daten einheitlich und ordnungsgemäß gekennzeichnet ist.  
  
 Für Standards, die einen Typ der codieren bereitstellen, ist eine Bytereihenfolge-Marke gewisse Weise redundant. Es kann jedoch verwendet werden, können Sie einen Server, den richtigen encoding-Header senden. Alternativ können sie als ausweichlösung verwendet werden, für den Fall, dass die Codierung verloren gegangen ist.  
  
 Es gibt einige Nachteile mit einer Bytereihenfolge-Marke. Wissen, wie die Datenbankfelder zu begrenzen, die eine Bytereihenfolge-Marke verwenden kann z. B. schwierig sein. Verkettung von Dateien, problematisch sein kann auch, z. B. beim Zusammenführen von Dateien so eine Möglichkeit, die ein unnötiges Zeichen in der Mitte Daten ergeben kann. Trotz der einige Nachteile wird jedoch dringend die Verwendung einer Stückliste empfohlen.  
  
 Weitere Informationen zu Byte-Reihenfolge und die Bytereihenfolge-Marke, finden Sie im Unicode-Standard auf die [Unicode-Homepage](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn sie als eine Datei oder einem Stream gespeichert werden, können Sie den Anfang eines Streams codierter Bytes mit einer Präambel voranstellen. Beachten Sie, dass die <xref:System.Text.UTF8Encoding.GetBytes%2A> Methode wird keine BOM, um eine codierte Bytefolge vorangestellt ist eine Bytereihenfolge-Marke am Anfang einer entsprechenden Bytedatenstrom angeben der Verantwortung des Entwicklers.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.UTF8Encoding.GetPreamble%2A> -Methode zur Rückgabe der Unicode-Byte order Mark in UTF-8-Format codiert. Beachten Sie, dass der Standardkonstruktor für <xref:System.Text.UTF8Encoding> bietet keine Präambel.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 Das folgende Beispiel instanziiert werden zwei <xref:System.Text.UTF8Encoding> Objekte, die erste durch den Aufruf eines parameterlosen <xref:System.Text.UTF8Encoding.%23ctor> -Konstruktor, der keine BOM, und die zweite durch Aufrufen von bietet die <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29> Konstruktor mit der `encoderShouldEmitUTF8Identifier` -Argument festgelegt `true`. Es ruft dann die <xref:System.Text.UTF8Encoding.GetPreamble%2A> Methode, um die Bytereihenfolge-Marke in eine Datei zu schreiben, bevor Sie eine UF8-codierte Zeichenfolge zu schreiben. Wie in der Konsolenausgabe aus dem Beispiel wird gezeigt, wurde die Datei, die die Bytes aus dem zweiten Encoder speichert drei weitere Bytes als das erste.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/cs/getpreamble1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/vb/getpreamble1.vb#1)]  
  
 Sie können auch die Dateien vergleichen, mit der `fc` Befehl in einem Konsolenfenster eingeben, oder Sie können überprüfen, dass die Dateien in einem Text-Editor, der einen hexadezimal-Anzeigemodus enthält. Beachten Sie, dass die Datei in einem Editor geöffnet ist, die UTF-8 unterstützt, die BOM nicht angezeigt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="uTF8Encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>Decodes a range of bytes from a byte array into a string.</summary>
        <returns>A <see cref="T:System.String" /> containing the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der fehlererkennung, eine ungültige Sequenz verursacht, löst diese Methode eine <xref:System.ArgumentException> Ausnahme. Fehler unbemerkt ungültige Sequenzen werden ignoriert, und keine Ausnahme ausgelöst wird.  
  
 Wenn der Bereich der zu decodierenden Bytes die Bytereihenfolge-Marke (BOM umfasst), und die Byte-Array von einer Methode eines nicht-BOM bewusst-Typs zurückgegeben wurde, ist das Zeichen, U + FFFE in der von dieser Methode zurückgegebene Array von Zeichen enthalten. Sie können diese entfernen, durch den Aufruf der <xref:System.String.TrimStart%2A?displayProperty=nameWithType> Methode.  
  
 Daten konvertiert werden, z. B. aus einem Stream gelesene Daten möglicherweise nur in sequenzielle Blöcke verfügbar. In diesem Fall, oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF8Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF8Encoding.GetEncoder%2A> -Methode, bzw.  
  
   
  
## Examples  
 Im folgende Beispiel wird ein Array initialisiert, durch den Aufruf der <xref:System.Text.UTF8Encoding.GetByteCount%2A> Methode, um zu bestimmen, genau wie viele Bytes für eine codierte Zeichenfolge und das anschließende Hinzufügen der Anzahl der Byte-reihenfolgemarkierung (BOM) erforderlich sind. Das Beispiel ruft dann die <xref:System.Text.UTF8Encoding.GetPreamble%2A> Methode zum Speichern der Bytereihenfolge-Marke in das Array vor dem Aufruf der <xref:System.Text.UTF8Encoding.GetBytes%2A> Methode, um die codierten Bytes in das Array zu speichern. Das Beispiel ruft dann die <xref:System.Text.UTF8Encoding.GetString%2A> Methode, um die Zeichenfolge zu decodieren.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Beachten Sie, dass in diesem Fall die decodierte Zeichenfolge aus der ursprünglichen Zeichenfolge, unterscheidet, da er mit einer 16-Bit-Bytereihenfolge-Marke U + FFFD beginnt. Dies bedeutet, dass die beiden Zeichenfolgen als ungleich verglichen werden und wenn die Ausgabe ist, die BOM als das zu ersetzende Zeichen angezeigt wird "?". Um die Bytereihenfolge-Marke am Anfang der Zeichenfolge zu entfernen, rufen Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>