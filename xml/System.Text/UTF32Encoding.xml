<Type Name="UTF32Encoding" FullName="System.Text.UTF32Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6090dc5b6caa657ce22059939ed5f0dbd147aaf6" /><Meta Name="ms.sourcegitcommit" Value="385ff23cc00fe9aa1c93460c62603b45c2041d0b" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/22/2019" /><Meta Name="ms.locfileid" Value="74388038" /></Metadata><TypeSignature Language="C#" Value="public sealed class UTF32Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit UTF32Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF32Encoding" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class UTF32Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF32Encoding sealed : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UTF32Encoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a UTF-32 encoding of Unicode characters.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Kodieren werden Unicode-Zeichen in eine Bytefolge transformiert. Beim Decodieren wird eine Sequenz codierter Bytes in eine Gruppe von Unicode-Zeichen transformiert.  
  
 Gemäß [Unicode-Standard](https://go.microsoft.com/fwlink/?linkid=37123) werden jedem Zeichen aller unterstützten Skripts ein Codepunkt (eine Zahl) und ein Name zugewiesen. UTF (Unicode Transformation Format) ist eine Möglichkeit, diesen Codepunkt zu codieren. Der [Unicode-Standard](https://go.microsoft.com/fwlink/?linkid=37123) verwendet die folgenden UTFs:  
  
-   UTF-8, das die einzelnen Code Punkte als Sequenz von einem bis vier Bytes darstellt.  
  
-   UTF-16, das die einzelnen Code Punkte als Sequenz von einer bis zu 2 16-Bit-Ganzzahlen darstellt.  
  
-   UTF-32, das die einzelnen Code Punkte als 32-Bit-Ganzzahl darstellt.  
  
 Weitere Informationen zu den UTFs und anderen Codierungen, die von <xref:System.Text>unterstützt werden, finden Sie unter [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md).
  
 Die <xref:System.Text.UTF32Encoding>-Klasse stellt eine UTF-32-Codierung dar. Der Encoder kann die Big-Endian-Byte Reihenfolge (signifikanteste Byte zuerst) oder die kleine Endian-Byte Reihenfolge (das niedrigste signifikante Byte zuerst) verwenden. Der lateinische Großbuchstabe A (Codepunkt U + 0041) wird z. b. wie folgt serialisiert (in Hexadezimal):  
  
-   Big-Endian-Byte Reihenfolge: 00 00 00 41  
  
-   Little-Endian-Byte Reihenfolge: 41 00 00 00  
  
 Es ist in der Regel effizienter, Unicode-Zeichen mithilfe der systemeigenen Byte Reihenfolge zu speichern. Beispielsweise ist es besser, die Little-Endian-Byte Reihenfolge auf kleinen Endian-Plattformen wie z. b. Intel-Computern zu verwenden. <xref:System.Text.UTF32Encoding> entspricht den Windows-Codepages 12000 (Little-Endian-Byte Reihenfolge) und 12001 (Big Endian-Byte Reihenfolge). Sie können die "Einschreibung" einer bestimmten Architektur ermitteln, indem Sie die <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType>-Methode aufrufen.  
  
 Das <xref:System.Text.UTF32Encoding>-Objekt stellt optional eine Byte Reihenfolge-Marke (Byte Order Mark, BOM) bereit, bei der es sich um ein Bytearray handelt, dem die Bytefolge des Codierungs Prozesses vorangestellt werden kann. Wenn die Präambel eine Byte Reihenfolge-Marke (BOM) enthält, unterstützt Sie der Decoder dabei, die Byte Reihenfolge und das Transformations Format oder UTF eines Bytearrays zu bestimmen.  
  
 Wenn die <xref:System.Text.UTF32Encoding> Instanz so konfiguriert ist, dass Sie eine BOM bereitstellt, können Sie Sie abrufen, indem Sie die <xref:System.Text.UTF32Encoding.GetPreamble%2A>-Methode aufrufen. Andernfalls gibt die Methode ein leeres Array zurück. Beachten Sie, dass Sie, selbst wenn ein <xref:System.Text.UTF32Encoding> Objekt für die BOM-Unterstützung konfiguriert ist, die BOM nach Bedarf am Anfang des codierten Bytestreams einschließen müssen. die Codierungs Methoden der <xref:System.Text.UTF32Encoding>-Klasse führen dies nicht automatisch aus.  

> [!CAUTION]  
> Um die Fehlererkennung zu aktivieren und die Klasseninstanz sicherer zu machen, sollten Sie ein <xref:System.Text.UTF32Encoding> Objekt instanziieren, indem Sie den <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29>-Konstruktor aufrufen und dessen `throwOnInvalidBytes` Argument auf `true`festlegen. Bei der Fehlererkennung löst eine Methode, die eine ungültige Sequenz von Zeichen oder Bytes erkennt, eine <xref:System.ArgumentException> Ausnahme aus. Ohne Fehlererkennung wird keine Ausnahme ausgelöst, und die ungültige Sequenz wird im Allgemeinen ignoriert.  
  
 Sie können ein <xref:System.Text.UTF32Encoding> Objekt auf verschiedene Weise instanziieren, abhängig davon, ob Sie eine Byte Reihenfolge-Marke (BOM) bereitstellen möchten, ob Sie Big-Endian-oder Little-Endian-Codierung wünschen und ob Sie die Fehlererkennung aktivieren möchten. In der folgenden Tabelle werden die <xref:System.Text.UTF32Encoding>-Konstruktoren und die <xref:System.Text.Encoding> Eigenschaften aufgelistet, die ein <xref:System.Text.UnicodeEncoding>-Objekt zurückgeben.  
  
|Member|Endianness|BOM|Fehlererkennung|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType>|Little-d|Ja|Nein (Ersatz Fall Back)|  
|<xref:System.Text.UTF32Encoding.%23ctor?displayProperty=nameWithType>|Little-d|Ja|Nein (Ersatz Fall Back)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Konfigurierbare|Konfigurierbare|Nein (Ersatz Fall Back)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Konfigurierbare|Konfigurierbare|Konfigurierbare|  
  
 Die <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode bestimmt, wie viele Bytes zum Codieren eines Satzes von Unicode-Zeichen führen, und die <xref:System.Text.UTF32Encoding.GetBytes%2A>-Methode führt die eigentliche Codierung aus.  
  
 Ebenso bestimmt die <xref:System.Text.UTF32Encoding.GetCharCount%2A> Methode, wie viele Zeichen zum Decodieren einer Bytefolge führen, und die Methoden <xref:System.Text.UTF32Encoding.GetChars%2A> und <xref:System.Text.UTF32Encoding.GetString%2A> führen die eigentliche Decodierung aus.  
  
 Für einen Encoder oder Decoder, der zum Speichern von Zustandsinformationen, die beim Codieren oder Decodieren von Daten, die umfasst mehrere Blöcke (z. B. String von 1 Mio. Zeichen, die in Segmenten von 100.000 Zeichen codiert wird) verwenden, können die <xref:System.Text.UTF32Encoding.GetEncoder%2A> und <xref:System.Text.UTF32Encoding.GetDecoder%2A> Eigenschaften bzw.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Verhalten <xref:System.Text.UTF32Encoding>-Objekten mit und ohne aktivierte Fehlererkennung veranschaulicht. Es wird ein Bytearray erstellt, dessen letzte vier Bytes ein ungültiges Ersatz Zeichenpaar darstellen. auf das hohe Ersatz Zeichen "u + D8FF" folgt ein u + 01FF, das außerhalb des Bereichs der unteren Surrogates liegt (0xDC00 bis 0xDFFF). Ohne Fehlererkennung verwendet der UTF32-Decoder den Ersatz Fall Back, um das ungültige Ersatz Zeichenpaar durch Ersatz Zeichen (U + FFFD) zu ersetzen.  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 Im folgenden Beispiel wird eine Zeichenfolge von Unicode-Zeichen in ein Bytearray codiert, indem ein <xref:System.Text.UTF32Encoding>-Objekt verwendet wird. Das Bytearray wird dann in eine Zeichenfolge decodiert, um zu veranschaulichen, dass kein Datenverlust vorliegt.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/snippet.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/snippet.vb#1)]  
  
 Im folgenden Beispiel wird dieselbe Zeichenfolge wie die vorherige verwendet, außer dass die codierten Bytes in eine Datei geschrieben und der Bytestream mit einer Byte Reihenfolge Markierung (BOM) vorangestellt wird. Anschließend wird die Datei auf zwei verschiedene Arten gelesen: als Textdatei mit einem <xref:System.IO.StreamReader> Objekt. und als Binärdatei. Erwartungsgemäß enthält weder die neu gelesene Zeichenfolge die BOM.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/bom1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Text.UnicodeEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.UTF32Encoding" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.UTF32Encoding" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt eine Instanz, die die Little-Endian-Byte Reihenfolge verwendet, eine Unicode-Byte Reihenfolge Markierung bereitstellt und keine Ausnahme auslöst, wenn eine ungültige Codierung erkannt wird.  
  
> [!CAUTION]
>  Aus Sicherheitsgründen sollten Sie die Fehlererkennung aktivieren, indem Sie den <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29>-Konstruktor aufrufen und das `throwOnInvalidCharacters`-Argument auf `true`festlegen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Byte Reihenfolge-Markierung für verschiedene <xref:System.Text.UTF32Encoding> Instanzen abgerufen und angezeigt.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF32Encoding : bool * bool -&gt; System.Text.UTF32Encoding" Usage="new System.Text.UTF32Encoding (bigEndian, byteOrderMark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian"><see langword="true" /> to use the big endian byte order (most significant byte first), or <see langword="false" /> to use the little endian byte order (least significant byte first).</param>
        <param name="byteOrderMark"><see langword="true" /> to specify that a Unicode byte order mark is provided; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.UTF32Encoding" /> class. Parameters specify whether to use the big endian byte order and whether the <see cref="M:System.Text.UTF32Encoding.GetPreamble" /> method returns a Unicode byte order mark.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt eine-Instanz, die keine Ausnahme auslöst, wenn eine ungültige Codierung erkannt wird.  
  
> [!CAUTION]
>  Aus Sicherheitsgründen sollten Sie die Fehlererkennung aktivieren, indem Sie den <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29>-Konstruktor aufrufen und das `throwOnInvalidCharacters`-Argument auf `true`festlegen.  
  
## Examples  
 Im folgenden Beispiel wird die Byte Reihenfolge-Markierung für verschiedene <xref:System.Text.UTF32Encoding> Instanzen abgerufen und angezeigt.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidCharacters As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF32Encoding : bool * bool * bool -&gt; System.Text.UTF32Encoding" Usage="new System.Text.UTF32Encoding (bigEndian, byteOrderMark, throwOnInvalidCharacters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidCharacters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian"><see langword="true" /> to use the big endian byte order (most significant byte first), or <see langword="false" /> to use the little endian byte order (least significant byte first).</param>
        <param name="byteOrderMark"><see langword="true" /> to specify that a Unicode byte order mark is provided; otherwise, <see langword="false" />.</param>
        <param name="throwOnInvalidCharacters"><see langword="true" /> to specify that an exception should be thrown when an invalid encoding is detected; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.UTF32Encoding" /> class. Parameters specify whether to use the big endian byte order, whether to provide a Unicode byte order mark, and whether to throw an exception when an invalid encoding is detected.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `throwOnInvalidCharacters` `true`ist, löst eine Methode, die eine ungültige Byte Sequenz erkennt, <xref:System.ArgumentException?displayProperty=nameWithType>aus. Andernfalls löst die Methode keine Ausnahme aus, und die ungültige Sequenz wird ignoriert.  
  
> [!CAUTION]
>  Aus Sicherheitsgründen sollten Sie die Fehlererkennung aktivieren, indem Sie den <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29>-Konstruktor aufrufen und das `throwOnInvalidCharacters`-Argument auf `true`festlegen.
  
## Examples  
 Im folgenden Beispiel wird das Verhalten von <xref:System.Text.UTF32Encoding>mit aktivierter Fehlererkennung und ohne veranschaulicht.  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uTF32Encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The <see cref="T:System.Object" /> to compare with the current object.</param>
        <summary>Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Text.UTF32Encoding" /> object.</summary>
        <returns><see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.UTF32Encoding" /> and is equal to the current object; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei <xref:System.Text.UTF32Encoding> Objekte werden als gleich betrachtet, wenn alle der folgenden Bedingungen zutreffen:  
  
-   Beide-Objekte verwenden die gleiche Byte Reihenfolge.  
  
-   Beide-Objekte stellen die Byte Reihenfolge-Marke oder beides nicht bereit.  
  
-   Beide Objekte verwenden denselben EncoderFallback.  
  
-   Beide Objekte verwenden denselben Decoder-Fallback.  
  
   
  
## Examples  
 Im folgenden Beispiel werden <xref:System.Text.UTF32Encoding> Objekte mit unterschiedlichen Parameterwerten erstellt und dann auf Gleichheit überprüft.  
  
 [!code-cpp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calculates the number of bytes produced by encoding a set of characters.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="uTF32Encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The <see cref="T:System.String" /> containing the set of characters to encode.</param>
        <summary>Calculates the number of bytes produced by encoding the characters in the specified <see cref="T:System.String" />.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF32Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen der Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Bytefolge, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers, und die Anzahl der Bytes in der Präambel wird nicht in dem Wert widergespiegelt, der von der <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Methoden <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> und <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> aufgerufen, um die maximale und tatsächliche Anzahl von Bytes zu berechnen, die zum Codieren einer Zeichenfolge erforderlich sind. Es zeigt auch die tatsächliche Anzahl von Bytes an, die zum Speichern eines Bytestreams mit einer Byte Reihenfolge-Marke erforderlich ist.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="s" /> contains an invalid sequence of characters.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF32Encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A pointer to the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF32Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, nennen Sie den <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Die <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie in einer Datei oder einem Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen einer Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Folge von Bytes, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers, und die Anzahl der Bytes in der Präambel wird nicht in dem Wert wiedergegeben, der von der <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode zurückgegeben wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> is less than zero.  
  
-or- 
The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="uTF32Encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="index">The index of the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>Calculates the number of bytes produced by encoding a set of characters from the specified character array.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF32Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie in einer Datei oder einem Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen einer Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Folge von Bytes, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers, und die Anzahl der Bytes in der Präambel wird nicht in dem Wert wiedergegeben, der von der <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array mit einem lateinischen groß-und Kleinbuchstaben aufgefüllt und die <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Methode aufgerufen, um die Anzahl von Bytes zu bestimmen, die zum Codieren der Zeichen für Lateinische Kleinbuchstaben benötigt werden. Diese Informationen werden dann zusammen mit der Gesamtanzahl der benötigten Bytes angezeigt, wenn eine Byte Reihenfolge-Markierung hinzugefügt wird. Diese Zahl wird mit dem Wert verglichen, der von der <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode zurückgegeben wird, die die maximale Anzahl von Bytes angibt, die zum Codieren der lateinischen Kleinbuchstaben erforderlich sind. Im folgenden Beispiel wird ein Array mit einer Kombination aus griechischen und kyrillischen Zeichen aufgefüllt und die <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Methode aufgerufen, um die Anzahl von Bytes zu bestimmen, die zum Codieren der kyrillischen Zeichen benötigt werden. Diese Informationen werden dann zusammen mit der Gesamtanzahl der benötigten Bytes angezeigt, wenn eine Byte Reihenfolge-Markierung hinzugefügt wird. Diese Zahl wird mit dem Wert verglichen, der von der <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>-Methode zurückgegeben wird, die die maximale Anzahl von Bytes angibt, die zum Codieren der kyrillischen Zeichen benötigt werden.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> or <paramref name="count" /> is less than zero.  
  
-or- 
 <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.  
  
-or- 
The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Encodes a set of characters into a sequence of bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF32Encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A pointer to the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">A pointer to the location at which to start writing the resulting sequence of bytes.</param>
        <param name="byteCount">The maximum number of bytes to write.</param>
        <summary>Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</summary>
        <returns>The actual number of bytes written at the location indicated by the <paramref name="bytes" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF32Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwendet die Anwendung die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF32Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF32Encoding.GetEncoder%2A> Methode bzw.  
  
> [!IMPORTANT]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen einer Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Folge von Bytes, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers. Die <xref:System.Text.UTF32Encoding.GetBytes%2A>-Methode stellt dem Anfang einer Sequenz codierter Bytes keine Präambel voran.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> is <see langword="null" />.  
  
-or- 
 <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.  
  
-or- 
 <paramref name="byteCount" /> is less than the resulting number of bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="uTF32Encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="charIndex">The index of the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
        <param name="byteIndex">The index at which to start writing the resulting sequence of bytes.</param>
        <summary>Encodes a set of characters from the specified character array into the specified byte array.</summary>
        <returns>The actual number of bytes written into <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF32Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwendet die Anwendung die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF32Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF32Encoding.GetEncoder%2A> Methode bzw.  
  
> [!IMPORTANT]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen einer Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Folge von Bytes, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers. Die <xref:System.Text.UTF32Encoding.GetBytes%2A>-Methode stellt dem Anfang einer Sequenz codierter Bytes keine Präambel voran.
  
## Examples  
 Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die zum Codieren von drei Zeichen aus einem Zeichen Array erforderlich sind. Anschließend werden die Zeichen codiert und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/VB/GetBytes_CharArr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> is <see langword="null" />.  
  
-or- 
 <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.  
  
-or- 
 <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.  
  
-or- 
 <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.  
  
-or- 
 <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="uTF32Encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">The <see cref="T:System.String" /> containing the set of characters to encode.</param>
        <param name="charIndex">The index of the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
        <param name="byteIndex">The index at which to start writing the resulting sequence of bytes.</param>
        <summary>Encodes a set of characters from the specified <see cref="T:System.String" /> into the specified byte array.</summary>
        <returns>The actual number of bytes written into <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF32Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwendet die Anwendung die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF32Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF32Encoding.GetEncoder%2A> Methode bzw.  
  
> [!IMPORTANT]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, wenn Sie als Datei oder als Stream gespeichert werden, können Sie einem Stream codierter Bytes eine Präambel als Präfix voranstellen. Das Einfügen einer Präambel am Anfang eines Bytestreams (z. b. am Anfang einer Folge von Bytes, die in eine Datei geschrieben werden soll) ist die Verantwortung des Entwicklers. Die <xref:System.Text.UTF32Encoding.GetBytes%2A>-Methode stellt dem Anfang einer Sequenz codierter Bytes keine Präambel voran.
  
## Examples  
 Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die zum Codieren einer Zeichenfolge erforderlich sind. Anschließend wird die Zeichenfolge codiert und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> is <see langword="null" />.  
  
-or- 
 <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.  
  
-or- 
 <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.  
  
-or- 
 <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="s" /> contains an invalid sequence of characters.  
  
-or- 
 <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calculates the number of characters produced by decoding a sequence of bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF32Encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding.GetCharCount%2A> berechnet die genaue Array Größe, die für die <xref:System.Text.UTF32Encoding.GetChars%2A>-Methode erforderlich ist, um die resultierenden Zeichen zu speichern. Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>-Methode aufzurufen. Die <xref:System.Text.UTF32Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> is less than zero.  
  
-or- 
The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="uTF32Encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.UTF32Encoding.GetCharCount%2A>-Methode berechnet die genaue Array Größe, die für die <xref:System.Text.UTF32Encoding.GetChars%2A>-Methode erforderlich ist, um die resultierenden Zeichen zu speichern. Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>-Methode aufzurufen. Die <xref:System.Text.UTF32Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Bytearray codiert und dann in ein Zeichen Array decodiert.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> or <paramref name="count" /> is less than zero.  
  
-or- 
 <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.  
  
-or- 
The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodes a sequence of bytes into a set of characters.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF32Encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to the first byte to decode.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <param name="chars">A pointer to the location at which to start writing the resulting set of characters.</param>
        <param name="charCount">The maximum number of characters to write.</param>
        <summary>Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</summary>
        <returns>The actual number of characters written at the location indicated by <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF32Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, müssen Sie die <xref:System.Text.UTF32Encoding.GetCharCount%2A>-Methode aufzurufen. Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>-Methode aufzurufen. Die <xref:System.Text.UTF32Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Wenn der zu decodierte Byte Bereich die Byte Reihenfolge-Marke (Byte Order Mark, BOM) einschließt und das Bytearray von einer Methode eines nicht-BOM-fähigen Typs zurückgegeben wurde, ist das Zeichen U + FFFE in dem von dieser Methode zurückgegebenen Zeichen Array enthalten. Sie können es entfernen, indem Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufrufen.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwendet die Anwendung die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF32Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF32Encoding.GetEncoder%2A> Methode bzw.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> is <see langword="null" />.  
  
-or- 
 <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.  
  
-or- 
 <paramref name="charCount" /> is less than the resulting number of characters.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="uTF32Encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="byteIndex">The index of the first byte to decode.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <param name="chars">The character array to contain the resulting set of characters.</param>
        <param name="charIndex">The index at which to start writing the resulting set of characters.</param>
        <summary>Decodes a sequence of bytes from the specified byte array into the specified character array.</summary>
        <returns>The actual number of characters written into <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF32Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, müssen Sie die <xref:System.Text.UTF32Encoding.GetCharCount%2A>-Methode aufzurufen. Um die maximale Array Größe zu berechnen, müssen Sie die <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>-Methode aufzurufen. Die <xref:System.Text.UTF32Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Wenn der zu decodierte Byte Bereich die Byte Reihenfolge-Marke (Byte Order Mark, BOM) einschließt und das Bytearray von einer Methode eines nicht-BOM-fähigen Typs zurückgegeben wurde, ist das Zeichen U + FFFE in dem von dieser Methode zurückgegebenen Zeichen Array enthalten. Sie können es entfernen, indem Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufrufen.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, verwendet die Anwendung die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF32Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF32Encoding.GetEncoder%2A> Methode bzw.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Bytearray codiert und dann in ein Zeichen Array decodiert.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> is <see langword="null" />.  
  
-or- 
 <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.  
  
-or- 
 <paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.  
  
-or- 
 <paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.  
  
-or- 
 <paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="uTF32Encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtains a decoder that converts a UTF-32 encoded sequence of bytes into a sequence of Unicode characters.</summary>
        <returns>A <see cref="T:System.Text.Decoder" /> that converts a UTF-32 encoded sequence of bytes into a sequence of Unicode characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>-Methode konvertiert sequenzielle Block von Bytes auf eine Weise, die der <xref:System.Text.UTF32Encoding.GetChars%2A>-Methode ähnelt, in sequenzielle Zeichenblöcke. Eine <xref:System.Text.Decoder> behält jedoch Zustandsinformationen zwischen Aufrufen bei, damit Byte Sequenzen, die Blöcke spannen, ordnungsgemäß decodiert werden können. Der <xref:System.Text.Decoder> behält auch nachfolgende Bytes am Ende der Datenblöcke bei und verwendet die nachfolgenden Bytes im nächsten Decodierungs Vorgang. Aus diesem Grund sind <xref:System.Text.UTF32Encoding.GetDecoder%2A> und <xref:System.Text.UTF32Encoding.GetEncoder%2A> für Netzwerkübertragungs-und Datei Vorgänge nützlich, da diese Vorgänge häufig Datenblöcke anstelle eines gesamten Datenstroms behandeln.  
  
 Wenn die Fehlererkennung aktiviert ist, d. h. der `throwOnInvalidCharacters`-Parameter des Konstruktors auf `true`festgelegt wurde, wird die Fehlererkennung auch in der <xref:System.Text.Decoder> aktiviert, die von dieser Methode zurückgegeben wird. Wenn die Fehlererkennung aktiviert ist und eine ungültige Sequenz gefunden wird, ist der Status des Decoders nicht definiert, und die Verarbeitung muss beendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Encoder und ein Decoder verwendet, um eine Zeichenfolge in ein Bytearray zu codieren und anschließend die Bytes in ein Zeichen Array zu decodieren.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="uTF32Encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtains an encoder that converts a sequence of Unicode characters into a UTF-32 encoded sequence of bytes.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> that converts a sequence of Unicode characters into a UTF-32 encoded sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>-Methode konvertiert sequenzielle Zeichenblöcke in eine Weise, die der <xref:System.Text.UTF32Encoding.GetBytes%2A>-Methode ähnelt. Eine <xref:System.Text.Encoder> verwaltet jedoch Zustandsinformationen zwischen aufrufen, sodass Sie Zeichen folgen, die Blöcke spannen, ordnungsgemäß codieren können. Der <xref:System.Text.Encoder> behält auch nachfolgende Zeichen am Ende der Datenblöcke bei und verwendet die nachfolgenden Zeichen im nächsten Codierungs Vorgang. Beispielsweise kann ein Datenblock mit einem nicht übereinstimmenden hohen Ersatz Zeichen enden, und das entsprechende niedrige Ersatz Zeichen kann sich im nächsten Datenblock befinden. Aus diesem Grund sind <xref:System.Text.UTF32Encoding.GetDecoder%2A> und <xref:System.Text.UTF32Encoding.GetEncoder%2A> für Netzwerkübertragungs-und Datei Vorgänge nützlich, da diese Vorgänge häufig Datenblöcke anstelle eines gesamten Datenstroms behandeln.  
  
 Wenn die Fehlererkennung aktiviert ist, d. h. der `throwOnInvalidCharacters`-Parameter des Konstruktors auf `true`festgelegt wurde, wird die Fehlererkennung auch in der <xref:System.Text.Encoder> aktiviert, die von dieser Methode zurückgegeben wird. Wenn die Fehlererkennung aktiviert ist und eine ungültige Sequenz gefunden wird, ist der Status des Encoders nicht definiert, und die Verarbeitung muss beendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Encoder und ein Decoder verwendet, um eine Zeichenfolge in ein Bytearray zu codieren und anschließend die Bytes in ein Zeichen Array zu decodieren.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Grundlegendes zu Codierungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uTF32Encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for the current instance.</summary>
        <returns>The hash code for the current <see cref="T:System.Text.UTF32Encoding" /> object.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="uTF32Encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">The number of characters to encode.</param>
        <summary>Calculates the maximum number of bytes produced by encoding the specified number of characters.</summary>
        <returns>The maximum number of bytes produced by encoding the specified number of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF32Encoding.GetBytes%2A> zum Speichern der resultierenden Bytes benötigt, wird die <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> ist eine Zahl mit dem ungünstigsten Fall, einschließlich des ungünstigsten Falls für den aktuell ausgewählten <xref:System.Text.EncoderFallback>. Wenn ein Fall Back mit einer potenziell großen Zeichenfolge ausgewählt wird, können <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> große Werte zurückgeben.  
  
 In den meisten Fällen gibt diese Methode für kleine Zeichen folgen angemessene Zahlen zurück. Bei großen Zeichen folgen müssen Sie möglicherweise zwischen der Verwendung sehr großer Puffer und dem Abfangen von Fehlern wählen, wenn ein sinnvoller Puffer überschritten wird. Möglicherweise möchten Sie auch einen anderen Ansatz in Erwägung gezogen und <xref:System.Text.UTF32Encoding.GetByteCount%2A> oder <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>verwenden.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> hat keine Beziehung zu <xref:System.Text.UTF32Encoding.GetChars%2A>. Wenn Sie eine ähnliche Funktion benötigen, die mit <xref:System.Text.UTF32Encoding.GetChars%2A>verwendet werden soll, verwenden Sie <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` ist nicht notwendigerweise derselbe Wert wie `N* GetMaxByteCount(1)`.  
  
## Examples  
 Im folgenden Beispiel wird die Anzahl der Bytes festgelegt, die zum Codieren einer Zeichenfolge erforderlich sind. Anschließend wird die Zeichenfolge codiert und die resultierenden Bytes angezeigt.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> is less than zero.  
  
-or- 
The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="uTF32Encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">The number of bytes to decode.</param>
        <summary>Calculates the maximum number of characters produced by decoding the specified number of bytes.</summary>
        <returns>The maximum number of characters produced by decoding the specified number of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die genaue Array Größe zu berechnen, die <xref:System.Text.UTF32Encoding.GetChars%2A> zum Speichern der resultierenden Zeichen benötigt, wird die <xref:System.Text.UTF32Encoding.GetCharCount%2A>-Methode aufgerufen. Um die maximale Array Größe zu berechnen, wird die <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>-Methode aufgerufen. Die <xref:System.Text.UTF32Encoding.GetCharCount%2A>-Methode weist im Allgemeinen weniger Arbeitsspeicher zu, während die <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>-Methode im Allgemeinen schneller ausgeführt wird.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> ist eine Zahl mit dem ungünstigsten Fall, einschließlich des ungünstigsten Falls für den aktuell ausgewählten <xref:System.Text.DecoderFallback>. Wenn ein Fall Back mit einer potenziell großen Zeichenfolge ausgewählt wird, können <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> große Werte zurückgeben.  
  
 In den meisten Fällen gibt diese Methode für kleine Zeichen folgen angemessene Zahlen zurück. Bei großen Zeichen folgen müssen Sie möglicherweise zwischen der Verwendung sehr großer Puffer und dem Abfangen von Fehlern wählen, wenn ein sinnvoller Puffer überschritten wird. Möglicherweise möchten Sie auch einen anderen Ansatz in Erwägung gezogen und <xref:System.Text.UTF32Encoding.GetCharCount%2A> oder <xref:System.Text.Decoder.Convert%2A>verwenden.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> hat keine Beziehung zu <xref:System.Text.UTF32Encoding.GetBytes%2A>. Wenn Sie eine ähnliche Funktion benötigen, die mit <xref:System.Text.UTF32Encoding.GetBytes%2A>verwendet werden soll, verwenden Sie <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` ist nicht notwendigerweise derselbe Wert wie `N* GetMaxCharCount(1)`.  
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in ein Bytearray codiert und dann in ein Zeichen Array decodiert.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> is less than zero.  
  
-or- 
The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="uTF32Encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a Unicode byte order mark encoded in UTF-32 format, if the <see cref="T:System.Text.UTF32Encoding" /> object is configured to supply one.</summary>
        <returns>A byte array containing the Unicode byte order mark, if the <see cref="T:System.Text.UTF32Encoding" /> object is configured to supply one. Otherwise, this method returns a zero-length byte array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Text.UTF32Encoding>-Objekt kann eine Präambel bereitstellen, bei der es sich um ein Bytearray handelt, dem die Byte Sequenz vorangestellt werden kann, die sich aus dem Codierungsprozess ergibt. Wenn eine Sequenz codierter Bytes mit einer Byte Reihenfolge-Markierung (Code Punkte u + 0000 U + FEFF) vorangestellt ist, kann der Decoder die Byte Reihenfolge und das Transformations Format (UTF) bestimmen. Die Unicode-Byte Reihenfolge Markierung (BOM) wird wie folgt serialisiert (in Hexadezimal):  
  
-   Big-Endian-Byte Reihenfolge: 00 00 FE FF  
  
-   Little-Endian-Byte Reihenfolge: FF FE 00 00  
  
 Sie können ein <xref:System.Text.UTF32Encoding> Objekt instanziieren, dessen <xref:System.Text.UTF32Encoding.GetPreamble%2A> Methode eine gültige BOM auf folgende Weise zurückgibt:  
  
-   Durch Abrufen des <xref:System.Text.UTF32Encoding> Objekts, das von der <xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird.  
  
-   Durch Aufrufen des Parameter losen <xref:System.Text.UTF32Encoding.%23ctor> Konstruktors, um ein <xref:System.Text.UTF32Encoding> Objekt zu instanziieren.  
  
-   Durch Bereitstellen von `true` als Wert des `byteOrderMark` Arguments für die <xref:System.Text.UTF32Encoding.%23ctor%2A> und <xref:System.Text.UTF32Encoding.%23ctor%2A> Konstruktoren.  
  
 Es wird empfohlen, dass Sie die BOM verwenden, da Sie eine Codierung einer Codierung für Dateien bereitstellt, die andernfalls den Verweis auf das <xref:System.Text.UTF32Encoding> Objekt verloren haben, z. b. nicht markierte oder nicht ordnungsgemäß markierte Webdaten, oder zufällige Textdateien, die gespeichert wurden, wenn ein Unternehmen über keine internationalen Probleme oder andere Daten verfügte. Häufig können Benutzer Probleme vermieden werden, wenn die Daten konsistent und ordnungsgemäß gekennzeichnet sind.  
  
 Bei Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant. Sie kann jedoch verwendet werden, um einem Server zu helfen, den richtigen Codierungs Header zu senden. Alternativ kann es als Fall Back für den Fall verwendet werden, dass die Codierung andernfalls verloren geht.  
  
 Es gibt einige Nachteile bei der Verwendung einer BOM. Beispielsweise kann das Einschränken der Datenbankfelder, die eine BOM verwenden, schwierig sein. Die Verkettung von Dateien kann auch ein Problem darstellen, z. b. wenn Dateien so zusammengeführt werden, dass ein unnötiges Zeichen in der Mitte der Daten enden kann. Trotz der wenigen Nachteile wird die Verwendung einer BOM dringend empfohlen.  
  
 Weitere Informationen zur Byte Reihenfolge und zur Byte Reihenfolge-Markierung finden Sie im Unicode-Standard auf der [Unicode-Homepage](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!IMPORTANT]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie codierte Bytes mit einer Präambel versehen. Beachten Sie, dass die <xref:System.Text.UTF32Encoding.GetBytes%2A>-Methode einer Sequenz codierter Bytes keine BOM voranstellt. das Bereitstellen einer BOM am Anfang eines entsprechenden Bytestreams ist die Verantwortung des Entwicklers.  
  
## Examples  
 Im folgenden Codebeispiel wird die Byte Reihenfolge-Markierung für verschiedene <xref:System.Text.UTF32Encoding> Instanzen abgerufen und angezeigt.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 Im folgenden Beispiel werden zwei <xref:System.Text.UTF32Encoding>-Objekte instanziiert, wobei der erste keine BOM und der zweite-Wert bereitstellt. Anschließend wird die <xref:System.Text.UTF32Encoding.GetPreamble%2A>-Methode aufgerufen, um die BOM in eine Datei zu schreiben, bevor eine UTF-32-codierte Zeichenfolge geschrieben wird. Wie die Ausgabe des Beispiels zeigt, weist die Datei, die die Bytes aus dem zweiten Encoder speichert, vier weitere Bytes auf, die der erste ist.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/getpreamble1.vb#2)]  
  
 Sie können die Dateien auch mit dem `fc`-Befehl in einem Konsolenfenster vergleichen, oder Sie können die Dateien in einem Text-Editor untersuchen, der einen Hexadezimal Ansichtsmodus enthält. Beachten Sie, dass die BOM nicht angezeigt wird, wenn die Datei in einem Editor geöffnet wird, der UTF-32 unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="uTF32Encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>Decodes a range of bytes from a byte array into a string.</summary>
        <returns>A string that contains the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Fehlererkennung bewirkt eine ungültige Sequenz, dass diese Methode eine <xref:System.ArgumentException>auslöst. Ohne Fehlererkennung werden ungültige Sequenzen ignoriert, und es wird keine Ausnahme ausgelöst.  
  
 Wenn der zu decodierte Byte Bereich die Byte Reihenfolge-Marke (Byte Order Mark, BOM) einschließt und das Bytearray von einer Methode eines nicht-BOM-fähigen Typs zurückgegeben wurde, ist das Zeichen U + FFFE in dem von dieser Methode zurückgegebenen Zeichen Array enthalten. Sie können es entfernen, indem Sie die <xref:System.String.TrimStart%2A?displayProperty=nameWithType>-Methode aufrufen.  
  
 Daten, die konvertiert werden sollen, z. b. aus einem Stream gelesene Daten, sind möglicherweise nur in sequenziellen Blöcken verfügbar. In diesem Fall oder wenn die Menge der Daten so umfangreich ist, dass er in kleinere Blöcke aufgeteilt werden muss, sollte die Anwendung verwenden die <xref:System.Text.Decoder> oder die <xref:System.Text.Encoder> gebotenen der <xref:System.Text.UTF32Encoding.GetDecoder%2A> Methode oder die <xref:System.Text.UTF32Encoding.GetEncoder%2A> Methode bzw.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in zwei Byte Arrays codiert, eine in Little-Endian-Reihenfolge und die andere in Big-Endian-Reihenfolge. Anschließend werden die Bytes wieder in eine Zeichenfolge decodiert.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/getstring.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString.vb#1)]  
  
 Im folgenden Beispiel wird ein Array initialisiert, indem die <xref:System.Text.UTF32Encoding.GetByteCount%2A>-Methode aufgerufen wird, um genau zu bestimmen, wie viele Bytes für eine codierte Zeichenfolge erforderlich sind, und dann die Größe der Byte Reihenfolge-Marke (BOM) hinzugefügt Im Beispiel wird dann die <xref:System.Text.UTF32Encoding.GetPreamble%2A>-Methode aufgerufen, um die BOM im Array zu speichern, bevor die <xref:System.Text.UTF32Encoding.GetBytes%2A>-Methode aufgerufen wird, um die codierten Bytes im Array zu speichern. Im Beispiel wird dann die <xref:System.Text.UTF32Encoding.GetString%2A>-Methode aufgerufen, um die Zeichenfolge zu decodieren.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/GetString1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString1.vb#2)]  
  
 Beachten Sie, dass die decodierte Zeichenfolge in diesem Fall von der ursprünglichen Zeichenfolge abweicht, da Sie mit einer 32-Bit-Byte Reihenfolge Markierung u + FFFE u + 0000 beginnt. Dies bedeutet, dass die beiden Zeichen folgen als ungleich verglichen werden und dass, wenn die Zeichenfolge ausgegeben wird, die BOM als Ersatz Zeichen "?" angezeigt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> or <paramref name="count" /> is less than zero.  
  
-or- 
 <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for a complete explanation) 
-and- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public override ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.UTF32Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.UTF32Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a Unicode byte order mark encoded in UTF-32 format, if this object is configured to supply one.</summary>
        <value>Eine Byte Spanne, die die Unicode-Byte Reihenfolge Markierung enthält, wenn dieses Objekt für die Bereitstellung eines solchen konfiguriert ist. andernfalls eine Standard Spanne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Text.UTF32Encoding>-Objekt kann eine Präambel bereitstellen, bei der es sich um einen Byte Bereich handelt, dem die Byte Sequenz vorangestellt werden kann, die sich aus dem Codierungsprozess ergibt. Wenn eine Sequenz codierter Bytes mit einer Byte Reihenfolge-Markierung (Code Punkte `U+0000` `U+FEFF`) vorangestellt ist, kann der Decoder die Byte Reihenfolge und das Transformations Format (UTF) bestimmen. Die Unicode-Byte Reihenfolge Markierung (BOM) wird wie folgt serialisiert (in Hexadezimal):  
  
-   Big-Endian-Byte Reihenfolge: `00 00 FE FF`  
  
-   Little-Endian-Byte Reihenfolge: `FF FE 00 00`  
  
 Sie können ein <xref:System.Text.UTF32Encoding> Objekt instanziieren, dessen <xref:System.Text.UTF32Encoding.Preamble>-Eigenschaft eine gültige BOM auf folgende Weise ist:  
  
-   Durch Abrufen des <xref:System.Text.UTF32Encoding> Objekts, das von der <xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird.  
  
-   Durch Aufrufen des Parameter losen <xref:System.Text.UTF32Encoding.%23ctor> Konstruktors, um ein <xref:System.Text.UTF32Encoding> Objekt zu instanziieren.  
  
-   Durch Bereitstellen von `true` als Wert des `byteOrderMark` Arguments für die <xref:System.Text.UTF32Encoding.%23ctor%2A> und <xref:System.Text.UTF32Encoding.%23ctor%2A> Konstruktoren.  
  
 Es wird empfohlen, die BOM zu verwenden, da Sie eine bestimmte Identifizierung einer Codierung für Dateien bereitstellt, die andernfalls einen Verweis auf das <xref:System.Text.UTF32Encoding> Objekt verloren haben (z. b. nicht markierte oder nicht ordnungsgemäß markierte Webdaten), oder zufällige Textdateien, die gespeichert wurden, wenn ein Unternehmen über keine internationalen Probleme oder andere Daten verfügte. Häufig können Benutzer Probleme vermieden werden, wenn die Daten konsistent und ordnungsgemäß gekennzeichnet sind.  
  
 Bei Standards, die einen Codierungstyp bereitstellen, ist eine BOM etwas redundant. Sie kann jedoch verwendet werden, um einem Server zu helfen, den richtigen Codierungs Header zu senden. Alternativ kann es als Fall Back für den Fall verwendet werden, dass die Codierung andernfalls verloren geht.  
  
 Es gibt einige Nachteile bei der Verwendung einer BOM. Beispielsweise kann das Einschränken der Datenbankfelder, die eine BOM verwenden, schwierig sein. Die Verkettung von Dateien kann auch ein Problem darstellen, z. b. wenn Dateien so zusammengeführt werden, dass ein unnötiges Zeichen in der Mitte der Daten enden kann. Trotz der wenigen Nachteile wird die Verwendung einer BOM dringend empfohlen.  
  
 Weitere Informationen zur Byte Reihenfolge und zur Byte Reihenfolge-Markierung finden Sie im Unicode-Standard auf der [Unicode-Homepage](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!IMPORTANT]
>  Um sicherzustellen, dass die codierten Bytes ordnungsgemäß decodiert werden, sollten Sie codierte Bytes mit einer Präambel versehen. Beachten Sie, dass die <xref:System.Text.UTF32Encoding.GetBytes%2A>-Methode einer Sequenz codierter Bytes keine BOM voranstellt. das Bereitstellen einer BOM am Anfang eines entsprechenden Bytestreams ist die Verantwortung des Entwicklers.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
