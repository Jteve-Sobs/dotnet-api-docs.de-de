<Type Name="ObjectContext" FullName="System.Data.Objects.ObjectContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e84d040793d5a046dc9222b6a729560a3610c601" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78687666" /></Metadata><TypeSignature Language="C#" Value="public class ObjectContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ObjectContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.ObjectContext" />
  <TypeSignature Language="VB.NET" Value="Public Class ObjectContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectContext : IDisposable" />
  <TypeSignature Language="F#" Value="type ObjectContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt Funktionen bereit, mit denen Entitätsdaten als Objekte abgefragt und bearbeitet werden können.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  Die <xref:System.Data.Objects.ObjectContext>-Klasse ist nicht threadsicher. Die Integrität von Datenobjekten in einem <xref:System.Data.Objects.ObjectContext> kann in Multithread-Szenarien nicht sichergestellt werden.

 Die <xref:System.Data.Objects.ObjectContext>-Klasse ist die primäre Klasse für die Interaktion mit Daten als Objekte, bei denen es sich um Instanzen von Entitäts Typen handelt, die in einem konzeptionellen Modell definiert sind. Eine Instanz der <xref:System.Data.Objects.ObjectContext>-Klasse dient zum Kapseln folgender Objekte:

-   Eine Verbindung zur Datenbank in Form eines <xref:System.Data.EntityClient.EntityConnection>-Objekts.

-   Metadaten zur Beschreibung des Modells in Form eines <xref:System.Data.Metadata.Edm.MetadataWorkspace>-Objekts.

-   Ein <xref:System.Data.Objects.ObjectStateManager>-Objekt zur Verwaltung der im Cache befindlichen Objekte.

 Wenn die Objektebene, die ein konzeptionelles Modell darstellt, durch die Entity Data Model-Tools generiert wird, wird die-Klasse, die die <xref:System.Data.Metadata.Edm.EntityContainer> für das Modell darstellt, vom <xref:System.Data.Objects.ObjectContext>abgeleitet.



## Examples
 Dieses Beispiel basiert auf den [Microsoft SQL Server Product Samples: Database](https://archive.codeplex.com/?p=msftdbprodsamples). Das folgende Beispiel zeigt die Vorgehensweise beim Erstellen eines <xref:System.Data.Objects.ObjectContext>.

 [!code-csharp[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectcontext)]
 [!code-vb[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectcontext)]

 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Abfragen von Daten als Objekte (Entity Framework)</related>
    <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.Objects.ObjectContext" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (System.Data.EntityClient.EntityConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.EntityClient.EntityConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.Data.EntityClient.EntityConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As EntityConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectContext(System::Data::EntityClient::EntityConnection ^ connection);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : System.Data.EntityClient.EntityConnection -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext connection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.EntityClient.EntityConnection" />
      </Parameters>
      <Docs>
        <param name="connection">Ein <see cref="T:System.Data.EntityClient.EntityConnection" />, das Verweise auf das Modell und die Datenquellenverbindung enthält.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.Objects.ObjectContext" />-Klasse mit der angegebenen Verbindung. Während der Konstruktion wird der Metadaten-Arbeitsbereich aus dem <see cref="T:System.Data.EntityClient.EntityConnection" />-Objekt extrahiert.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connection" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="connection" /> ist ungültig.

- oder -

Der Metadaten-Arbeitsbereich ist ungültig.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (string connectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectContext(System::String ^ connectionString);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext connectionString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Die Verbindungszeichenfolge, die auch den Zugriff auf die Metadateninformationen bereitstellt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.Objects.ObjectContext" />-Klasse mit der angegebenen Verbindungszeichenfolge und dem standardmäßigen Entitätencontainernamen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Der `connectionString` ist eine Zeichenfolge, die Informationen enthält, die für den Zugriff auf ein konzeptionelles Modell und das Herstellen einer Verbindung mit einer Datenquelle erforderlich sind. Die <xref:System.Data.EntityClient.EntityConnectionStringBuilder>-Klasse kann zur ordnungsgemäßen Formatierung der Zeichenfolge verwendet werden.

 Die [Entity Data Model Tools](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb399249(v%3dvs.100)) generieren eine benannte Verbindungs Zeichenfolge, die in der Konfigurationsdatei der Anwendung gespeichert ist. Diese benannte Verbindungs Zeichenfolge kann anstelle des `connectionString`-Parameters angegeben werden, wenn die <xref:System.Data.Objects.ObjectContext>-Klasse instanziiert wird.



## Examples
 Das Beispiel in diesem Thema basiert auf den [Microsoft SQL Server Product Samples: Database](https://archive.codeplex.com/?p=msftdbprodsamples). Das Beispiel zeigt die Erstellung eines <xref:System.Data.Objects.ObjectContext>.

 [!code-csharp[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectcontext)]
 [!code-vb[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectcontext)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connectionString" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="connectionString" /> ist ungültig.

- oder -

Der Metadaten-Arbeitsbereich ist ungültig.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (System.Data.EntityClient.EntityConnection connection, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Data.EntityClient.EntityConnection connection, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.Data.EntityClient.EntityConnection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connection As EntityConnection, defaultContainerName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectContext(System::Data::EntityClient::EntityConnection ^ connection, System::String ^ defaultContainerName);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : System.Data.EntityClient.EntityConnection * string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext (connection, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.EntityClient.EntityConnection" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connection">Ein <see cref="T:System.Data.EntityClient.EntityConnection" />, das Verweise auf das Modell und die Datenquellenverbindung enthält.</param>
        <param name="defaultContainerName">Der Name des Standardentitätscontainers. Wenn <paramref name="defaultContainerName" /> mit dieser Methode festgelegt wird, ist die Eigenschaft schreibgeschützt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.Objects.ObjectContext" />-Klasse mit einer angegebenen Verbindung und einem angegebenen Entitätscontainernamen.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connection" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="connection" />, <paramref name="defaultContainerName" /> oder Metadatenarbeitsbereich ist ungültig.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (string connectionString, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string connectionString, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connectionString As String, defaultContainerName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectContext(System::String ^ connectionString, System::String ^ defaultContainerName);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : string * string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext (connectionString, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Die Verbindungszeichenfolge, die auch den Zugriff auf die Metadateninformationen bereitstellt.</param>
        <param name="defaultContainerName">Der Name des standardmäßigen Entitätencontainers. Wenn <paramref name="defaultContainerName" /> mit dieser Methode festgelegt wird, ist die Eigenschaft schreibgeschützt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.Objects.ObjectContext" />-Klasse mit einer angegebenen Verbindungszeichenfolge und einem angegebenen Entitätencontainernamen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Der `connectionString` ist eine Zeichenfolge, die Informationen enthält, die für den Zugriff auf ein konzeptionelles Modell und das Herstellen einer Verbindung mit einer Datenquelle erforderlich sind. Die <xref:System.Data.EntityClient.EntityConnectionStringBuilder>-Klasse kann zur ordnungsgemäßen Formatierung der Zeichenfolge verwendet werden.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connectionString" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="connectionString" />, <paramref name="defaultContainerName" /> oder Metadatenarbeitsbereich ist ungültig.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="AcceptAllChanges">
      <MemberSignature Language="C#" Value="public void AcceptAllChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptAllChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AcceptAllChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptAllChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptAllChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptAllChanges : unit -&gt; unit" Usage="objectContext.AcceptAllChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Übernimmt alle Änderungen, die an Objekten im Objektkontext vorgenommen werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Übernimmt die Änderungen an allen zugehörigen Einträgen im <xref:System.Data.Objects.ObjectStateManager>, sodass ihr anschließender Status unverändert oder getrennt ist.

 Diese Methode durchläuft alle <xref:System.Data.Objects.ObjectStateEntry>-Objekte innerhalb des <xref:System.Data.Objects.ObjectStateManager> mit Status "Added" oder "Modified" und legt dann den Status des Eintrags auf "Unchanged" fest. Die gelöschten Elemente werden getrennt.

 Wenn die <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>-Methode aufgerufen wurde und die <xref:System.Data.Objects.SaveOptions.AcceptAllChangesAfterSave> nicht angegeben wurde, muss der Benutzer die <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A>-Methode aufrufen. Die <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A>-Methode ist hilfreich, wenn eine Transaktion fehlgeschlagen ist und der Benutzer einen erneuten Versuch unternehmen möchte.

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="AddObject">
      <MemberSignature Language="C#" Value="public void AddObject (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddObject(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AddObject(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddObject (entitySetName As String, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddObject(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.AddObject : string * obj -&gt; unit" Usage="objectContext.AddObject (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Stellt den Namen der Entitätenmenge dar, der optional durch den Entitätencontainernamen qualifiziert werden kann.</param>
        <param name="entity">Das hinzuzufügende <see cref="T:System.Object" />.</param>
        <summary>Fügt dem Objektkontext ein Objekt hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Rufen Sie <xref:System.Data.Objects.ObjectContext.AddObject%2A> für den <xref:System.Data.Objects.ObjectContext> auf, um das Objekt dem Objektkontext hinzuzufügen. Dies ist der Fall, wenn das Objekt ein neues Objekt ist, das noch nicht in der Datenquelle vorhanden ist. Weitere Informationen finden Sie unter Anfügen [und trennen von Objekten](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).

 Objekte werden dem <xref:System.Data.Objects.ObjectStateManager> im Status <xref:System.Data.EntityState.Detached>, <xref:System.Data.EntityState.Deleted> oder <xref:System.Data.EntityState.Added> hinzugefügt.

 Bei Erstellung eines neuen Objekts, das mit einem anderen Objekt im Objektkontext verbunden ist, sollte das Objekt mit einer der folgenden Methoden hinzugefügt werden:

-   Rufen Sie die <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A>-Methode für die <xref:System.Data.Objects.DataClasses.EntityCollection%601> auf, und geben Sie das verbundene Objekt an. Dies gilt für 1:n- und m:n-Beziehungen.

-   Legen Sie die <xref:System.Data.Objects.DataClasses.EntityReference%601.Value%2A>-Eigenschaft des <xref:System.Data.Objects.DataClasses.EntityReference%601> auf das verbundene Objekt fest. Dies gilt für 1:1- und m:1-Beziehungen.

 Weitere Informationen finden Sie unter [erstellen, hinzufügen, ändern und Löschen von Objekten](https://msdn.microsoft.com/library/f76f1fad-c553-4b59-820b-89b3dec2fad1).

 Wenn sich das Objekt in einem getrennten Zustand befindet, darf es keine <xref:System.Data.EntityKey>haben.

 Die Regeln für das `entitySetName` Format lauten wie folgt:

-   Wenn die <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A>-Eigenschaft `null`ist, muss die `entitySetName` voll qualifiziert sein, wie in *\<Entitätencontainername >*. *\<Name der Entitätenmenge >*.

-   Wenn <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> nicht `null`ist, kann der `entitySetName` entweder *\<Entitätencontainername >* sein. *\<Name der Entitätenmenge >* oder *\<Name der Entitätenmenge >*.

 Wenn die `object` über eine <xref:System.Data.EntityKey> verfügt und `entitySetName` über einen Wert verfügt, muss die <xref:System.Data.Metadata.Edm.EntitySet> des Entitäts Schlüssels mit der <xref:System.Data.Metadata.Edm.EntitySet> identisch sein, die auf der Grundlage der `entitySetName` und des Entitätencontainernamens gefunden wurde.



## Examples
 Dieses Beispiel basiert auf den [Microsoft SQL Server Product Samples: Database](https://archive.codeplex.com/?p=msftdbprodsamples). Im Beispiel wird ein neues Produkt hinzugefügt und die Änderungen in der Datenbank gespeichert.

 [!code-csharp[DP ObjectServices Concepts#AddObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobject)]
 [!code-vb[DP ObjectServices Concepts#AddObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobject)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="entity" />-Parameter ist <see langword="null" />.

- oder -

Der <paramref name="entitySetName" /> qualifiziert nicht.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.AddObject(`0)" />
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyCurrentValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public TEntity ApplyCurrentValues&lt;TEntity&gt; (string entitySetName, TEntity currentEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEntity ApplyCurrentValues&lt;class TEntity&gt;(string entitySetName, !!TEntity currentEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyCurrentValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyCurrentValues(Of TEntity As Class) (entitySetName As String, currentEntity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class TEntity ApplyCurrentValues(System::String ^ entitySetName, TEntity currentEntity);" />
      <MemberSignature Language="F#" Value="member this.ApplyCurrentValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyCurrentValues (entitySetName, currentEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="currentEntity" Type="TEntity" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Der Entitätstyp des Objekts.</typeparam>
        <param name="entitySetName">Der Name der Entitätenmenge, der das Objekt angehört.</param>
        <param name="currentEntity">Das getrennte Objekt, das über Eigenschaftsaktualisierungen verfügt, die auf das ursprüngliche Objekt angewendet werden sollen. Der Entitätsschlüssel von <paramref name="currentEntity" /> muss zur <see cref="P:System.Data.Objects.ObjectStateEntry.EntityKey" />-Eigenschaft eines Eintrags in <see cref="T:System.Data.Objects.ObjectContext" /> passen.</param>
        <summary>Kopiert die Skalarwerte aus dem angegebenen Objekt in das Objekt im <see cref="T:System.Data.Objects.ObjectContext" />, das über den gleichen Schlüssel verfügt.</summary>
        <returns>Das aktualisierte Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A>-Methode wird verwendet, um an Objekten außerhalb der <xref:System.Data.Objects.ObjectContext>vorgenommene Änderungen zu übernehmen, z. b. getrennte Objekte, die von einem Webdienst empfangen werden. Die-Methode kopiert die skalaren Werte aus dem angegebenen-Objekt in das-Objekt im <xref:System.Data.Objects.ObjectContext>, das denselben Schlüssel aufweist. Sie können die <xref:System.Data.EntityKey> des getrennten-Objekts verwenden, um eine Instanz dieses Objekts aus der Datenquelle abzurufen. Weitere Informationen finden Sie unter Gewusst [wie: Zurückgeben eines bestimmten Objekts mithilfe des Schlüssels](https://msdn.microsoft.com/library/2e9902af-29b0-4e5d-92db-03dfe6ec49bd). Alle Werte, die sich von den ursprünglichen Werten des-Objekts unterscheiden, werden als geändert markiert. Beachten Sie, dass die-Methode die aktuellen Werte nicht auf die zugehörigen Objekte `currentEntity`anwendet.

 Wenn Sie ein Diagramm mit den aktuellen Werten haben und die ursprünglichen Werte anwenden möchten, wenden Sie <xref:System.Data.Objects.ObjectContext.ApplyOriginalValues%2A> Methode an.

 Sie können auch die <xref:System.Data.Objects.ObjectSet%601.ApplyCurrentValues%2A> der <xref:System.Data.Objects.ObjectSet%601>-oder <xref:System.Data.Objects.ObjectStateEntry.ApplyCurrentValues%2A>-Methode der <xref:System.Data.Objects.ObjectStateEntry>verwenden. Weitere Informationen finden Sie unter [Building N-Tier Applications](https://msdn.microsoft.com/library/9439d2ba-6b5f-44e8-be65-8a442d922cbb).

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entitySetName" /> oder <paramref name="current" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Data.Metadata.Edm.EntitySet" />-Element von <paramref name="entitySetName" /> stimmt nicht mit dem <see cref="T:System.Data.Metadata.Edm.EntitySet" />-Element des <see cref="T:System.Data.EntityKey" /> des Objekts überein.

- oder -

Das Objekt befindet sich nicht im <see cref="T:System.Data.Objects.ObjectStateManager" />-Zustand oder aber es befindet sich in einem <see cref="F:System.Data.EntityState.Detached" />-Zustand.

- oder -

Der Entitätsschlüssel des angegebenen Objekts ist ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="entitySetName" /> ist eine leere Zeichenfolge.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.ApplyCurrentValues(`0)" />
        <altmember cref="M:System.Data.Objects.ObjectStateEntry.ApplyCurrentValues(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyOriginalValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public TEntity ApplyOriginalValues&lt;TEntity&gt; (string entitySetName, TEntity originalEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEntity ApplyOriginalValues&lt;class TEntity&gt;(string entitySetName, !!TEntity originalEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyOriginalValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyOriginalValues(Of TEntity As Class) (entitySetName As String, originalEntity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class TEntity ApplyOriginalValues(System::String ^ entitySetName, TEntity originalEntity);" />
      <MemberSignature Language="F#" Value="member this.ApplyOriginalValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyOriginalValues (entitySetName, originalEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="originalEntity" Type="TEntity" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Der Typ des Entitätsobjekts.</typeparam>
        <param name="entitySetName">Der Name der Entitätenmenge, der das Objekt angehört.</param>
        <param name="originalEntity">Das getrennte Objekt mit ursprünglichen Werten, die auf das Objekt angewendet werden sollen. Der Entitätsschlüssel von <paramref name="originalEntity" /> muss zur <see cref="P:System.Data.Objects.ObjectStateEntry.EntityKey" />-Eigenschaft eines Eintrags in <see cref="T:System.Data.Objects.ObjectContext" /> passen.</param>
        <summary>Kopiert die Skalarwerte aus dem angegebenen Objekt in den Satz von ursprünglichen Werten für das Objekt im <see cref="T:System.Data.Objects.ObjectContext" />, das über den gleichen Schlüssel verfügt.</summary>
        <returns>Das aktualisierte Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Objects.ObjectContext.ApplyOriginalValues%2A>-Methode wird verwendet, um an Objekten außerhalb der <xref:System.Data.Objects.ObjectContext>vorgenommene Änderungen zu übernehmen, z. b. getrennte Objekte, die von einem Webdienst empfangen werden. Die-Methode kopiert die skalaren Werte aus dem angegebenen-Objekt in das-Objekt im <xref:System.Data.Objects.ObjectContext>, das denselben Schlüssel aufweist. Sie können die <xref:System.Data.EntityKey> des getrennten-Objekts verwenden, um eine Instanz dieses Objekts aus der Datenquelle abzurufen. Weitere Informationen finden Sie unter Gewusst [wie: Zurückgeben eines bestimmten Objekts mithilfe des Schlüssels](https://msdn.microsoft.com/library/2e9902af-29b0-4e5d-92db-03dfe6ec49bd). Alle Werte, die sich von den aktuellen Werten des-Objekts unterscheiden, werden als geändert markiert. Beachten Sie, dass die-Methode die aktuellen Werte nicht auf die zugehörigen Objekte `originalEntity`anwendet.

 Wenn Sie ein Diagramm mit den ursprünglichen Werten haben und die aktuellen Werte anwenden möchten, müssen Sie <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> Methode abrufen.

 Sie können auch die <xref:System.Data.Objects.ObjectSet%601.ApplyOriginalValues%2A> der <xref:System.Data.Objects.ObjectSet%601>-oder <xref:System.Data.Objects.ObjectStateEntry.ApplyOriginalValues%2A>-Methode der <xref:System.Data.Objects.ObjectStateEntry>verwenden. Weitere Informationen finden Sie unter [Building N-Tier Applications](https://msdn.microsoft.com/library/9439d2ba-6b5f-44e8-be65-8a442d922cbb).

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entitySetName" /> oder <paramref name="original" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Data.Metadata.Edm.EntitySet" />-Element von <paramref name="entitySetName" /> stimmt nicht mit dem <see cref="T:System.Data.Metadata.Edm.EntitySet" />-Element des <see cref="T:System.Data.EntityKey" /> des Objekts überein.

- oder -

Ein <see cref="T:System.Data.Objects.ObjectStateEntry" /> für das Objekt kann im <see cref="T:System.Data.Objects.ObjectStateManager" /> nicht gefunden werden. - oder -

Das zurückgegebene Objekt befindet sich in einem <see cref="F:System.Data.EntityState.Added" />- oder einem <see cref="F:System.Data.EntityState.Detached" />-Zustand.

- oder -

Der Entitätsschlüssel des angegebenen Objekts ist ungültig oder verfügt über Eigenschaftenänderungen.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="entitySetName" /> ist eine leere Zeichenfolge.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.ApplyOriginalValues(`0)" />
        <altmember cref="M:System.Data.Objects.ObjectStateEntry.ApplyOriginalValues(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyPropertyChanges">
      <MemberSignature Language="C#" Value="public void ApplyPropertyChanges (string entitySetName, object changed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyPropertyChanges(string entitySetName, object changed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyPropertyChanges(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyPropertyChanges (entitySetName As String, changed As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyPropertyChanges(System::String ^ entitySetName, System::Object ^ changed);" />
      <MemberSignature Language="F#" Value="member this.ApplyPropertyChanges : string * obj -&gt; unit" Usage="objectContext.ApplyPropertyChanges (entitySetName, changed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use ApplyCurrentValues instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="changed" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Der Name der Entitätenmenge, der das Objekt angehört.</param>
        <param name="changed">Das getrennte Objekt, das über Eigenschaftsaktualisierungen verfügt, die für das ursprüngliche Objekt übernommen werden sollen.</param>
        <summary>Übernimmt Eigenschaftsänderungen eines getrennten Objekts für ein Objekt, das bereits an den Objektkontext angefügt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A>-Methode wird verwendet, um Eigenschaftsänderungen von einer geänderten, getrennten Version eines Objekts für die ursprüngliche Version zu übernehmen, die an den <xref:System.Data.Objects.ObjectContext> angefügt ist. Dadurch werden Szenarios wie beispielsweise Webdienste unterstützt, bei denen ein Entitätsobjekt getrennt und an eine Remoteanwendung gesendet wird, in der Eigenschaftsaktualisierungen vorgenommen werden. Mithilfe dieser Methode können solche Änderungen einfacher für das ursprüngliche Objekt übernommen werden.

 Nach Abschluss von <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> befindet sich das Objekt im <xref:System.Data.EntityState.Modified>-Status. Zum Aktualisieren der Datenquelle müssen Sie die <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>-Methode abrufen.

 Das ursprüngliche Objekt muss im <xref:System.Data.Objects.ObjectStateManager> vorhanden sein und den Status <xref:System.Data.EntityState.Modified> oder <xref:System.Data.EntityState.Unchanged> aufweisen. Das ursprüngliche Objekt wird nur geändert, wenn im `changed` Objekt geänderte Eigenschaften vorhanden sind.

 Die <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A>-Eigenschaft des angegebenen-Objekts muss auf einen gültigen <xref:System.Data.EntityKey>festgelegt werden.

 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> wirkt sich nicht auf Navigations Eigenschaften oder verwandte Objekte aus.

 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> legt lediglich Eigenschaften fest, die in den Entitätsmetadaten für den Typ vorhanden sind. Zum Beispiel sind Eigenschaften, die in einer partiellen Klasse hinzugefügt werden, nicht in die <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A>-Operation eingeschlossen.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wenn <paramref name="entitySetName" /> <see langword="null" /> oder eine leere Zeichenfolge ist.

- oder -

Wenn <paramref name="changed" /><see langword="null" /> ist.</exception>
        <exception cref="T:System.InvalidOperationException">Wenn das <see cref="T:System.Data.Metadata.Edm.EntitySet" />-Element von <paramref name="entitySetName" /> nicht mit dem <see cref="T:System.Data.Metadata.Edm.EntitySet" />-Element des <see cref="T:System.Data.EntityKey" /> des Objekts übereinstimmt.

- oder -

Wenn die Entität einen anderen Status als <see cref="F:System.Data.EntityState.Modified" /> oder <see cref="F:System.Data.EntityState.Unchanged" /> aufweist.

- oder -

Das ursprüngliche Objekt ist nicht an den Kontext angefügt.</exception>
        <exception cref="T:System.ArgumentException">Wenn der Typ des <paramref name="changed" />-Objekts nicht dem Typ des ursprünglichen Objekts entspricht.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (System.Data.Objects.DataClasses.IEntityWithKey entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(class System.Data.Objects.DataClasses.IEntityWithKey entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Attach(System.Data.Objects.DataClasses.IEntityWithKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As IEntityWithKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(System::Data::Objects::DataClasses::IEntityWithKey ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Attach : System.Data.Objects.DataClasses.IEntityWithKey -&gt; unit" Usage="objectContext.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Data.Objects.DataClasses.IEntityWithKey" />
      </Parameters>
      <Docs>
        <param name="entity">Das anzufügende Objekt.</param>
        <summary>Fügt ein Objekt oder Objektdiagramm an den Objektkontext an, wenn das Objekt über einen Entitätsschlüssel verfügt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Rufen Sie <xref:System.Data.Objects.ObjectContext.Attach%2A> für den <xref:System.Data.Objects.ObjectContext> auf, um das Objekt an den Objektkontext anzufügen. Dies ist der Fall, wenn das Objekt bereits in der Datenquelle vorhanden ist, aber derzeit nicht an den Kontext angefügt ist. Weitere Informationen finden Sie unter [Anpassen von Objekten](https://msdn.microsoft.com/library/af6f07ce-2261-4c65-87cf-d018ad082921).

 <xref:System.Data.Objects.ObjectContext.Attach%2A> wird verwendet, um ein Objekt oder das Objekt der obersten Ebene in einem Objekt Diagramm anzufügen.

 Das anzufügende Objekt muss <xref:System.Data.Objects.DataClasses.IEntityWithKey> implementieren, um einen <xref:System.Data.EntityKey> bereitzustellen. Von allen generierten Entitätsklassen wird <xref:System.Data.Objects.DataClasses.IEntityWithKey> implementiert.

 Wenn Sie verknüpfte Objekte anfügen, müssen Sie auch `Attach` für die <xref:System.Data.Objects.DataClasses.EntityReference%601> oder die <xref:System.Data.Objects.DataClasses.EntityCollection%601>, um die Beziehung zu definieren.

 Diese Methode ruft die <xref:System.Data.Objects.ObjectContext.AttachTo%2A>-Methode auf.

 Folgendes gilt beim Anfügen von Objekten:

-   Wenn das anzufügende Objekt über verbundene Objekte verfügt, werden auch diese Objekte an den Objektkontext angefügt.

-   Objekte werden dem Objektkontext im Status "Unchanged" hinzugefügt.

-   Das Objekt, das an die <xref:System.Data.Objects.ObjectContext.Attach%2A>-Methode übergeben wird, muss über einen gültigen <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A>-Wert verfügen. Wenn das Objekt keinen gültigen <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A>-Wert aufweist, geben Sie den Namen des Entitätssatzes mit der <xref:System.Data.Objects.ObjectContext.AttachTo%2A>-Methode an.



## Examples
 Das Beispiel in diesem Thema basiert auf den [Microsoft SQL Server Product Samples: Database](https://archive.codeplex.com/?p=msftdbprodsamples). In diesem Beispiel werden zwei Objekte angefügt, und anschließend wird die Beziehung definiert.

 [!code-csharp[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#attachrelatedobjects)]
 [!code-vb[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#attachrelatedobjects)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entity" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ungültiger Entitätsschlüssel.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Attach(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AttachTo">
      <MemberSignature Language="C#" Value="public void AttachTo (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachTo(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AttachTo(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AttachTo (entitySetName As String, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachTo(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.AttachTo : string * obj -&gt; unit" Usage="objectContext.AttachTo (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Stellt den Namen der Entitätenmenge dar, der optional durch den Entitätencontainernamen qualifiziert werden kann.</param>
        <param name="entity">Das anzufügende <see cref="T:System.Object" />.</param>
        <summary>Fügt ein Objekt oder Objektdiagramm an den Objektkontext in einer bestimmten Entitätenmenge an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Ruft <xref:System.Data.Objects.ObjectContext.AttachTo%2A> für die <xref:System.Data.Objects.ObjectContext> auf, um das Objekt an eine bestimmte Entitätenmenge im Objekt Kontext anzufügen, oder, wenn das Objekt über einen `null` (`Nothing` in Visual Basic) <xref:System.Data.EntityKey> Wert verfügt. Weitere Informationen finden Sie unter Anfügen [und trennen von Objekten](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).

 Das anzufügende Objekt kann eigenständig oder Teil des Diagramms sein.

 Die Regeln für das `entitySetName` Format lauten wie folgt:

-   Wenn die <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A>-Eigenschaft `null`ist, muss die `entitySetName` voll qualifiziert sein, wie in *\<Entitätencontainername >*. *\<Name der Entitätenmenge >*.

-   Wenn die <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> nicht `null`ist, kann die `entitySetName` entweder *\<Entitätencontainername >* sein. *\<Name der Entitätenmenge >* oder *\<Name der Entitätenmenge >*.

 Das anzufügende Objekt muss keinen damit verbundenen <xref:System.Data.EntityKey> haben. Wenn das Objekt über keinen Entitäts Schlüssel verfügt, kann `entitySetName` keine leere Zeichenfolge sein.

 Wenn das anzufügende Objekt über eine <xref:System.Data.EntityKey> verfügt und `entitySetName` über einen Wert verfügt, muss die <xref:System.Data.Metadata.Edm.EntitySet> des Entitäts Schlüssels mit der <xref:System.Data.Metadata.Edm.EntitySet> gefunden werden, die auf der Grundlage der `entitySetName` und des Entitätencontainernamens gefunden wurde.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entity" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ungültiger Entitätssatz.

- oder -

Das Objekt verfügt über einen temporären Schlüssel.

- oder -

Das Objekt verfügt über einen <see cref="T:System.Data.EntityKey" />, und die <see cref="T:System.Data.Metadata.Edm.EntitySet" /> stimmt nicht mit der Entitätenmenge überein, die der Methode als Argument übergeben wurde.

- oder -

Das Objekt hat keinen <see cref="T:System.Data.EntityKey" />, und es ist keine Entitätenmenge angegeben.

- oder -

Ein Objekt aus dem Objektdiagramm verfügt über einen temporären <see cref="T:System.Data.EntityKey" />.

- oder -

Ein Objekt aus dem Objektdiagramm verfügt über einen ungültigen <see cref="T:System.Data.EntityKey" /> (Beispiel: Werte im Schlüssel stimmen nicht mit Werten im Objekt überein).

- oder -

Der Entitätssatz wurde nicht anhand eines angegebenen <paramref name="entitySetName" /> und Entitätscontainernamens gefunden.

- oder -

Ein Objekt aus dem Objektdiagramm ist bereits in einem anderen Status-Manager vorhanden.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Attach(`0)" />
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public int? CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int32&gt; CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;int&gt; CommandTimeout { Nullable&lt;int&gt; get(); void set(Nullable&lt;int&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTimeout : Nullable&lt;int&gt; with get, set" Usage="System.Data.Objects.ObjectContext.CommandTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Timeoutwert in Sekunden für alle Operationen im Objektkontext ab oder legt diesen fest. Der Wert <see langword="null" /> gibt an, dass der Standardwert des zugrunde liegenden Anbieters verwendet wird.</summary>
        <value>Ein <see cref="T:System.Int32" />-Wert, der den Timeoutwert in Sekunden darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Das Standardtimeout für Objektabfragen und den <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>-Vorgang wird vom zugrunde liegenden Verbindungsanbieter definiert. Sie können diesen Standardtimeout jedoch mithilfe der <xref:System.Data.Objects.ObjectContext.CommandTimeout%2A>-Eigenschaft im <xref:System.Data.Objects.ObjectContext> überschreiben (siehe folgendes Beispiel).

 [!code-csharp[DP ObjectServices Concepts#QueryTimeout](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#querytimeout)]
 [!code-vb[DP ObjectServices Concepts#QueryTimeout](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#querytimeout)]

 Dieses Vorgehen wird empfohlen, wenn eine komplexe Abfrage durchgeführt wird, oder wenn andere Leistungsprobleme dazu führen, dass Abfragen oder Aufrufe von <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> häufig zu einem Timeout führen.



## Examples
 [Objekt Abfragen](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100))

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Timeoutwert ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.Common.DbConnection" Usage="System.Data.Objects.ObjectContext.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die vom Objektkontext verwendete Verbindung ab.</summary>
        <value>Ein <see cref="T:System.Data.Common.DbConnection" />-Objekt, das der Verbindung entspricht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Eigenschaft gibt das Verbindungsobjekt zurück, das an den Konstruktor übergeben bzw. während der Konstruktion erstellt wurde. Der Besitz der Verbindung hängt von den verwendeten Konstruktoren ab.



## Examples
 In diesem Beispiel wird ein <xref:System.Data.EntityClient.EntityConnection>-Objekt erstellt, das an den Konstruktor eines <xref:System.Data.Objects.ObjectContext> mit langer Laufzeit übergeben wird. Die Verbindung wird manuell geöffnet. Sowohl das <xref:System.Data.EntityClient.EntityConnection>-Objekt als auch das <xref:System.Data.Objects.ObjectContext>-Objekt werden manuell freigegeben.

 [!code-csharp[DP ObjectServices Concepts#OpenEntityConnection](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#openentityconnection)]
 [!code-vb[DP ObjectServices Concepts#OpenEntityConnection](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#openentityconnection)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Wenn die <see cref="T:System.Data.Objects.ObjectContext" />-Instanz entfernt wurde.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ContextOptions">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectContextOptions ContextOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Objects.ObjectContextOptions ContextOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.ContextOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContextOptions As ObjectContextOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Objects::ObjectContextOptions ^ ContextOptions { System::Data::Objects::ObjectContextOptions ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContextOptions : System.Data.Objects.ObjectContextOptions" Usage="System.Data.Objects.ObjectContext.ContextOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectContextOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Data.Objects.ObjectContextOptions" />-Instanz ab, die Optionen zum Steuern des Verhaltens von <see cref="T:System.Data.Objects.ObjectContext" /> enthält.</summary>
        <value>Die <see cref="T:System.Data.Objects.ObjectContextOptions" />-Instanz, die Optionen zum Steuern des Verhaltens von <see cref="T:System.Data.Objects.ObjectContext" /> enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabase : unit -&gt; unit" Usage="objectContext.CreateDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt die Datenbank mithilfe der aktuellen Datenquellenverbindung und der Metadaten in der <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Ruft <xref:System.Data.Objects.ObjectContext.CreateDatabaseScript%2A> auf, um das DDL-Skript (Data Definition Language) anzuzeigen. Ruft <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> auf, um das Skript auszuführen.

 Die meiste Arbeit wird an die <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A>-Methode delegiert.

 Weitere Informationen finden Sie unter [Arbeiten mit der Datendefinitionssprache](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).

 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="CreateDatabaseScript">
      <MemberSignature Language="C#" Value="public string CreateDatabaseScript ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string CreateDatabaseScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDatabaseScript () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ CreateDatabaseScript();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabaseScript : unit -&gt; string" Usage="objectContext.CreateDatabaseScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Generiert ein DDL (Data Definition Language)-Skript, das Schemaobjekte (Tabellen, Primärschlüssel, Fremdschlüssel) für die Metadaten in der <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" /> erstellt. <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" /> lädt Metadaten aus SSDL-Dateien (Store Schema Definition Language, Datenspeicherschema-Definitionssprache).</summary>
        <returns>Ein DDL-Skript, das Schemaobjekte für die Metadaten in der <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" /> erstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Ruft <xref:System.Data.Objects.ObjectContext.CreateDatabaseScript%2A> auf, um das DDL-Skript anzuzeigen. Ruft <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> auf, um das Skript auszuführen.

 Die meiste Arbeit wird an die <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A>-Methode delegiert.

 Weitere Informationen finden Sie unter [Arbeiten mit der Datendefinitionssprache](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).

 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="CreateEntityKey">
      <MemberSignature Language="C#" Value="public System.Data.EntityKey CreateEntityKey (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.EntityKey CreateEntityKey(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateEntityKey(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateEntityKey (entitySetName As String, entity As Object) As EntityKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::EntityKey ^ CreateEntityKey(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.CreateEntityKey : string * obj -&gt; System.Data.EntityKey" Usage="objectContext.CreateEntityKey (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Der voll qualifizierte Name der Entitätenmenge, der das Entitätsobjekt angehört.</param>
        <param name="entity">Das Objekt, für das der Entitätsschlüssel abgerufen wird.</param>
        <summary>Erstellt den Entitätsschlüssel für ein bestimmtes Objekt, oder gibt den Entitätsschlüssel zurück, wenn dieser bereits vorhanden ist.</summary>
        <returns>Der <see cref="T:System.Data.EntityKey" /> des Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn eine <xref:System.Data.EntityKey> für die `entity`nicht vorhanden ist, erstellt die <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A>-Methode einen neuen Schlüssel.

 Mit dieser Methode wird ermittelt, ob ein Objekt mit demselben <xref:System.Data.EntityKey> bereits an den <xref:System.Data.Objects.ObjectContext> angefügt wurde. Wenn ein Objekt mit demselben <xref:System.Data.EntityKey> bereits angefügt wurde, wird eine Ausnahme ausgelöst. Verwenden Sie die <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A>-Methode, um den <xref:System.Data.EntityKey> des getrennten Objekts abzurufen, bevor Sie die <xref:System.Data.Objects.ObjectContext.Attach%2A>-Methode aufrufen.



## Examples
 Das Beispiel in diesem Thema basiert auf den [Microsoft SQL Server Product Samples: Database](https://archive.codeplex.com/?p=msftdbprodsamples). In diesem Beispiel wird <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> verwendet, um den Entitätsschlüssel eines vorhandenen Objekts abzurufen.

 [!code-csharp[DP ObjectServices Concepts#ApplyItemUpdatesGetObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#applyitemupdatesgetobject)]
 [!code-vb[DP ObjectServices Concepts#ApplyItemUpdatesGetObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#applyitemupdatesgetobject)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wenn einer der Parameter <see langword="null" /> ist.</exception>
        <exception cref="T:System.ArgumentException">Wenn <paramref name="entitySetName" /> leer ist.

- oder -

Wenn der Typ des <paramref name="entity" />-Objekts in der Entitätenmenge nicht vorhanden ist.

- oder -

Wenn der <paramref name="entitySetName" /> nicht voll qualifiziert ist.</exception>
        <exception cref="T:System.InvalidOperationException">Wenn der Entitätsschlüssel anhand der angegebenen Parameter nicht erstellt werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T CreateObject&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T CreateObject&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObject``1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject(Of T As Class) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class T CreateObject();" />
      <MemberSignature Language="F#" Value="member this.CreateObject : unit -&gt; 'T (requires 'T : null)" Usage="objectContext.CreateObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Der Typ des zurückzugebenden Objekts.</typeparam>
        <summary>Erstellt eine Instanz des angeforderten Typs und gibt diese zurück.</summary>
        <returns>Eine Instanz des angeforderten Typs <paramref name="T" />, oder eine Instanz eines abgeleiteten Typs, der die Verwendung von <paramref name="T" /> mit dem Entity Framework ermöglicht. Das zurückgegebene Objekt ist entweder eine Instanz des angeforderten Typs oder eine Instanz eines abgeleiteten Typs, der es ermöglicht, dass der angeforderte Typ mit dem Entity Framework verwendet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Objects.ObjectContext.CreateObject%2A>-Methode wird mit benutzerdefinierten poco-Daten Klassen verwendet, um sicherzustellen, dass das zurückgegebene Objekt vom Entity Framework ordnungsgemäß verwaltet werden kann. Weitere Informationen finden Sie unter [Anforderungen zum Erstellen von poco](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) -Proxys und [Arbeiten mit poco-Entitäten](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObjectSet``1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectSet(Of TEntity As Class) () As ObjectSet(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Objects::ObjectSet&lt;TEntity&gt; ^ CreateObjectSet();" />
      <MemberSignature Language="F#" Value="member this.CreateObjectSet : unit -&gt; System.Data.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">Der Entitätstyp des angeforderten <see cref="T:System.Data.Objects.ObjectSet`1" />-Objekts.</typeparam>
        <summary>Erstellt eine neue <see cref="T:System.Data.Objects.ObjectSet`1" />-Instanz, die verwendet wird, um Objekte des angegebenen Entitätstyps abzufragen, hinzuzufügen, zu ändern und zu löschen.</summary>
        <returns>Die neue <see cref="T:System.Data.Objects.ObjectSet`1" />-Instanz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" />-Eigenschaft wird nicht für <see cref="T:System.Data.Objects.ObjectContext" /> festgelegt.

- oder -

Der angegebene Typ gehört zu mehr als einem Entitätssatz.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; (string entitySetName) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;(string entitySetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObjectSet``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectSet(Of TEntity As Class) (entitySetName As String) As ObjectSet(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Objects::ObjectSet&lt;TEntity&gt; ^ CreateObjectSet(System::String ^ entitySetName);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectSet : string -&gt; System.Data.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet entitySetName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Der Entitätstyp des angeforderten <see cref="T:System.Data.Objects.ObjectSet`1" />-Objekts.</typeparam>
        <param name="entitySetName">Der Name der Entitätenmenge für das zurückgegebene <see cref="T:System.Data.Objects.ObjectSet`1" />-Objekt. Die Zeichenfolge muss mit dem Standardcontainernamen qualifiziert werden, wenn die <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" />-Eigenschaft nicht für <see cref="T:System.Data.Objects.ObjectContext" /> festgelegt ist.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Objects.ObjectSet`1" />-Instanz, die verwendet wird, um Objekte des angegebenen Typs mit dem angegebenen Entitätenmengennamen abzufragen, hinzuzufügen, zu ändern und zu löschen.</summary>
        <returns>Die neue <see cref="T:System.Data.Objects.ObjectSet`1" />-Instanz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Data.Metadata.Edm.EntitySet" />-Element von <paramref name="entitySetName" /> stimmt nicht mit dem <see cref="T:System.Data.Metadata.Edm.EntitySet" />-Element des <see cref="T:System.Data.EntityKey" /> des Objekts überein.

- oder -

Die <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" />-Eigenschaft ist nicht für <see cref="T:System.Data.Objects.ObjectContext" /> festgelegt und der Name nicht als Teil des <paramref name="entitySetName" />-Parameters qualifiziert.

- oder -

Der angegebene Typ gehört zu mehr als einem Entitätssatz.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProxyTypes">
      <MemberSignature Language="C#" Value="public void CreateProxyTypes (System.Collections.Generic.IEnumerable&lt;Type&gt; types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateProxyTypes(class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateProxyTypes(System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateProxyTypes (types As IEnumerable(Of Type))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateProxyTypes(System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.CreateProxyTypes : seq&lt;Type&gt; -&gt; unit" Usage="objectContext.CreateProxyTypes types" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="types">Eine Enumeration von <see cref="T:System.Type" />-Objekten, die dem konzeptionellen Modell entsprechende benutzerdefinierte Datenklassen darstellen.</param>
        <summary>Generiert einen gleichwertigen Typ, der mit dem Entity Framework für jeden Typ in der angegebenen Enumeration verwendet werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Einzelne Typen in der `types` Enumeration, die keinem Entitätstyp im konzeptionellen Modell zugeordnet sind, werden ignoriert.

 Weitere Informationen finden Sie unter [Anforderungen zum Erstellen von poco](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) -Proxys und [Arbeiten mit poco-Entitäten](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateQuery&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; CreateQuery&lt;T&gt; (string queryString, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!!T&gt; CreateQuery&lt;T&gt;(string queryString, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateQuery``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateQuery(Of T) (queryString As String, ParamArray parameters As ObjectParameter()) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ CreateQuery(System::String ^ queryString, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.CreateQuery : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectContext.CreateQuery (queryString, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">Der Entitätstyp des zurückgegebenen <see cref="T:System.Data.Objects.ObjectQuery`1" />.</typeparam>
        <param name="queryString">Die auszuführende Abfragezeichenfolge.</param>
        <param name="parameters">An die Abfrage zu übergebende Parameter.</param>
        <summary>Erstellt im aktuellen Objektkontext mit der angegebenen Abfragezeichenfolge ein <see cref="T:System.Data.Objects.ObjectQuery`1" />.</summary>
        <returns>Eine <see cref="T:System.Data.Objects.ObjectQuery`1" /> des angegebenen Typs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Verwenden Sie <xref:System.Data.Objects.ObjectContext.CreateQuery%2A>, um eine <xref:System.Data.Objects.ObjectQuery%601> des angegebenen Typs zu erstellen, die dem aktuellen Objektkontext angehört.



## Examples
 Dieses Beispiel basiert auf den [Microsoft SQL Server Product Samples: Database](https://archive.codeplex.com/?p=msftdbprodsamples).

 In dem Beispiel wird eine einfache Abfrage erstellt und die Auflistung der Ergebnisse durchlaufen.

 [!code-csharp[DP ObjectServices Concepts#CreateQuery](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#createquery)]
 [!code-vb[DP ObjectServices Concepts#CreateQuery](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#createquery)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="queryString" />-Parameter oder der <paramref name="parameters" />-Parameter ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Abfragen eines konzeptionellen Modells</related>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberSignature Language="F#" Value="member this.DatabaseExists : unit -&gt; bool" Usage="objectContext.DatabaseExists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überprüft, ob die als Datenbank in der aktuellen Datenquellenverbindung angegebene Datenbank in der Datenquelle vorhanden ist.</summary>
        <returns><see langword="true" />, wenn die Datenbank vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die meiste Arbeit wird an die <xref:System.Data.Common.DbProviderServices.DatabaseExists%2A>-Methode delegiert.

 Weitere Informationen finden Sie unter [Arbeiten mit der Datendefinitionssprache](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).

 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
      </Docs>
    </Member>
    <Member MemberName="DefaultContainerName">
      <MemberSignature Language="C#" Value="public string DefaultContainerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultContainerName" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.DefaultContainerName" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultContainerName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DefaultContainerName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultContainerName : string with get, set" Usage="System.Data.Objects.ObjectContext.DefaultContainerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Standardcontainernamen ab oder legt diesen fest.</summary>
        <value>Eine <see cref="T:System.String" />, die den Standardcontainernamen darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> gibt niemals `null`zurück. entweder wird der Wert zurückgegeben, der festgelegt wurde, oder eine leere Zeichenfolge. Der Benutzer kann diese Eigenschaft auf `null`festlegen, aber intern wird der Name auf eine leere Zeichenfolge festgelegt, sodass der Benutzer nicht auf eine leere Zeichenfolge prüfen muss und `null`.

 Der Standardcontainername wird ebenfalls als Teil eines Konstruktors definiert. Wenn der Standardcontainername durch den geschützten Konstruktor festgelegt wird, ist die Eigenschaft schreibgeschützt.

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberSignature Language="F#" Value="member this.DeleteDatabase : unit -&gt; unit" Usage="objectContext.DeleteDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die Datenbank, die in der aktuellen Datenquellenverbindung als Datenbank angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die meiste Arbeit wird an die <xref:System.Data.Common.DbProviderServices.DeleteDatabase%2A>-Methode delegiert.

 Weitere Informationen finden Sie unter [Arbeiten mit der Datendefinitionssprache](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).

 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="DeleteObject">
      <MemberSignature Language="C#" Value="public void DeleteObject (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteObject(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DeleteObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteObject (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteObject(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.DeleteObject : obj -&gt; unit" Usage="objectContext.DeleteObject entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Ein Objekt, das die zu löschende Entität angibt. Das Objekt kann jeden Status außer <see cref="F:System.Data.EntityState.Detached" /> haben.</param>
        <summary>Markiert ein Objekt zum Löschen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Markiert ein Objekt aus dem <xref:System.Data.Objects.ObjectStateManager> zum Löschen. Das-Objekt wird in der Datenquelle gelöscht, wenn die <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>-Methode aufgerufen wird.

 Beim Löschen des übergeordneten Objekts werden auch alle untergeordneten Objekte in der eingeschränkten Beziehung gelöscht. Das Ergebnis ist das gleiche wie beim Aktivieren der `CascadeDelete`-Eigenschaft in der Zuordnung für die Beziehung.

 Die <xref:System.Data.Objects.ObjectContext.DeleteObject%2A>-Methode kann für Objekte aufgerufen werden, die bereits gelöscht wurden.



## Examples
 Diese Beispiele basieren auf den [Microsoft SQL Server Product Samples: Database](https://archive.codeplex.com/?p=msftdbprodsamples).

 In diesem Beispiel wird ein <xref:System.Data.EntityKey> mit einer bestimmten ProductID erstellt, der Schlüssel verwendet, um ein Product-Objekt aus der Datenquelle abzurufen, das Produkt zu löschen und die Änderungen in der Datenbank zu speichern.

 [!code-csharp[DP ObjectServices Concepts#DeleteObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#deleteobject)]
 [!code-vb[DP ObjectServices Concepts#DeleteObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#deleteobject)]

 In diesem Beispiel wird ein vorhandenes Bestell Element gelöscht, ein neues Element hinzugefügt und die Änderungen in der Datenbank gespeichert.

 [!code-csharp[DP ObjectServices Concepts#SaveChanges](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#savechanges)]
 [!code-vb[DP ObjectServices Concepts#SaveChanges](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#savechanges)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entity" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="entity" /> existiert nicht.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.DeleteObject(`0)" />
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Detach">
      <MemberSignature Language="C#" Value="public void Detach (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Detach(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Detach(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Detach (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Detach(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Detach : obj -&gt; unit" Usage="objectContext.Detach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Zu trennendes Objekt. Es wird nur die <paramref name="entity" /> entfernt. Wenn verknüpfte Objekte vorhanden sind, die von demselben <see cref="T:System.Data.Objects.ObjectStateManager" /> nachverfolgt werden, werden diese nicht automatisch getrennt.</param>
        <summary>Entfernt das Objekt aus dem Objektkontext.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Entfernt das Objekt aus dem <xref:System.Data.Objects.ObjectStateManager>. Dadurch werden Änderungsnachverfolgung und Identitätsauflösung für dieses Objekt deaktiviert. Weitere Informationen finden Sie unter Anfügen [und trennen von Objekten](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).

 Nach dem Aufruf der <xref:System.Data.Objects.ObjectContext.Detach%2A>-Methode werden vom System alle Verweise auf dieses Objekt gelöscht und es kann vom Garbage Collector gesammelt werden.

> [!NOTE]
>  Die Garbage Collection (automatische Speicherbereinigung) kann nur erfolgen, wenn der Benutzercode keine Verweise auf das getrennte Objekt enthält.

 Folgendes gilt beim Trennen von Objekten:

-   <xref:System.Data.Objects.ObjectContext.Detach%2A> betrifft nur das jeweilige Objekt, das an die Methode übergeben wird. Wenn das zu trennende Objekt über verbundene Objekte im Objektkontext verfügt, werden diese Objekte nicht getrennt.

-   Das Trennen von Objekten wirkt sich nicht auf Daten in der Datenquelle aus.

-   Während eines Trennvorgangs werden keine Anweisungen zur kaskadierten Löschung oder referenziellen Einschränkungen erzwungen.

 Weitere Informationen finden Sie unter Anfügen [und trennen von Objekten](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).



## Examples
 [!code-csharp[DP ObjectServices Concepts#DetachObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#detachobjects)]
 [!code-vb[DP ObjectServices Concepts#DetachObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#detachobjects)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entity" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <paramref name="entity" /> ist diesem <see cref="T:System.Data.Objects.ObjectContext" /> nicht zugeordnet (Beispiel: sie wurde neu erstellt und noch keinem Kontext zugeordnet, sie wurde durch einen anderen Kontext abgerufen oder sie wurde bereits getrennt).</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Detach(`0)" />
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="DetectChanges">
      <MemberSignature Language="C#" Value="public void DetectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DetectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub DetectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetectChanges();" />
      <MemberSignature Language="F#" Value="member this.DetectChanges : unit -&gt; unit" Usage="objectContext.DetectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt sicher, dass <see cref="T:System.Data.Objects.ObjectStateEntry" />-Änderungen mit Änderungen in allen von <see cref="T:System.Data.Objects.ObjectStateManager" /> nachverfolgten Objekten synchronisiert werden.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die vom Objektkontext verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="objectContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die vom Objektkontext verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode schließt die Verbindung, wenn Sie vom Entity Framework geöffnet wurde. Nachdem <xref:System.Data.Objects.ObjectContext.Dispose%2A> aufgerufen wurde, wird bei Vorgängen, die eine geöffnete Verbindung erfordern, wie z. b. das Ausführen einer Abfrage oder das Aufrufen der <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> Methode, eine Ausnahme ausgelöst. Operationen, für die keine offene Verbindung notwendig ist, wie das Verfassen von Abfragen oder das Anfügen von Objekten, verursachen keine Ausnahme. Durch die <xref:System.Data.Objects.ObjectContext.Dispose%2A>-Methode werden keine explizit geöffneten Verbindungen geschlossen.

 Durch Einschränken des Bereichs einer <xref:System.Data.Objects.ObjectContext> in einem `using` Block (`Using` in Visual Basic) wird sichergestellt, dass die Ressourcen ordnungsgemäß verworfen werden. Weitere Informationen finden Sie unter [Verwalten von Verbindungen und Transaktionen](https://msdn.microsoft.com/library/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).

 Die <xref:System.Data.Objects.ObjectContext.Dispose>-Methode ruft die `virtual` (`Overridable` in Visual Basic) <xref:System.Data.Objects.ObjectContext.Dispose%28System.Boolean%29> Methode auf.

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="objectContext.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die vom Objektkontext verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode schließt die Verbindung. Nachdem <xref:System.Data.Objects.ObjectContext.Dispose%2A> aufgerufen wurde, wird bei Vorgängen, die eine geöffnete Verbindung erfordern, wie z. b. das Ausführen einer Abfrage oder das Aufrufen der <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> Methode, eine Ausnahme ausgelöst. Operationen, für die keine offene Verbindung notwendig ist, wie das Verfassen von Abfragen oder das Anfügen von Objekten, verursachen keine Ausnahme.

 Durch Einschränken des Bereichs einer <xref:System.Data.Objects.ObjectContext> in einem `using` Block (`Using` in Visual Basic) wird sichergestellt, dass die Ressourcen ordnungsgemäß verworfen werden. Weitere Informationen finden Sie unter [Verwalten von Verbindungen und Transaktionen](https://msdn.microsoft.com/library/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction">
      <MemberSignature Language="C#" Value="public int ExecuteFunction (string functionName, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteFunction(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction (functionName As String, ParamArray parameters As ObjectParameter()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; int" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="functionName">Der Name der gespeicherten Prozedur oder Funktion. Der Name kann den Containernamen enthalten, z.B. <c>&lt;Container Name&gt;.&lt;Function Name&gt;</c>. Wenn der Standardcontainername bekannt ist, wird nur der Funktionsname benötigt.</param>
        <param name="parameters">Ein Array von <see cref="T:System.Data.Objects.ObjectParameter" />-Objekten.</param>
        <summary>Führt eine gespeicherte Prozedur oder eine Funktion aus, die in der Datenquelle definiert ist und im konzeptionellen Modell ausgedrückt wird, verwirft alle von der Funktion zurückgegebenen Ergebnisse, und gibt die von der Ausführung betroffene Anzahl von Zeilen zurück.</summary>
        <returns>Die Anzahl der betroffenen Zeilen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="function" /> ist NULL oder leer.

- oder -

 <paramref name="function" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Entitätsreader unterstützt diese <paramref name="function" /> nicht.

- oder -

Zwischen dem Reader und der <paramref name="function" /> ist ein Typenkonflikt vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="protected System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, params System.Data.Objects.ObjectParameter[] parameters) where TElement : System.Data.Objects.DataClasses.IEntityWithChangeTracker;" FrameworkAlternate="netframework-3.5" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;(class System.Data.Objects.DataClasses.IEntityWithChangeTracker) TElement&gt;(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" FrameworkAlternate="netframework-3.5" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Protected Function ExecuteFunction(Of TElement As IEntityWithChangeTracker) (functionName As String, ParamArray parameters As ObjectParameter()) As ObjectResult(Of TElement)" FrameworkAlternate="netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA;generic &lt;typename TElement&gt;&#xA; where TElement : System::Data::Objects::DataClasses::IEntityWithChangeTracker System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" FrameworkAlternate="netframework-3.5" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element (requires 'Element :&gt; System.Data.Objects.DataClasses.IEntityWithChangeTracker)&gt; (requires 'Element :&gt; System.Data.Objects.DataClasses.IEntityWithChangeTracker)" Usage="objectContext.ExecuteFunction (functionName, parameters)" FrameworkAlternate="netframework-3.5" />
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, params System.Data.Objects.ObjectParameter[] parameters);" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction(Of TElement) (functionName As String, ParamArray parameters As ObjectParameter()) As ObjectResult(Of TElement)" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, parameters)" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Der Entitätstyp des zurückgegebenen <see cref="T:System.Data.Objects.ObjectResult`1" />, wenn die Funktion für die Datenquelle ausgeführt wird. Dieser Typ muss <see cref="T:System.Data.Objects.DataClasses.IEntityWithChangeTracker" /> implementieren.</typeparam>
        <param name="functionName">Der Name der gespeicherten Prozedur oder Funktion. Der Name kann den Containernamen enthalten, z.B. <c>&lt;Container Name&gt;.&lt;Function Name&gt;</c>. Wenn der Standardcontainername bekannt ist, wird nur der Funktionsname benötigt.</param>
        <param name="parameters">Ein Array von <see cref="T:System.Data.Objects.ObjectParameter" />-Objekten.</param>
        <summary>Führt eine gespeicherte Prozedur oder eine Funktion, die in der Datenquelle definiert ist und im konzeptionellen Modell zugeordnet wird, mit den angegebenen Parametern aus. Gibt ein typisiertes <see cref="T:System.Data.Objects.ObjectResult`1" /> zurück.</summary>
        <returns>Ein <see cref="T:System.Data.Objects.ObjectResult`1" /> für die von der gespeicherten Prozedur zurückgegebenen Daten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A>-Methode ist eine Hilfsmethode, die zum Ausführen gespeicherter Prozeduren oder Funktionen verwendet wird, die in der Datenquelle definiert und im konzeptionellen Modell ausgedrückt werden. Die Entity Data Model-Tools generieren eine-Methode für jedes [FunctionImport-Element](/ef/ef6/modeling/designer/advanced/edmx/csdl-spec#functionimport-element-csdl) im konzeptionellen Modell. Diese Methoden geben einen stark typisierten `ExecuteFunction` an, um eine typisierte <xref:System.Data.Objects.ObjectResult%601>zurückzugeben. Weitere Informationen finden Sie unter [Anwendungs Code mit gespeicherten Prozeduren (Entity Framework)](https://docs.microsoft.com/previous-versions/cc716795(v=vs.90)).

 Alle Parameter für die Funktion sind im Parameter Array erforderlich, und alle Typen werden anhand der Metadaten für die Importfunktion überprüft, einschließlich des Typs der Funktion selbst. `null` Werte sind für CLR-Werttypen zulässig. Parametervalidierung wird vom Anbieter durchgeführt.

 Die <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A>-Methode verwendet den <xref:System.Data.Objects.MergeOption>-Wert von <xref:System.Data.Objects.MergeOption.AppendOnly>. Wenn ein Objekt bereits im Objekt Kontext vorhanden ist, wird es daher nicht aus der Datenquelle geladen.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="function" /> ist NULL oder leer.

- oder -

 <paramref name="function" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Entitätsreader unterstützt diese <paramref name="function" /> nicht.

- oder -

Zwischen dem Reader und der <paramref name="function" /> ist ein Typenkonflikt vorhanden.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, System.Data.Objects.MergeOption mergeOption, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, valuetype System.Data.Objects.MergeOption mergeOption, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Objects.MergeOption,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction(Of TElement) (functionName As String, mergeOption As MergeOption, ParamArray parameters As ObjectParameter()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, System::Data::Objects::MergeOption mergeOption, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.MergeOption * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Der Entitätstyp des zurückgegebenen <see cref="T:System.Data.Objects.ObjectResult`1" />, wenn die Funktion für die Datenquelle ausgeführt wird. Dieser Typ muss <see cref="T:System.Data.Objects.DataClasses.IEntityWithChangeTracker" /> implementieren.</typeparam>
        <param name="functionName">Der Name der gespeicherten Prozedur oder Funktion. Der Name kann den Containernamen enthalten, z.B. <c>&lt;Container Name&gt;.&lt;Function Name&gt;</c>. Wenn der Standardcontainername bekannt ist, wird nur der Funktionsname benötigt.</param>
        <param name="mergeOption">Die beim Ausführen der Abfrage zu verwendende <see cref="T:System.Data.Objects.MergeOption" />.</param>
        <param name="parameters">Ein Array von <see cref="T:System.Data.Objects.ObjectParameter" />-Objekten.</param>
        <summary>Führt die angegebene gespeicherte Prozedur oder Funktion, die in der Datenquelle definiert ist und im konzeptionellen Modell ausgedrückt wird, mit den angegebenen Parametern und der angegebenen Zusammenführungsoption aus. Gibt ein typisiertes <see cref="T:System.Data.Objects.ObjectResult`1" /> zurück.</summary>
        <returns>Ein <see cref="T:System.Data.Objects.ObjectResult`1" /> für die von der gespeicherten Prozedur zurückgegebenen Daten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A>-Methode ist eine Hilfsmethode, die zum Ausführen gespeicherter Prozeduren oder Funktionen verwendet wird, die in der Datenquelle definiert und im konzeptionellen Modell ausgedrückt werden. Die Entity Data Model-Tools generieren eine-Methode für jedes [FunctionImport-Element](/ef/ef6/modeling/designer/advanced/edmx/csdl-spec#functionimport-element-csdl) im konzeptionellen Modell. Diese Methoden geben einen stark typisierten `ExecuteFunction` an, um eine typisierte <xref:System.Data.Objects.ObjectResult%601>zurückzugeben. Weitere Informationen finden Sie unter [Anwendungs Code mit gespeicherten Prozeduren (Entity Framework)](https://docs.microsoft.com/previous-versions/cc716795(v=vs.90)).

 Alle Parameter für die Funktion sind im Parameter Array erforderlich, und alle Typen werden anhand der Metadaten für die Importfunktion überprüft, einschließlich des Typs der Funktion selbst. `null` Werte sind für CLR-Werttypen zulässig. Parametervalidierung wird vom Anbieter durchgeführt.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="function" /> ist NULL oder leer.

- oder -

 <paramref name="function" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Entitätsreader unterstützt diese <paramref name="function" /> nicht.

- oder -

Zwischen dem Reader und der <paramref name="function" /> ist ein Typenkonflikt vorhanden.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreCommand">
      <MemberSignature Language="C#" Value="public int ExecuteStoreCommand (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteStoreCommand(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreCommand (commandText As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteStoreCommand(System::String ^ commandText, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreCommand : string * obj[] -&gt; int" Usage="objectContext.ExecuteStoreCommand (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parameters" Type="System.Object[]" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="commandText">Der auszuführende Befehl in der systemeigenen Sprache der Datenquelle.</param>
        <param name="parameters">Ein Parameterarray, das an den Befehl übergeben werden soll.</param>
        <summary>Führt einen beliebigen Befehl unter Verwendung der vorhandenen Verbindung direkt für die Datenquelle aus.</summary>
        <returns>Die Anzahl der betroffenen Zeilen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die Verwendung parametrisierter Befehle hilft beim Schutz vor SQL Injection-Angriffen, bei denen ein Angreifer einen SQL-Befehl in eine SQL-Anweisung einschleust, der die Sicherheit auf dem Server gefährdet. Parametrisierte Befehle schützen vor einem SQL-Injection-Angriff, indem sichergestellt wird, dass von einer externen Quelle empfangene Werte nur als Werte und nicht als Teil der SQL-Anweisung ausgegeben werden. Folglich werden in einen Wert eingefügte SQL-Befehle nicht in der Datenquelle ausgeführt. Stattdessen werden sie nur als Parameterwert ausgewertet. Zusätzlich zu den Sicherheitsvorteilen bieten parametrisierte Befehle eine bequeme Methode zum Organisieren von Werten, die mit einer SQL-Anweisung oder einer gespeicherten Prozedur übergebenen werden.

 Der `parameters`-Wert kann ein Array von <xref:System.Data.Common.DbParameter>-Objekten oder ein Array von Parameterwerten sein. Wenn nur Werte angegeben werden, wird ein Array von <xref:System.Data.Common.DbParameter> Objekten basierend auf der Reihenfolge der Werte im Array erstellt.

 Der Store-Befehl wird im Kontext der aktuellen Transaktion ausgeführt, wenn eine aktuelle Transaktion vorhanden ist.

 Weitere Informationen finden Sie unter:

 [Direkte Ausführung von Speicher Befehlen](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) und

 [Gewusst wie: Direktes Ausführen von Befehlen für die Datenquelle](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteStoreQuery&lt;TElement&gt; (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteStoreQuery&lt;TElement&gt;(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreQuery(Of TElement) (commandText As String, ParamArray parameters As Object()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteStoreQuery(System::String ^ commandText, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQuery : string * obj[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parameters" Type="System.Object[]" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Der Typ der zurückgegebenen Daten.</typeparam>
        <param name="commandText">Der auszuführende Befehl in der systemeigenen Sprache der Datenquelle.</param>
        <param name="parameters">Ein Parameterarray, das an den Befehl übergeben werden soll.</param>
        <summary>Führt eine Abfrage, die eine Sequenz typisierter Ergebnisse zurückgibt, direkt für die Datenquelle aus.</summary>
        <returns>Eine Enumeration von Objekten vom Typ <paramref name="TElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A>-Methode verwendet die vorhandene Verbindung, um einen beliebigen Befehl direkt für die Datenquelle auszuführen. Der Speicherbefehl wird im Kontext der aktuellen Transaktion ausgeführt, wenn eine solche Transaktion vorhanden ist.

 Der Aufruf der <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A>-Methode entspricht dem Aufruf der <xref:System.Data.Common.DbCommand.ExecuteReader%2A>-Methode der <xref:System.Data.Common.DbCommand>-Klasse, nur gibt die <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A>-Methode Entitäten zurück und die <xref:System.Data.Common.DbCommand.ExecuteReader%2A>-Methode gibt Eigenschaftswerte im <xref:System.Data.Common.DbDataReader> zurück.

 Ruft die <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> mit dem angegebenen Entitätenmengennamen auf, wenn die Ergebnisse nachverfolgt werden sollen.

 Ruft die <xref:System.Data.Objects.ObjectContext.Translate%2A>-Methode auf, um eine <xref:System.Data.Common.DbDataReader> in Entitäts Objekte zu übersetzen, wenn der Reader Daten Zeilen enthält, die dem angegebenen Entitätstyp zugeordnet sind.

 Die Verwendung parametrisierter Befehle hilft beim Schutz vor SQL Injection-Angriffen, bei denen ein Angreifer einen SQL-Befehl in eine SQL-Anweisung einschleust, der die Sicherheit auf dem Server gefährdet. Parametrisierte Befehle schützen vor einem SQL-Injection-Angriff, indem sichergestellt wird, dass von einer externen Quelle empfangene Werte nur als Werte und nicht als Teil der SQL-Anweisung ausgegeben werden. Folglich werden in einen Wert eingefügte SQL-Befehle nicht in der Datenquelle ausgeführt. Stattdessen werden sie nur als Parameterwert ausgewertet. Zusätzlich zu den Sicherheitsvorteilen bieten parametrisierte Befehle eine bequeme Methode zum Organisieren von Werten, die mit einer SQL-Anweisung oder einer gespeicherten Prozedur übergebenen werden.

 Der `parameters`-Wert kann ein Array von <xref:System.Data.Common.DbParameter>-Objekten oder ein Array von Parameterwerten sein. Wenn nur Werte angegeben werden, wird ein Array von <xref:System.Data.Common.DbParameter> Objekten basierend auf der Reihenfolge der Werte im Array erstellt.

 Weitere Informationen finden Sie unter:

 [Direkte Ausführung von Speicher Befehlen](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) und

 [Gewusst wie: Direktes Ausführen von Befehlen für die Datenquelle](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TEntity&gt; ExecuteStoreQuery&lt;TEntity&gt; (string commandText, string entitySetName, System.Data.Objects.MergeOption mergeOption, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TEntity&gt; ExecuteStoreQuery&lt;TEntity&gt;(string commandText, string entitySetName, valuetype System.Data.Objects.MergeOption mergeOption, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.String,System.Data.Objects.MergeOption,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreQuery(Of TEntity) (commandText As String, entitySetName As String, mergeOption As MergeOption, ParamArray parameters As Object()) As ObjectResult(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; System::Data::Objects::ObjectResult&lt;TEntity&gt; ^ ExecuteStoreQuery(System::String ^ commandText, System::String ^ entitySetName, System::Data::Objects::MergeOption mergeOption, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQuery : string * string * System.Data.Objects.MergeOption * obj[] -&gt; System.Data.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, entitySetName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="entitySetName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Der Entitätstyp der zurückgegebenen Daten.</typeparam>
        <param name="commandText">Der auszuführende Befehl in der systemeigenen Sprache der Datenquelle.</param>
        <param name="entitySetName">Die Entitätenmenge vom <typeparamref name="TEntity" />-Typ. Wenn kein Entitätenmengenname angegeben wird, werden die Ergebnisse nicht nachverfolgt.</param>
        <param name="mergeOption">Die beim Ausführen der Abfrage zu verwendende <see cref="T:System.Data.Objects.MergeOption" />. Der Standardwert ist <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <param name="parameters">Ein Parameterarray, das an den Befehl übergeben werden soll.</param>
        <summary>Führt eine Abfrage, die eine Sequenz typisierter Ergebnisse zurückgibt, direkt für die Datenquelle aus. Geben Sie die Entitätenmenge und die Zusammenführungsoption an, damit Abfrageergebnisse als Entitäten nachverfolgt werden können.</summary>
        <returns>Eine Enumeration von Objekten vom Typ <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A>-Methode verwendet die vorhandene Verbindung, um einen beliebigen Befehl direkt für die Datenquelle auszuführen. Der Speicherbefehl wird im Kontext der aktuellen Transaktion ausgeführt, wenn eine solche Transaktion vorhanden ist.

 Der Aufruf der <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A>-Methode entspricht dem Aufruf der <xref:System.Data.Common.DbCommand.ExecuteReader%2A>-Methode der <xref:System.Data.Common.DbCommand>-Klasse, nur gibt die <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A>-Methode Entitäten zurück und die <xref:System.Data.Common.DbCommand.ExecuteReader%2A>-Methode gibt Eigenschaftswerte im <xref:System.Data.Common.DbDataReader> zurück.

 Geben Sie den Namen der Entitätenmenge an, wenn die Ergebnisse als Entitäten nachverfolgt werden sollen.

 Ruft <xref:System.Data.Objects.ObjectContext.Translate%2A> Methode auf, um eine <xref:System.Data.Common.DbDataReader> in Entitäts Objekte zu übersetzen, wenn der Reader Daten Zeilen enthält, die dem angegebenen Entitätstyp zugeordnet sind.

 Die Verwendung parametrisierter Befehle hilft beim Schutz vor SQL Injection-Angriffen, bei denen ein Angreifer einen SQL-Befehl in eine SQL-Anweisung einschleust, der die Sicherheit auf dem Server gefährdet. Parametrisierte Befehle schützen vor einem SQL-Injection-Angriff, indem sichergestellt wird, dass von einer externen Quelle empfangene Werte nur als Werte und nicht als Teil der SQL-Anweisung ausgegeben werden. Folglich werden in einen Wert eingefügte SQL-Befehle nicht in der Datenquelle ausgeführt. Stattdessen werden sie nur als Parameterwert ausgewertet. Zusätzlich zu den Sicherheitsvorteilen bieten parametrisierte Befehle eine bequeme Methode zum Organisieren von Werten, die mit einer SQL-Anweisung oder einer gespeicherten Prozedur übergebenen werden.

 Der `parameters`-Wert kann ein Array von <xref:System.Data.Common.DbParameter>-Objekten oder ein Array von Parameterwerten sein. Wenn nur Werte angegeben werden, wird ein Array von <xref:System.Data.Common.DbParameter> Objekten basierend auf der Reihenfolge der Werte im Array erstellt.

 Weitere Informationen finden Sie unter:

 [Direkte Ausführung von Speicher Befehlen](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) und

 [Gewusst wie: Direktes Ausführen von Befehlen für die Datenquelle](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKnownProxyTypes">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Type&gt; GetKnownProxyTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; GetKnownProxyTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetKnownProxyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetKnownProxyTypes () As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ GetKnownProxyTypes();" />
      <MemberSignature Language="F#" Value="static member GetKnownProxyTypes : unit -&gt; seq&lt;Type&gt;" Usage="System.Data.Objects.ObjectContext.GetKnownProxyTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle vorhandenen Proxytypen zurück.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> aller vorhandenen Proxytypen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Objects.ObjectContext.GetKnownProxyTypes%2A>-Methode wird verwendet, wenn die Proxy Objekt Generierung für poco-Entitäten aktiviert ist. Weitere Informationen finden Sie unter [Anforderungen zum Erstellen von poco](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) -Proxys und [Arbeiten mit poco-Entitäten](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectByKey">
      <MemberSignature Language="C#" Value="public object GetObjectByKey (System.Data.EntityKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetObjectByKey(class System.Data.EntityKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetObjectByKey(System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObjectByKey (key As EntityKey) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetObjectByKey(System::Data::EntityKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.GetObjectByKey : System.Data.EntityKey -&gt; obj" Usage="objectContext.GetObjectByKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu suchenden Objekts.</param>
        <summary>Gibt ein Objekt mit dem angegebenen Entitätsschlüssel zurück.</summary>
        <returns>Ein <see cref="T:System.Object" />, bei dem es sich um die Instanz eines Entitätstyps handelt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> versucht ein Objekt mit dem angegebenen <xref:System.Data.EntityKey> vom <xref:System.Data.Objects.ObjectStateManager> abzurufen. Wenn das Objekt derzeit nicht in den Objekt Kontext geladen wird, wird eine Abfrage ausgeführt, wenn versucht wird, das Objekt aus der Datenquelle zurückzugeben. Weitere Informationen finden Sie unter [Objekt Abfragen](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)).

 <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> löst eine <xref:System.Data.ObjectNotFoundException> aus, wenn das Objekt nicht gefunden wird. Um die Behandlung dieser Ausnahme zu vermeiden, können Sie stattdessen die <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A>-Methode verwenden.

 Diese Methode gibt Objekte im <xref:System.Data.EntityState.Deleted>-Status zurück.

 Ein temporärer Schlüssel kann nicht verwendet werden, um ein Objekt aus der Datenquelle zurückzugeben.



## Examples
 Dieses Beispiel basiert auf den [Microsoft SQL Server Product Samples: Database](https://archive.codeplex.com/?p=msftdbprodsamples). In dem Beispiel wird ein <xref:System.Data.EntityKey> für eine Entität des angegebenen Typs erstellt und anschließend eine Entität mittels Schlüssel abgerufen.

 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_GetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_getobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_GetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_getobjectbykey)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="key" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Data.ObjectNotFoundException">Das Objekt wurde weder im <see cref="T:System.Data.Objects.ObjectStateManager" /> noch in der Datenquelle gefunden.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Abfragen von Daten als Objekte (Entity Framework)</related>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObjectType">
      <MemberSignature Language="C#" Value="public static Type GetObjectType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetObjectType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetObjectType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectType (type As Type) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetObjectType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetObjectType : Type -&gt; Type" Usage="System.Data.Objects.ObjectContext.GetObjectType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="type">Das <see cref="T:System.Type" /> des Proxyobjekts.</param>
        <summary>Gibt den Entitätstyp der POCO-Entität mit einem Proxyobjekt eines angegebenen Typs zurück.</summary>
        <returns>Der <see cref="T:System.Type" /> der zugeordneten POCO-Entität.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Objects.ObjectContext.GetObjectType%2A>-Methode wird verwendet, wenn die Proxy Objekt Generierung für poco-Entitäten aktiviert ist. Weitere Informationen finden Sie unter [Anforderungen zum Erstellen von poco](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) -Proxys und [Arbeiten mit poco-Entitäten](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadProperty">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt ein verbundenes Objekt explizit, wenn Sie benutzerdefinierte POCO-Datenklassen verwenden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Wenn Sie benutzerdefinierte poco-Daten Klassen verwenden, können verknüpfte Objekte nicht explizit wie Instanzen von Entitäts Typen geladen werden, die von den Entity Data Model Tools generiert werden. Dies liegt daran, dass die-Tools die Navigations Eigenschaften generieren, die eine <xref:System.Data.Objects.DataClasses.EntityCollection%601> oder <xref:System.Data.Objects.DataClasses.EntityReference%601> verwandter Objekte zurückgeben, wenn <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> für eine <xref:System.Data.Objects.DataClasses.RelatedEnd>aufgerufen wird. Poco-Entitäten können weiterhin mithilfe von Lazy Loading geladen werden, indem die <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A>-Eigenschaft auf `true` in der Instanz von <xref:System.Data.Objects.ObjectContextOptions> festgelegt wird, die von der <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird, oder mithilfe von Eager Loading mit der <xref:System.Data.Objects.ObjectQuery%601.Include%2A>-Methode auf dem <xref:System.Data.Objects.ObjectQuery%601>.

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public void LoadProperty (object entity, string navigationProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty(object entity, string navigationProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty (entity As Object, navigationProperty As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadProperty(System::Object ^ entity, System::String ^ navigationProperty);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : obj * string -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="navigationProperty" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, für die verbundene Objekte geladen werden sollen.</param>
        <param name="navigationProperty">Der Name der Navigationseigenschaft, die die zu ladenden verbundenen Objekte zurückgibt.</param>
        <summary>Lädt ein mit dem angegebenen Objekt verbundenes Objekt explizit anhand der angegebenen Navigationseigenschaft und unter Verwendung der standardmäßigen Zusammenführungsoption.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>-Methode muss aufgerufen werden, um explizites laden zu erreichen, wenn Sie benutzerdefinierte poco-Daten Klassen verwenden.

 Nach dem Aufrufen von <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>kann über die Navigations Eigenschaften der Quell Entität auf das verbundene Objekt zugegriffen werden.

 Wenn Sie benutzerdefinierte poco-Daten Klassen verwenden, können verknüpfte Objekte nicht explizit wie Instanzen von Entitäts Typen geladen werden, die von den Entity Data Model Tools generiert werden. Dies liegt daran, dass die-Tools die Navigations Eigenschaften generieren, die eine <xref:System.Data.Objects.DataClasses.EntityCollection%601> oder <xref:System.Data.Objects.DataClasses.EntityReference%601> verwandter Objekte zurückgeben, wenn <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> für eine <xref:System.Data.Objects.DataClasses.RelatedEnd>aufgerufen wird. Poco-Entitäten können weiterhin mithilfe von Lazy Loading geladen werden, indem die <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A>-Eigenschaft auf `true` in der Instanz von <xref:System.Data.Objects.ObjectContextOptions> festgelegt wird, die von der <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird, oder mithilfe von Eager Loading mit der <xref:System.Data.Objects.ObjectQuery%601.Include%2A>-Methode auf dem <xref:System.Data.Objects.ObjectQuery%601>.

 Wenn die <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>-Methode aufgerufen wird, werden-Objekte mithilfe des Standard <xref:System.Data.Objects.MergeOption> Werts <xref:System.Data.Objects.MergeOption.AppendOnly>in den <xref:System.Data.Objects.ObjectContext> geladen.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das <paramref name="entity" />-Element ist im Zustand <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> oder <see cref="F:System.Data.EntityState.Deleted" />.

- oder -

Das <paramref name="entity" />-Element ist an eine andere Instanz von <see cref="T:System.Data.Objects.ObjectContext" /> angefügt.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public void LoadProperty (object entity, string navigationProperty, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty(object entity, string navigationProperty, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty(System.Object,System.String,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty (entity As Object, navigationProperty As String, mergeOption As MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadProperty(System::Object ^ entity, System::String ^ navigationProperty, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : obj * string * System.Data.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="navigationProperty" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="entity">Die Entität, für die verbundene Objekte geladen werden sollen.</param>
        <param name="navigationProperty">Der Name der Navigationseigenschaft, die die zu ladenden verbundenen Objekte zurückgibt.</param>
        <param name="mergeOption">Der beim Laden der verbundenen Objekte zu verwendende <see cref="T:System.Data.Objects.MergeOption" />-Wert.</param>
        <summary>Lädt ein mit dem angegebenen Objekt verbundenes Objekt explizit anhand der angegebenen Navigationseigenschaft und unter Verwendung der angegebenen Zusammenführungsoption.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>-Methode muss aufgerufen werden, um explizites laden zu erreichen, wenn Sie benutzerdefinierte poco-Daten Klassen verwenden.

 Nach dem Aufrufen von <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>kann über die Navigations Eigenschaften der Quell Entität auf das verbundene Objekt zugegriffen werden.

 Wenn Sie benutzerdefinierte poco-Daten Klassen verwenden, können verknüpfte Objekte nicht explizit wie Instanzen von Entitäts Typen geladen werden, die von den Entity Data Model Tools generiert werden. Dies liegt daran, dass die-Tools die Navigations Eigenschaften generieren, die eine <xref:System.Data.Objects.DataClasses.EntityCollection%601> oder <xref:System.Data.Objects.DataClasses.EntityReference%601> verwandter Objekte zurückgeben, wenn <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> für eine <xref:System.Data.Objects.DataClasses.RelatedEnd>aufgerufen wird. Poco-Entitäten können weiterhin mithilfe von Lazy Loading geladen werden, indem die <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A>-Eigenschaft auf `true` in der Instanz von <xref:System.Data.Objects.ObjectContextOptions> festgelegt wird, die von der <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird, oder mithilfe von Eager Loading mit der <xref:System.Data.Objects.ObjectQuery%601.Include%2A>-Methode auf dem <xref:System.Data.Objects.ObjectQuery%601>.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das <paramref name="entity" />-Element ist im Zustand <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> oder <see cref="F:System.Data.EntityState.Deleted" />.

- oder -

Das <paramref name="entity" />-Element ist an eine andere Instanz von <see cref="T:System.Data.Objects.ObjectContext" /> angefügt.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty(Of TEntity) (entity As TEntity, selector As Expression(Of Func(Of TEntity, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; void LoadProperty(TEntity entity, System::Linq::Expressions::Expression&lt;Func&lt;TEntity, System::Object ^&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; -&gt; unit" Usage="objectContext.LoadProperty (entity, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Der Typ des angegebenen Objekts.</typeparam>
        <param name="entity">Das Quellobjekt, für das verbundene Objekte geladen werden sollen.</param>
        <param name="selector">Ein LINQ-Ausdruck, der die zu ladenden verbundenen Objekte definiert.</param>
        <summary>Lädt ein mit dem angegebenen Objekt verbundenes Objekt explizit anhand der angegebenen LINQ-Abfrage und unter Verwendung der standardmäßigen Zusammenführungsoption.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>-Methode muss aufgerufen werden, um explizites laden zu erreichen, wenn Sie benutzerdefinierte poco-Daten Klassen verwenden.

 Nach dem Aufrufen von <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>kann über die Navigations Eigenschaften der Quell Entität auf das verbundene Objekt zugegriffen werden.

 Die zu ladende Eigenschaft wird durch einen LINQ-Ausdruck angegeben, der in Form eines einfachen Eigenschaftenmember-Zugriffs vorliegen muss, wie in `(entity) => entity.PropertyName`, wobei *propertyName* die Navigations Eigenschaft ist, die die zu ladenden verknüpften Objekte zurückgibt. Eine Ausnahme tritt auf, wenn andere Formen des LINQ-Ausdrucks verwendet werden.

 Wenn Sie benutzerdefinierte poco-Daten Klassen verwenden, können verknüpfte Objekte nicht explizit wie Instanzen von Entitäts Typen geladen werden, die von den Entity Data Model Tools generiert werden. Dies liegt daran, dass die-Tools die Navigations Eigenschaften generieren, die eine <xref:System.Data.Objects.DataClasses.EntityCollection%601> oder <xref:System.Data.Objects.DataClasses.EntityReference%601> verwandter Objekte zurückgeben, wenn <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> für eine <xref:System.Data.Objects.DataClasses.RelatedEnd>aufgerufen wird. Poco-Entitäten können weiterhin mithilfe von Lazy Loading geladen werden, indem die <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A>-Eigenschaft auf `true` in der Instanz von <xref:System.Data.Objects.ObjectContextOptions> festgelegt wird, die von der <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird, oder mithilfe von Eager Loading mit der <xref:System.Data.Objects.ObjectQuery%601.Include%2A>-Methode auf dem <xref:System.Data.Objects.ObjectQuery%601>.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="selector" /> gibt keinen gültigen Eingabeparameter zurück.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="selector" /> ist NULL.</exception>
        <exception cref="T:System.InvalidOperationException">Das <paramref name="entity" />-Element ist im Zustand <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> oder <see cref="F:System.Data.EntityState.Deleted" />.

- oder -

Das <paramref name="entity" />-Element ist an eine andere Instanz von <see cref="T:System.Data.Objects.ObjectContext" /> angefügt.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Data.Objects.MergeOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty(Of TEntity) (entity As TEntity, selector As Expression(Of Func(Of TEntity, Object)), mergeOption As MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; void LoadProperty(TEntity entity, System::Linq::Expressions::Expression&lt;Func&lt;TEntity, System::Object ^&gt; ^&gt; ^ selector, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; * System.Data.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, selector, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Der Typ des angegebenen Objekts.</typeparam>
        <param name="entity">Das Quellobjekt, für das verbundene Objekte geladen werden sollen.</param>
        <param name="selector">Ein LINQ-Ausdruck, der die zu ladenden verbundenen Objekte definiert.</param>
        <param name="mergeOption">Der beim Laden der verbundenen Objekte zu verwendende <see cref="T:System.Data.Objects.MergeOption" />-Wert.</param>
        <summary>Lädt ein mit dem angegebenen Objekt verbundenes Objekt explizit anhand der angegebenen LINQ-Abfrage und unter Verwendung der angegebenen Zusammenführungsoption.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>-Methode muss aufgerufen werden, um explizites laden zu erreichen, wenn Sie benutzerdefinierte poco-Daten Klassen verwenden.

 Nach dem Aufrufen von <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>kann über die Navigations Eigenschaften der Quell Entität auf das verbundene Objekt zugegriffen werden.

 Die zu ladende Eigenschaft wird durch einen LINQ-Ausdruck angegeben, der in Form eines einfachen Eigenschaftenmember-Zugriffs vorliegen muss, wie in `(entity) => entity.PropertyName`, wobei *propertyName* die Navigations Eigenschaft ist, die die zu ladenden verknüpften Objekte zurückgibt. Eine Ausnahme tritt auf, wenn andere Formen des LINQ-Ausdrucks verwendet werden.

 Wenn Sie benutzerdefinierte poco-Daten Klassen verwenden, können verknüpfte Objekte nicht explizit wie Instanzen von Entitäts Typen geladen werden, die von den Entity Data Model Tools generiert werden. Dies liegt daran, dass die-Tools die Navigations Eigenschaften generieren, die eine <xref:System.Data.Objects.DataClasses.EntityCollection%601> oder <xref:System.Data.Objects.DataClasses.EntityReference%601> verwandter Objekte zurückgeben, wenn <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> für eine <xref:System.Data.Objects.DataClasses.RelatedEnd>aufgerufen wird. Poco-Entitäten können weiterhin mithilfe von Lazy Loading geladen werden, indem die <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A>-Eigenschaft auf `true` in der Instanz von <xref:System.Data.Objects.ObjectContextOptions> festgelegt wird, die von der <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird, oder mithilfe von Eager Loading mit der <xref:System.Data.Objects.ObjectQuery%601.Include%2A>-Methode auf dem <xref:System.Data.Objects.ObjectQuery%601>.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="selector" /> gibt keinen gültigen Eingabeparameter zurück.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="selector" /> ist NULL.</exception>
        <exception cref="T:System.InvalidOperationException">Das <paramref name="entity" />-Element ist im Zustand <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> oder <see cref="F:System.Data.EntityState.Deleted" />.

- oder -

Das <paramref name="entity" />-Element ist an eine andere Instanz von <see cref="T:System.Data.Objects.ObjectContext" /> angefügt.</exception>
      </Docs>
    </Member>
    <Member MemberName="MetadataWorkspace">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.MetadataWorkspace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MetadataWorkspace As MetadataWorkspace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Metadata::Edm::MetadataWorkspace ^ MetadataWorkspace { System::Data::Metadata::Edm::MetadataWorkspace ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataWorkspace : System.Data.Metadata.Edm.MetadataWorkspace" Usage="System.Data.Objects.ObjectContext.MetadataWorkspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.MetadataWorkspace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vom Objektkontext verwendeten Metadaten-Arbeitsbereich ab.</summary>
        <value>Das diesem <see cref="T:System.Data.Metadata.Edm.MetadataWorkspace" /> zugeordnete <see cref="T:System.Data.Objects.ObjectContext" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Metadata.Edm.MetadataWorkspace>-Klasse ist eine zentrale Laufzeit-API, mit deren Hilfe im Kontext einer Anwendung mit den Entity Data Model-Metadaten (EDM) interagiert werden kann.

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ObjectMaterialized">
      <MemberSignature Language="C#" Value="public event System.Data.Objects.ObjectMaterializedEventHandler ObjectMaterialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.Objects.ObjectMaterializedEventHandler ObjectMaterialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.Objects.ObjectContext.ObjectMaterialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ObjectMaterialized As ObjectMaterializedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::Objects::ObjectMaterializedEventHandler ^ ObjectMaterialized;" />
      <MemberSignature Language="F#" Value="member this.ObjectMaterialized : System.Data.Objects.ObjectMaterializedEventHandler " Usage="member this.ObjectMaterialized : System.Data.Objects.ObjectMaterializedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectMaterializedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn im Rahmen einer Abfrage oder eines Ladevorgangs ein neues Entitätsobjekt aus Daten in der Datenquelle erstellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Dieses Ereignis wird ausgelöst, nachdem alle skalaren, komplexen und Verweis Eigenschaften für ein Objekt festgelegt wurden, aber bevor Auflistungen geladen werden. Wenn ein Objekt mit demselben Schlüsselwert im Objekt Kontext vorhanden ist, wird das Objekt vom Entity Framework nicht neu erstellt, und dieses Ereignis wird nicht ausgelöst.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectStateManager">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectStateManager ObjectStateManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Objects.ObjectStateManager ObjectStateManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.ObjectStateManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ObjectStateManager As ObjectStateManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Objects::ObjectStateManager ^ ObjectStateManager { System::Data::Objects::ObjectStateManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ObjectStateManager : System.Data.Objects.ObjectStateManager" Usage="System.Data.Objects.ObjectContext.ObjectStateManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectStateManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Objektstatus-Manager ab, der vom Objektkontext verwendet wird, um Objektänderungen nachzuverfolgen.</summary>
        <value>Der von diesem <see cref="T:System.Data.Objects.ObjectStateManager" /> verwendete <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 Diese Beispiele basieren auf den [Microsoft SQL Server Product Samples: Database](https://archive.codeplex.com/?p=msftdbprodsamples). In diesem Beispiel wird der <xref:System.Data.Objects.ObjectStateManager> aus dem <xref:System.Data.Objects.ObjectContext> abgerufen und für den Zugriff auf ein Objekt im Kontext verwendet.

 [!code-csharp[DP ObjectServices Concepts#ObjectStateManager](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectstatemanager)]
 [!code-vb[DP ObjectServices Concepts#ObjectStateManager](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectstatemanager)]

 In diesem Beispiel wird die <xref:System.Data.Objects.ObjectStateManager.TryGetObjectStateEntry%2A>-Methode für den zurückgegebenen <xref:System.Data.Objects.ObjectStateManager> verwendet, um ein Objekt auf Grundlage des zugehörigen Entitätsschlüssels abzurufen.

 [!code-csharp[DP ObjectServices Concepts#ApplyItemUpdates](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#applyitemupdates)]
 [!code-vb[DP ObjectServices Concepts#ApplyItemUpdates](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#applyitemupdates)]

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="QueryProvider">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryProvider QueryProvider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.IQueryProvider QueryProvider" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.QueryProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property QueryProvider As IQueryProvider" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Linq::IQueryProvider ^ QueryProvider { System::Linq::IQueryProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryProvider : System.Linq.IQueryProvider" Usage="System.Data.Objects.ObjectContext.QueryProvider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zugeordneten LINQ-Abfrageanbieter dieses Objektkontexts ab.</summary>
        <value>Die von diesem Objektkontext verwendete <see cref="T:System.Linq.IQueryProvider" />-Instanz.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualisiert bestimmte Objekte im Objektkontext mit Daten aus der Datenquelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die Reihenfolge, in der Objekte aktualisiert werden, ist nicht deterministisch.

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Objects.RefreshMode refreshMode, System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Objects.RefreshMode refreshMode, class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Refresh(System.Data.Objects.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (refreshMode As RefreshMode, collection As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Objects::RefreshMode refreshMode, System::Collections::IEnumerable ^ collection);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Objects.RefreshMode * System.Collections.IEnumerable -&gt; unit" Usage="objectContext.Refresh (refreshMode, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Objects.RefreshMode" />
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="refreshMode">Ein <see cref="T:System.Data.Objects.RefreshMode" />-Wert, der angibt, ob Eigenschaftsänderungen im Objektkontext durch Eigenschaftswerte aus der Datenquelle überschrieben werden.</param>
        <param name="collection">Eine <see cref="T:System.Collections.IEnumerable" />-Auflistung von zu aktualisierenden Objekten.</param>
        <summary>Aktualisiert eine Auflistung von Objekten im Objektkontext mit Daten aus der Datenquelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Diese Methode hat den doppelten Zweck, das Aktualisieren von Objekten im Objekt Kontext mit Daten aus der Datenquelle zuzulassen, und stellt den Mechanismus dar, durch den Konflikte aufgelöst werden können. Weitere Informationen finden Sie unter [Speichern von Änderungen und verwalten](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e)von Parallelität.

 Die Reihenfolge, in der Objekte aktualisiert werden, ist nicht deterministisch.

 Nachdem <xref:System.Data.Objects.ObjectContext.Refresh%2A> aufgerufen wurde, werden die ursprünglichen Werte des Objekts stets mit dem Datenquellen Wert aktualisiert. die aktuellen Werte werden jedoch möglicherweise mit dem Datenquellen Wert aktualisiert. Dies ist abhängig vom <xref:System.Data.Objects.RefreshMode>-Wert. Der <xref:System.Data.Objects.RefreshMode.StoreWins> Modus bedeutet, dass die Objekte in der Auflistung aktualisiert werden sollen, damit Sie den Datenquellen Werten entsprechen. <xref:System.Data.Objects.RefreshMode.ClientWins> bedeutet, dass nur die Änderungen im Objekt Kontext persistent gespeichert werden, auch wenn andere Änderungen an der Datenquelle vorgenommen wurden.

 Um sicherzustellen, dass Objekte mit Datenquellen seitiger Logik aktualisiert wurden, können Sie <xref:System.Data.Objects.ObjectContext.Refresh%2A> mit <xref:System.Data.Objects.RefreshMode.StoreWins> abrufen, nachdem Sie die <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>-Methode aufgerufen haben.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="refreshMode" /> ist nicht gültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="collection" /> ist leer.

- oder -

Ein Objekt ist nicht an den Kontext angefügt.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Objects.RefreshMode refreshMode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Objects.RefreshMode refreshMode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Refresh(System.Data.Objects.RefreshMode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (refreshMode As RefreshMode, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Objects::RefreshMode refreshMode, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Objects.RefreshMode * obj -&gt; unit" Usage="objectContext.Refresh (refreshMode, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Objects.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="refreshMode">Einer der <see cref="T:System.Data.Objects.RefreshMode" />-Werte, der den Modus zum Aktualisieren des <see cref="T:System.Data.Objects.ObjectStateManager" /> angibt.</param>
        <param name="entity">Das zu aktualisierende Objekt.</param>
        <summary>Aktualisiert ein Objekt im Objektkontext mit Daten aus der Datenquelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Data.Objects.ObjectContext.Refresh%2A> hat den doppelten Zweck, ein Objekt zu aktualisieren, das mit Daten aus der Datenquelle aktualisiert werden kann, und es ist der Mechanismus, mit dem Konflikte aufgelöst werden können. Weitere Informationen finden Sie unter [Speichern von Änderungen und verwalten](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e)von Parallelität.

 Die Reihenfolge, in der Objekte aktualisiert werden, ist nicht deterministisch.

 Nachdem die <xref:System.Data.Objects.ObjectContext.Refresh%2A>-Methode aufgerufen wurde, werden die ursprünglichen Werte des Objekts stets mit dem Datenquellen Wert aktualisiert. die aktuellen Werte werden jedoch möglicherweise mit dem Datenquellen Wert aktualisiert. Dies ist abhängig vom <xref:System.Data.Objects.RefreshMode>. Der <xref:System.Data.Objects.RefreshMode.StoreWins> Modus bedeutet, dass das Objekt entsprechend den Datenquellen Werten aktualisiert werden soll. Der <xref:System.Data.Objects.RefreshMode.ClientWins> Wert bedeutet, dass nur die Änderungen im Objekt Kontext persistent gespeichert werden, auch wenn andere Änderungen an der Datenquelle vorgenommen wurden.

 Um sicherzustellen, dass ein Objekt durch Datenquellen Logik aktualisiert wurde, können Sie die <xref:System.Data.Objects.ObjectContext.Refresh%2A>-Methode mit dem <xref:System.Data.Objects.RefreshMode.StoreWins> Wert abrufen, nachdem Sie die <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>-Methode aufgerufen haben.



## Examples
 Dieses Beispiel basiert auf den [Microsoft SQL Server Product Samples: Database](https://archive.codeplex.com/?p=msftdbprodsamples). Im diesem Beispiel wird versucht, Änderungen zu speichern, was zu einem Parallelitätskonflikt führen kann. Anschließend wird gezeigt, wie der Parallelitätskonflikt gelöst wird, indem der Objektkontext aktualisiert wird, bevor die Änderungen erneut gespeichert werden.

 [!code-csharp[DP ObjectServices Concepts#Concurrency](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#concurrency)]
 [!code-vb[DP ObjectServices Concepts#Concurrency](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#concurrency)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="refreshMode" /> ist nicht gültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="collection" /> ist leer.

- oder -

Ein Objekt ist nicht an den Kontext angefügt.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Speichert alle Aktualisierungen der Datenquelle permanent.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public int SaveChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SaveChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveChanges () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SaveChanges();" />
      <MemberSignature Language="F#" Value="member this.SaveChanges : unit -&gt; int" Usage="objectContext.SaveChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert alle Aktualisierungen der Datenquelle permanent und setzt die Änderungsnachverfolgung im Objektkontext zurück.</summary>
        <returns>Die Anzahl von Objekten im Status <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" /> oder <see cref="F:System.Data.EntityState.Deleted" />, als <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" /> aufgerufen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Um sicherzustellen, dass Objekte auf dem Client durch Datenquellen seitige Logik aktualisiert wurden, können Sie die <xref:System.Data.Objects.ObjectContext.Refresh%2A>-Methode mit dem <xref:System.Data.Objects.RefreshMode.StoreWins> Wert abrufen, nachdem Sie <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>aufgerufen haben. Weitere Informationen finden Sie unter [Speichern von Änderungen und verwalten](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e)von Parallelität.

 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> innerhalb einer Transaktion. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> führt ein Rollback für diese Transaktion aus und löst eine Ausnahme aus, wenn eines der geänderten <xref:System.Data.Objects.ObjectStateEntry> Objekte nicht beibehalten werden kann.

 Wenn die vollständige Parallelität verletzt wurde, wird eine <xref:System.Data.OptimisticConcurrencyException> ausgelöst. Die Verletzung der vollständigen Parallelität kann aufgelöst werden, indem Sie sie abfangen, die <xref:System.Data.Objects.ObjectContext.Refresh%2A>-Methode mit dem Wert <xref:System.Data.Objects.RefreshMode.StoreWins> oder <xref:System.Data.Objects.RefreshMode.ClientWins> aufrufen und anschließend <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> erneut aufrufen. Weitere Informationen finden Sie unter Gewusst [wie: Verwalten von Daten Parallelität im Objekt Kontext](https://msdn.microsoft.com/library/25ffe70d-ce97-4f0a-8ae0-22b7c40f748a).



## Examples
 Dieses Beispiel basiert auf den [Microsoft SQL Server Product Samples: Database](https://archive.codeplex.com/?p=msftdbprodsamples). Im diesem Beispiel wird versucht, Änderungen zu speichern, die möglicherweise einen Parallelitätskonflikt verursachen. Anschließend wird gezeigt, wie der Parallelitätskonflikt gelöst wird, indem der Objektkontext aktualisiert wird, bevor die Änderungen erneut gespeichert werden.

 [!code-csharp[DP ObjectServices Concepts#Concurrency](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#concurrency)]
 [!code-vb[DP ObjectServices Concepts#Concurrency](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#concurrency)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">In der Datenquelle wurde die vollständige Parallelität verletzt.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public int SaveChanges (bool acceptChangesDuringSave);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SaveChanges(bool acceptChangesDuringSave) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveChanges (acceptChangesDuringSave As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SaveChanges(bool acceptChangesDuringSave);" />
      <MemberSignature Language="F#" Value="member this.SaveChanges : bool -&gt; int" Usage="objectContext.SaveChanges acceptChangesDuringSave" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use SaveChanges(SaveOptions options) instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptChangesDuringSave" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="acceptChangesDuringSave">Dieser Parameter wird für clientseitige Transaktionsunterstützung benötigt. Wenn <see langword="true" /> festgelegt ist, wird die Änderungsnachverfolgung für alle Objekte nach Abschluss von <see cref="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" /> zurückgesetzt. Wenn <see langword="false" /> festgelegt ist, muss die <see cref="M:System.Data.Objects.ObjectContext.AcceptAllChanges" />-Methode nach <see cref="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" /> aufgerufen werden.</param>
        <summary>Speichert alle Aktualisierungen der Datenquelle permanent und setzt optional die Änderungsnachverfolgung im Objektkontext zurück.</summary>
        <returns>Die Anzahl von Objekten im Status <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" /> oder <see cref="F:System.Data.EntityState.Deleted" />, als <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" /> aufgerufen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Stattdessen wird die <xref:System.Data.Objects.ObjectContext.SaveChanges%28System.Data.Objects.SaveOptions%29>-Methode aufgerufen.

 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Die vollständige Parallelität wurde verletzt.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public virtual int SaveChanges (System.Data.Objects.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 SaveChanges(valuetype System.Data.Objects.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges(System.Data.Objects.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SaveChanges (options As SaveOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int SaveChanges(System::Data::Objects::SaveOptions options);" />
      <MemberSignature Language="F#" Value="abstract member SaveChanges : System.Data.Objects.SaveOptions -&gt; int&#xA;override this.SaveChanges : System.Data.Objects.SaveOptions -&gt; int" Usage="objectContext.SaveChanges options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Data.Objects.SaveOptions" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="options">Ein <see cref="T:System.Data.Objects.SaveOptions" />-Wert, der das Verhalten des Vorgangs bestimmt.</param>
        <summary>Speichert alle Aktualisierungen der Datenquelle permanent mit dem angegebenen <see cref="T:System.Data.Objects.SaveOptions" />.</summary>
        <returns>Die Anzahl von Objekten im Status <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" /> oder <see cref="F:System.Data.EntityState.Deleted" />, als <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" /> aufgerufen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Verwenden Sie diese spezielle Überladung von <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>, um sicherzustellen, dass <xref:System.Data.Objects.ObjectContext.DetectChanges%2A> aufgerufen wird, bevor Sie Änderungen an der Datenquelle speichern, oder dass <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> aufgerufen wird, nachdem Sie die Änderungen an der Datenquelle gespeichert haben.

 Diese Enumeration verfügt über eine <xref:System.FlagsAttribute>, die eine bitweise Kombination der Element Werte zulässt.

 Um sicherzustellen, dass Objekte auf dem Client durch Datenquellen seitige Logik aktualisiert wurden, können Sie die <xref:System.Data.Objects.ObjectContext.Refresh%2A>-Methode mit dem <xref:System.Data.Objects.RefreshMode.StoreWins> Wert abrufen, nachdem Sie <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>aufgerufen haben. Die <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>-Methode arbeitet in einer Transaktion. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> führt ein Rollback für diese Transaktion aus und löst eine Ausnahme aus, wenn eines der geänderten <xref:System.Data.Objects.ObjectStateEntry> Objekte nicht beibehalten werden kann.

 Wenn die vollständige Parallelität verletzt wurde, wird eine <xref:System.Data.OptimisticConcurrencyException> ausgelöst. Die Verletzung der vollständigen Parallelität kann aufgelöst werden, indem Sie sie abfangen, die <xref:System.Data.Objects.ObjectContext.Refresh%2A>-Methode mit dem Wert <xref:System.Data.Objects.RefreshMode.StoreWins> oder <xref:System.Data.Objects.RefreshMode.ClientWins> aufrufen und anschließend die <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>-Methode erneut aufrufen. Weitere Informationen finden Sie unter Gewusst [wie: Verwalten von Daten Parallelität im Objekt Kontext](https://msdn.microsoft.com/library/25ffe70d-ce97-4f0a-8ae0-22b7c40f748a).

 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Die vollständige Parallelität wurde verletzt.</exception>
      </Docs>
    </Member>
    <Member MemberName="SavingChanges">
      <MemberSignature Language="C#" Value="public event EventHandler SavingChanges;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SavingChanges" />
      <MemberSignature Language="DocId" Value="E:System.Data.Objects.ObjectContext.SavingChanges" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SavingChanges As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SavingChanges;" />
      <MemberSignature Language="F#" Value="member this.SavingChanges : EventHandler " Usage="member this.SavingChanges : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn Änderungen in der Datenquelle gespeichert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Das <xref:System.Data.Objects.ObjectContext.SavingChanges>-Ereignis wird zu Beginn einer <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>-Operation für einen <xref:System.Data.Objects.ObjectContext> ausgelöst. Dieses Ereignis wird normalerweise dazu verwendet, um geänderte Objekte zu validieren, bevor neue Werte in die Datenbank geschrieben werden.



## Examples
 Dieses Beispiel basiert auf den [Microsoft SQL Server Product Samples: Database](https://archive.codeplex.com/?p=msftdbprodsamples). Dabei wird ein Handler für das <xref:System.Data.Objects.ObjectContext.SavingChanges>-Ereignis registriert, der die Validierung des Entitätsstatus durchführt.

 [!code-csharp[DP ObjectServices Concepts#SavingChanges](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#savingchanges)]
 [!code-vb[DP ObjectServices Concepts#SavingChanges](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#savingchanges)]

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; Translate&lt;TElement&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; Translate&lt;TElement&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TElement) (reader As DbDataReader) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TElement">Der Entitätstyp der Daten in <see cref="T:System.Data.Common.DbDataReader" />.</typeparam>
        <param name="reader">Das <see cref="T:System.Data.Common.DbDataReader" /> mit Entitätsdaten, die in Entitätsobjekte übersetzt werden sollen.</param>
        <summary>Übersetzt einen <see cref="T:System.Data.Common.DbDataReader" />, der Zeilen mit Entitätsdaten enthält, in Objekte des angeforderten Entitätstyps.</summary>
        <returns>Eine Enumeration von Objekten vom Typ <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Objects.ObjectContext.Translate%2A>-Methode wird verwendet, um Entitäts Daten aus einem <xref:System.Data.Common.DbDataReader> in Objekte des angeforderten Typs zu übersetzen. Dieser Prozess wird automatisch ausgeführt, wenn eine <xref:System.Data.Objects.ObjectQuery%601> ausgeführt wird, um Entitäts Daten zurückzugeben. Die <xref:System.Data.Objects.ObjectContext.Translate%2A>-Methode ermöglicht es Ihnen, eine standardmäßige ADO.NET-Abfrage für eine Datenquelle auszuführen und die zurückgegebenen Daten Zeilen in Entitäts Objekte zu übersetzen.

 Der angegebene <xref:System.Data.Common.DbDataReader> muss Daten enthalten, die dem angeforderten Entitätstyp zugeordnet sind.

 Weitere Informationen finden Sie unter:

 [Direkte Ausführung von Speicher Befehlen](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) und

 [Gewusst wie: Direktes Ausführen von Befehlen für die Datenquelle](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wenn <paramref name="reader" /><see langword="null" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TEntity&gt; Translate&lt;TEntity&gt; (System.Data.Common.DbDataReader reader, string entitySetName, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TEntity&gt; Translate&lt;TEntity&gt;(class System.Data.Common.DbDataReader reader, string entitySetName, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader,System.String,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TEntity) (reader As DbDataReader, entitySetName As String, mergeOption As MergeOption) As ObjectResult(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; System::Data::Objects::ObjectResult&lt;TEntity&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader, System::String ^ entitySetName, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader * string * System.Data.Objects.MergeOption -&gt; System.Data.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.Translate (reader, entitySetName, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="entitySetName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Der Entitätstyp der Daten in <see cref="T:System.Data.Common.DbDataReader" />.</typeparam>
        <param name="reader">Das <see cref="T:System.Data.Common.DbDataReader" /> mit Entitätsdaten, die in Entitätsobjekte übersetzt werden sollen.</param>
        <param name="entitySetName">Die Entitätenmenge vom <typeparamref name="TEntity" />-Typ.</param>
        <param name="mergeOption">Das beim Hinzufügen übersetzter Objekte zum Objektkontext zu verwendende <see cref="T:System.Data.Objects.MergeOption" />. Der Standardwert ist <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <summary>Übersetzt ein <see cref="T:System.Data.Common.DbDataReader" />, das Zeilen mit Entitätsdaten enthält, in einer bestimmten Entitätenmenge und mit der angegebenen Zusammenführungsoption in Objekte des angeforderten Entitätstyps.</summary>
        <returns>Eine Enumeration von Objekten vom Typ <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Die <xref:System.Data.Objects.ObjectContext.Translate%2A>-Methode wird verwendet, um Entitäts Daten aus einem <xref:System.Data.Common.DbDataReader> in Objekte des angeforderten Typs zu übersetzen. Dieser Prozess wird automatisch ausgeführt, wenn eine <xref:System.Data.Objects.ObjectQuery%601> ausgeführt wird, um Entitäts Daten zurückzugeben. Die <xref:System.Data.Objects.ObjectContext.Translate%2A>-Methode ermöglicht es Ihnen, eine standardmäßige ADO.NET-Abfrage für eine Datenquelle auszuführen und die zurückgegebenen Daten Zeilen in Entitäts Objekte zu übersetzen.

 Der angegebene <xref:System.Data.Common.DbDataReader> muss Daten enthalten, die dem angeforderten Entitätstyp zugeordnet sind.

 Weitere Informationen finden Sie unter:

 [Direkte Ausführung von Speicher Befehlen](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) und

 [Gewusst wie: Direktes Ausführen von Befehlen für die Datenquelle](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wenn <paramref name="reader" /><see langword="null" /> ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wenn die angegebene <paramref name="mergeOption" /> kein gültiger <see cref="T:System.Data.Objects.MergeOption" />-Wert ist.</exception>
        <exception cref="T:System.InvalidOperationException">Wenn der angegebene <paramref name="entitySetName" /> keine gültige Entitätenmenge für den <paramref name="TResult" />-Typ ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetObjectByKey">
      <MemberSignature Language="C#" Value="public bool TryGetObjectByKey (System.Data.EntityKey key, out object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetObjectByKey(class System.Data.EntityKey key, [out] object&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.TryGetObjectByKey(System.Data.EntityKey,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetObjectByKey (key As EntityKey, ByRef value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetObjectByKey(System::Data::EntityKey ^ key, [Runtime::InteropServices::Out] System::Object ^ % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetObjectByKey : System.Data.EntityKey * obj -&gt; bool" Usage="objectContext.TryGetObjectByKey (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.EntityKey" />
        <Parameter Name="value" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des gesuchten Objekts.</param>
        <param name="value">Enthält das Objekt, wenn diese Methode erfolgreich beendet wurde.</param>
        <summary>Gibt ein Objekt mit dem angegebenen Entitätsschlüssel zurück.</summary>
        <returns><see langword="true" />, wenn das Objekt erfolgreich abgerufen wurde. <see langword="false" />, wenn der <paramref name="key" /> temporär ist, wenn die Verbindung <see langword="null" /> ist oder wenn <paramref name="value" /><see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> versucht ein Objekt mit dem angegebenen <xref:System.Data.EntityKey> vom <xref:System.Data.Objects.ObjectStateManager> abzurufen. Wenn das Objekt derzeit nicht in den Objekt Kontext geladen wird, wird eine Abfrage ausgeführt, wenn versucht wird, das Objekt aus der Datenquelle zurückzugeben. Weitere Informationen finden Sie unter [Objekt Abfragen](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)).

 Verwenden Sie die <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A>-Methode, um die Behandlung der <xref:System.Data.ObjectNotFoundException> zu vermeiden, die vom <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> ausgelöst wird, wenn das Objekt nicht gefunden wurde.

 Diese Methode gibt Objekte im <xref:System.Data.EntityState.Deleted>-Status zurück.

 Ein temporärer Schlüssel kann nicht verwendet werden, um ein Objekt aus der Datenquelle zurückzugeben.

 Die <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A>-Methode wendet das standardmäßige .net-`TryParse` Muster für die <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A>-Methode an und gibt `false` zurück, wenn der <xref:System.Data.ObjectNotFoundException> abgefangen wird.



## Examples
 Das Beispiel in diesem Thema basiert auf den [Microsoft SQL Server Product Samples: Database](https://archive.codeplex.com/?p=msftdbprodsamples). In dem Beispiel wird ein <xref:System.Data.EntityKey> für eine Entität des angegebenen Typs erstellt und anschließend versucht, eine Entität mittels Schlüssel abzurufen.

 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_trygetobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_trygetobjectbykey)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nicht kompatible Metadaten für <paramref name="key" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/working-with-objects.md">Arbeiten mit Objekten (Entity Framework)</related>
      </Docs>
    </Member>
  </Members>
</Type>
