<Type Name="MemoryMappedFile" FullName="System.IO.MemoryMappedFiles.MemoryMappedFile">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7d168823b36f95593f506945258a3e9f9ff52e4a" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75133101" /></Metadata><TypeSignature Language="C#" Value="public class MemoryMappedFile : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryMappedFile extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryMappedFile&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryMappedFile : IDisposable" />
  <TypeSignature Language="F#" Value="type MemoryMappedFile = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Speicherabbilddatei dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine im Speicher abgebildete Datei ordnet den Inhalt einer Datei dem logischen Adressraum einer Anwendung zu. Speicher Abbild Dateien ermöglichen Programmierern, mit extrem großen Dateien zu arbeiten, da der Arbeitsspeicher gleichzeitig verwaltet werden kann, und Sie ermöglichen den kompletten, zufälligen Zugriff auf eine Datei, ohne dass eine Suche erforderlich ist. Im Speicher abgebildete Dateien können auch für mehrere Prozesse freigegeben werden.  
  
 Die <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%2A> Methoden erstellen eine Speicherabbilddatei aus einem angegebenen Pfad oder ein <xref:System.IO.FileStream> einer vorhandenen Datei auf dem Datenträger. Änderungen werden automatisch an den Datenträger weitergegeben, wenn die Datei nicht zugeordnet ist.  
  
 Die <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%2A>-Methoden erstellen eine Speicher Abbild Datei, die keiner vorhandenen Datei auf dem Datenträger zugeordnet ist. und sind für die Erstellung von frei gegebenem Speicher für die prozessübergreifende Kommunikation (prozessübergreifende Kommunikation) geeignet.  
  
 Einer Speicher Abbild Datei kann ein optionaler Name zugeordnet werden, der zulässt, dass die im Speicher abgebildete Datei mit anderen Prozessen gemeinsam genutzt werden kann. 
  
 Sie können mehrere Ansichten der Speicher Abbild Datei erstellen, einschließlich Ansichten von Teilen der Datei. Sie können denselben Teil einer Datei mehreren Adressen zuordnen, um gleichzeitigen Speicher zu erstellen. Parallele Ansichten müssen aus der gleichen Speicherabbilddatei erstellt werden. Das Erstellen von zwei Dateizuordnungen derselben Datei mit zwei Ansichten bietet keine Parallelität.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Speicherabbild für einen Teil einer sehr großen Datei erstellt und teilweise bearbeitet.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#1)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateFromFile">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Speicherabbilddatei aus einer vorhandenen Datei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der abzubildenden Datei.</param>
        <summary>Erstellt eine Speicherabbilddatei aus einer Datei auf dem Datenträger.</summary>
        <returns>Eine Speicherabbilddatei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%2A>-Methode verwendet, um eine Speicher Abbild Datei zu erstellen und dann eine Speicher Abbild Ansicht für einen Teil einer extrem großen Datei zu erstellen.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#1)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerraum oder mindestens ein gemäß der Definition von <see cref="M:System.IO.Path.GetInvalidFileNameChars" />-Methode ungültiges Zeichen.  
  
- oder - 
 <paramref name="path" /> verweist auf ein ungültiges Gerät.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> übersteigt die vom Betriebssystem definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für die Datei.</exception>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der abzubildenden Datei.</param>
        <param name="mode">Der Zugriffsmodus. Muss <see cref="F:System.IO.FileMode.Open" /> sein.</param>
        <summary>Erstellt eine im Speicher abgebildete Datei mit dem angegebenen Zugriffsmodus aus einer Datei auf dem Datenträger.</summary>
        <returns>Eine im Speicher abgebildete Datei mit dem angegebenen Zugriffsmodus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `mode`-Parameter bezieht sich auf die Quelldatei auf dem Datenträger. Sie können nur den <xref:System.IO.FileMode.Open> Enumerationswert verwenden, um die Speicher Abbild Datei aus der Quelldatei auf dem Datenträger zu erstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerraum oder mindestens ein gemäß der Definition von <see cref="M:System.IO.Path.GetInvalidFileNameChars" />-Methode ungültiges Zeichen.  
  
- oder - 
 <paramref name="path" /> verweist auf ein ungültiges Gerät.  
  
- oder - 
 <paramref name="mode" /> ist <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="mode" /> ist <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" /> oder <see cref="F:System.IO.FileMode.Truncate" />.  
  
- oder - 
 <paramref name="mode" /> ist <see cref="F:System.IO.FileMode.OpenOrCreate" /> und die Datei auf dem Datenträger nicht vorhanden ist.  
  
- oder - 
E/A-Fehler</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> übersteigt die vom Betriebssystem definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für die Datei.</exception>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode * string -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode, mapName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der abzubildenden Datei.</param>
        <param name="mode">Der Zugriffsmodus. Muss <see cref="F:System.IO.FileMode.Open" /> sein.</param>
        <param name="mapName">Ein Name, der der im Speicher abgebildeten Datei zugewiesen werden soll, oder <see langword="null" /> für eine <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />, die Sie nicht für mehrere Vorgänge freigeben möchten.</param>
        <summary>Erstellt eine im Speicher abgebildete Datei mit den angegebenen Werten für Zugriffsmodus und Name aus einer Datei auf dem Datenträger.</summary>
        <returns>Eine im Speicher abgebildete Datei mit den angegebenen Werten für Name und Zugriffsmodus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `mode`-Parameter bezieht sich auf die Quelldatei auf dem Datenträger. Sie können nur den <xref:System.IO.FileMode.Open> Enumerationswert verwenden, um die Speicher Abbild Datei aus der Quelldatei auf dem Datenträger zu erstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerraum oder mindestens ein gemäß der Definition von <see cref="M:System.IO.Path.GetInvalidFileNameChars" />-Methode ungültiges Zeichen.  
  
- oder - 
 <paramref name="path" /> verweist auf ein ungültiges Gerät.  
  
- oder - 
 <paramref name="mapName" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="mode" /> ist <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="mode" /> ist <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" /> oder <see cref="F:System.IO.FileMode.Truncate" />.  
  
- oder - 
 <paramref name="mode" /> ist <see cref="F:System.IO.FileMode.OpenOrCreate" /> und die Datei auf dem Datenträger nicht vorhanden ist.  
  
- oder - 
E/A-Fehler</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> übersteigt die vom Betriebssystem definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für die Datei.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName, long capacity);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode * string * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode, mapName, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der abzubildenden Datei.</param>
        <param name="mode">Zugriffsmodus; kann einer der <see cref="T:System.IO.FileMode" />-Enumerationswerte, außer <see cref="F:System.IO.FileMode.Append" />, sein.</param>
        <param name="mapName">Ein Name, der der im Speicher abgebildeten Datei zugewiesen werden soll, oder <see langword="null" /> für eine <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />, die Sie nicht für mehrere Vorgänge freigeben möchten.</param>
        <param name="capacity">Die maximale Größe (in Bytes), die für die Speicherabbilddatei reserviert werden soll. Geben Sie 0 an, um die Kapazität auf die Größe der Datei auf dem Datenträger festzulegen.</param>
        <summary>Erstellt eine im Speicher abgebildete Datei mit den angegebenen Werten für Zugriffsmodus, Name und Kapazität aus einer Datei auf dem Datenträger.</summary>
        <returns>Eine Speicherabbilddatei, die die angegebenen Merkmale aufweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `mode`-Parameter bezieht sich auf die Quelldatei auf dem Datenträger.  
  
 Wenn `capacity` größer als die Größe der Datei auf dem Datenträger ist, wird die Datei auf dem Datenträger entsprechend der angegebenen Kapazität vergrößert, auch wenn keine Daten in die Speicher Abbild Datei geschrieben werden. Um dies zu verhindern, geben Sie 0 (null) für die Standardkapazität an, die `capacity` intern auf die Größe der Datei auf dem Datenträger festgelegt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerraum oder mindestens ein gemäß der Definition von <see cref="M:System.IO.Path.GetInvalidFileNameChars" />-Methode ungültiges Zeichen.  
  
- oder - 
 <paramref name="path" /> verweist auf ein ungültiges Gerät.  
  
- oder - 
 <paramref name="mapName" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="mode" /> ist <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist größer als die Größe des logischen Adressbereichs.  
  
- oder - 
 <paramref name="capacity" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="capacity" /> ist kleiner als die Dateigröße (aber nicht null).  
  
- oder - 
 <paramref name="capacity" /> ist 0 (null), und die Größe der Datei auf dem Datenträger ist auch 0 (null).</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> übersteigt die vom Betriebssystem definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für die Datei.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : string * System.IO.FileMode * string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (path, mode, mapName, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der abzubildenden Datei.</param>
        <param name="mode">Zugriffsmodus; kann einer der <see cref="T:System.IO.FileMode" />-Enumerationswerte, außer <see cref="F:System.IO.FileMode.Append" />, sein.</param>
        <param name="mapName">Ein Name, der der im Speicher abgebildeten Datei zugewiesen werden soll, oder <see langword="null" /> für eine <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />, die Sie nicht für mehrere Vorgänge freigeben möchten.</param>
        <param name="capacity">Die maximale Größe (in Bytes), die für die Speicherabbilddatei reserviert werden soll. Geben Sie 0 an, um die Kapazität auf die Größe der Datei auf dem Datenträger festzulegen.</param>
        <param name="access">Einer der Enumerationswerte, der den zulässigen Zugriffstyp für die Speicherabbilddatei angibt.</param>
        <summary>Erstellt eine im Speicher abgebildete Datei mit den angegebenen Werten für Zugriffsmodus, Name, Kapazität und Zugriffstyp aus einer Datei auf dem Datenträger.</summary>
        <returns>Eine Speicherabbilddatei, die die angegebenen Merkmale aufweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `mode`-Parameter bezieht sich auf die Quelldatei auf dem Datenträger.  
  
 Wenn `capacity` größer als die Größe der Datei auf dem Datenträger ist, wird die Datei auf dem Datenträger entsprechend der angegebenen Kapazität vergrößert, auch wenn keine Daten in die Speicher Abbild Datei geschrieben werden. Um dies zu verhindern, geben Sie 0 (null) für die Standardkapazität an, die `capacity` intern auf die Größe der Datei auf dem Datenträger festgelegt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="access" /> ist kein zulässiger Wert.  
  
- oder - 
 <paramref name="path" /> gibt eine leere Datei an.  
  
- oder - 
 <paramref name="access" /> wird als <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> angegeben und die Kapazität ist höer als die Größe der von <paramref name="path" /> angegebenen Datei.  
  
- oder - 
 <paramref name="mode" /> ist <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist größer als die Größe des logischen Adressbereichs.  
  
- oder - 
 <paramref name="capacity" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="capacity" /> ist kleiner als die Dateigröße (aber nicht null).  
  
- oder - 
 <paramref name="capacity" /> ist 0 (null), und die Größe der Datei auf dem Datenträger ist auch 0 (null).  
  
- oder - 
 <paramref name="access" /> ist kein definierter <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />-Wert.  
  
- oder - 
Die Größer der von <paramref name="path" /> angegebenen Datei ist größer als <paramref name="capacity" />.</exception>
        <exception cref="T:System.IO.IOException">- oder -  
  
 E/A-Fehler</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> übersteigt die vom Betriebssystem definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für die Datei.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (System.IO.FileStream fileStream, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(class System.IO.FileStream fileStream, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.HandleInheritability inheritability, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.IO.FileStream,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.HandleInheritability,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::IO::FileStream ^ fileStream, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : System.IO.FileStream * string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.HandleInheritability * bool -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (fileStream, mapName, capacity, access, inheritability, leaveOpen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileStream" Type="System.IO.FileStream" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mapName" Type="System.String" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="leaveOpen" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileStream">Der Dateistream der angegebenen Datei.</param>
        <param name="mapName">Ein Name, der der im Speicher abgebildeten Datei zugewiesen werden soll, oder <see langword="null" /> für eine <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />, die Sie nicht für mehrere Vorgänge freigeben möchten.</param>
        <param name="capacity">Die maximale Größe (in Bytes), die für die Speicherabbilddatei reserviert werden soll. Geben Sie 0 (null) an, um die Kapazität auf die Größe von <c>fileStream</c> festzulegen.</param>
        <param name="access">Einer der Enumerationswerte, der den zulässigen Zugriffstyp für die Speicherabbilddatei angibt.  
  
Dieser Parameter kann nicht auf <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> festgelegt werden.</param>
        <param name="inheritability">Einer der Enumerationswerte, der angibt, ob ein Handle auf die Speicherabbilddatei von einem untergeordneten Prozess geerbt werden kann. Der Standardwert ist <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <param name="leaveOpen">Dieser Wert gibt an, ob der Stream der Quelldatei geschlossen werden soll, wenn <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> freigegeben wird.</param>
        <summary>Erstellt eine im Speicher abgebildete Datei aus einer vorhandenen Datei mit dem angegebenen Zugriffsmodus, den angegebenen Namen, der angegebenen Vererbbarkeit und Kapazität.</summary>
        <returns>Eine Speicherabbilddatei, die die angegebenen Merkmale aufweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="mapName" /> ist <see langword="null" /> oder eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="capacity" /> und die Länge der Datei sind 0 (null).  
  
- oder - 
 <paramref name="access" /> ist auf den Enumerationswert <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> oder <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> festgelegt. Dies ist nicht erlaubt.  
  
- oder - 
 <paramref name="access" /> ist auf <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> festgelegt, und <paramref name="capacity" /> ist größer als die Länge von <see langword="filestream" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileStream" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="capacity" /> ist kleiner als die Dateigröße.  
  
- oder - 
 <paramref name="access" /> ist kein gültiger <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />-Enumerationswert.  
  
- oder - 
 <paramref name="inheritability" /> ist kein gültiger <see cref="T:System.IO.HandleInheritability" />-Enumerationswert.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (System.IO.FileStream fileStream, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(class System.IO.FileStream fileStream, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.IO.FileStream,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::IO::FileStream ^ fileStream, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="static member CreateFromFile : System.IO.FileStream * string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileSecurity * System.IO.HandleInheritability * bool -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile (fileStream, mapName, capacity, access, memoryMappedFileSecurity, inheritability, leaveOpen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileStream" Type="System.IO.FileStream" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mapName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="leaveOpen" Type="System.Boolean" Index="6" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileStream">Der <paramref name="fileStream" /> für die zuzuordnende Datei.</param>
        <param name="mapName">Ein Name, der der im Speicher abgebildeten Datei zugewiesen werden soll, oder <see langword="null" /> für eine <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />, die Sie nicht für mehrere Vorgänge freigeben möchten.</param>
        <param name="capacity">Die maximale Größe (in Bytes), die für die Speicherabbilddatei reserviert werden soll. Geben Sie 0 an, um die Kapazität auf die Größe der Datei auf dem Datenträger festzulegen.</param>
        <param name="access">Einer der Enumerationswerte, der den zulässigen Zugriffstyp für die Speicherabbilddatei angibt.  
  
Dieser Parameter kann nicht auf <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> festgelegt werden.</param>
        <param name="memoryMappedFileSecurity">Die Berechtigungen, die für den Dateizugriff und für Vorgänge für Speicherabbilddateien gewährt werden können.  
  
Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="inheritability">Einer der Enumerationswerte, der angibt, ob ein Handle auf die Speicherabbilddatei von einem untergeordneten Prozess geerbt werden kann. Der Standardwert ist <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <param name="leaveOpen"><see langword="true" />, um <paramref name="fileStream" /> nicht freizugeben, nachdem <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> geschlossen wurde, <see langword="false" />, um <paramref name="fileStream" /> freizugeben.</param>
        <summary>Erstellt eine im Speicher abgebildete Datei mit den angegebenen Werten für Name, Kapazität, Zugriffstyp, Sicherheitsberechtigungen, Vererbbarkeit und Freigabeanforderung aus einer Datei auf dem Datenträger.</summary>
        <returns>Eine Speicherabbilddatei, die die angegebenen Merkmale aufweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `capacity` größer als die Größe der Datei auf dem Datenträger ist, wird die Datei auf dem Datenträger entsprechend der angegebenen Kapazität vergrößert, auch wenn keine Daten in die Speicher Abbild Datei geschrieben werden. Um dies zu verhindern, geben Sie 0 (null) für die Standardkapazität an, die `capacity` intern auf die Größe der Datei auf dem Datenträger festgelegt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="capacity" /> und die Länge der Datei sind 0 (null).  
  
- oder - 
 <paramref name="access" /> wird auf den Enumerationswert <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> oder <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> festgelegt, der nicht zulässig ist.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileStream" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="capacity" /> ist kleiner als die Dateigröße.  
  
- oder - 
 <paramref name="access" /> ist kein gültiger <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />-Enumerationswert.  
  
- oder - 
 <paramref name="inheritability" /> ist kein gültiger <see cref="T:System.IO.HandleInheritability" />-Enumerationswert.</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="fileStream" /> wurde geschlossen.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> wird auf <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" /> festgelegt, wenn der Zugriff von <paramref name="fileStream" /> auf <see cref="F:System.IO.FileAccess.Read" /> oder <see cref="F:System.IO.FileAccess.Write" /> festgelegt wird.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="mapName" /> ist bereits vorhanden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNew">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Speicherabbilddatei im Systemspeicher.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="mapName">Ein Name, der der im Speicher abgebildeten Datei zugewiesen werden soll, oder <see langword="null" /> für eine <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />, die Sie nicht für mehrere Vorgänge freigeben möchten.</param>
        <param name="capacity">Die maximale Größe (in Bytes), die für die Speicherabbilddatei reserviert werden soll.</param>
        <summary>Erstellt eine im Speicher abgebildete Datei mit der angegebenen Kapazität im Systemspeicher.</summary>
        <returns>Eine im Speicher abgebildete Datei mit den angegebenen Werten für Name und Kapazität.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Speicher Abbild Datei zu erstellen, die nicht persistent gespeichert ist (d. h. nicht mit einer Datei auf dem Datenträger verknüpft ist), die Sie zum Freigeben von Daten zwischen Prozessen verwenden können.  
  
   
  
## Examples  
 Das folgende Beispiel besteht aus drei separate Prozesse (konsolenanwendungen) auf, die schreiben `Boolean` Werte für eine Speicherabbilddatei. Die folgende Sequenz von Aktionen wird ausgeführt:  
  
1.  Prozess A erstellt die Speicher Abbild Datei und schreibt einen Wert in diese Datei.  
  
2.  Prozess B öffnet die im Speicher abgebildete Datei und schreibt einen Wert in diese Datei.  
  
3.  Prozess C öffnet die im Speicher abgebildete Datei und schreibt einen Wert in diese Datei.  
  
4.  Verarbeiten eines Lesevorgangs und Anzeigen der Werte aus der Speicher Abbild Datei.  
  
5.  Nachdem Prozess A mit der Speicher Abbild Datei fertiggestellt wurde, wird die Datei sofort von Garbage Collection freigegeben.  
  
 Gehen Sie folgendermaßen vor, um dieses Beispiel auszuführen:  
  
1.  Kompilieren Sie die Anwendungen, und öffnen Sie drei Befehlsfenster.  
  
2.  Führen Sie im ersten Befehlsfenster Prozess A aus.  
  
3.  Führen Sie in der zweiten Befehlsfenster Prozess B aus.  
  
4.  Wechseln Sie zu Process A, und drücken Sie die EINGABETASTE  
  
5.  Führen Sie in der dritten Befehlsfenster Prozess C aus.  
  
6.  Wechseln Sie zu Process A, und drücken Sie die EINGABETASTE  
  
 Die Ausgabe von Prozess A lautet wie folgt:  
  
```  
Start Process B and press ENTER to continue.  
Start Process C and press ENTER to continue.  
Process A says: True  
Process B says: False  
Process C says: True  
```  
  
 **Prozess A**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_X#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_X#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/vb/program.vb#1)]  
  
 **Prozess B**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_A#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_a/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_A#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_a/vb/program.vb#1)]  
  
 **Prozess C**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_B#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_b/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_B#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_b/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner gleich 0 (null).</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Aufrufe der <c>CreateNew</c>-Methode mit einer benannten im Speicher abgebildeten Datei (d.h. einer <paramref name="mapName" /> ungleich null) werden nur unter Windows-Betriebssystemen unterstützt.</exception>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="mapName">Ein Name, der der im Speicher abgebildeten Datei zugewiesen werden soll, oder <see langword="null" /> für eine <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />, die Sie nicht für mehrere Vorgänge freigeben möchten.</param>
        <param name="capacity">Die maximale Größe (in Bytes), die für die Speicherabbilddatei reserviert werden soll.</param>
        <param name="access">Einer der Enumerationswerte, der den zulässigen Zugriffstyp für die Speicherabbilddatei angibt. Der Standardwert ist <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Erstellt eine im Speicher abgebildete Datei mit den angegebenen Werten für Kapazität und Zugriffstyp im Systemspeicher.</summary>
        <returns>Eine Speicherabbilddatei, die die angegebenen Merkmale aufweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Speicher Abbild Datei zu erstellen, die nicht persistent gespeichert ist (d. h. nicht mit einer Datei auf dem Datenträger verknüpft ist), die Sie zum Freigeben von Daten zwischen Prozessen verwenden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="access" /> ist mit dem <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />-Enumerationswert auf „Nur Schreibzugriff“ festgelegt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner gleich 0 (null).  
  
- oder - 
 <paramref name="access" /> ist kein gültiger <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />-Enumerationswert.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Aufrufe der <c>CreateNew</c>-Methode mit einer benannten im Speicher abgebildeten Datei (d.h. einer <paramref name="mapName" /> ungleich null) werden nur unter Windows-Betriebssystemen unterstützt.</exception>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long, access As MemoryMappedFileAccess, options As MemoryMappedFileOptions, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity, access, options, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mapName">Ein Name, der der im Speicher abgebildeten Datei zugewiesen werden soll, oder <see langword="null" /> für eine <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />, die Sie nicht für mehrere Vorgänge freigeben möchten.</param>
        <param name="capacity">Die maximale Größe (in Bytes), die für die Speicherabbilddatei reserviert werden soll.</param>
        <param name="access">Einer der Enumerationswerte, der den zulässigen Zugriffstyp für die Speicherabbilddatei angibt. Der Standardwert ist <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Eine bitweise Kombination von Enumerationswerten, die Speicherbelegungsoptionen für die Speicherabbilddatei angeben.</param>
        <param name="inheritability">Ein Wert, der angibt, ob ein Handle auf die Speicherabbilddatei von einem untergeordneten Prozess geerbt werden kann. Der Standardwert ist <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Erstellt eine im Speicher abgebildete Datei mit den angegebenen Werten für Name, Kapazität, Zugriffstyp, Speicherbelegung und Vererbbarkeit.</summary>
        <returns>Eine Speicherabbilddatei, die die angegebenen Merkmale aufweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="access" /> ist mit dem <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />-Enumerationswert auf „Nur Schreibzugriff“ festgelegt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner gleich 0 (null).  
  
- oder - 
 <paramref name="access" /> ist kein gültiger <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />-Enumerationswert.  
  
- oder - 
 <paramref name="inheritability" /> ist kein gültiger <see cref="T:System.IO.HandleInheritability" />-Wert.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Aufrufe der <c>CreateNew</c>-Methode mit einer benannten im Speicher abgebildeten Datei (d.h. einer <paramref name="mapName" /> ungleich null) werden nur unter Windows-Betriebssystemen unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateNew : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.MemoryMappedFiles.MemoryMappedFileSecurity * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew (mapName, capacity, access, options, memoryMappedFileSecurity, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mapName">Ein Name, der der im Speicher abgebildeten Datei zugewiesen werden soll, oder <see langword="null" /> für eine <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />, die Sie nicht für mehrere Vorgänge freigeben möchten.</param>
        <param name="capacity">Die maximale Größe (in Bytes), die für die Speicherabbilddatei reserviert werden soll.</param>
        <param name="access">Einer der Enumerationswerte, der den zulässigen Zugriffstyp für die Speicherabbilddatei angibt. Der Standardwert ist <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Eine bitweise Kombination von Enumerationswerten, die Speicherbelegungsoptionen für die Speicherabbilddatei angeben.</param>
        <param name="memoryMappedFileSecurity">Die Berechtigungen, die für den Dateizugriff und für Vorgänge für Speicherabbilddateien gewährt werden können.  
  
Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="inheritability">Einer der Enumerationswerte, der angibt, ob ein Handle auf die Speicherabbilddatei von einem untergeordneten Prozess geerbt werden kann. Der Standardwert ist <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Erstellt eine im Speicher abgebildete Datei mit den angegebenen Werten für Kapazität, Zugriffstyp, Speicherbelegung, Sicherheitsberechtigungen und Vererbbarkeit im Systemspeicher.</summary>
        <returns>Eine Speicherabbilddatei, die die angegebenen Merkmale aufweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Speicher Abbild Datei zu erstellen, die nicht persistent gespeichert ist (d. h. nicht mit einer Datei auf dem Datenträger verknüpft ist), die Sie zum Freigeben von Daten zwischen Prozessen verwenden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="access" /> ist mit dem <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />-Enumerationswert auf „Nur Schreibzugriff“ festgelegt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner gleich 0 (null).  
  
- oder - 
 <paramref name="access" /> ist kein gültiger <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />-Enumerationswert.  
  
- oder - 
 <paramref name="inheritability" /> ist kein gültiger <see cref="T:System.IO.HandleInheritability" />-Enumerationswert.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateOrOpen">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt oder öffnet eine Speicherabbilddatei im Systemspeicher.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="mapName">Der Name der im Speicher abgebildeten Datei.</param>
        <param name="capacity">Die maximale Größe (in Bytes), die für die Speicherabbilddatei reserviert werden soll.</param>
        <summary>Erstellt oder öffnet eine im Speicher abgebildete Datei mit dem angegebenen Namen und der angegebenen Kapazität im Systemspeicher.</summary>
        <returns>Eine Speicherabbilddatei, die den angegebenen Namen und die angegebene Größe aufweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Speicher Abbild Datei zu erstellen oder zu öffnen, die nicht persistent gespeichert ist (d. h. nicht mit einer Datei auf dem Datenträger verknüpft ist), die Sie zum Freigeben von Daten zwischen Prozessen verwenden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist größer als die Größe des logischen Adressbereichs.  
  
- oder - 
 <paramref name="capacity" /> ist kleiner gleich 0 (null).</exception>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="mapName">Der Name der im Speicher abgebildeten Datei.</param>
        <param name="capacity">Die maximale Größe (in Bytes), die für die Speicherabbilddatei reserviert werden soll.</param>
        <param name="access">Einer der Enumerationswerte, der den zulässigen Zugriffstyp für die Speicherabbilddatei angibt. Der Standardwert ist <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Erstellt oder öffnet eine im Speicher abgebildete Datei mit den angegebenen Werten für Name, Kapazität und Zugriffstyp im Systemspeicher.</summary>
        <returns>Eine Speicherabbilddatei, die die angegebenen Merkmale aufweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Speicher Abbild Datei zu erstellen oder zu öffnen, die nicht persistent gespeichert ist (d. h. nicht mit einer Datei auf dem Datenträger verknüpft ist), die Sie zum Freigeben von Daten zwischen Prozessen verwenden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="access" /> ist mit dem <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />-Enumerationswert auf „Nur Schreibzugriff“ festgelegt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist größer als die Größe des logischen Adressbereichs.  
  
- oder - 
 <paramref name="capacity" /> ist kleiner gleich 0 (null).  
  
- oder - 
 <paramref name="access" /> ist kein gültiger <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />-Enumerationswert.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das Betriebssystem hat den angegebenen Zugriff auf die Datei verweigert. access ist z. B. auf <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> oder <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" /> festgelegt, aber die Datei oder das Verzeichnis ist schreibgeschützt.</exception>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long, access As MemoryMappedFileAccess, options As MemoryMappedFileOptions, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity, access, options, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mapName">Der Name der im Speicher abgebildeten Datei.</param>
        <param name="capacity">Die maximale Größe (in Bytes), die für die Speicherabbilddatei reserviert werden soll.</param>
        <param name="access">Einer der Enumerationswerte, der den zulässigen Zugriffstyp für die Speicherabbilddatei angibt. Der Standardwert ist <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Eine bitweise Kombination von Werten, die Speicherbelegungsoptionen für die Datei angeben.</param>
        <param name="inheritability">Ein Wert, der angibt, ob ein Handle auf die Speicherabbilddatei von einem untergeordneten Prozess geerbt werden kann. Der Standardwert ist <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Erstellt eine neue leere im Speicher abgebildete Datei oder öffnet eine vorhandene im Speicher abgebildete Datei, wenn eine Datei mit diesem Namen existiert. Wenn Sie eine vorhandene Datei angeben, werden die Werte für Kapazität, Optionen und Speicherargumente ignoriert.</summary>
        <returns>Eine Speicherabbilddatei, die die angegebenen Merkmale aufweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="access" /> ist mit dem <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />-Enumerationswert auf „Nur Schreibzugriff“ festgelegt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist größer als die Größe des logischen Adressbereichs.  
  
- oder - 
 <paramref name="capacity" /> ist kleiner gleich 0 (null).  
  
- oder - 
 <paramref name="access" /> ist kein gültiger <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />-Enumerationswert.  
  
- oder - 
 <paramref name="inheritability" /> ist kein gültiger <see cref="T:System.IO.HandleInheritability" />-Enumerationswert.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das Betriebssystem hat den angegebenen Zugriff auf die Datei verweigert. access ist z. B. auf <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> oder <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" /> festgelegt, aber die Datei oder das Verzeichnis ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member CreateOrOpen : string * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess * System.IO.MemoryMappedFiles.MemoryMappedFileOptions * System.IO.MemoryMappedFiles.MemoryMappedFileSecurity * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen (mapName, capacity, access, options, memoryMappedFileSecurity, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="capacity" Type="System.Int64" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mapName">Der Name der im Speicher abgebildeten Datei.</param>
        <param name="capacity">Die maximale Größe (in Bytes), die für die Speicherabbilddatei reserviert werden soll.</param>
        <param name="access">Einer der Enumerationswerte, der den zulässigen Zugriffstyp für die Speicherabbilddatei angibt. Der Standardwert ist <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Eine bitweise Kombination von Enumerationswerten, die Speicherbelegungsoptionen für die Speicherabbilddatei angeben.</param>
        <param name="memoryMappedFileSecurity">Die Berechtigungen, die für den Dateizugriff und für Vorgänge für Speicherabbilddateien gewährt werden können.  
  
Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="inheritability">Einer der Enumerationswerte, der angibt, ob ein Handle auf die Speicherabbilddatei von einem untergeordneten Prozess geerbt werden kann. Der Standardwert ist <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Erstellt oder öffnet eine im Speicher abgebildete Datei mit den angegebenen Werten für Kapazität, Zugriffstyp, Speicherbelegung, Sicherheitsberechtigungen und Vererbbarkeit im Systemspeicher.</summary>
        <returns>Eine Speicherabbilddatei, die die angegebenen Merkmale aufweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Speicher Abbild Datei zu erstellen oder zu öffnen, die nicht persistent gespeichert ist (d. h. nicht mit einer Datei auf dem Datenträger verknüpft ist), die Sie zum Freigeben von Daten zwischen Prozessen verwenden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> ist eine leere Zeichenfolge.  
  
- oder - 
 <paramref name="access" /> ist mit dem <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />-Enumerationswert auf „Nur Schreibzugriff“ festgelegt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist größer als die Größe des logischen Adressbereichs.  
  
- oder - 
 <paramref name="capacity" /> ist kleiner gleich 0 (null).  
  
- oder - 
 <paramref name="access" /> ist kein gültiger <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />-Enumerationswert.  
  
- oder - 
 <paramref name="inheritability" /> ist kein gültiger <see cref="T:System.IO.HandleInheritability" />-Enumerationswert.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das Betriebssystem hat den angegebenen <paramref name="access" /> auf die Datei verweigert. <paramref name="access" /> ist z. B. auf <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> oder <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" /> festgelegt, aber die Datei oder das Verzeichnis ist schreibgeschützt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateViewAccessor">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" />, der einer Ansicht der Speicherabbilddatei zugeordnet ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor () As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor();" />
      <MemberSignature Language="F#" Value="member this.CreateViewAccessor : unit -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" Usage="memoryMappedFile.CreateViewAccessor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" />, der einer Ansicht der Speicherabbilddatei zugeordnet ist.</summary>
        <returns>Ein Speicherblock mit wahlfreiem Zugriff.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die von dieser Methode zurückgegebene Ansicht für den zufälligen Zugriff auf eine im Speicher abgebildete Datei verwenden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf Speicherabbilddatei ist nicht zugelassen.</exception>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor (long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor(int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor (offset As Long, size As Long) As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor(long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.CreateViewAccessor : int64 * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" Usage="memoryMappedFile.CreateViewAccessor (offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">Das Byte, ab dem die Ansicht beginnen soll.</param>
        <param name="size">Die Größe der Ansicht. Geben Sie 0 (null) an, um eine Ansicht zu erstellen, die bei <paramref name="offset" /> beginnt und ungefähr am Ende der Speicherimagedatei endet.</param>
        <summary>Erstellt ein <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" />, das einer Ansicht der im Speicher abgebildeten Datei zugeordnet ist und über die angegebenen Werte für Offset und Größe verfügt.</summary>
        <returns>Ein Speicherblock mit wahlfreiem Zugriff.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die von dieser Methode zurückgegebene Ansicht für den zufälligen Zugriff auf eine im Speicher abgebildete Datei verwenden.  
  
 Um eine umfassende Ansicht der Speicher Abbild Datei zu erstellen, geben Sie 0 (null) für den `size`-Parameter an. Wenn Sie dies tun, kann die Größe der Sicht kleiner oder größer als die Größe der Quelldatei auf dem Datenträger sein. Dies liegt daran, dass Sichten in Einheiten von System Seiten bereitgestellt werden und die Größe der Ansicht auf die nächste System Seitengröße aufgerundet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Ansicht einer Speicher Abbild Datei erstellt und bearbeitet. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.MemoryMappedFiles.MemoryMappedFile>-Klasse bereitgestellt wird.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#2](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#2)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="size" /> ist ein negativer Wert.  
  
- oder - 
 <paramref name="size" /> ist größer als der logische Adressbereich.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf Speicherabbilddatei ist nicht zugelassen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor (long offset, long size, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor(int64 offset, int64 size, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor (offset As Long, size As Long, access As MemoryMappedFileAccess) As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor(long offset, long size, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="member this.CreateViewAccessor : int64 * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" Usage="memoryMappedFile.CreateViewAccessor (offset, size, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="offset">Das Byte, ab dem die Ansicht beginnen soll.</param>
        <param name="size">Die Größe der Ansicht. Geben Sie 0 (null) an, um eine Ansicht zu erstellen, die bei <paramref name="offset" /> beginnt und ungefähr am Ende der Speicherimagedatei endet.</param>
        <param name="access">Einer der Enumerationswerte, der den zulässigen Zugriffstyp für die Speicherabbilddatei angibt. Der Standardwert ist <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Erstellt ein <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" />, das einer Ansicht der im Speicher abgebildeten Datei zugeordnet ist und über die angegebenen Werte für Offset, Größe und Zugriffseinschränkungen verfügt.</summary>
        <returns>Ein Speicherblock mit wahlfreiem Zugriff.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die von dieser Methode zurückgegebene Ansicht für den zufälligen Zugriff auf eine im Speicher abgebildete Datei verwenden.  
  
 Um eine umfassende Ansicht der Speicher Abbild Datei zu erstellen, geben Sie 0 (null) für den `size`-Parameter an. Wenn Sie dies tun, kann die Größe der Sicht kleiner oder größer als die Größe der Quelldatei auf dem Datenträger sein. Dies liegt daran, dass Sichten in Einheiten von System Seiten bereitgestellt werden und die Größe der Ansicht auf die nächste System Seitengröße aufgerundet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="size" /> ist ein negativer Wert.  
  
- oder - 
 <paramref name="size" /> ist größer als der logische Adressbereich.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> ist für die dem Speicher zugeordnete Datei ungültig.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateViewStream">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen Stream, der einer Ansicht der Speicherabbilddatei zugeordnet ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream () As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream();" />
      <MemberSignature Language="F#" Value="member this.CreateViewStream : unit -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewStream" Usage="memoryMappedFile.CreateViewStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen Stream, der einer Ansicht der Speicherabbilddatei zugeordnet ist.</summary>
        <returns>Ein Speicherstream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den von dieser Methode zurückgegebenen Stream für den sequenziellen Zugriff auf eine Speicher Abbild Datei verwenden, z. b. für die prozessübergreifende Kommunikation.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Stream erstellt und ein Wert in diesen geschrieben. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%2A>-Methode bereitgestellt wird.  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_X#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/cs/program.cs#2)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_X#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf Speicherabbilddatei ist nicht zugelassen.</exception>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream (long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream(int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream (offset As Long, size As Long) As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream(long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.CreateViewStream : int64 * int64 -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewStream" Usage="memoryMappedFile.CreateViewStream (offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">Das Byte, ab dem die Ansicht beginnen soll.</param>
        <param name="size">Die Größe der Ansicht. Geben Sie 0 (null) an, um eine Ansicht zu erstellen, die bei <paramref name="offset" /> beginnt und ungefähr am Ende der Speicherimagedatei endet.</param>
        <summary>Erstellt einen Datenstrom, der einer Ansicht der im Speicher abgebildeten Datei zugeordnet ist und über die angegebenen Werte für Offset und Größe verfügt.</summary>
        <returns>Ein Speicherdatenstrom mit den angegebenen Werten für Offset und Größe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den von dieser Methode zurückgegebenen Stream für den sequenziellen Zugriff auf eine Speicher Abbild Datei verwenden, z. b. für die prozessübergreifende Kommunikation.  
  
 Um eine umfassende Ansicht der Speicher Abbild Datei zu erstellen, geben Sie 0 (null) für den `size`-Parameter an. Wenn Sie dies tun, kann die Größe der Sicht kleiner oder größer als die Größe der Quelldatei auf dem Datenträger sein. Dies liegt daran, dass Sichten in Einheiten von System Seiten bereitgestellt werden und die Größe der Ansicht auf die nächste System Seitengröße aufgerundet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="size" /> ist ein negativer Wert.  
  
- oder - 
 <paramref name="size" /> ist größer als der logische Adressbereich.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf Speicherabbilddatei ist nicht zugelassen.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="size" /> ist größer als der gesamte virtuelle Arbeitsspeicher.</exception>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream (long offset, long size, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream(int64 offset, int64 size, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream (offset As Long, size As Long, access As MemoryMappedFileAccess) As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream(long offset, long size, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberSignature Language="F#" Value="member this.CreateViewStream : int64 * int64 * System.IO.MemoryMappedFiles.MemoryMappedFileAccess -&gt; System.IO.MemoryMappedFiles.MemoryMappedViewStream" Usage="memoryMappedFile.CreateViewStream (offset, size, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="offset">Das Byte, ab dem die Ansicht beginnen soll.</param>
        <param name="size">Die Größe der Ansicht. Geben Sie 0 (null) an, um eine Ansicht zu erstellen, die bei <paramref name="offset" /> beginnt und ungefähr am Ende der Speicherimagedatei endet.</param>
        <param name="access">Einer der Enumerationswerte, der den zulässigen Zugriffstyp für die Speicherabbilddatei angibt. Der Standardwert ist <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Erstellt einen Datenstrom, der einer Ansicht der im Speicher abgebildeten Datei zugeordnet ist und über die angegebenen Werte für Offset, Größe und Zugriffstyp verfügt.</summary>
        <returns>Ein Speicherdatenstrom mit den angegebenen Eigenschaften.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den von dieser Methode zurückgegebenen Stream für den sequenziellen Zugriff auf eine Speicher Abbild Datei verwenden, z. b. für die prozessübergreifende Kommunikation.  
  
 Um eine umfassende Ansicht der Speicher Abbild Datei zu erstellen, geben Sie 0 (null) für den `size`-Parameter an. Wenn Sie dies tun, kann die Größe der Sicht kleiner oder größer als die Größe der Quelldatei auf dem Datenträger sein. Dies liegt daran, dass Sichten in Einheiten von System Seiten bereitgestellt werden und die Größe der Ansicht auf die nächste System Seitengröße aufgerundet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="size" /> ist ein negativer Wert.  
  
- oder - 
 <paramref name="size" /> ist größer als der logische Adressbereich.  
  
- oder - 
 <paramref name="access" /> ist kein gültiger <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />-Enumerationswert.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="access" /> ist für die dem Speicher zugeordnete Datei ungültig.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="size" /> ist größer als der gesamte virtuelle Arbeitsspeicher.  
  
- oder - 
 <paramref name="access" /> ist für die dem Speicher zugeordnete Datei ungültig.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die von der <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="memoryMappedFile.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle vom <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="memoryMappedFile.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedFileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MemoryMappedFileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Usage="memoryMappedFile.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Zugriffssteuerung für die Ressource der Speicherabbilddatei ab.</summary>
        <returns>Die Berechtigungen, die für den Dateizugriff und für Vorgänge für Speicherabbilddateien gewährt werden können.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Fehler beim zugrunde liegenden Aufruf zum Festlegen der Sicherheitsinformationen.</exception>
        <exception cref="T:System.NotSupportedException">Fehler beim zugrunde liegenden Aufruf zum Festlegen der Sicherheitsinformationen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Speicherabbilddatei wird geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die aktuelle Plattform ist Windows 98 oder früher.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Fehler beim zugrunde liegenden Aufruf zum Festlegen der Sicherheitsinformationen.  
  
- oder - 
Die Speicherabbilddatei wurde nur als <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> geöffnet.</exception>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet eine vorhandene benannte Speicherabbilddatei im Systemspeicher.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting mapName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="mapName">Der Name der im Speicher abgebildeten Datei.</param>
        <summary>Öffnet eine vorhandene im Speicher abgebildete Datei mit dem angegebenen Namen im Systemspeicher.</summary>
        <returns>Eine Speicherabbilddatei, die über den angegebenen Namen verfügt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Speicher Abbild Datei kann entweder eine beibehaltene Speicher Abbild Datei (die einer Datei auf dem Datenträger zugeordnet ist) oder nicht persistent sein.  
  
   
  
## Examples  
 **Öffnen einer permanenten Speicher Abbild Datei**  
  
 Im folgenden Beispiel wird eine im Speicher abgebildete Datei mit dem Namen `ImgA` geöffnet, die bereits aus einer Datei auf dem Datenträger erstellt wurde (wie im Beispiel für die <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%28System.String%29>-Methode gezeigt).  
  
 [!code-csharp[memorymappedfiles.memorymappedfile.openexisting#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.openexisting/cs/program.cs#1)]
 [!code-vb[memorymappedfiles.memorymappedfile.openexisting#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.openexisting/vb/program.vb#1)]  
  
 **Öffnen einer nicht persistenten Speicher Abbild Datei**  
  
 Im folgenden Beispiel wird eine Speicher Abbild Datei geöffnet, die für die prozessübergreifende Kommunikation verwendet wird. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%28System.String%2CSystem.Int64%29>-Methode bereitgestellt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die für <paramref name="mapName" /> angegebene Datei ist nicht vorhanden.</exception>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName, System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String,System.IO.MemoryMappedFiles.MemoryMappedFileRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String, desiredAccessRights As MemoryMappedFileRights) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName, System::IO::MemoryMappedFiles::MemoryMappedFileRights desiredAccessRights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.IO.MemoryMappedFiles.MemoryMappedFileRights -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting (mapName, desiredAccessRights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="desiredAccessRights" Type="System.IO.MemoryMappedFiles.MemoryMappedFileRights" />
      </Parameters>
      <Docs>
        <param name="mapName">Der Name der zu öffnenden Speicherabbilddatei.</param>
        <param name="desiredAccessRights">Einer der Enumerationswerte, der die anzuwendenden Zugriffsrechte für die Speicherabbilddatei angibt.</param>
        <summary>Öffnet eine vorhandene im Speicher abgebildete Datei mit den angegebenen Werten für Name und Zugriffsrechte im Systemspeicher.</summary>
        <returns>Eine Speicherabbilddatei, die die angegebenen Merkmale aufweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="desiredAccessRights" /> ist kein gültiger <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" />-Enumerationswert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die für <paramref name="mapName" /> angegebene Datei ist nicht vorhanden.</exception>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName, System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String,System.IO.MemoryMappedFiles.MemoryMappedFileRights,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String, desiredAccessRights As MemoryMappedFileRights, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName, System::IO::MemoryMappedFiles::MemoryMappedFileRights desiredAccessRights, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.IO.MemoryMappedFiles.MemoryMappedFileRights * System.IO.HandleInheritability -&gt; System.IO.MemoryMappedFiles.MemoryMappedFile" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting (mapName, desiredAccessRights, inheritability)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="desiredAccessRights" Type="System.IO.MemoryMappedFiles.MemoryMappedFileRights" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Der Name der zu öffnenden Speicherabbilddatei.</param>
        <param name="desiredAccessRights">Einer der Enumerationswerte, der die anzuwendenden Zugriffsrechte für die Speicherabbilddatei angibt.</param>
        <param name="inheritability">Einer der Enumerationswerte, der angibt, ob ein Handle auf die Speicherabbilddatei von einem untergeordneten Prozess geerbt werden kann. Der Standardwert ist <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Öffnet eine vorhandene im Speicher abgebildete Datei mit den angegebenen Werten für Name, Zugriffsrechte und Vererbbarkeit im Systemspeicher.</summary>
        <returns>Eine Speicherabbilddatei, die die angegebenen Merkmale aufweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mapName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mapName" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="desiredAccessRights" /> ist kein gültiger <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" />-Enumerationswert.  
  
- oder - 
 <paramref name="inheritability" /> ist kein gültiger <see cref="T:System.IO.HandleInheritability" />-Enumerationswert.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte Zugriff ist für die dem Speicher zugeordnete Datei ungültig.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die für <paramref name="mapName" /> angegebene Datei ist nicht vorhanden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <Member MemberName="SafeMemoryMappedFileHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryMappedFiles.MemoryMappedFile.SafeMemoryMappedFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeMemoryMappedFileHandle As SafeMemoryMappedFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeMemoryMappedFileHandle ^ SafeMemoryMappedFileHandle { Microsoft::Win32::SafeHandles::SafeMemoryMappedFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeMemoryMappedFileHandle : Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle" Usage="System.IO.MemoryMappedFiles.MemoryMappedFile.SafeMemoryMappedFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Dateihandle einer Speicherabbilddatei ab.</summary>
        <value>Das Handle für die Speicherabbilddatei.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.SetAccessControl(System.IO.MemoryMappedFiles.MemoryMappedFileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.IO.MemoryMappedFiles.MemoryMappedFileSecurity -&gt; unit" Usage="memoryMappedFile.SetAccessControl memoryMappedFileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="memoryMappedFileSecurity">Die Berechtigungen, die für den Dateizugriff und für Vorgänge für Speicherabbilddateien gewährt werden können.</param>
        <summary>Legt die Zugriffssteuerung für die Ressource der Speicherabbilddatei fest.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="memoryMappedFileSecurity" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Fehler beim zugrunde liegenden Aufruf zum Festlegen der Sicherheitsinformationen.</exception>
        <exception cref="T:System.NotSupportedException">Fehler beim zugrunde liegenden Aufruf zum Festlegen der Sicherheitsinformationen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Fehler beim zugrunde liegenden Aufruf zum Festlegen der Sicherheitsinformationen.</exception>
        <related type="Article" href="~/docs/standard/io/memory-mapped-files.md">Speicherabbilddateien</related>
      </Docs>
    </Member>
  </Members>
</Type>
