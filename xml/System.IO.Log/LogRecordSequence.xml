<Type Name="LogRecordSequence" FullName="System.IO.Log.LogRecordSequence">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7156e4e610a9d14909a701b75c25fcdefeaf4c8c" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37655523" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <TypeSignature Language="F#" Value="type LogRecordSequence = class&#xA;    interface IRecordSequence&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents a record sequence stored in a <see cref="T:System.IO.Log.LogStore" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Log.LogRecordSequence>-Klasse stellt eine Implementierung der Datensatzsequenzschnittstelle auf einem CLFS-Protokoll (gemeinsames Protokolldateisystem) bereit. Zusätzlich zu den datensatzorientierten Standardfunktionen wird ein Richtlinienmodell zur Vermeidung von vollen Protokollen und von Multiplexing von Clients auf derselben physischen Datei bereitgestellt. Die Funktionsweise erfolgt in Kombination mit der <xref:System.IO.Log.LogStore>-Klasse, die eine Schnittstelle für die direkte Bearbeitung und Verwaltung einer CLFS-Protokolldatei bereitstellt. Die Beziehung zwischen der <xref:System.IO.Log.LogStore>-Klasse und der <xref:System.IO.Log.LogRecordSequence>-Klasse ähnelt der Beziehung zwischen einer Datenträgerdatei und einem <xref:System.IO.FileStream>-Objekt. Die Datenträgerdatei stellt den tatsächlichen Speicherplatz bereit und weist Attribute wie die Länge und den letzten Zugriff auf, während das <xref:System.IO.FileStream>-Objekt eine Ansicht der Datei bereitstellt, über die Lese- und Schreibvorgänge für die Datei ausgeführt werden können. Die <xref:System.IO.Log.LogStore>-Klasse weist Attribute wie eine Richtlinie und eine Auflistung von Datenträgerwertebereichen auf, und die <xref:System.IO.Log.LogRecordSequence>-Klasse bietet einen datensatzorientierten Mechanismus zum Lesen und Schreiben von Daten.  
  
   
  
## Examples  
 In diesem Beispiel wird die Verwendung der <xref:System.IO.Log.LogRecordSequence>-Klasse veranschaulicht.  
  
 [!code-csharp[S_UELogRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#0)]
 [!code-vb[S_UELogRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence logStore" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
      </Parameters>
      <Docs>
        <param name="logStore">The <see cref="T:System.IO.Log.LogStore" /> that this record sequence should use.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with the specified log store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Puffergröße bestimmt die maximale Größe des Datensatzes, der angefügt oder gelesen werden kann. In diesem Konstruktor ist ein Standardwert von 64 festgelegt. Die gewünschte Anzahl der Puffer wird auf 10 gesetzt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logStore" /> is invalid.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">A relative or absolute path for the base file of the log store to open.</param>
        <param name="mode">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert eine neue <xref:System.IO.Log.LogRecordSequence> auf einem neuen <xref:System.IO.Log.LogStore>-Objekt, das er mit dem angegebenen Pfad und Modus öffnet. Dem Objekt wird Lese-/Schreibzugriff auf den Speicher erteilt, und der Speicher wird geöffnet und der Lesezugriff freigegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> is an empty string ("").  -or-  <paramref name="path" /> contains only white space.  -or-  <paramref name="path" /> contains one or more invalid characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contains an invalid value.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when opening the log store.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.NotSupportedException">This operation is not supported.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (logStore, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="logStore">The <see cref="T:System.IO.Log.LogStore" /> that this record sequence should use.</param>
        <param name="bufferSize">The desired buffer size in bytes. The buffer size determines the maximum size of the record that can be appended or read.</param>
        <param name="bufferCount">The desired number of buffers.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with the specified log store, buffer size for each record, and buffer number.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn Sie Werte für `bufferSize` und `bufferCount` angeben möchten und nicht den Standardwert 64 für `bufferSize` und 10 für `bufferCount` verwenden möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="logStore" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> is negative or zero.  -or-  <paramref name="bufferCount" /> is negative or zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">A relative or absolute path for the base file of the log store to open.</param>
        <param name="mode">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</param>
        <param name="access">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access and share modes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert eine neue <xref:System.IO.Log.LogRecordSequence> auf einem neuen <xref:System.IO.Log.LogStore>-Objekt, das er mit dem angegebenen Pfad, Modus und Zugriff öffnet. Der Speicher wird geöffnet und der Lesezugriff freigegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> is an empty string ("").  -or-  <paramref name="path" /> contains only white space.  -or-  <paramref name="path" /> contains one or more invalid characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contains an invalid value.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when opening the log store.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.NotSupportedException">This operation is not supported.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">A relative or absolute path for the base file of the log store to open.</param>
        <param name="mode">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</param>
        <param name="access">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert eine neue <xref:System.IO.Log.LogRecordSequence> auf einem neuen <xref:System.IO.Log.LogStore>-Objekt, das er mit dem angegebenen Pfad, Modus und Zugriff öffnet. Der Speicher wird geöffnet und der angegebene Zugriff freigegeben.  
  
   
  
## Examples  
 Dieses Beispiel zeigt die Verwendung dieses <xref:System.IO.Log.LogRecordSequence>-Konstruktors:  
  
 [!code-csharp[S_UELogRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#1)]
 [!code-vb[S_UELogRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> is an empty string ("").  -or-  <paramref name="path" /> contains only white space.  -or-  <paramref name="path" /> contains one or more invalid characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contains an invalid value.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when opening the log store.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.NotSupportedException">This operation is not supported.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, bufferCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">A relative or absolute path for the base file of the log store to open.</param>
        <param name="mode">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</param>
        <param name="access">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</param>
        <param name="bufferSize">The desired buffer size in bytes. The buffer size determines the maximum size of the record that can be appended or read.</param>
        <param name="bufferCount">The desired number of buffers.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store, file permission, access and share modes, and the buffer size and count for records.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert eine neue <xref:System.IO.Log.LogRecordSequence> auf einem neuen <xref:System.IO.Log.LogStore>-Objekt, das er mit dem angegebenen Pfad, Modus und Zugriff öffnet. Der Speicher wird geöffnet und der angegebene Zugriff freigegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> is an empty string ("").  -or-  <paramref name="path" /> contains only white space.  -or-  <paramref name="path" /> contains one or more invalid characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contains an invalid value.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurs when opening the log store.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.NotSupportedException">This operation is not supported.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">A relative or absolute path for the base file of the log store to open.</param>
        <param name="mode">A valid <see cref="T:System.IO.FileMode" /> value that determines how to open or create the store.</param>
        <param name="access">A valid <see cref="T:System.IO.FileAccess" /> value that determines how the log store can be accessed.</param>
        <param name="share">A valid <see cref="T:System.IO.FileShare" /> value that determines how the log store will be shared among processes.</param>
        <param name="bufferSize">The desired buffer size in bytes. The buffer size determines the maximum size of the record that can be appended or read.</param>
        <param name="bufferCount">The desired number of buffers.</param>
        <param name="fileSecurity">A valid <see cref="T:System.Security.AccessControl.FileSecurity" /> value that specifies the security to set on the newly created store if the store must be created.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">The file specified by <paramref name="path" /> is not valid.  -or-  The specified log store file name is not valid.  -or-  <paramref name="mode" /> has a value of <see cref="F:System.IO.FileMode.CreateNew" />, and cannot be used without write access.  -or-  <paramref name="mode" /> has a value of <see cref="F:System.IO.FileMode.OpenOrCreate" />, and cannot be used without write access.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the arguments are <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">One or more of the arguments are out of range.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file specified by <paramref name="path" /> cannot be found.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The file specified by <paramref name="path" /> cannot be accessed because it is in use by another process.  -or-  The file specified by <paramref name="path" /> cannot be created because the file or directory already exists.  -or-  The log handle could not be bound to the thread pool.  -or-  The specified log file format or version is invalid.</exception>
        <exception cref="T:System.NotSupportedException">This operation is not supported.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed. Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit&#xA;override this.AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">Specifies the new base <see cref="T:System.IO.Log.SequenceNumber" /> for the log. This must lie in the range between the current base sequence number and the last sequence number of the log inclusively.</param>
        <summary>Moves the base sequence number of the log forward. This method cannot be inherited.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird oft mit dem <xref:System.IO.Log.LogRecordSequence.TailPinned>-Ereignis verwendet, um Speicherplatz in einem Datensatz freizugeben. Das <xref:System.IO.Log.LogRecordSequence.TailPinned>-Ereignis gibt an, dass das Ende der Sequenz (die Basissequenznummer) nach vorne verschoben werden muss, um Speicherplatz freizugeben. Speicherplatz kann freigegeben werden, indem Neustartbereiche mit der <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>-Methode geschrieben werden oder indem das Protokoll abgeschnitten wird und die Basissequenznummer eines Protokolls mit der <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>-Methode in die durch den `newBaseSequenceNumber`-Parameter angegebene Nummer geändert wird. Im Codebeispiel im Abschnitt mit dem Beispiel wird der zweite Ansatz veranschaulicht.  
  
 Beachten Sie, dass das Aufrufen dieser Methode dem Festlegen einer neuen Basissequenznummer mit der <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>-Methode entspricht. Die einzige Ausnahme besteht darin, dass kein Neustartdatensatz in das Protokoll geschrieben wird.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>-Methode mit dem <xref:System.IO.Log.LogRecordSequence.TailPinned>-Ereignis, um Speicherplatz in einer Protokollsequenz freizugeben.  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSequenceNumber" /> is not valid for this sequence.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A new or existing archive tail or base of the active log is invalid.  -or-  <paramref name="newBaseSequenceNumber" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.</exception>
        <exception cref="T:System.InvalidOperationException">The specified log does not have any extents. One or more extents must be created before a record sequence may be used.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung des <xref:System.IO.Log.LogRecordSequence.Append%2A>-Members.  
  
 [!code-csharp[S_UELogRecordSequence#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#5)]
 [!code-vb[S_UELogRecordSequence#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="nextUndoRecord">The sequence number of the next record in the user-specified order.</param>
        <param name="previousRecord">The sequence number of the next record in Previous order.</param>
        <param name="recordAppendOptions">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</param>
        <summary>Writes a log record to the <see cref="T:System.IO.Log.LogRecordSequence" />. This method cannot be inherited.</summary>
        <returns>The sequence number of the appended log record.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie diese Methode verwendet werden kann, um einer Sequenz einen Protokolldatensatz anzufügen.  
  
 [!code-csharp[S_UELogRecordSequence#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#13)]
 [!code-vb[S_UELogRecordSequence#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.  -or-  <paramref name="data" /> cannot be appended because it is larger than the maximum record size.  -or-  <paramref name="reservations" /> was not created by this record sequence.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the arguments are <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.</exception>
        <exception cref="T:System.NotSupportedException">The operation cannot be performed because the record sequence was opened with read-only access.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="userRecord">The sequence number of the next record in the user-specified order.</param>
        <param name="previousRecord">The sequence number of the next record in Previous order.</param>
        <param name="recordAppendOptions">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</param>
        <summary>Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />. This method cannot be inherited.</summary>
        <returns>The sequence number of the appended log record.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.  -or-  <paramref name="data" /> cannot be appended because it is larger than the maximum record size.  -or-  <paramref name="reservations" /> was not created by this record sequence.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the arguments are <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.</exception>
        <exception cref="T:System.NotSupportedException">The operation cannot be performed because the record sequence was opened with read-only access.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="nextUndoRecord">The sequence number of the next record in the user-specified order.</param>
        <param name="previousRecord">The sequence number of the next record in Previous order.</param>
        <param name="recordAppendOptions">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</param>
        <summary>Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence. This method cannot be inherited.</summary>
        <returns>The sequence number of the appended log record.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Der angefügte Datensatz, der zuvor mithilfe einer vom `reservations`-Parameter angegebenen Reservierung reserviert wurde, nimmt Speicherplatz ein. Wenn der Anfügevorgang erfolgreich ist, wird der kleinstmögliche Reservierungsbereich verwendet, der die Daten aufnehmen kann. Dieser Reservierungsbereich wird dann aus der Auflistung entfernt.  
  
 Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.  -or-  <paramref name="data" /> cannot be appended because it is larger than the maximum record size.  -or-  <paramref name="reservations" /> was not created by this record sequence.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the arguments are <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.</exception>
        <exception cref="T:System.NotSupportedException">The operation cannot be performed because the record sequence was opened with read-only access.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="userRecord">The sequence number of the next record in the user-specified order.</param>
        <param name="previousRecord">The sequence number of the next record in Previous order.</param>
        <param name="recordAppendOptions">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</param>
        <summary>Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence. This method cannot be inherited.</summary>
        <returns>The sequence number of the appended log record.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Der angefügte Datensatz, der zuvor mithilfe einer vom `reservations`-Parameter angegebenen Reservierung reserviert wurde, nimmt Speicherplatz ein. Wenn der Anfügevorgang erfolgreich ist, wird der kleinstmögliche Reservierungsbereich verwendet, der die Daten aufnehmen kann. Dieser Reservierungsbereich wird dann aus der Auflistung entfernt.  
  
 Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.IRecordSequence.Flush%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.  -or-  <paramref name="data" /> cannot be appended because it is larger than the maximum record size.  -or-  <paramref name="reservations" /> was not created by this record sequence.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the arguments are <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.</exception>
        <exception cref="T:System.NotSupportedException">The operation cannot be performed because the record sequence was opened with read-only access.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the sequence number of the first valid record in the current <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <value>Die niedrigste Sequenznummer, die einem gültigen Datensatz in der <see cref="T:System.IO.Log.LogRecordSequence" /> entspricht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gültige Sequenznummern sind größer oder gleich <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> und kleiner als <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.  
  
 Der Wert dieser Eigenschaft kann durch Aufrufen der <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>-Methode oder der <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>-Methode geändert werden.  
  
   
  
## Examples  
 In diesem Beispiel wird die Verwendung des <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A>-Members in einer Schleife veranschaulicht.  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The property was accessed after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Begins an asynchronous append operation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="nextUndoRecord">The sequence number of the next record in the user-specified order.</param>
        <param name="previousRecord">The sequence number of the next record in Previous order.</param>
        <param name="recordAppendOptions">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</param>
        <param name="callback">An optional asynchronous callback, to be called when the append is complete.</param>
        <param name="state">A user-provided object that distinguishes this particular asynchronous append request from other requests.</param>
        <summary>Begins an asynchronous append operation. This method cannot be inherited.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können. Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.  -or-  <paramref name="data" /> cannot be appended because it is larger than the maximum record size.  -or-  <paramref name="reservations" /> was not created by this record sequence.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the arguments are <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.</exception>
        <exception cref="T:System.NotSupportedException">The operation cannot be performed because the record sequence was opened with read-only access.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="userRecord">The sequence number of the next record in the user-specified order.</param>
        <param name="previousRecord">The sequence number of the next record in Previous order.</param>
        <param name="recordAppendOptions">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</param>
        <param name="callback">An optional asynchronous callback, to be called when the append is complete.</param>
        <param name="state">A user-provided object that distinguishes this particular asynchronous append request from other requests.</param>
        <summary>Begins an asynchronous append operation. This method cannot be inherited.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können. Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.  -or-  <paramref name="data" /> cannot be appended because it is larger than the maximum record size.  -or-  <paramref name="reservations" /> was not created by this record sequence.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the arguments are <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.</exception>
        <exception cref="T:System.NotSupportedException">The operation cannot be performed because the record sequence was opened with read-only access.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="nextUndoRecord">The sequence number of the next record in the user-specified order.</param>
        <param name="previousRecord">The sequence number of the next record in Previous order.</param>
        <param name="recordAppendOptions">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</param>
        <param name="callback">An optional asynchronous callback, to be called when the append is complete.</param>
        <param name="state">A user-provided object that distinguishes this particular asynchronous append request from other requests.</param>
        <summary>Begins an asynchronous append operation. This method cannot be inherited.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können. Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Der angefügte Datensatz, der zuvor mithilfe einer vom `reservations`-Parameter angegebenen Reservierung reserviert wurde, nimmt Speicherplatz ein. Wenn der Anfügevorgang erfolgreich ist, wird der kleinstmögliche Reservierungsbereich verwendet, der die Daten aufnehmen kann. Dieser Reservierungsbereich wird dann aus der Auflistung entfernt.  
  
 Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.  -or-  <paramref name="data" /> cannot be appended because it is larger than the maximum record size.  -or-  <paramref name="reservations" /> was not created by this record sequence.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the arguments are <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.</exception>
        <exception cref="T:System.NotSupportedException">The operation cannot be performed because the record sequence was opened with read-only access.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="userRecord">The sequence number of the next record in the user-specified order.</param>
        <param name="previousRecord">The sequence number of the next record in Previous order.</param>
        <param name="recordAppendOptions">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</param>
        <param name="callback">An optional asynchronous callback, to be called when the append is complete.</param>
        <param name="state">A user-provided object that distinguishes this particular asynchronous append request from other requests.</param>
        <summary>Begins an asynchronous append operation. This method cannot be inherited.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können. Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Der angefügte Datensatz, der zuvor mithilfe einer vom `reservations`-Parameter angegebenen Reservierung reserviert wurde, nimmt Speicherplatz ein. Wenn der Anfügevorgang erfolgreich ist, wird der kleinstmögliche Reservierungsbereich verwendet, der die Daten aufnehmen kann. Dieser Reservierungsbereich wird dann aus der Auflistung entfernt.  
  
 Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.  -or-  <paramref name="data" /> cannot be appended because it is larger than the maximum record size.  -or-  <paramref name="reservations" /> was not created by this record sequence.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the arguments are <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.</exception>
        <exception cref="T:System.NotSupportedException">The operation cannot be performed because the record sequence was opened with read-only access.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">The sequence number of the latest record that must be written. If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</param>
        <param name="callback">An optional asynchronous callback, to be called when the flush is complete.</param>
        <param name="state">A user-provided object that distinguishes this particular asynchronous flush request from other requests.</param>
        <summary>Begins an asynchronous flush operation, using space previously reserved in the sequence. This method cannot be inherited.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that represents the asynchronous flush operation, which could still be pending.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von der aktuellen Methode ausgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>-Methode weiterleiten, um sicherzustellen, dass der Löschvorgang abgeschlossen wird und die Ressourcen korrekt freigegeben werden. Wenn während eines asynchronen Löschvorgangs ein Fehler auftritt, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Durch das Aufrufen dieser Methode wird sichergestellt, dass alle Datensätze, die der <xref:System.IO.Log.LogRecordSequence> angefügt wurden, dauerhaft geschrieben werden.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Bei einer asynchronen Löschanforderung auftretende Fehler, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sequenceNumber" /> is not valid for this sequence.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.</exception>
        <exception cref="T:System.InvalidOperationException">The specified log does not have any extents. One or more extents must be created before a record sequence can be used.</exception>
        <exception cref="T:System.NotSupportedException">The operation cannot be performed because the record sequence was opened with read-only access.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Begins an asynchronous reserve and append operation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="nextUndoRecord">The sequence number of the next record in the user-specified order.</param>
        <param name="previousRecord">The sequence number of the next record in Previous order.</param>
        <param name="recordAppendOptions">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</param>
        <param name="reservationCollection">The reservation collection to make reservations in.</param>
        <param name="reservations">The reservations to make, in bytes.</param>
        <param name="callback">An optional asynchronous callback, to be called when the append is complete.</param>
        <param name="state">A user-provided object that distinguishes this particular asynchronous append request from other requests.</param>
        <summary>Begins an asynchronous reserve and append operation. This method cannot be inherited.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können. Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Die angegebenen Reservierungen werden in einer atomaren Operation mit einem Vorgang zum Anfügen von Datensätzen der bereitgestellten Reservierungsauflistung hinzugefügt. Wenn der Anfügevorgang scheitert, wird kein Speicherplatz reserviert.  
  
 Normalerweise kann diese Methode abgeschlossen werden, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.  -or-  <paramref name="data" /> cannot be appended because it is larger than the maximum record size.  -or-  <paramref name="reservations" /> was not created by this record sequence.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the arguments are <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.</exception>
        <exception cref="T:System.NotSupportedException">The operation cannot be performed because the record sequence was opened with read-only access.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="userRecord">The sequence number of the next record in the user-specified order.</param>
        <param name="previousRecord">The sequence number of the next record in Previous order.</param>
        <param name="recordAppendOptions">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</param>
        <param name="reservationCollection">The reservation collection to make reservations in.</param>
        <param name="reservations">The reservations to make, in bytes.</param>
        <param name="callback">An optional asynchronous callback, to be called when the append is complete.</param>
        <param name="state">A user-provided object that distinguishes this particular asynchronous append request from other requests.</param>
        <summary>Begins an asynchronous reserve and append operation. This method cannot be inherited.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können. Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Die angegebenen Reservierungen werden in einer atomaren Operation mit einem Vorgang zum Anfügen von Datensätzen der bereitgestellten Reservierungsauflistung hinzugefügt. Wenn der Anfügevorgang scheitert, wird kein Speicherplatz reserviert.  
  
 Normalerweise kann diese Methode abgeschlossen werden, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">One or more of the arguments is invalid.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred while appending the record.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence could not make enough free space to contain the new record, or to make the reservation.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Begins an asynchronous restart area write operation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Byte array segments that will be concatenated and appended as the record.</param>
        <param name="newBaseSeqNum">The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.</param>
        <param name="reservation">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</param>
        <param name="callback">An optional asynchronous callback, to be called when the restart area write is complete.</param>
        <param name="state">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</param>
        <summary>Begins an asynchronous restart area write operation, using space previously reserved in the sequence. This method cannot be inherited.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode weiterleiten, um sicherzustellen, dass der Neustartbereich-Schreibvorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können. Wenn während eines asynchronen Neustartbereich-Schreibvorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Wenn die Operation erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert. Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.  
  
 Wenn eine <xref:System.IO.Log.ReservationCollection> angegeben wird, nimmt der geschriebene Neustartbereich, der zuvor mithilfe einer in der Auflistung enthaltenen Reservierung reserviert wurde, Speicherplatz ein. Wenn diese Methode erfolgreich ist, wird die kleinstmögliche Reservierung verwendet, die die Daten aufnehmen kann. Diese Reservierung wird dann aus der Auflistung entfernt.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> is not valid for this sequence.  -or-  The specified log enumeration start sequence number is invalid.  -or-  <paramref name="data" /> cannot be appended because it is larger than the maximum record size.  -or-  <paramref name="reservation" /> was not created by this record sequence.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the parameters is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A new or existing archive tail or base of the active log is invalid.  -or-  <paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservationCollection, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="newBaseSeqNum">The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.</param>
        <param name="reservationCollection">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</param>
        <param name="callback">An optional asynchronous callback, to be called when the restart area write is complete.</param>
        <param name="state">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</param>
        <summary>Begins an asynchronous restart area write operation, using space previously reserved in the sequence. This method cannot be inherited.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten das von dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode weiterleiten, um sicherzustellen, dass der Neustartbereich-Schreibvorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können. Wenn während eines asynchronen Neustartbereich-Schreibvorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.  
  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Wenn die Operation erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert. Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.  
  
 Wenn eine <xref:System.IO.Log.ReservationCollection> angegeben wird, nimmt der geschriebene Neustartbereich, der zuvor mithilfe einer in der Auflistung enthaltenen Reservierung reserviert wurde, Speicherplatz ein. Wenn diese Methode erfolgreich ist, wird die kleinstmögliche Reservierung verwendet, die die Daten aufnehmen kann. Diese Reservierung wird dann aus der Auflistung entfernt.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> is not valid for this sequence.  -or-  The specified log enumeration start sequence number is invalid.  -or-  <paramref name="data" /> cannot be appended because it is larger than the maximum record size.  -or-  <paramref name="reservationCollection" /> was not created by this record sequence.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the parameters is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A new or existing archive tail or base of the active log is invalid.  -or-  <paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection&#xA;override this.CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="logRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.IO.Log.ReservationCollection" />. This method cannot be inherited.</summary>
        <returns>The newly created <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Reservierungen können auf zwei Arten vorgenommen werden, wie in den nachstehenden Beispielen beschrieben. Sie können die Vorgehensweise aus den Beispielen für stabile Verarbeitung übernehmen. Beachten Sie, dass diese Aufgabe nur bei Verwendung der CLFS-basierten <xref:System.IO.Log.LogRecordSequence>-Klasse ausgeführt werden kann.  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logRecordSequence.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases the resources used by the component.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Dieses Beispiel zeigt, wie Sie mit <xref:System.IO.Log.LogRecordSequence.Dispose%2A> , um Ressourcen freizugeben:  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 [!code-csharp[S_UELogRecordSequence#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#12)] 
 [!code-vb[S_UELogRecordSequence#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#12)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">A reference to the outstanding asynchronous I/O request.</param>
        <summary>Ends an asynchronous append operation. This method cannot be inherited.</summary>
        <returns>The sequence number of the appended log record.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist. Fehler, die während einer asynchronen Schreibanforderung auftreten, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, werden sichtbar, wenn <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> aufgerufen wird.  
  
 Diese Methode muss genau einmal für jedes <xref:System.IAsyncResult>, das von der <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>-Methode zurückgegeben wird, aufgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> is invalid.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> has already been called for this asynchronous operation.</exception>
        <exception cref="T:System.NotSupportedException">The operation cannot be performed because the record sequence was opened with read-only access.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">A reference to the outstanding asynchronous I/O request.</param>
        <summary>Ends an asynchronous flush operation. This method cannot be inherited.</summary>
        <returns>The sequence number of the last record written.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist. Fehler, die während einer asynchronen Löschanforderung auftreten, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, werden sichtbar, wenn <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> aufgerufen wird.  
  
 Diese Methode muss genau einmal für jedes <xref:System.IAsyncResult>, das von der <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>-Methode zurückgegeben wird, aufgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> is invalid.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> has already been called for this asynchronous operation.</exception>
        <exception cref="T:System.NotSupportedException">The operation cannot be performed because the record sequence was opened with read-only access.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">A reference to the outstanding asynchronous I/O request.</param>
        <summary>Ends an asynchronous reserve and append operation. This method cannot be inherited.</summary>
        <returns>The sequence number of the appended log record.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist. Fehler, die während einer asynchronen Schreibanforderung auftreten, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, werden sichtbar, wenn <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> aufgerufen wird.  
  
 Diese Methode muss genau einmal für jedes <xref:System.IAsyncResult>, das von der <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>-Methode zurückgegeben wird, aufgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> is invalid.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> has already been called for this asynchronous operation.</exception>
        <exception cref="T:System.NotSupportedException">The operation cannot be performed because the record sequence was opened with read-only access.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">A reference to the outstanding asynchronous I/O request.</param>
        <summary>Ends an asynchronous restart area write operation. This method cannot be inherited.</summary>
        <returns>The sequence number of the written log record.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist. Fehler, die während einer asynchronen Schreibanforderung auftreten, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, werden sichtbar, wenn <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> aufgerufen wird.  
  
 Diese Methode muss genau einmal für jedes <xref:System.IAsyncResult>, das von der <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>-Methode zurückgegeben wird, aufgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> is not valid.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A new or existing archive tail or base of the active log is invalid.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> has already been called for this asynchronous operation.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes appended records durably</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ensures that all appended records have been written. This method cannot be inherited.</summary>
        <returns>The sequence number of the last record written.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Aufrufen dieser Methode wird sichergestellt, dass alle Datensätze, die der <xref:System.IO.Log.LogRecordSequence> angefügt wurden, dauerhaft geschrieben wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">An I/O error occurred while flushing the data.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.NotSupportedException">This operation is not supported.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence could not make enough free space to contain the new restart area.</exception>
        <exception cref="T:System.InvalidOperationException">The specified log does not have any extents. One or more extents must be created before a record sequence can be used.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">The sequence number of the latest record that must be written. If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</param>
        <summary>Ensures that all appended records up to and including the record with the specified sequence number have been durably written. This method cannot be inherited.</summary>
        <returns>The sequence number of the last record written.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Aufrufen diese Methode wird sichergestellt, dass alle Datensätze mit Sequenznummern bis zu der angegebenen Sequenznummer dauerhaft geschrieben wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sequenceNumber" /> is not valid for this sequence.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.</exception>
        <exception cref="T:System.InvalidOperationException">The specified log does not have any extents. One or more extents must be created before a record sequence can be used.</exception>
        <exception cref="T:System.NotSupportedException">The operation cannot be performed because the record sequence was opened with read-only access.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the sequence number which is greater than the last record appended</summary>
        <value>Eine Sequenznummer, die größer ist als der letzte angefügte Datensatz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft enthält eine Sequenznummer, die in jedem Fall größer ist als die Sequenznummer des letzten angefügten Datensatzes. Gültige Sequenznummern sind größer oder gleich <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> und kleiner als <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>. Alle anderen Sequenznummern sind ungültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The property was accessed after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogStore">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogStore LogStore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogStore LogStore" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LogStore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogStore As LogStore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogStore ^ LogStore { System::IO::Log::LogStore ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogStore : System.IO.Log.LogStore" Usage="System.IO.Log.LogRecordSequence.LogStore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.IO.Log.LogStore" /> that contains the data for this record sequence. This method cannot be inherited.</summary>
        <value>Der <see cref="T:System.IO.Log.LogStore" />, der die Daten für diese Datensatzsequenz enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel wird die Verwendung des <xref:System.IO.Log.LogRecordSequence.LogStore%2A>-Members zum Hinzufügen von Wertebereichen veranschaulicht.  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum size of a record that can be added to this record sequence.</summary>
        <value>Die maximale Größe eines Datensatzes, der dieser Datensatzsequenz hinzugefügt werden kann.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">The sequence number of the first record where the reading starts.</param>
        <param name="logRecordEnum">A valid <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> value that specifies the manner (that is, forward or backward) in which records should be read from a <see cref="T:System.IO.Log.LogRecordSequence" />.</param>
        <summary>Returns an enumerable collection of records in the sequence. This method cannot be inherited.</summary>
        <returns>An enumerable collection of records in the sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt eine aufzählbare Auflistung von Datensätzen in der Sequenz zurück. Die Reihenfolge der aufgelisteten Datensätze hängt vom Wert des `logRecordEnum`-Parameters ab.  
  
   
  
## Examples  
 In diesem Beispiel wird die Verwendung von <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A> in einer Schleife veranschaulicht.  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="start" /> is not valid for this sequence.  -or-  <paramref name="logRecordEnum" /> is invalid.  -or-  The specified element was not found in the collection.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="start" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.  -or  The buffer size used to write the log record is larger than the buffer size being used to read it.  -or-  The record sequence is corrupted.  -or-  The specified log file format or version is invalid.  -or-  The record was written with an incompatible version of the record sequence.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is invalid because the enumeration has not been started. A call to <see cref="M:System.Collections.IEnumerator.MoveNext" /> must be made.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerable collection of the restart areas in the sequence. This method cannot be inherited.</summary>
        <returns>An enumerable collection of the restart areas in the sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Neustartbereiche sind in umgekehrter Reihenfolge der Sequenznummern aufgelistet, von der höchsten bis zur niedrigsten Sequenznummer. Nur Neustartbereiche mit Sequenznummern zwischen der letzten Sequenznummer und der Basissequenznummer sind aufgelistet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="start" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.  -or  The buffer size used to write the log record is larger than the buffer size being used to read it.  -or-  The record sequence is corrupted.  -or-  The specified log file format or version is invalid.  -or-  The record was written with an incompatible version of the record sequence.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is invalid because the enumeration has not been started. A call to <see cref="M:System.Collections.IEnumerator.MoveNext" /> must be made.  -or  The enumeration has ended.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Automatically makes a single reservation and appends a record to the sequence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="nextUndoRecord">The sequence number of the next record in the user-specified order.</param>
        <param name="previousRecord">The sequence number of the next record in Previous order.</param>
        <param name="recordAppendOptions">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</param>
        <param name="reservationCollection">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the collection to make reservations in.</param>
        <param name="reservations">The reservations to make, in bytes.</param>
        <summary>Automatically makes a single reservation and appends a record to the sequence. This method cannot be inherited.</summary>
        <returns>The sequence number of the appended log record.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Die angegebenen Reservierungen werden in einer atomaren Operation mit einem Vorgang zum Anfügen von Datensätzen der bereitgestellten Reservierungsauflistung hinzugefügt. Wenn der Anfügevorgang scheitert, wird kein Speicherplatz reserviert.  
  
 Normalerweise kann diese Methode abgeschlossen werden, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie mit dieser Methode Reservierungen vornehmen. Beachten Sie, dass diese Aufgabe nur bei Verwendung der CLFS-basierten <xref:System.IO.Log.LogRecordSequence>-Klasse ausgeführt werden kann.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.  -or-  <paramref name="data" /> cannot be appended because it is larger than the maximum record size.  -or-  <paramref name="reservations" /> was not created by this record sequence.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the arguments are <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.</exception>
        <exception cref="T:System.NotSupportedException">The operation cannot be performed because the record sequence was opened with read-only access.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="userRecord">The sequence number of the next record in the user-specified order.</param>
        <param name="previousRecord">The sequence number of the next record in Previous order.</param>
        <param name="recordAppendOptions">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</param>
        <param name="reservationCollection">The reservation collection to make reservations in.</param>
        <param name="reservations">The reservations to make, in bytes.</param>
        <summary>Automatically makes a single reservation and appends a record to the sequence. This method cannot be inherited.</summary>
        <returns>The sequence number of the appended log record.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.  
  
 Die angegebenen Reservierungen werden in einer atomaren Operation mit einem Vorgang zum Anfügen von Datensätzen der bereitgestellten Reservierungsauflistung hinzugefügt. Wenn der Anfügevorgang scheitert, wird kein Speicherplatz reserviert.  
  
 Normalerweise kann diese Methode abgeschlossen werden, bevor der Datensatz geschrieben wird. Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">One or more of the arguments is invalid.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred while appending the record.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence could not make enough free space to contain the new record, or to make the reservation.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the arguments are <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.NotSupportedException">The operation cannot be performed because the record sequence was opened with read-only access.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the total number of bytes that have been reserved.</summary>
        <value>Die Gesamtgröße aller in dieser Datensatzsequenz vorgenommenen Reservierungen.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">The property was accessed after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the sequence number of the restart area closest to the end of the log.</summary>
        <value>Die Sequenznummer des Neustartbereichs, die am nächsten am Protokollende liegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern. Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist. Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation. Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.  
  
 Mit der <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>-Methode können Sie den zuletzt geschriebenen Neustartbereich entfernen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The property was accessed after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether or not appends are automatically retried if the log is full.</summary>
        <value>
          <see langword="true" />, wenn Anfügevorgänge automatisch wiederholt werden, wenn das Protokoll voll ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert der Eigenschaft `true` lautet und ein <xref:System.IO.Log.LogRecordSequence.Append%2A>-Abruf fehlschlägt, da die Sequenz nicht genügend Speicherplatz aufweist, versucht die Datensatzsequenz, Speicherplatz freizugeben und den Anfügevorgang zu wiederholen.  
  
   
  
## Examples  
 In diesem Beispiel wird die Verwendung der <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A>-Eigenschaft veranschaulicht.  
  
 [!code-csharp[S_UELogRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#3)]
 [!code-vb[S_UELogRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The property was accessed after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLastRecord">
      <MemberSignature Language="C#" Value="public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLastRecord(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLastRecord(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="member this.SetLastRecord : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.SetLastRecord sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">The new last sequence number in the <see cref="T:System.IO.Log.LogRecordSequence" />.  This should refer to a current valid record   currently in the log.</param>
        <summary>Sets the last record in the <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die angegebene Sequenznummer muss größer sein als die Basissequenznummer.  
  
 Wenn diese Methode abgeschlossen ist, ist der Zugriff auf Datensätze, die zuvor mit Sequenznummern angehängt wurden, die größer sind als die angegebene Sequenznummer, nicht mehr möglich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sequenceNumber" /> is not valid for this sequence.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A new or existing archive tail or base of the active log is invalid.  -or-  <paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The end of the log has been reached.  -or-  The specified log file format or version is invalid.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.LogRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Signals the need to move the tail of the sequence.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können dieses Ereignis auslösen, wenn der Datensatzsequenz Speicherplatz ausgegangen ist. Wenn dieses Ereignis ausgelöst wird, wird das Ende der Sequenz (die Basissequenznummer) nach vorn verschoben, um Speicherplatz freizugeben.  
  
 Das Ereignis kann jederzeit ausgelöst werden, wenn die Datensatzsequenz aus einem beliebigen Grund Speicherplatz freigeben muss. So kann die CLFS-Richtlinien-Engine beispielsweise entscheiden, das Ereignis auszulösen, wenn sie feststellt, dass die Enden von zwei Anmeldeclients, die sich eine Protokolldatei teilen, zu weit auseinander liegen. Die Freigabe von Speicherplatz kann durch Schreiben von Neustartbereichen oder durch Abschneiden des Protokolls und Freigeben von Speicherplatz mit der <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>-Methode erfolgen. Im Codebeispiel im Abschnitt mit dem Beispiel wird der zweite Ansatz veranschaulicht.  
  
 Sie können auch die <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>-Methode außerhalb des <xref:System.IO.Log.LogRecordSequence.TailPinned>-Ereignisses aufrufen, um Speicherplatz freizugeben. Ein Neustartbereich ist mit einem Prüfpunkt anderer Protokollverarbeitungssysteme vergleichbar. Beim Aufruf dieser Methode betrachtet die Anwendung alle vorherigen Datensätze vor dem Neustartbereich als abgeschlossen und für spätere Datensatzanhängevorgänge verfügbar. Ähnlich wie andere Datensätze erfordert der mit dieser Methode geschriebene Datensatz tatsächlich freien Speicherplatz im Protokoll, um funktionieren zu können.  
  
   
  
## Examples  
 In diesem Beispiel wird die Verwendung des <xref:System.IO.Log.LogRecordSequence.TailPinned>-Ereignisses veranschaulicht.  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern. Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist. Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation. Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.  
  
 Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">An array segment that will be concatenated and appended as the record.</param>
        <summary>Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />. This method cannot be inherited.</summary>
        <returns>The sequence number of the written restart area.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern. Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist. Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation. Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.  
  
 Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.  
  
 Die im Bytearraysegment enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">One or more of the arguments is invalid.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred while writing the restart area.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence could not make enough free space to contain the new restart area.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the arguments are <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <summary>Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />. This method cannot be inherited.</summary>
        <returns>The sequence number of the written restart area.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern. Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist. Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation. Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.  
  
 Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.  
  
 Die im Bytearraysegment enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">One or more of the arguments is invalid.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred while writing the restart area.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence could not make enough free space to contain the new restart area.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the arguments are <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="newBaseSeqNum">The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.</param>
        <summary>Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> and updates the base sequence number. This method cannot be inherited.</summary>
        <returns>The sequence number of the written restart area.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern. Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist. Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation. Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.  
  
 Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.  
  
 Wenn ein Neustartbereich geschrieben wird, werden die im Bytearraysegment enthaltenen Daten zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.  
  
 Wenn diese Methode erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert. Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">One or more of the arguments is invalid.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred while writing the restart area.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence could not make enough free space to contain the new restart area.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="newBaseSeqNum">The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.</param>
        <summary>Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> and updates the base sequence number. This method cannot be inherited.</summary>
        <returns>The sequence number of the written restart area.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern. Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist. Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation. Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.  
  
 Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.  
  
 Wenn ein Neustartbereich geschrieben wird, werden die im Bytearraysegment enthaltenen Daten zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.  
  
 Wenn diese Methode erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert. Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">One or more of the arguments is invalid.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred while writing the restart area.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence could not make enough free space to contain the new restart area.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="newBaseSeqNum">The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.</param>
        <param name="reservations">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</param>
        <summary>Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> using a reservation, and updates the base sequence number. This method cannot be inherited.</summary>
        <returns>The sequence number of the written restart area.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern. Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist. Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation. Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.  
  
 Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.  
  
 Wenn ein Neustartbereich geschrieben wird, werden die im Bytearraysegment enthaltenen Daten zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.  
  
 Wenn eine Reservierung angegeben wird, nimmt der geschriebene Neustartbereich, der zuvor mithilfe einer in der Auflistung enthaltenen Reservierung reserviert wurde, Speicherplatz ein. Wenn diese Methode erfolgreich ist, wird die kleinstmögliche Reservierung verwendet, die die Daten aufnehmen kann. Diese Reservierung wird dann aus der Auflistung entfernt.  
  
 Wenn diese Methode erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert. Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">One or more of the arguments is invalid.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred while writing the restart area.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence could not make enough free space to contain the new restart area.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservationCollection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">A list of byte array segments that will be concatenated and appended as the record.</param>
        <param name="newBaseSeqNum">The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.</param>
        <param name="reservationCollection">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</param>
        <summary>Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> using a reservation, and updates the base sequence number. This method cannot be inherited.</summary>
        <returns>The sequence number of the written restart area.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern. Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist. Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation. Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.  
  
 Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.  
  
 Wenn ein Neustartbereich geschrieben wird, werden die im Bytearraysegment enthaltenen Daten zum Anfügen als Datensatz in einem Array mit einem Byte verkettet. Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.  
  
 Wenn eine Reservierung angegeben wird, nimmt der geschriebene Neustartbereich, der zuvor mithilfe einer in der Auflistung enthaltenen Reservierung reserviert wurde, Speicherplatz ein. Wenn diese Methode erfolgreich ist, wird die kleinstmögliche Reservierung verwendet, die die Daten aufnehmen kann. Diese Reservierung wird dann aus der Auflistung entfernt.  
  
 Wenn diese Methode erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert. Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.  
  
 Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst. Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> is not valid for this sequence.  -or-  The specified log enumeration start sequence number is invalid.  -or-  <paramref name="data" /> cannot be appended because it is larger than the maximum record size.  -or-  <paramref name="reservationCollection" /> was not created by this record sequence.</exception>
        <exception cref="T:System.ArgumentNullException">One or more of the parameters is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A new or existing archive tail or base of the active log is invalid.  -or-  <paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</exception>
        <exception cref="T:System.IO.IOException">The request could not be performed because of an unexpected I/O exception.  -or-  The request could not be performed because of an I/O device error.</exception>
        <exception cref="T:System.ObjectDisposedException">The method was called after the sequence has been disposed of.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory to continue the execution of the program.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Access for the specified log sequence is denied by the operating system.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">The record sequence is full.</exception>
      </Docs>
    </Member>
  </Members>
</Type>