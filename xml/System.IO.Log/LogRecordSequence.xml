<Type Name="LogRecordSequence" FullName="System.IO.Log.LogRecordSequence">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7156e4e610a9d14909a701b75c25fcdefeaf4c8c" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="37655523" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <TypeSignature Language="F#" Value="type LogRecordSequence = class&#xA;    interface IRecordSequence&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="99f26-101">Stellt eine in einem <see cref="T:System.IO.Log.LogStore" /> gespeicherte Datensatzsequenz dar.</span>
      <span class="sxs-lookup">
        <span data-stu-id="99f26-101">Represents a record sequence stored in a <see cref="T:System.IO.Log.LogStore" />.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-102">Die <xref:System.IO.Log.LogRecordSequence>-Klasse stellt eine Implementierung der Datensatzsequenzschnittstelle auf einem CLFS-Protokoll (gemeinsames Protokolldateisystem) bereit.</span><span class="sxs-lookup"><span data-stu-id="99f26-102">The <xref:System.IO.Log.LogRecordSequence> class provides an implementation of the record sequence interface on top of a Common Log File System (CLFS) log.</span></span> <span data-ttu-id="99f26-103">Zusätzlich zu den datensatzorientierten Standardfunktionen wird ein Richtlinienmodell zur Vermeidung von vollen Protokollen und von Multiplexing von Clients auf derselben physischen Datei bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="99f26-103">In addition to the standard record-oriented features, it provides a policy model for avoiding log-full conditions, and multiplexing of clients on the same physical file.</span></span> <span data-ttu-id="99f26-104">Die Funktionsweise erfolgt in Kombination mit der <xref:System.IO.Log.LogStore>-Klasse, die eine Schnittstelle für die direkte Bearbeitung und Verwaltung einer CLFS-Protokolldatei bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="99f26-104">It works with the <xref:System.IO.Log.LogStore> class, which provides an interface for directly manipulating and managing a CLFS log file.</span></span> <span data-ttu-id="99f26-105">Die Beziehung zwischen der <xref:System.IO.Log.LogStore>-Klasse und der <xref:System.IO.Log.LogRecordSequence>-Klasse ähnelt der Beziehung zwischen einer Datenträgerdatei und einem <xref:System.IO.FileStream>-Objekt.</span><span class="sxs-lookup"><span data-stu-id="99f26-105">The relationship between the <xref:System.IO.Log.LogStore> class and the <xref:System.IO.Log.LogRecordSequence> class is similar to the relationship between a disk file and a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="99f26-106">Die Datenträgerdatei stellt den tatsächlichen Speicherplatz bereit und weist Attribute wie die Länge und den letzten Zugriff auf, während das <xref:System.IO.FileStream>-Objekt eine Ansicht der Datei bereitstellt, über die Lese- und Schreibvorgänge für die Datei ausgeführt werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-106">The disk file provides the concrete storage, and has attributes such as length and last access time; while the <xref:System.IO.FileStream> object provides a view on the file that can be used to read from it and write to it.</span></span> <span data-ttu-id="99f26-107">Die <xref:System.IO.Log.LogStore>-Klasse weist Attribute wie eine Richtlinie und eine Auflistung von Datenträgerwertebereichen auf, und die <xref:System.IO.Log.LogRecordSequence>-Klasse bietet einen datensatzorientierten Mechanismus zum Lesen und Schreiben von Daten.</span><span class="sxs-lookup"><span data-stu-id="99f26-107">Similarly, the <xref:System.IO.Log.LogStore> class has attributes like a policy and a collection of disk extents; and the <xref:System.IO.Log.LogRecordSequence> class provides a record-oriented mechanism for reading and writing data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99f26-108">In diesem Beispiel wird die Verwendung der <xref:System.IO.Log.LogRecordSequence>-Klasse veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="99f26-108">This example shows how to use the <xref:System.IO.Log.LogRecordSequence> class:</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#0)]
 [!code-vb[S_UELogRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="99f26-109">Initialisiert eine neue Instanz der <see cref="T:System.IO.Log.LogRecordSequence" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-109">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence logStore" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
      </Parameters>
      <Docs>
        <param name="logStore">
          <span data-ttu-id="99f26-110">Der <see cref="T:System.IO.Log.LogStore" />, den diese Datensatzsequenz verwenden sollte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-110">The <see cref="T:System.IO.Log.LogStore" /> that this record sequence should use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-111">Initialisiert eine neue Instanz der <see cref="T:System.IO.Log.LogRecordSequence" />-Klasse mit dem angegebenen Protokollspeicher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-111">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with the specified log store.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-112">Die Puffergröße bestimmt die maximale Größe des Datensatzes, der angefügt oder gelesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="99f26-112">The buffer size determines the maximum size of the record that can be appended or read.</span></span> <span data-ttu-id="99f26-113">In diesem Konstruktor ist ein Standardwert von 64 festgelegt.</span><span class="sxs-lookup"><span data-stu-id="99f26-113">In this constructor, a default value of 64 is set.</span></span> <span data-ttu-id="99f26-114">Die gewünschte Anzahl der Puffer wird auf 10 gesetzt.</span><span class="sxs-lookup"><span data-stu-id="99f26-114">The desired number of buffers is set to 10.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-115">
            <paramref name="logStore" /> ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-115">
              <paramref name="logStore" /> is invalid.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="99f26-116">Ein relativer oder absoluter Pfad für die Basisdatei des Protokollspeichers, die geöffnet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-116">A relative or absolute path for the base file of the log store to open.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="99f26-117">Einer der <see cref="T:System.IO.FileMode" />-Werte, der bestimmt, wie der Speicher geöffnet oder erstellt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-117">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-118">Initialisiert eine neue Instanz der <see cref="T:System.IO.Log.LogRecordSequence" />-Klasse mit einem angegebenen Pfad zum Protokollspeicher und dem Zugriffsmodus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-118">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-119">Dieser Konstruktor initialisiert eine neue <xref:System.IO.Log.LogRecordSequence> auf einem neuen <xref:System.IO.Log.LogStore>-Objekt, das er mit dem angegebenen Pfad und Modus öffnet.</span><span class="sxs-lookup"><span data-stu-id="99f26-119">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path and mode.</span></span> <span data-ttu-id="99f26-120">Dem Objekt wird Lese-/Schreibzugriff auf den Speicher erteilt, und der Speicher wird geöffnet und der Lesezugriff freigegeben.</span><span class="sxs-lookup"><span data-stu-id="99f26-120">It is given read/write access to the store, and the store is opened sharing Read access.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-121">
            <paramref name="path" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-121">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-122">
            <paramref name="path" /> ist eine leere Zeichenfolge ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-122">
              <paramref name="path" /> is an empty string ("").</span>
          </span>
          <span data-ttu-id="99f26-123">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-123">-or-</span>
          </span>
          <span data-ttu-id="99f26-124">
            <paramref name="path" /> enthält nur Leerraum.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-124">
              <paramref name="path" /> contains only white space.</span>
          </span>
          <span data-ttu-id="99f26-125">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-125">-or-</span>
          </span>
          <span data-ttu-id="99f26-126">
            <paramref name="path" /> enthält mindestens ein ungültiges Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-126">
              <paramref name="path" /> contains one or more invalid characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-127">
            <paramref name="mode" /> enthält einen ungültigen Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-127">
              <paramref name="mode" /> contains an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="99f26-128">Die Datei kann nicht gefunden werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-128">The file cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-129">Ein E/A-Fehler tritt auf, wenn der Protokollspeicher geöffnet wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-129">An I/O error occurs when opening the log store.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-130">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-130">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-131">Diese Operation wird nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-131">This operation is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-132">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-132">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="99f26-133">
            <see cref="T:System.IO.Log.LogRecordSequence" /> kann nicht verwendet werden, da die erforderliche CLFS-Komponente (gemeinsames Protokolldateisystem) nicht installiert ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-133">
              <see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span>
          </span>
          <span data-ttu-id="99f26-134">Installieren Sie die CLFS-Komponente, wenn sie für Ihre Plattform verfügbar ist, oder verwenden Sie die <see cref="T:System.IO.Log.FileRecordSequence" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-134">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (logStore, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="logStore">
          <span data-ttu-id="99f26-135">Der <see cref="T:System.IO.Log.LogStore" />, den diese Datensatzsequenz verwenden sollte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-135">The <see cref="T:System.IO.Log.LogStore" /> that this record sequence should use.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="99f26-136">Die gewünschte Puffergröße in Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-136">The desired buffer size in bytes.</span>
          </span>
          <span data-ttu-id="99f26-137">Die Puffergröße bestimmt die maximale Größe des Datensatzes, der angefügt oder gelesen werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-137">The buffer size determines the maximum size of the record that can be appended or read.</span>
          </span>
        </param>
        <param name="bufferCount">
          <span data-ttu-id="99f26-138">Die gewünschte Anzahl an Puffern.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-138">The desired number of buffers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-139">Initialisiert eine neue Instanz der <see cref="T:System.IO.Log.LogRecordSequence" />-Klasse mit dem angegebenen Protokollspeicher, der angegebenen Puffergröße für jeden Datensatz und der Pufferanzahl.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-139">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with the specified log store, buffer size for each record, and buffer number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-140">Verwenden Sie diesen Konstruktor, wenn Sie Werte für `bufferSize` und `bufferCount` angeben möchten und nicht den Standardwert 64 für `bufferSize` und 10 für `bufferCount` verwenden möchten.</span><span class="sxs-lookup"><span data-stu-id="99f26-140">Use this constructor if you want to specify values for `bufferSize` and `bufferCount` and do not want to use the default value of 64 for `bufferSize` and 10 for `bufferCount`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-141">
            <paramref name="logStore" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-141">
              <paramref name="logStore" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-142">
            <paramref name="bufferSize" /> ist negativ oder 0 (null).</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-142">
              <paramref name="bufferSize" /> is negative or zero.</span>
          </span>
          <span data-ttu-id="99f26-143">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-143">-or-</span>
          </span>
          <span data-ttu-id="99f26-144">
            <paramref name="bufferCount" /> ist negativ oder 0 (null).</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-144">
              <paramref name="bufferCount" /> is negative or zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="99f26-145">Ein relativer oder absoluter Pfad für die Basisdatei des Protokollspeichers, die geöffnet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-145">A relative or absolute path for the base file of the log store to open.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="99f26-146">Einer der <see cref="T:System.IO.FileMode" />-Werte, der bestimmt, wie der Speicher geöffnet oder erstellt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-146">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="99f26-147">Einer der <see cref="T:System.IO.FileAccess" />-Werte, der festlegt, wie der <see cref="T:System.IO.Log.LogStore" /> auf die Datei zugreifen kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-147">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-148">Initialisiert eine neue Instanz der <see cref="T:System.IO.Log.LogRecordSequence" />-Klasse mit einem angegebenen Pfad zum Protokollspeicher und dem Zugriffs- und Freigabemodus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-148">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access and share modes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-149">Dieser Konstruktor initialisiert eine neue <xref:System.IO.Log.LogRecordSequence> auf einem neuen <xref:System.IO.Log.LogStore>-Objekt, das er mit dem angegebenen Pfad, Modus und Zugriff öffnet.</span><span class="sxs-lookup"><span data-stu-id="99f26-149">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="99f26-150">Der Speicher wird geöffnet und der Lesezugriff freigegeben.</span><span class="sxs-lookup"><span data-stu-id="99f26-150">The store is opened sharing Read access.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-151">
            <paramref name="path" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-151">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-152">
            <paramref name="path" /> ist eine leere Zeichenfolge ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-152">
              <paramref name="path" /> is an empty string ("").</span>
          </span>
          <span data-ttu-id="99f26-153">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-153">-or-</span>
          </span>
          <span data-ttu-id="99f26-154">
            <paramref name="path" /> enthält nur Leerraum.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-154">
              <paramref name="path" /> contains only white space.</span>
          </span>
          <span data-ttu-id="99f26-155">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-155">-or-</span>
          </span>
          <span data-ttu-id="99f26-156">
            <paramref name="path" /> enthält mindestens ein ungültiges Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-156">
              <paramref name="path" /> contains one or more invalid characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-157">
            <paramref name="mode" /> enthält einen ungültigen Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-157">
              <paramref name="mode" /> contains an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="99f26-158">Die Datei kann nicht gefunden werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-158">The file cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-159">Ein E/A-Fehler tritt auf, wenn der Protokollspeicher geöffnet wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-159">An I/O error occurs when opening the log store.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-160">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-160">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-161">Diese Operation wird nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-161">This operation is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-162">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-162">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="99f26-163">
            <see cref="T:System.IO.Log.LogRecordSequence" /> kann nicht verwendet werden, da die erforderliche CLFS-Komponente (gemeinsames Protokolldateisystem) nicht installiert ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-163">
              <see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span>
          </span>
          <span data-ttu-id="99f26-164">Installieren Sie die CLFS-Komponente, wenn sie für Ihre Plattform verfügbar ist, oder verwenden Sie die <see cref="T:System.IO.Log.FileRecordSequence" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-164">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="99f26-165">Ein relativer oder absoluter Pfad für die Basisdatei des Protokollspeichers, die geöffnet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-165">A relative or absolute path for the base file of the log store to open.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="99f26-166">Einer der <see cref="T:System.IO.FileMode" />-Werte, der bestimmt, wie der Speicher geöffnet oder erstellt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-166">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="99f26-167">Einer der <see cref="T:System.IO.FileAccess" />-Werte, der festlegt, wie der <see cref="T:System.IO.Log.LogStore" /> auf die Datei zugreifen kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-167">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="99f26-168">Einer der <see cref="T:System.IO.FileShare" />-Werte, der bestimmt, wie der Protokollspeicher für Prozesse freigegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-168">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-169">Initialisiert eine neue Instanz der <see cref="T:System.IO.Log.LogRecordSequence" />-Klasse mit einem angegebenen Pfad zum Protokollspeicher und dem Zugriffsmodus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-169">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-170">Dieser Konstruktor initialisiert eine neue <xref:System.IO.Log.LogRecordSequence> auf einem neuen <xref:System.IO.Log.LogStore>-Objekt, das er mit dem angegebenen Pfad, Modus und Zugriff öffnet.</span><span class="sxs-lookup"><span data-stu-id="99f26-170">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="99f26-171">Der Speicher wird geöffnet und der angegebene Zugriff freigegeben.</span><span class="sxs-lookup"><span data-stu-id="99f26-171">The store is opened sharing the specified access.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99f26-172">Dieses Beispiel zeigt die Verwendung dieses <xref:System.IO.Log.LogRecordSequence>-Konstruktors:</span><span class="sxs-lookup"><span data-stu-id="99f26-172">This example shows how to use this <xref:System.IO.Log.LogRecordSequence> constructor:</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#1)]
 [!code-vb[S_UELogRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-173">
            <paramref name="path" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-173">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-174">
            <paramref name="path" /> ist eine leere Zeichenfolge ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-174">
              <paramref name="path" /> is an empty string ("").</span>
          </span>
          <span data-ttu-id="99f26-175">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-175">-or-</span>
          </span>
          <span data-ttu-id="99f26-176">
            <paramref name="path" /> enthält nur Leerraum.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-176">
              <paramref name="path" /> contains only white space.</span>
          </span>
          <span data-ttu-id="99f26-177">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-177">-or-</span>
          </span>
          <span data-ttu-id="99f26-178">
            <paramref name="path" /> enthält mindestens ein ungültiges Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-178">
              <paramref name="path" /> contains one or more invalid characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-179">
            <paramref name="mode" /> enthält einen ungültigen Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-179">
              <paramref name="mode" /> contains an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="99f26-180">Die Datei kann nicht gefunden werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-180">The file cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-181">Ein E/A-Fehler tritt auf, wenn der Protokollspeicher geöffnet wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-181">An I/O error occurs when opening the log store.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-182">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-182">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-183">Diese Operation wird nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-183">This operation is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-184">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-184">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="99f26-185">
            <see cref="T:System.IO.Log.LogRecordSequence" /> kann nicht verwendet werden, da die erforderliche CLFS-Komponente (gemeinsames Protokolldateisystem) nicht installiert ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-185">
              <see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span>
          </span>
          <span data-ttu-id="99f26-186">Installieren Sie die CLFS-Komponente, wenn sie für Ihre Plattform verfügbar ist, oder verwenden Sie die <see cref="T:System.IO.Log.FileRecordSequence" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-186">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, bufferCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="99f26-187">Ein relativer oder absoluter Pfad für die Basisdatei des Protokollspeichers, die geöffnet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-187">A relative or absolute path for the base file of the log store to open.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="99f26-188">Einer der <see cref="T:System.IO.FileMode" />-Werte, der bestimmt, wie der Speicher geöffnet oder erstellt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-188">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="99f26-189">Einer der <see cref="T:System.IO.FileAccess" />-Werte, der festlegt, wie der <see cref="T:System.IO.Log.LogStore" /> auf die Datei zugreifen kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-189">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="99f26-190">Einer der <see cref="T:System.IO.FileShare" />-Werte, der bestimmt, wie der Protokollspeicher für Prozesse freigegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-190">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="99f26-191">Die gewünschte Puffergröße in Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-191">The desired buffer size in bytes.</span>
          </span>
          <span data-ttu-id="99f26-192">Die Puffergröße bestimmt die maximale Größe des Datensatzes, der angefügt oder gelesen werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-192">The buffer size determines the maximum size of the record that can be appended or read.</span>
          </span>
        </param>
        <param name="bufferCount">
          <span data-ttu-id="99f26-193">Die gewünschte Anzahl an Puffern.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-193">The desired number of buffers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-194">Initialisiert eine neue Instanz der <see cref="T:System.IO.Log.LogRecordSequence" />-Klasse mit den Angaben für den Pfad zum Protokollspeicher, die Dateiberechtigung, den Zugriffs- und Freigabemodus sowie die Puffergröße und -anzahl für Datensätze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-194">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store, file permission, access and share modes, and the buffer size and count for records.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-195">Dieser Konstruktor initialisiert eine neue <xref:System.IO.Log.LogRecordSequence> auf einem neuen <xref:System.IO.Log.LogStore>-Objekt, das er mit dem angegebenen Pfad, Modus und Zugriff öffnet.</span><span class="sxs-lookup"><span data-stu-id="99f26-195">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="99f26-196">Der Speicher wird geöffnet und der angegebene Zugriff freigegeben.</span><span class="sxs-lookup"><span data-stu-id="99f26-196">The store is opened sharing the specified access.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-197">
            <paramref name="path" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-197">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-198">
            <paramref name="path" /> ist eine leere Zeichenfolge ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-198">
              <paramref name="path" /> is an empty string ("").</span>
          </span>
          <span data-ttu-id="99f26-199">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-199">-or-</span>
          </span>
          <span data-ttu-id="99f26-200">
            <paramref name="path" /> enthält nur Leerraum.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-200">
              <paramref name="path" /> contains only white space.</span>
          </span>
          <span data-ttu-id="99f26-201">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-201">-or-</span>
          </span>
          <span data-ttu-id="99f26-202">
            <paramref name="path" /> enthält mindestens ein ungültiges Zeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-202">
              <paramref name="path" /> contains one or more invalid characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-203">
            <paramref name="mode" /> enthält einen ungültigen Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-203">
              <paramref name="mode" /> contains an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="99f26-204">Die Datei kann nicht gefunden werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-204">The file cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-205">Ein E/A-Fehler tritt auf, wenn der Protokollspeicher geöffnet wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-205">An I/O error occurs when opening the log store.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-206">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-206">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-207">Diese Operation wird nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-207">This operation is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-208">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-208">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="99f26-209">
            <see cref="T:System.IO.Log.LogRecordSequence" /> kann nicht verwendet werden, da die erforderliche CLFS-Komponente (gemeinsames Protokolldateisystem) nicht installiert ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-209">
              <see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span>
          </span>
          <span data-ttu-id="99f26-210">Installieren Sie die CLFS-Komponente, wenn sie für Ihre Plattform verfügbar ist, oder verwenden Sie die <see cref="T:System.IO.Log.FileRecordSequence" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-210">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="99f26-211">Ein relativer oder absoluter Pfad für die Basisdatei des Protokollspeichers, die geöffnet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-211">A relative or absolute path for the base file of the log store to open.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="99f26-212">Ein gültiger <see cref="T:System.IO.FileMode" />-Wert, der bestimmt, wie der Speicher geöffnet oder erstellt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-212">A valid <see cref="T:System.IO.FileMode" /> value that determines how to open or create the store.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="99f26-213">Ein gültiger <see cref="T:System.IO.FileAccess" />-Wert, der festlegt, wie auf den Protokollspeicher zugegriffen werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-213">A valid <see cref="T:System.IO.FileAccess" /> value that determines how the log store can be accessed.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="99f26-214">Ein gültiger <see cref="T:System.IO.FileShare" />-Wert, der bestimmt, wie der Protokollspeicher unter Prozessen freigegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-214">A valid <see cref="T:System.IO.FileShare" /> value that determines how the log store will be shared among processes.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="99f26-215">Die gewünschte Puffergröße in Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-215">The desired buffer size in bytes.</span>
          </span>
          <span data-ttu-id="99f26-216">Die Puffergröße bestimmt die maximale Größe des Datensatzes, der angefügt oder gelesen werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-216">The buffer size determines the maximum size of the record that can be appended or read.</span>
          </span>
        </param>
        <param name="bufferCount">
          <span data-ttu-id="99f26-217">Die gewünschte Anzahl an Puffern.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-217">The desired number of buffers.</span>
          </span>
        </param>
        <param name="fileSecurity">
          <span data-ttu-id="99f26-218">Ein gültiger <see cref="T:System.Security.AccessControl.FileSecurity" />-Wert, der die Sicherheit für den neu erstellten Speicher festlegt, sofern der Speicher erstellt werden muss.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-218">A valid <see cref="T:System.Security.AccessControl.FileSecurity" /> value that specifies the security to set on the newly created store if the store must be created.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-219">Initialisiert eine neue Instanz der <see cref="T:System.IO.Log.LogRecordSequence" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-219">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-220">Die durch <paramref name="path" /> angegebene Datei ist nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-220">The file specified by <paramref name="path" /> is not valid.</span>
          </span>
          <span data-ttu-id="99f26-221">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-221">-or-</span>
          </span>
          <span data-ttu-id="99f26-222">Der angegebene Dateiname des Protokollspeichers ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-222">The specified log store file name is not valid.</span>
          </span>
          <span data-ttu-id="99f26-223">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-223">-or-</span>
          </span>
          <span data-ttu-id="99f26-224">
            <paramref name="mode" /> hat den Wert <see cref="F:System.IO.FileMode.CreateNew" /> und kann nicht ohne Schreibzugriff verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-224">
              <paramref name="mode" /> has a value of <see cref="F:System.IO.FileMode.CreateNew" />, and cannot be used without write access.</span>
          </span>
          <span data-ttu-id="99f26-225">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-225">-or-</span>
          </span>
          <span data-ttu-id="99f26-226">
            <paramref name="mode" /> hat den Wert <see cref="F:System.IO.FileMode.OpenOrCreate" /> und kann nicht ohne Schreibzugriff verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-226">
              <paramref name="mode" /> has a value of <see cref="F:System.IO.FileMode.OpenOrCreate" />, and cannot be used without write access.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-227">Mindestens ein Argument ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-227">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-228">Mindestens ein Argument liegt außerhalb des Bereichs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-228">One or more of the arguments are out of range.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="99f26-229">Die durch <paramref name="path" /> angegebene Datei kann nicht gefunden werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-229">The file specified by <paramref name="path" /> cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-230">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-230">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-231">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-231">-or-</span>
          </span>
          <span data-ttu-id="99f26-232">Auf die von <paramref name="path" /> angegebene Datei kann nicht zugegriffen werden, da sie von einem anderen Prozess verwendet wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-232">The file specified by <paramref name="path" /> cannot be accessed because it is in use by another process.</span>
          </span>
          <span data-ttu-id="99f26-233">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-233">-or-</span>
          </span>
          <span data-ttu-id="99f26-234">Die von <paramref name="path" /> angegebene Datei kann nicht erstellt werden, da die Datei oder das Verzeichnis bereits vorhanden ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-234">The file specified by <paramref name="path" /> cannot be created because the file or directory already exists.</span>
          </span>
          <span data-ttu-id="99f26-235">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-235">-or-</span>
          </span>
          <span data-ttu-id="99f26-236">Das Protokollhandle konnte nicht an den Threadpool gebunden werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-236">The log handle could not be bound to the thread pool.</span>
          </span>
          <span data-ttu-id="99f26-237">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-237">-or-</span>
          </span>
          <span data-ttu-id="99f26-238">Das angegebene Protokolldateiformat oder die Version ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-238">The specified log file format or version is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-239">Diese Operation wird nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-239">This operation is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-240">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-240">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-241">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-241">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="99f26-242">
            <see cref="T:System.IO.Log.LogRecordSequence" /> kann nicht verwendet werden, da die erforderliche CLFS-Komponente (gemeinsames Protokolldateisystem) nicht installiert ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-242">
              <see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span>
          </span>
          <span data-ttu-id="99f26-243">Installieren Sie die CLFS-Komponente, wenn sie für Ihre Plattform verfügbar ist, oder verwenden Sie die <see cref="T:System.IO.Log.FileRecordSequence" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-243">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-244">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-244">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-245">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-245">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit&#xA;override this.AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="99f26-246">Gibt die neue Basis-<see cref="T:System.IO.Log.SequenceNumber" /> für das Protokoll an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-246">Specifies the new base <see cref="T:System.IO.Log.SequenceNumber" /> for the log.</span>
          </span>
          <span data-ttu-id="99f26-247">Diese muss im Bereich zwischen der aktuellen Basissequenznummer und der letzten Sequenznummer des Protokolls liegen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-247">This must lie in the range between the current base sequence number and the last sequence number of the log inclusively.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-248">Rückt die Basissequenznummer des Protokolls vor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-248">Moves the base sequence number of the log forward.</span>
          </span>
          <span data-ttu-id="99f26-249">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-249">This method cannot be inherited.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-250">Diese Methode wird oft mit dem <xref:System.IO.Log.LogRecordSequence.TailPinned>-Ereignis verwendet, um Speicherplatz in einem Datensatz freizugeben.</span><span class="sxs-lookup"><span data-stu-id="99f26-250">This method is often used with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a record.</span></span> <span data-ttu-id="99f26-251">Das <xref:System.IO.Log.LogRecordSequence.TailPinned>-Ereignis gibt an, dass das Ende der Sequenz (die Basissequenznummer) nach vorne verschoben werden muss, um Speicherplatz freizugeben.</span><span class="sxs-lookup"><span data-stu-id="99f26-251">The <xref:System.IO.Log.LogRecordSequence.TailPinned> event indicates that the tail of the sequence (that is, the base sequence number) needs to be moved forward to free up space.</span></span> <span data-ttu-id="99f26-252">Speicherplatz kann freigegeben werden, indem Neustartbereiche mit der <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>-Methode geschrieben werden oder indem das Protokoll abgeschnitten wird und die Basissequenznummer eines Protokolls mit der <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>-Methode in die durch den `newBaseSequenceNumber`-Parameter angegebene Nummer geändert wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-252">Freeing space can be done by either writing restart areas using the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method, or truncating the log and using the <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method to advance the base sequence number of a log to the one specified by the `newBaseSequenceNumber` parameter.</span></span> <span data-ttu-id="99f26-253">Im Codebeispiel im Abschnitt mit dem Beispiel wird der zweite Ansatz veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="99f26-253">The code sample in the Example section demonstrates the second approach.</span></span>  
  
 <span data-ttu-id="99f26-254">Beachten Sie, dass das Aufrufen dieser Methode dem Festlegen einer neuen Basissequenznummer mit der <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>-Methode entspricht. Die einzige Ausnahme besteht darin, dass kein Neustartdatensatz in das Protokoll geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-254">Note that calling this method is the same as setting a new base sequence number using the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method, except that no restart record is written to the log.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99f26-255">Dieses Beispiel veranschaulicht die Verwendung der <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>-Methode mit dem <xref:System.IO.Log.LogRecordSequence.TailPinned>-Ereignis, um Speicherplatz in einer Protokollsequenz freizugeben.</span><span class="sxs-lookup"><span data-stu-id="99f26-255">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a log sequence.</span></span>  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-256">
            <paramref name="newBaseSequenceNumber" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-256">
              <paramref name="newBaseSequenceNumber" /> is not valid for this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-257">Ein neues oder vorhandenes Archivende oder eine Basis des aktiven Protokolls ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-257">A new or existing archive tail or base of the active log is invalid.</span>
          </span>
          <span data-ttu-id="99f26-258">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-258">-or-</span>
          </span>
          <span data-ttu-id="99f26-259">
            <paramref name="newBaseSequenceNumber" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-259">
              <paramref name="newBaseSequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-260">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-260">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-261">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-261">-or-</span>
          </span>
          <span data-ttu-id="99f26-262">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-262">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="99f26-263">Das angegebene Protokoll verfügt nicht über Wertebereiche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-263">The specified log does not have any extents.</span>
          </span>
          <span data-ttu-id="99f26-264">Ein oder mehrere Wertebereiche müssen erstellt werden, bevor eine Datensatzsequenz verwendet werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-264">One or more extents must be created before a record sequence may be used.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-265">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-265">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-266">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-266">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-267">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-267">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-268">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-268">The record sequence is full.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="99f26-269">Schreibt einen Protokolldatensatz in die <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-269">Writes a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="99f26-270">Dieses Beispiel veranschaulicht die Verwendung des <xref:System.IO.Log.LogRecordSequence.Append%2A>-Members.</span><span class="sxs-lookup"><span data-stu-id="99f26-270">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.Append%2A> member</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#5)]
 [!code-vb[S_UELogRecordSequence#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-271">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-271">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="99f26-272">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-272">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="99f26-273">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-273">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="99f26-274">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-274">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-275">Schreibt einen Protokolldatensatz in die <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-275">Writes a log record to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
          <span data-ttu-id="99f26-276">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-276">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-277">Die Sequenznummer des angefügten Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-277">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-278">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-278">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-279">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="99f26-279">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="99f26-280">Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-280">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="99f26-281">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="99f26-281">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99f26-282">Im folgenden Beispiel wird veranschaulicht, wie diese Methode verwendet werden kann, um einer Sequenz einen Protokolldatensatz anzufügen.</span><span class="sxs-lookup"><span data-stu-id="99f26-282">The following example demonstrates how to use this method to append a log record to the sequence.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#13)]
 [!code-vb[S_UELogRecordSequence#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-283">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-283">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="99f26-284">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-284">-or-</span>
          </span>
          <span data-ttu-id="99f26-285">
            <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-285">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="99f26-286">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-286">-or-</span>
          </span>
          <span data-ttu-id="99f26-287">
            <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-287">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-288">Mindestens ein Argument ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-288">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-289">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-289">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-290">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-290">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-291">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-291">-or-</span>
          </span>
          <span data-ttu-id="99f26-292">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-292">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-293">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-293">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-294">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-294">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-295">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-295">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-296">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-296">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-297">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-297">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-298">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-298">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="userRecord">
          <span data-ttu-id="99f26-299">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-299">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="99f26-300">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-300">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="99f26-301">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-301">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-302">Fügt einen Protokolldatensatz an die <see cref="T:System.IO.Log.IRecordSequence" /> an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-302">Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
          <span data-ttu-id="99f26-303">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-303">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-304">Die Sequenznummer des angefügten Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-304">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-305">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-305">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-306">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="99f26-306">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="99f26-307">Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-307">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="99f26-308">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="99f26-308">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-309">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-309">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="99f26-310">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-310">-or-</span>
          </span>
          <span data-ttu-id="99f26-311">
            <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-311">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="99f26-312">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-312">-or-</span>
          </span>
          <span data-ttu-id="99f26-313">
            <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-313">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-314">Mindestens ein Argument ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-314">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-315">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-315">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-316">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-316">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-317">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-317">-or-</span>
          </span>
          <span data-ttu-id="99f26-318">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-318">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-319">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-319">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-320">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-320">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-321">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-321">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-322">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-322">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-323">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-323">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-324">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-324">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="99f26-325">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-325">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="99f26-326">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-326">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="99f26-327">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-327">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="99f26-328">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Datensatz verwendet werden sollte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-328">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-329">Fügt der <see cref="T:System.IO.Log.IRecordSequence" /> mithilfe von zuvor in der Sequenz reserviertem Speicherplatz einen Protokolldatensatz an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-329">Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span>
          </span>
          <span data-ttu-id="99f26-330">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-330">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-331">Die Sequenznummer des angefügten Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-331">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-332">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-332">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-333">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="99f26-333">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="99f26-334">Der angefügte Datensatz, der zuvor mithilfe einer vom `reservations`-Parameter angegebenen Reservierung reserviert wurde, nimmt Speicherplatz ein.</span><span class="sxs-lookup"><span data-stu-id="99f26-334">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="99f26-335">Wenn der Anfügevorgang erfolgreich ist, wird der kleinstmögliche Reservierungsbereich verwendet, der die Daten aufnehmen kann. Dieser Reservierungsbereich wird dann aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="99f26-335">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="99f26-336">Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-336">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="99f26-337">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="99f26-337">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-338">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-338">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="99f26-339">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-339">-or-</span>
          </span>
          <span data-ttu-id="99f26-340">
            <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-340">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="99f26-341">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-341">-or-</span>
          </span>
          <span data-ttu-id="99f26-342">
            <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-342">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-343">Mindestens ein Argument ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-343">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-344">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-344">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-345">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-345">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-346">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-346">-or-</span>
          </span>
          <span data-ttu-id="99f26-347">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-347">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-348">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-348">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-349">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-349">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-350">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-350">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-351">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-351">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-352">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-352">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <span data-ttu-id="99f26-353">Keine Reservierung, die groß genug für <paramref name="data" /> ist, kann in <paramref name="reservations" /> gefunden werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-353">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-354">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-354">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="userRecord">
          <span data-ttu-id="99f26-355">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-355">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="99f26-356">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-356">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="99f26-357">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-357">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="99f26-358">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Datensatz verwendet werden sollte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-358">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-359">Fügt der <see cref="T:System.IO.Log.IRecordSequence" /> mithilfe von zuvor in der Sequenz reserviertem Speicherplatz einen Protokolldatensatz an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-359">Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span>
          </span>
          <span data-ttu-id="99f26-360">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-360">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-361">Die Sequenznummer des angefügten Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-361">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-362">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-362">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-363">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="99f26-363">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="99f26-364">Der angefügte Datensatz, der zuvor mithilfe einer vom `reservations`-Parameter angegebenen Reservierung reserviert wurde, nimmt Speicherplatz ein.</span><span class="sxs-lookup"><span data-stu-id="99f26-364">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="99f26-365">Wenn der Anfügevorgang erfolgreich ist, wird der kleinstmögliche Reservierungsbereich verwendet, der die Daten aufnehmen kann. Dieser Reservierungsbereich wird dann aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="99f26-365">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="99f26-366">Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-366">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="99f26-367">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.IRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="99f26-367">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-368">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-368">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="99f26-369">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-369">-or-</span>
          </span>
          <span data-ttu-id="99f26-370">
            <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-370">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="99f26-371">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-371">-or-</span>
          </span>
          <span data-ttu-id="99f26-372">
            <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-372">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-373">Mindestens ein Argument ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-373">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-374">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-374">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-375">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-375">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-376">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-376">-or-</span>
          </span>
          <span data-ttu-id="99f26-377">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-377">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-378">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-378">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-379">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-379">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-380">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-380">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-381">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-381">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-382">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-382">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <span data-ttu-id="99f26-383">Keine Reservierung, die groß genug für <paramref name="data" /> ist, kann in <paramref name="reservations" /> gefunden werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-383">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="99f26-384">Ruft die Sequenznummer des ersten gültigen Datensatzes in der <see cref="T:System.IO.Log.LogRecordSequence" /> ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-384">Gets the sequence number of the first valid record in the current <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="99f26-385">Die niedrigste Sequenznummer, die einem gültigen Datensatz in der <see cref="T:System.IO.Log.LogRecordSequence" /> entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-385">The lowest sequence number that corresponds to a valid record in the <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-386">Gültige Sequenznummern sind größer oder gleich <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> und kleiner als <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</span><span class="sxs-lookup"><span data-stu-id="99f26-386">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</span></span>  
  
 <span data-ttu-id="99f26-387">Der Wert dieser Eigenschaft kann durch Aufrufen der <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>-Methode oder der <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>-Methode geändert werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-387">The value of this property can be changed by calling the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method or <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99f26-388">In diesem Beispiel wird die Verwendung des <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A>-Members in einer Schleife veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="99f26-388">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> member in a loop.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-389">Auf die Eigenschaft wurde zugegriffen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-389">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="99f26-390">Startet einen asynchronen Anfügevorgang.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-390">Begins an asynchronous append operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-391">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-391">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="99f26-392">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-392">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="99f26-393">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-393">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="99f26-394">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-394">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="99f26-395">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-395">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="99f26-396">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-396">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-397">Startet einen asynchronen Anfügevorgang.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-397">Begins an asynchronous append operation.</span>
          </span>
          <span data-ttu-id="99f26-398">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-398">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-399">Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Anfügevorgang darstellt, der möglicherweise noch aussteht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-399">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-400">Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-400">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="99f26-401">Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-401">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="99f26-402">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-402">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-403">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="99f26-403">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="99f26-404">Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-404">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="99f26-405">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="99f26-405">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-406">
            <paramref name="nextUndoRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-406">
              <paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="99f26-407">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-407">-or-</span>
          </span>
          <span data-ttu-id="99f26-408">
            <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-408">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="99f26-409">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-409">-or-</span>
          </span>
          <span data-ttu-id="99f26-410">
            <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-410">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-411">Mindestens ein Argument ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-411">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-412">
            <paramref name="nextUndoRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-412">
              <paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-413">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-413">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-414">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-414">-or-</span>
          </span>
          <span data-ttu-id="99f26-415">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-415">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-416">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-416">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-417">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-417">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-418">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-418">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-419">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-419">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-420">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-420">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-421">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-421">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="userRecord">
          <span data-ttu-id="99f26-422">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-422">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="99f26-423">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-423">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="99f26-424">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-424">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="99f26-425">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-425">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="99f26-426">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-426">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-427">Startet einen asynchronen Anfügevorgang.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-427">Begins an asynchronous append operation.</span>
          </span>
          <span data-ttu-id="99f26-428">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-428">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-429">Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Anfügevorgang darstellt, der möglicherweise noch aussteht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-429">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-430">Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-430">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="99f26-431">Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-431">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="99f26-432">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-432">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-433">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="99f26-433">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="99f26-434">Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-434">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="99f26-435">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="99f26-435">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-436">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-436">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="99f26-437">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-437">-or-</span>
          </span>
          <span data-ttu-id="99f26-438">
            <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-438">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="99f26-439">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-439">-or-</span>
          </span>
          <span data-ttu-id="99f26-440">
            <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-440">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-441">Mindestens ein Argument ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-441">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-442">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-442">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-443">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-443">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-444">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-444">-or-</span>
          </span>
          <span data-ttu-id="99f26-445">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-445">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-446">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-446">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-447">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-447">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-448">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-448">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-449">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-449">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-450">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-450">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-451">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-451">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="99f26-452">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-452">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="99f26-453">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-453">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="99f26-454">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-454">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="99f26-455">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Datensatz verwendet werden sollte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-455">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="99f26-456">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-456">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="99f26-457">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-457">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-458">Startet einen asynchronen Anfügevorgang.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-458">Begins an asynchronous append operation.</span>
          </span>
          <span data-ttu-id="99f26-459">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-459">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-460">Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Anfügevorgang darstellt, der möglicherweise noch aussteht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-460">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-461">Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-461">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="99f26-462">Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-462">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="99f26-463">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-463">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-464">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="99f26-464">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="99f26-465">Der angefügte Datensatz, der zuvor mithilfe einer vom `reservations`-Parameter angegebenen Reservierung reserviert wurde, nimmt Speicherplatz ein.</span><span class="sxs-lookup"><span data-stu-id="99f26-465">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="99f26-466">Wenn der Anfügevorgang erfolgreich ist, wird der kleinstmögliche Reservierungsbereich verwendet, der die Daten aufnehmen kann. Dieser Reservierungsbereich wird dann aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="99f26-466">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="99f26-467">Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-467">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="99f26-468">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="99f26-468">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-469">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-469">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="99f26-470">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-470">-or-</span>
          </span>
          <span data-ttu-id="99f26-471">
            <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-471">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="99f26-472">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-472">-or-</span>
          </span>
          <span data-ttu-id="99f26-473">
            <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-473">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-474">Mindestens ein Argument ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-474">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-475">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-475">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-476">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-476">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-477">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-477">-or-</span>
          </span>
          <span data-ttu-id="99f26-478">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-478">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-479">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-479">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-480">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-480">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-481">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-481">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-482">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-482">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-483">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-483">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <span data-ttu-id="99f26-484">Keine Reservierung, die groß genug für <paramref name="data" /> ist, kann in <paramref name="reservations" /> gefunden werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-484">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-485">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-485">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="userRecord">
          <span data-ttu-id="99f26-486">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-486">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="99f26-487">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-487">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="99f26-488">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-488">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="99f26-489">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Datensatz verwendet werden sollte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-489">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="99f26-490">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-490">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="99f26-491">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-491">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-492">Startet einen asynchronen Anfügevorgang.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-492">Begins an asynchronous append operation.</span>
          </span>
          <span data-ttu-id="99f26-493">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-493">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-494">Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Anfügevorgang darstellt, der möglicherweise noch aussteht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-494">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-495">Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-495">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="99f26-496">Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-496">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="99f26-497">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-497">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-498">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="99f26-498">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="99f26-499">Der angefügte Datensatz, der zuvor mithilfe einer vom `reservations`-Parameter angegebenen Reservierung reserviert wurde, nimmt Speicherplatz ein.</span><span class="sxs-lookup"><span data-stu-id="99f26-499">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="99f26-500">Wenn der Anfügevorgang erfolgreich ist, wird der kleinstmögliche Reservierungsbereich verwendet, der die Daten aufnehmen kann. Dieser Reservierungsbereich wird dann aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="99f26-500">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="99f26-501">Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-501">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="99f26-502">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="99f26-502">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-503">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-503">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="99f26-504">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-504">-or-</span>
          </span>
          <span data-ttu-id="99f26-505">
            <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-505">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="99f26-506">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-506">-or-</span>
          </span>
          <span data-ttu-id="99f26-507">
            <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-507">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-508">Mindestens ein Argument ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-508">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-509">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-509">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-510">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-510">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-511">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-511">-or-</span>
          </span>
          <span data-ttu-id="99f26-512">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-512">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-513">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-513">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-514">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-514">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-515">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-515">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-516">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-516">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-517">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-517">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <span data-ttu-id="99f26-518">Keine Reservierung, die groß genug für <paramref name="data" /> ist, kann in <paramref name="reservations" /> gefunden werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-518">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">
          <span data-ttu-id="99f26-519">Die Sequenznummer des letzten Datensatzes, der geschrieben werden muss.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-519">The sequence number of the latest record that must be written.</span>
          </span>
          <span data-ttu-id="99f26-520">Wenn diese <see cref="T:System.IO.Log.SequenceNumber" /> ungültig ist, müssen alle Datensätze geschrieben werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-520">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="99f26-521">Ein optionaler asynchroner Rückruf, der nach Abschluss des Löschvorgangs aufgerufen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-521">An optional asynchronous callback, to be called when the flush is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="99f26-522">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Löschanforderung von anderen Anforderungen unterscheidet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-522">A user-provided object that distinguishes this particular asynchronous flush request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-523">Startet einen asynchronen Löschvorgang und verwendet Speicherplatz, der zuvor in der Sequenz reserviert wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-523">Begins an asynchronous flush operation, using space previously reserved in the sequence.</span>
          </span>
          <span data-ttu-id="99f26-524">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-524">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-525">Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Löschvorgang darstellt, der möglicherweise noch aussteht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-525">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous flush operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-526">Sie sollten das von der aktuellen Methode ausgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>-Methode weiterleiten, um sicherzustellen, dass der Löschvorgang abgeschlossen wird und die Ressourcen korrekt freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-526">You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately.</span></span> <span data-ttu-id="99f26-527">Wenn während eines asynchronen Löschvorgangs ein Fehler auftritt, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-527">If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="99f26-528">Durch das Aufrufen dieser Methode wird sichergestellt, dass alle Datensätze, die der <xref:System.IO.Log.LogRecordSequence> angefügt wurden, dauerhaft geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-528">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.LogRecordSequence> are durably written.</span></span>  
  
 <span data-ttu-id="99f26-529">Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="99f26-529">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="99f26-530">Bei einer asynchronen Löschanforderung auftretende Fehler, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>-Methode Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="99f26-530">Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-531">
            <paramref name="sequenceNumber" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-531">
              <paramref name="sequenceNumber" /> is not valid for this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-532">
            <paramref name="sequenceNumber" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-532">
              <paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-533">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-533">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="99f26-534">Das angegebene Protokoll verfügt nicht über Wertebereiche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-534">The specified log does not have any extents.</span>
          </span>
          <span data-ttu-id="99f26-535">Ein oder mehrere Wertebereiche müssen erstellt werden, bevor eine Datensatzsequenz verwendet werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-535">One or more extents must be created before a record sequence can be used.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-536">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-536">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-537">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-537">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-538">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-538">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-539">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-539">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-540">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-540">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="99f26-541">Startet einen asynchronen Reservierungs- und Anfügevorgang.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-541">Begins an asynchronous reserve and append operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-542">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-542">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="99f26-543">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-543">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="99f26-544">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-544">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="99f26-545">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-545">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="99f26-546">Die Reservierungsauflistung, in der Reservierungen vorgenommen werden können.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-546">The reservation collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="99f26-547">Die vorzunehmenden Reservierungen in Byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-547">The reservations to make, in bytes.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="99f26-548">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-548">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="99f26-549">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-549">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-550">Startet einen asynchronen Reservierungs- und Anfügevorgang.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-550">Begins an asynchronous reserve and append operation.</span>
          </span>
          <span data-ttu-id="99f26-551">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-551">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-552">Ein <see cref="T:System.IAsyncResult" />, das diesen asynchronen Vorgang darstellt, der möglicherweise noch aussteht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-552">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-553">Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-553">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="99f26-554">Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-554">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="99f26-555">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-555">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-556">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="99f26-556">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="99f26-557">Die angegebenen Reservierungen werden in einer atomaren Operation mit einem Vorgang zum Anfügen von Datensätzen der bereitgestellten Reservierungsauflistung hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="99f26-557">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="99f26-558">Wenn der Anfügevorgang scheitert, wird kein Speicherplatz reserviert.</span><span class="sxs-lookup"><span data-stu-id="99f26-558">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="99f26-559">Normalerweise kann diese Methode abgeschlossen werden, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-559">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="99f26-560">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="99f26-560">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="99f26-561">Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="99f26-561">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="99f26-562">Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="99f26-562">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-563">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-563">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="99f26-564">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-564">-or-</span>
          </span>
          <span data-ttu-id="99f26-565">
            <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-565">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="99f26-566">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-566">-or-</span>
          </span>
          <span data-ttu-id="99f26-567">
            <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-567">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-568">Mindestens ein Argument ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-568">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-569">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-569">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-570">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-570">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-571">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-571">-or-</span>
          </span>
          <span data-ttu-id="99f26-572">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-572">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-573">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-573">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-574">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-574">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-575">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-575">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-576">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-576">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-577">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-577">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <span data-ttu-id="99f26-578">Keine Reservierung, die groß genug für <paramref name="data" /> ist, kann in <paramref name="reservations" /> gefunden werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-578">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-579">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-579">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="userRecord">
          <span data-ttu-id="99f26-580">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-580">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="99f26-581">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-581">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="99f26-582">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-582">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="99f26-583">Die Reservierungsauflistung, in der Reservierungen vorgenommen werden können.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-583">The reservation collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="99f26-584">Die vorzunehmenden Reservierungen in Byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-584">The reservations to make, in bytes.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="99f26-585">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-585">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="99f26-586">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-586">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-587">Startet einen asynchronen Reservierungs- und Anfügevorgang.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-587">Begins an asynchronous reserve and append operation.</span>
          </span>
          <span data-ttu-id="99f26-588">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-588">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-589">Ein <see cref="T:System.IAsyncResult" />, das diesen asynchronen Vorgang darstellt, der möglicherweise noch aussteht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-589">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-590">Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-590">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="99f26-591">Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-591">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="99f26-592">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-592">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-593">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="99f26-593">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="99f26-594">Die angegebenen Reservierungen werden in einer atomaren Operation mit einem Vorgang zum Anfügen von Datensätzen der bereitgestellten Reservierungsauflistung hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="99f26-594">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="99f26-595">Wenn der Anfügevorgang scheitert, wird kein Speicherplatz reserviert.</span><span class="sxs-lookup"><span data-stu-id="99f26-595">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="99f26-596">Normalerweise kann diese Methode abgeschlossen werden, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-596">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="99f26-597">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="99f26-597">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="99f26-598">Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="99f26-598">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="99f26-599">Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="99f26-599">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-600">Mindestens eines der Argumente ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-600">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-601">Beim Anfügen des Datensatzes ist ein E/A-Fehler aufgetreten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-601">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-602">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten oder die Reservierung auszuführen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-602">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-603">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-603">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="99f26-604">Startet einen asynchronen Neustartbereichsschreibvorgang.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-604">Begins an asynchronous restart area write operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-605">Bytearraysegmente, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-605">Byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSeqNum">
          <span data-ttu-id="99f26-606">Die neue Basissequenznummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-606">The new base sequence number.</span>
          </span>
          <span data-ttu-id="99f26-607">Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-607">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservation">
          <span data-ttu-id="99f26-608">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Neustartbereich verwendet werden sollte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-608">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="99f26-609">Ein optionaler asynchroner Rückruf, der nach Abschluss des Neustartbereich-Schreibvorgangs aufgerufen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-609">An optional asynchronous callback, to be called when the restart area write is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="99f26-610">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Neustartbereichschreibanforderung von anderen Anforderungen unterscheidet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-610">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-611">Startet einen asynchronen Neustartbereich-Schreibvorgang, wobei der zuvor in der Sequenz reservierte Speicherplatz verwendet wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-611">Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span>
          </span>
          <span data-ttu-id="99f26-612">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-612">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-613">Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Neustartbereich-Schreibvorgang darstellt, der möglicherweise noch aussteht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-613">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-614">Sie sollten das von dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode weiterleiten, um sicherzustellen, dass der Neustartbereich-Schreibvorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-614">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="99f26-615">Wenn während eines asynchronen Neustartbereich-Schreibvorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-615">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="99f26-616">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-616">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-617">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="99f26-617">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="99f26-618">Wenn die Operation erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="99f26-618">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="99f26-619">Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-619">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="99f26-620">Wenn eine <xref:System.IO.Log.ReservationCollection> angegeben wird, nimmt der geschriebene Neustartbereich, der zuvor mithilfe einer in der Auflistung enthaltenen Reservierung reserviert wurde, Speicherplatz ein.</span><span class="sxs-lookup"><span data-stu-id="99f26-620">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="99f26-621">Wenn diese Methode erfolgreich ist, wird die kleinstmögliche Reservierung verwendet, die die Daten aufnehmen kann. Diese Reservierung wird dann aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="99f26-621">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="99f26-622">Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="99f26-622">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="99f26-623">Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="99f26-623">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-624">
            <paramref name="newBaseSeqNum" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-624">
              <paramref name="newBaseSeqNum" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="99f26-625">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-625">-or-</span>
          </span>
          <span data-ttu-id="99f26-626">Die angegebene Sequenznummer für den Protokollenumerationsstart ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-626">The specified log enumeration start sequence number is invalid.</span>
          </span>
          <span data-ttu-id="99f26-627">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-627">-or-</span>
          </span>
          <span data-ttu-id="99f26-628">
            <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-628">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="99f26-629">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-629">-or-</span>
          </span>
          <span data-ttu-id="99f26-630">
            <paramref name="reservation" /> wurde nicht von dieser Datensatzsequenz erstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-630">
              <paramref name="reservation" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-631">Ein oder mehrere Parameter haben den Wert <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-631">One or more of the parameters is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-632">Ein neues oder vorhandenes Archivende oder eine Basis des aktiven Protokolls ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-632">A new or existing archive tail or base of the active log is invalid.</span>
          </span>
          <span data-ttu-id="99f26-633">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-633">-or-</span>
          </span>
          <span data-ttu-id="99f26-634">
            <paramref name="newBaseSeqNum" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-634">
              <paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-635">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-635">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-636">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-636">-or-</span>
          </span>
          <span data-ttu-id="99f26-637">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-637">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-638">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-638">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-639">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-639">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-640">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-640">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-641">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-641">The record sequence is full.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservationCollection, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-642">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-642">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSeqNum">
          <span data-ttu-id="99f26-643">Die neue Basissequenznummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-643">The new base sequence number.</span>
          </span>
          <span data-ttu-id="99f26-644">Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-644">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="99f26-645">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Neustartbereich verwendet werden sollte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-645">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="99f26-646">Ein optionaler asynchroner Rückruf, der nach Abschluss des Neustartbereich-Schreibvorgangs aufgerufen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-646">An optional asynchronous callback, to be called when the restart area write is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="99f26-647">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Neustartbereichschreibanforderung von anderen Anforderungen unterscheidet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-647">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-648">Startet einen asynchronen Neustartbereich-Schreibvorgang, wobei der zuvor in der Sequenz reservierte Speicherplatz verwendet wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-648">Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span>
          </span>
          <span data-ttu-id="99f26-649">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-649">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-650">Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Neustartbereich-Schreibvorgang darstellt, der möglicherweise noch aussteht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-650">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-651">Sie sollten das von dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode weiterleiten, um sicherzustellen, dass der Neustartbereich-Schreibvorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-651">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="99f26-652">Wenn während eines asynchronen Neustartbereich-Schreibvorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-652">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="99f26-653">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-653">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-654">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="99f26-654">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="99f26-655">Wenn die Operation erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="99f26-655">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="99f26-656">Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-656">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="99f26-657">Wenn eine <xref:System.IO.Log.ReservationCollection> angegeben wird, nimmt der geschriebene Neustartbereich, der zuvor mithilfe einer in der Auflistung enthaltenen Reservierung reserviert wurde, Speicherplatz ein.</span><span class="sxs-lookup"><span data-stu-id="99f26-657">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="99f26-658">Wenn diese Methode erfolgreich ist, wird die kleinstmögliche Reservierung verwendet, die die Daten aufnehmen kann. Diese Reservierung wird dann aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="99f26-658">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="99f26-659">Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="99f26-659">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="99f26-660">Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>-Methode Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="99f26-660">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-661">
            <paramref name="newBaseSeqNum" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-661">
              <paramref name="newBaseSeqNum" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="99f26-662">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-662">-or-</span>
          </span>
          <span data-ttu-id="99f26-663">Die angegebene Sequenznummer für den Protokollenumerationsstart ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-663">The specified log enumeration start sequence number is invalid.</span>
          </span>
          <span data-ttu-id="99f26-664">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-664">-or-</span>
          </span>
          <span data-ttu-id="99f26-665">
            <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-665">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="99f26-666">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-666">-or-</span>
          </span>
          <span data-ttu-id="99f26-667">
            <paramref name="reservationCollection" /> wurde nicht von dieser Datensatzsequenz erstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-667">
              <paramref name="reservationCollection" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-668">Ein oder mehrere Parameter haben den Wert <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-668">One or more of the parameters is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-669">Ein neues oder vorhandenes Archivende oder eine Basis des aktiven Protokolls ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-669">A new or existing archive tail or base of the active log is invalid.</span>
          </span>
          <span data-ttu-id="99f26-670">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-670">-or-</span>
          </span>
          <span data-ttu-id="99f26-671">
            <paramref name="newBaseSeqNum" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-671">
              <paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-672">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-672">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-673">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-673">-or-</span>
          </span>
          <span data-ttu-id="99f26-674">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-674">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-675">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-675">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-676">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-676">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-677">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-677">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-678">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-678">The record sequence is full.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection&#xA;override this.CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="logRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="99f26-679">Erstellt einen neuen <see cref="T:System.IO.Log.ReservationCollection" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-679">Creates a new <see cref="T:System.IO.Log.ReservationCollection" />.</span>
          </span>
          <span data-ttu-id="99f26-680">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-680">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-681">Der neu erstellte <see cref="T:System.IO.Log.ReservationCollection" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-681">The newly created <see cref="T:System.IO.Log.ReservationCollection" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="99f26-682">Reservierungen können auf zwei Arten vorgenommen werden, wie in den nachstehenden Beispielen beschrieben.</span><span class="sxs-lookup"><span data-stu-id="99f26-682">Reservations can be performed in two ways as shown in the following examples.</span></span> <span data-ttu-id="99f26-683">Sie können die Vorgehensweise aus den Beispielen für stabile Verarbeitung übernehmen.</span><span class="sxs-lookup"><span data-stu-id="99f26-683">You can adopt the practices in the samples for robust processing.</span></span> <span data-ttu-id="99f26-684">Beachten Sie, dass diese Aufgabe nur bei Verwendung der CLFS-basierten <xref:System.IO.Log.LogRecordSequence>-Klasse ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="99f26-684">Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.</span></span>  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-685">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-685">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logRecordSequence.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="99f26-686">Gibt die von der Komponente verwendeten Ressourcen frei.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-686">Releases the resources used by the component.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="99f26-687">Dieses Beispiel zeigt, wie Sie mit <xref:System.IO.Log.LogRecordSequence.Dispose%2A> , um Ressourcen freizugeben:</span><span class="sxs-lookup"><span data-stu-id="99f26-687">This example shows how to use <xref:System.IO.Log.LogRecordSequence.Dispose%2A> to release resources:</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 [!code-csharp[S_UELogRecordSequence#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#12)] 
 [!code-vb[S_UELogRecordSequence#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#12)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-688">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-688">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-689">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-689">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="99f26-690">Ein Verweis auf die ausstehende asynchrone E/A-Anforderung.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-690">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-691">Beendet einen asynchronen Anfügevorgang.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-691">Ends an asynchronous append operation.</span>
          </span>
          <span data-ttu-id="99f26-692">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-692">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-693">Die Sequenznummer des angefügten Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-693">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-694">Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="99f26-694">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="99f26-695">Fehler, die während einer asynchronen Schreibanforderung auftreten, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, werden sichtbar, wenn <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-695">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="99f26-696">Diese Methode muss genau einmal für jedes <xref:System.IAsyncResult>, das von der <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>-Methode zurückgegeben wird, aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-696">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-697">
            <paramref name="result" /> ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-697">
              <paramref name="result" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-698">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-698">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-699">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-699">-or-</span>
          </span>
          <span data-ttu-id="99f26-700">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-700">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="99f26-701">
            <see langword="End" /> wurde bereits für diesen asynchronen Vorgang aufgerufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-701">
              <see langword="End" /> has already been called for this asynchronous operation.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-702">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-702">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-703">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-703">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-704">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-704">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-705">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-705">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-706">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-706">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="99f26-707">Ein Verweis auf die ausstehende asynchrone E/A-Anforderung.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-707">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-708">Beendet einen asynchronen Löschvorgang.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-708">Ends an asynchronous flush operation.</span>
          </span>
          <span data-ttu-id="99f26-709">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-709">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-710">Die Sequenznummer des letzten geschriebenen Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-710">The sequence number of the last record written.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-711">Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="99f26-711">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="99f26-712">Fehler, die während einer asynchronen Löschanforderung auftreten, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, werden sichtbar, wenn <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-712">Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> is called.</span></span>  
  
 <span data-ttu-id="99f26-713">Diese Methode muss genau einmal für jedes <xref:System.IAsyncResult>, das von der <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>-Methode zurückgegeben wird, aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-713">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-714">
            <paramref name="result" /> ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-714">
              <paramref name="result" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-715">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-715">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="99f26-716">
            <see langword="End" /> wurde bereits für diesen asynchronen Vorgang aufgerufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-716">
              <see langword="End" /> has already been called for this asynchronous operation.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-717">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-717">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-718">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-718">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-719">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-719">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-720">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-720">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-721">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-721">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="99f26-722">Ein Verweis auf die ausstehende asynchrone E/A-Anforderung.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-722">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-723">Beendet einen asynchronen Reservierungs- und Anfügevorgang.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-723">Ends an asynchronous reserve and append operation.</span>
          </span>
          <span data-ttu-id="99f26-724">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-724">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-725">Die Sequenznummer des angefügten Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-725">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-726">Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="99f26-726">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="99f26-727">Fehler, die während einer asynchronen Schreibanforderung auftreten, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, werden sichtbar, wenn <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-727">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="99f26-728">Diese Methode muss genau einmal für jedes <xref:System.IAsyncResult>, das von der <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>-Methode zurückgegeben wird, aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-728">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-729">
            <paramref name="result" /> ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-729">
              <paramref name="result" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-730">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-730">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-731">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-731">-or-</span>
          </span>
          <span data-ttu-id="99f26-732">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-732">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="99f26-733">
            <see langword="End" /> wurde bereits für diesen asynchronen Vorgang aufgerufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-733">
              <see langword="End" /> has already been called for this asynchronous operation.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-734">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-734">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-735">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-735">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-736">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-736">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-737">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-737">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-738">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-738">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="99f26-739">Ein Verweis auf die ausstehende asynchrone E/A-Anforderung.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-739">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-740">Beendet einen asynchronen Neustartbereichsschreibvorgang.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-740">Ends an asynchronous restart area write operation.</span>
          </span>
          <span data-ttu-id="99f26-741">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-741">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-742">Die Sequenznummer des geschriebenen Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-742">The sequence number of the written log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-743">Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="99f26-743">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="99f26-744">Fehler, die während einer asynchronen Schreibanforderung auftreten, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, werden sichtbar, wenn <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-744">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> is called.</span></span>  
  
 <span data-ttu-id="99f26-745">Diese Methode muss genau einmal für jedes <xref:System.IAsyncResult>, das von der <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>-Methode zurückgegeben wird, aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-745">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-746">
            <paramref name="result" /> ist nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-746">
              <paramref name="result" /> is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-747">Ein neues oder vorhandenes Archivende oder eine Basis des aktiven Protokolls ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-747">A new or existing archive tail or base of the active log is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-748">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-748">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="99f26-749">
            <see langword="End" /> wurde bereits für diesen asynchronen Vorgang aufgerufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-749">
              <see langword="End" /> has already been called for this asynchronous operation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-750">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-750">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-751">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-751">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-752">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-752">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-753">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-753">The record sequence is full.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="99f26-754">Schreibt angefügte Datensätze dauerhaft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-754">Writes appended records durably</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="99f26-755">Stellt sicher, dass alle angefügten Datensätze geschrieben wurden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-755">Ensures that all appended records have been written.</span>
          </span>
          <span data-ttu-id="99f26-756">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-756">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-757">Die Sequenznummer des letzten geschriebenen Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-757">The sequence number of the last record written.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-758">Durch das Aufrufen dieser Methode wird sichergestellt, dass alle Datensätze, die der <xref:System.IO.Log.LogRecordSequence> angefügt wurden, dauerhaft geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="99f26-758">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.LogRecordSequence> have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-759">Beim Löschen der Daten ist ein E/A-Fehler aufgetreten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-759">An I/O error occurred while flushing the data.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-760">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-760">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-761">Diese Operation wird nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-761">This operation is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-762">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-762">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-763">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-763">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-764">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-764">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="99f26-765">Das angegebene Protokoll verfügt nicht über Wertebereiche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-765">The specified log does not have any extents.</span>
          </span>
          <span data-ttu-id="99f26-766">Ein oder mehrere Wertebereiche müssen erstellt werden, bevor eine Datensatzsequenz verwendet werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-766">One or more extents must be created before a record sequence can be used.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">
          <span data-ttu-id="99f26-767">Die Sequenznummer des letzten Datensatzes, der geschrieben werden muss.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-767">The sequence number of the latest record that must be written.</span>
          </span>
          <span data-ttu-id="99f26-768">Wenn diese <see cref="T:System.IO.Log.SequenceNumber" /> ungültig ist, müssen alle Datensätze geschrieben werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-768">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-769">Gewährleistet, dass alle angehängten Datensätze bis zum Datensatz mit der angegebenen Sequenznummer dauerhaft geschrieben wurden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-769">Ensures that all appended records up to and including the record with the specified sequence number have been durably written.</span>
          </span>
          <span data-ttu-id="99f26-770">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-770">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-771">Die Sequenznummer des letzten geschriebenen Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-771">The sequence number of the last record written.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-772">Durch das Aufrufen diese Methode wird sichergestellt, dass alle Datensätze mit Sequenznummern bis zu der angegebenen Sequenznummer dauerhaft geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="99f26-772">Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-773">
            <paramref name="sequenceNumber" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-773">
              <paramref name="sequenceNumber" /> is not valid for this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-774">
            <paramref name="sequenceNumber" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-774">
              <paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-775">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-775">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="99f26-776">Das angegebene Protokoll verfügt nicht über Wertebereiche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-776">The specified log does not have any extents.</span>
          </span>
          <span data-ttu-id="99f26-777">Ein oder mehrere Wertebereiche müssen erstellt werden, bevor eine Datensatzsequenz verwendet werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-777">One or more extents must be created before a record sequence can be used.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-778">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-778">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-779">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-779">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-780">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-780">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-781">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-781">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-782">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-782">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="99f26-783">Eine Sequenznummer, die größer ist als der letzte angefügte Datensatz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-783">Gets the sequence number which is greater than the last record appended</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="99f26-784">Eine Sequenznummer, die größer ist als der letzte angefügte Datensatz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-784">A sequence number which is greater than the last record appended.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-785">Diese Eigenschaft enthält eine Sequenznummer, die in jedem Fall größer ist als die Sequenznummer des letzten angefügten Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="99f26-785">This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</span></span> <span data-ttu-id="99f26-786">Gültige Sequenznummern sind größer oder gleich <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> und kleiner als <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</span><span class="sxs-lookup"><span data-stu-id="99f26-786">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</span></span> <span data-ttu-id="99f26-787">Alle anderen Sequenznummern sind ungültig.</span><span class="sxs-lookup"><span data-stu-id="99f26-787">All other sequence numbers are invalid.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-788">Auf die Eigenschaft wurde zugegriffen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-788">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LogStore">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogStore LogStore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogStore LogStore" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LogStore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogStore As LogStore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogStore ^ LogStore { System::IO::Log::LogStore ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogStore : System.IO.Log.LogStore" Usage="System.IO.Log.LogRecordSequence.LogStore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="99f26-789">Ruft den <see cref="T:System.IO.Log.LogStore" /> ab, der die Daten für diese Datensatzsequenz enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-789">Gets the <see cref="T:System.IO.Log.LogStore" /> that contains the data for this record sequence.</span>
          </span>
          <span data-ttu-id="99f26-790">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-790">This method cannot be inherited.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="99f26-791">Der <see cref="T:System.IO.Log.LogStore" />, der die Daten für diese Datensatzsequenz enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-791">The <see cref="T:System.IO.Log.LogStore" /> that contains the data for this record sequence.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="99f26-792">In diesem Beispiel wird die Verwendung des <xref:System.IO.Log.LogRecordSequence.LogStore%2A>-Members zum Hinzufügen von Wertebereichen veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="99f26-792">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.LogStore%2A> member to add extents.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="99f26-793">Ruft die maximale Größe eines Datensatzes ab, der dieser Datensatzsequenz hinzugefügt werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-793">Gets the maximum size of a record that can be added to this record sequence.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="99f26-794">Die maximale Größe eines Datensatzes, der dieser Datensatzsequenz hinzugefügt werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-794">The maximum size of a record that can be added to this record sequence.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="99f26-795">Die Sequenznummer des ersten Datensatzes, bei dem mit dem Lesen begonnen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-795">The sequence number of the first record where the reading starts.</span>
          </span>
        </param>
        <param name="logRecordEnum">
          <span data-ttu-id="99f26-796">Ein gültiger <see cref="T:System.IO.Log.LogRecordEnumeratorType" />-Wert, der die Art (vorwärts oder rückwärts) angibt, in der Datensätze aus einer <see cref="T:System.IO.Log.LogRecordSequence" /> gelesen werden sollten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-796">A valid <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> value that specifies the manner (that is, forward or backward) in which records should be read from a <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-797">Gibt eine zählbare Auflistung von Datensätzen in der Sequenz zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-797">Returns an enumerable collection of records in the sequence.</span>
          </span>
          <span data-ttu-id="99f26-798">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-798">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-799">Eine zählbare Auflistung von Datensätzen in der Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-799">An enumerable collection of records in the sequence.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-800">Diese Methode gibt eine aufzählbare Auflistung von Datensätzen in der Sequenz zurück.</span><span class="sxs-lookup"><span data-stu-id="99f26-800">This method returns an enumerable collection of records in the sequence.</span></span> <span data-ttu-id="99f26-801">Die Reihenfolge der aufgelisteten Datensätze hängt vom Wert des `logRecordEnum`-Parameters ab.</span><span class="sxs-lookup"><span data-stu-id="99f26-801">The order of the enumerated records depends on the value of the `logRecordEnum` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99f26-802">In diesem Beispiel wird die Verwendung von <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A> in einer Schleife veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="99f26-802">This example shows how to use <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A> in a loop.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-803">
            <paramref name="start" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-803">
              <paramref name="start" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="99f26-804">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-804">-or-</span>
          </span>
          <span data-ttu-id="99f26-805">
            <paramref name="logRecordEnum" /> ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-805">
              <paramref name="logRecordEnum" /> is invalid.</span>
          </span>
          <span data-ttu-id="99f26-806">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-806">-or-</span>
          </span>
          <span data-ttu-id="99f26-807">Das angegebene Element wurde nicht in der Auflistung gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-807">The specified element was not found in the collection.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-808">
            <paramref name="start" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-808">
              <paramref name="start" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-809">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-809">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-810">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-810">-or-</span>
          </span>
          <span data-ttu-id="99f26-811">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-811">The request could not be performed because of an I/O device error.</span>
          </span>
          <span data-ttu-id="99f26-812">– oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-812">-or</span>
          </span>
          <span data-ttu-id="99f26-813">Die zum Schreiben des Protokolldatensatzes verwendete Puffergröße ist größer als die zum Lesen verwendete Puffergröße.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-813">The buffer size used to write the log record is larger than the buffer size being used to read it.</span>
          </span>
          <span data-ttu-id="99f26-814">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-814">-or-</span>
          </span>
          <span data-ttu-id="99f26-815">Die Datensatzsequenz ist beschädigt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-815">The record sequence is corrupted.</span>
          </span>
          <span data-ttu-id="99f26-816">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-816">-or-</span>
          </span>
          <span data-ttu-id="99f26-817">Das angegebene Protokolldateiformat oder die Version ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-817">The specified log file format or version is invalid.</span>
          </span>
          <span data-ttu-id="99f26-818">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-818">-or-</span>
          </span>
          <span data-ttu-id="99f26-819">Der Datensatz wurde mit einer inkompatiblen Version der Datensatzsequenz geschrieben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-819">The record was written with an incompatible version of the record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="99f26-820">Der Vorgang ist ungültig, da die Enumeration nicht gestartet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-820">The operation is invalid because the enumeration has not been started.</span>
          </span>
          <span data-ttu-id="99f26-821">Ein Aufruf von <see cref="M:System.Collections.IEnumerator.MoveNext" /> muss erfolgen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-821">A call to <see cref="M:System.Collections.IEnumerator.MoveNext" /> must be made.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-822">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-822">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-823">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-823">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-824">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-824">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="99f26-825">Gibt eine zählbare Auflistung der Neustartbereiche in der Sequenz zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-825">Returns an enumerable collection of the restart areas in the sequence.</span>
          </span>
          <span data-ttu-id="99f26-826">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-826">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-827">Eine zählbare Auflistung der Neustartbereiche in der Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-827">An enumerable collection of the restart areas in the sequence.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-828">Die Neustartbereiche sind in umgekehrter Reihenfolge der Sequenznummern aufgelistet, von der höchsten bis zur niedrigsten Sequenznummer.</span><span class="sxs-lookup"><span data-stu-id="99f26-828">The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number.</span></span> <span data-ttu-id="99f26-829">Nur Neustartbereiche mit Sequenznummern zwischen der letzten Sequenznummer und der Basissequenznummer sind aufgelistet.</span><span class="sxs-lookup"><span data-stu-id="99f26-829">Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-830">
            <paramref name="start" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-830">
              <paramref name="start" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-831">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-831">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-832">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-832">-or-</span>
          </span>
          <span data-ttu-id="99f26-833">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-833">The request could not be performed because of an I/O device error.</span>
          </span>
          <span data-ttu-id="99f26-834">– oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-834">-or</span>
          </span>
          <span data-ttu-id="99f26-835">Die zum Schreiben des Protokolldatensatzes verwendete Puffergröße ist größer als die zum Lesen verwendete Puffergröße.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-835">The buffer size used to write the log record is larger than the buffer size being used to read it.</span>
          </span>
          <span data-ttu-id="99f26-836">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-836">-or-</span>
          </span>
          <span data-ttu-id="99f26-837">Die Datensatzsequenz ist beschädigt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-837">The record sequence is corrupted.</span>
          </span>
          <span data-ttu-id="99f26-838">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-838">-or-</span>
          </span>
          <span data-ttu-id="99f26-839">Das angegebene Protokolldateiformat oder die Version ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-839">The specified log file format or version is invalid.</span>
          </span>
          <span data-ttu-id="99f26-840">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-840">-or-</span>
          </span>
          <span data-ttu-id="99f26-841">Der Datensatz wurde mit einer inkompatiblen Version der Datensatzsequenz geschrieben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-841">The record was written with an incompatible version of the record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="99f26-842">Der Vorgang ist ungültig, da die Enumeration nicht gestartet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-842">The operation is invalid because the enumeration has not been started.</span>
          </span>
          <span data-ttu-id="99f26-843">Ein Aufruf von <see cref="M:System.Collections.IEnumerator.MoveNext" /> muss erfolgen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-843">A call to <see cref="M:System.Collections.IEnumerator.MoveNext" /> must be made.</span>
          </span>
          <span data-ttu-id="99f26-844">– oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-844">-or</span>
          </span>
          <span data-ttu-id="99f26-845">Die Enumeration wurde beendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-845">The enumeration has ended.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-846">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-846">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-847">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-847">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-848">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-848">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="99f26-849">Führt automatisch eine einzelne Reservierung durch und fügt der Sequenz einen Datensatz an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-849">Automatically makes a single reservation and appends a record to the sequence.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-850">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-850">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="99f26-851">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-851">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="99f26-852">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-852">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="99f26-853">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-853">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="99f26-854">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Auflistung enthält, in der Reservierungen vorgenommen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-854">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="99f26-855">Die vorzunehmenden Reservierungen in Byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-855">The reservations to make, in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-856">Führt automatisch eine einzelne Reservierung durch und fügt der Sequenz einen Datensatz an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-856">Automatically makes a single reservation and appends a record to the sequence.</span>
          </span>
          <span data-ttu-id="99f26-857">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-857">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-858">Die Sequenznummer des angefügten Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-858">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-859">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-859">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-860">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="99f26-860">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="99f26-861">Die angegebenen Reservierungen werden in einer atomaren Operation mit einem Vorgang zum Anfügen von Datensätzen der bereitgestellten Reservierungsauflistung hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="99f26-861">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="99f26-862">Wenn der Anfügevorgang scheitert, wird kein Speicherplatz reserviert.</span><span class="sxs-lookup"><span data-stu-id="99f26-862">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="99f26-863">Normalerweise kann diese Methode abgeschlossen werden, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-863">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="99f26-864">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="99f26-864">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99f26-865">Im folgenden Beispiel wird veranschaulicht, wie Sie mit dieser Methode Reservierungen vornehmen.</span><span class="sxs-lookup"><span data-stu-id="99f26-865">The following example shows how to use this method to make reservations.</span></span> <span data-ttu-id="99f26-866">Beachten Sie, dass diese Aufgabe nur bei Verwendung der CLFS-basierten <xref:System.IO.Log.LogRecordSequence>-Klasse ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="99f26-866">Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.</span></span>  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-867">
            <paramref name="nextUndoRecord" /> oder <paramref name="previousRecord" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-867">
              <paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="99f26-868">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-868">-or-</span>
          </span>
          <span data-ttu-id="99f26-869">
            <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-869">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="99f26-870">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-870">-or-</span>
          </span>
          <span data-ttu-id="99f26-871">
            <paramref name="reservations" /> wurde nicht von dieser Datensatzsequenz erstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-871">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-872">Mindestens ein Argument ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-872">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-873">
            <paramref name="nextUndoRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-873">
              <paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-874">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-874">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-875">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-875">-or-</span>
          </span>
          <span data-ttu-id="99f26-876">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-876">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-877">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-877">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-878">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-878">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-879">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-879">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-880">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-880">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-881">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-881">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <span data-ttu-id="99f26-882">Keine Reservierung, die groß genug für <paramref name="data" /> ist, kann in <paramref name="reservations" /> gefunden werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-882">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-883">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-883">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="userRecord">
          <span data-ttu-id="99f26-884">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-884">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="99f26-885">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-885">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="99f26-886">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-886">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="99f26-887">Die Reservierungsauflistung, in der Reservierungen vorgenommen werden können.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-887">The reservation collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="99f26-888">Die vorzunehmenden Reservierungen in Byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-888">The reservations to make, in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-889">Führt automatisch eine einzelne Reservierung durch und fügt der Sequenz einen Datensatz an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-889">Automatically makes a single reservation and appends a record to the sequence.</span>
          </span>
          <span data-ttu-id="99f26-890">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-890">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-891">Die Sequenznummer des angefügten Datensatzes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-891">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-892">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-892">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-893">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="99f26-893">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="99f26-894">Die angegebenen Reservierungen werden in einer atomaren Operation mit einem Vorgang zum Anfügen von Datensätzen der bereitgestellten Reservierungsauflistung hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="99f26-894">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="99f26-895">Wenn der Anfügevorgang scheitert, wird kein Speicherplatz reserviert.</span><span class="sxs-lookup"><span data-stu-id="99f26-895">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="99f26-896">Normalerweise kann diese Methode abgeschlossen werden, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-896">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="99f26-897">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.LogRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="99f26-897">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-898">Mindestens eines der Argumente ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-898">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-899">Beim Anfügen des Datensatzes ist ein E/A-Fehler aufgetreten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-899">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-900">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten oder die Reservierung auszuführen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-900">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-901">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-901">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-902">Mindestens ein Argument ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-902">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-903">
            <paramref name="userRecord" /> oder <paramref name="previousRecord" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-903">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="99f26-904">Der Vorgang kann nicht ausgeführt werden, da die Datensatzsequenz mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-904">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-905">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-905">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-906">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-906">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <span data-ttu-id="99f26-907">Keine Reservierung, die groß genug für <paramref name="data" /> ist, kann in <paramref name="reservations" /> gefunden werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-907">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="99f26-908">Ruft die Gesamtanzahl von Byte ab, die reserviert wurden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-908">Gets the total number of bytes that have been reserved.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="99f26-909">Die Gesamtgröße aller in dieser Datensatzsequenz vorgenommenen Reservierungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-909">The total size of all reservations made in this record sequence.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-910">Auf die Eigenschaft wurde zugegriffen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-910">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="99f26-911">Ruft die Sequenznummer des Neustartbereichs ab, die am nächsten am Protokollende liegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-911">Gets the sequence number of the restart area closest to the end of the log.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="99f26-912">Die Sequenznummer des Neustartbereichs, die am nächsten am Protokollende liegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-912">The sequence number of the restart area closest to the end of the log.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-913">Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern.</span><span class="sxs-lookup"><span data-stu-id="99f26-913">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="99f26-914">Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="99f26-914">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="99f26-915">Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation.</span><span class="sxs-lookup"><span data-stu-id="99f26-915">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="99f26-916">Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-916">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="99f26-917">Mit der <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>-Methode können Sie den zuletzt geschriebenen Neustartbereich entfernen.</span><span class="sxs-lookup"><span data-stu-id="99f26-917">Using the <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A> method, you can remove the most recently written restart area.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-918">Auf die Eigenschaft wurde zugegriffen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-918">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="99f26-919">Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob Anfügevorgänge automatisch wiederholt werden, wenn das Protokoll voll ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-919">Gets or sets a value indicating whether or not appends are automatically retried if the log is full.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="99f26-920">
            <see langword="true" />, wenn Anfügevorgänge automatisch wiederholt werden, wenn das Protokoll voll ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-920">
              <see langword="true" /> if appends are automatically retried if the log is full; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="99f26-921">Der Standardwert ist <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-921">The default is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-922">Wenn der Wert der Eigenschaft `true` lautet und ein <xref:System.IO.Log.LogRecordSequence.Append%2A>-Abruf fehlschlägt, da die Sequenz nicht genügend Speicherplatz aufweist, versucht die Datensatzsequenz, Speicherplatz freizugeben und den Anfügevorgang zu wiederholen.</span><span class="sxs-lookup"><span data-stu-id="99f26-922">If the value of this property is `true`, and an <xref:System.IO.Log.LogRecordSequence.Append%2A> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99f26-923">In diesem Beispiel wird die Verwendung der <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A>-Eigenschaft veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="99f26-923">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A> property.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#3)]
 [!code-vb[S_UELogRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-924">Auf die Eigenschaft wurde zugegriffen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-924">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetLastRecord">
      <MemberSignature Language="C#" Value="public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLastRecord(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLastRecord(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="member this.SetLastRecord : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.SetLastRecord sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">
          <span data-ttu-id="99f26-925">Die neue letzte Sequenznummer für die <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-925">The new last sequence number in the <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
          <span data-ttu-id="99f26-926">Dies sollte auf einen aktuellen gültigen Datensatz verweisen, der sich zurzeit im Protokoll befindet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-926">This should refer to a current valid record   currently in the log.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-927">Legt den letzten Datensatz in der <see cref="T:System.IO.Log.LogRecordSequence" /> fest.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-927">Sets the last record in the <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-928">Die angegebene Sequenznummer muss größer sein als die Basissequenznummer.</span><span class="sxs-lookup"><span data-stu-id="99f26-928">The specified sequence number must be larger than the base sequence number.</span></span>  
  
 <span data-ttu-id="99f26-929">Wenn diese Methode abgeschlossen ist, ist der Zugriff auf Datensätze, die zuvor mit Sequenznummern angehängt wurden, die größer sind als die angegebene Sequenznummer, nicht mehr möglich.</span><span class="sxs-lookup"><span data-stu-id="99f26-929">When this method completes, all records that had previously been appended with sequence numbers greater than the specified sequence number are inaccessible.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-930">
            <paramref name="sequenceNumber" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-930">
              <paramref name="sequenceNumber" /> is not valid for this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-931">Ein neues oder vorhandenes Archivende oder eine Basis des aktiven Protokolls ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-931">A new or existing archive tail or base of the active log is invalid.</span>
          </span>
          <span data-ttu-id="99f26-932">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-932">-or-</span>
          </span>
          <span data-ttu-id="99f26-933">
            <paramref name="sequenceNumber" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-933">
              <paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-934">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-934">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-935">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-935">-or-</span>
          </span>
          <span data-ttu-id="99f26-936">Das Ende des Protokolls wurde erreicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-936">The end of the log has been reached.</span>
          </span>
          <span data-ttu-id="99f26-937">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-937">-or-</span>
          </span>
          <span data-ttu-id="99f26-938">Das angegebene Protokolldateiformat oder die Version ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-938">The specified log file format or version is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-939">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-939">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-940">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-940">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-941">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-941">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.LogRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="99f26-942">Signalisiert das Erfordernis, das Ende der Sequenz zu verschieben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-942">Signals the need to move the tail of the sequence.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-943">Sie können dieses Ereignis auslösen, wenn der Datensatzsequenz Speicherplatz ausgegangen ist.</span><span class="sxs-lookup"><span data-stu-id="99f26-943">You can fire this event when the record sequence has run out of space.</span></span> <span data-ttu-id="99f26-944">Wenn dieses Ereignis ausgelöst wird, wird das Ende der Sequenz (die Basissequenznummer) nach vorn verschoben, um Speicherplatz freizugeben.</span><span class="sxs-lookup"><span data-stu-id="99f26-944">When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.</span></span>  
  
 <span data-ttu-id="99f26-945">Das Ereignis kann jederzeit ausgelöst werden, wenn die Datensatzsequenz aus einem beliebigen Grund Speicherplatz freigeben muss.</span><span class="sxs-lookup"><span data-stu-id="99f26-945">The event can be fired at any time when the record sequence decides that it must free up space, for any reason.</span></span> <span data-ttu-id="99f26-946">So kann die CLFS-Richtlinien-Engine beispielsweise entscheiden, das Ereignis auszulösen, wenn sie feststellt, dass die Enden von zwei Anmeldeclients, die sich eine Protokolldatei teilen, zu weit auseinander liegen.</span><span class="sxs-lookup"><span data-stu-id="99f26-946">For example, the CLFS policy engine may decide to fire the event when it determines that the tails of two log clients sharing the same log file are too far apart.</span></span> <span data-ttu-id="99f26-947">Die Freigabe von Speicherplatz kann durch Schreiben von Neustartbereichen oder durch Abschneiden des Protokolls und Freigeben von Speicherplatz mit der <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>-Methode erfolgen.</span><span class="sxs-lookup"><span data-stu-id="99f26-947">Freeing space can be done by either writing restart areas, or truncating the log and using the <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method to clear space.</span></span> <span data-ttu-id="99f26-948">Im Codebeispiel im Abschnitt mit dem Beispiel wird der zweite Ansatz veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="99f26-948">The code sample in the Example section demonstrates the second approach.</span></span>  
  
 <span data-ttu-id="99f26-949">Sie können auch die <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>-Methode außerhalb des <xref:System.IO.Log.LogRecordSequence.TailPinned>-Ereignisses aufrufen, um Speicherplatz freizugeben.</span><span class="sxs-lookup"><span data-stu-id="99f26-949">You can also call the <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> method outside of the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free space.</span></span> <span data-ttu-id="99f26-950">Ein Neustartbereich ist mit einem Prüfpunkt anderer Protokollverarbeitungssysteme vergleichbar.</span><span class="sxs-lookup"><span data-stu-id="99f26-950">A restart area is similar to a checkpoint in other log processing systems.</span></span> <span data-ttu-id="99f26-951">Beim Aufruf dieser Methode betrachtet die Anwendung alle vorherigen Datensätze vor dem Neustartbereich als abgeschlossen und für spätere Datensatzanhängevorgänge verfügbar.</span><span class="sxs-lookup"><span data-stu-id="99f26-951">Calling this method indicates that the application considers all prior records before the restart area as fully completed, and usable for future record appends.</span></span> <span data-ttu-id="99f26-952">Ähnlich wie andere Datensätze erfordert der mit dieser Methode geschriebene Datensatz tatsächlich freien Speicherplatz im Protokoll, um funktionieren zu können.</span><span class="sxs-lookup"><span data-stu-id="99f26-952">Similar to any other records, the record written by this method requires actual free space in the log to function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99f26-953">In diesem Beispiel wird die Verwendung des <xref:System.IO.Log.LogRecordSequence.TailPinned>-Ereignisses veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="99f26-953">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.TailPinned> event.</span></span>  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="99f26-954">Schreibt einen Neustartbereich in die <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-954">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-955">Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern.</span><span class="sxs-lookup"><span data-stu-id="99f26-955">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="99f26-956">Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="99f26-956">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="99f26-957">Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation.</span><span class="sxs-lookup"><span data-stu-id="99f26-957">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="99f26-958">Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-958">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="99f26-959">Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-959">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-960">Ein Arraysegment, das verkettet und als Datensatz angefügt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-960">An array segment that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-961">Schreibt einen Neustartbereich in die <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-961">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
          <span data-ttu-id="99f26-962">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-962">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-963">Die Sequenznummer des geschriebenen Neustartbereichs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-963">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-964">Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern.</span><span class="sxs-lookup"><span data-stu-id="99f26-964">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="99f26-965">Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="99f26-965">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="99f26-966">Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation.</span><span class="sxs-lookup"><span data-stu-id="99f26-966">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="99f26-967">Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-967">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="99f26-968">Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-968">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="99f26-969">Die im Bytearraysegment enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-969">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-970">Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-970">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-971">Mindestens eines der Argumente ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-971">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-972">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-972">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-973">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-973">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-974">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-974">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-975">Mindestens ein Argument ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-975">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-976">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-976">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-977">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-977">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-978">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-978">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-979">Schreibt einen Neustartbereich in die <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-979">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
          <span data-ttu-id="99f26-980">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-980">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-981">Die Sequenznummer des geschriebenen Neustartbereichs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-981">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-982">Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern.</span><span class="sxs-lookup"><span data-stu-id="99f26-982">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="99f26-983">Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="99f26-983">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="99f26-984">Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation.</span><span class="sxs-lookup"><span data-stu-id="99f26-984">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="99f26-985">Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-985">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="99f26-986">Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-986">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="99f26-987">Die im Bytearraysegment enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-987">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-988">Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-988">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-989">Mindestens eines der Argumente ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-989">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-990">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-990">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-991">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-991">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-992">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-992">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-993">Mindestens ein Argument ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-993">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-994">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-994">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-995">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-995">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-996">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-996">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSeqNum">
          <span data-ttu-id="99f26-997">Die neue Basissequenznummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-997">The new base sequence number.</span>
          </span>
          <span data-ttu-id="99f26-998">Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-998">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-999">Schreibt einen Neustartbereich in die <see cref="T:System.IO.Log.LogRecordSequence" /> und aktualisiert die Basissequenznummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-999">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> and updates the base sequence number.</span>
          </span>
          <span data-ttu-id="99f26-1000">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1000">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-1001">Die Sequenznummer des geschriebenen Neustartbereichs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1001">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-1002">Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern.</span><span class="sxs-lookup"><span data-stu-id="99f26-1002">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="99f26-1003">Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="99f26-1003">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="99f26-1004">Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation.</span><span class="sxs-lookup"><span data-stu-id="99f26-1004">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="99f26-1005">Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-1005">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="99f26-1006">Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-1006">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="99f26-1007">Wenn ein Neustartbereich geschrieben wird, werden die im Bytearraysegment enthaltenen Daten zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-1007">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-1008">Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-1008">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="99f26-1009">Wenn diese Methode erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="99f26-1009">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="99f26-1010">Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-1010">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="99f26-1011">Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="99f26-1011">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="99f26-1012">Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="99f26-1012">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-1013">Mindestens eines der Argumente ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1013">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-1014">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1014">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-1015">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1015">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-1016">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1016">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-1017">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1017">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSeqNum">
          <span data-ttu-id="99f26-1018">Die neue Basissequenznummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1018">The new base sequence number.</span>
          </span>
          <span data-ttu-id="99f26-1019">Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1019">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-1020">Schreibt einen Neustartbereich in die <see cref="T:System.IO.Log.LogRecordSequence" /> und aktualisiert die Basissequenznummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1020">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> and updates the base sequence number.</span>
          </span>
          <span data-ttu-id="99f26-1021">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1021">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-1022">Die Sequenznummer des geschriebenen Neustartbereichs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1022">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-1023">Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern.</span><span class="sxs-lookup"><span data-stu-id="99f26-1023">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="99f26-1024">Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="99f26-1024">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="99f26-1025">Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation.</span><span class="sxs-lookup"><span data-stu-id="99f26-1025">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="99f26-1026">Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-1026">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="99f26-1027">Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-1027">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="99f26-1028">Wenn ein Neustartbereich geschrieben wird, werden die im Bytearraysegment enthaltenen Daten zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-1028">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-1029">Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-1029">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="99f26-1030">Wenn diese Methode erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="99f26-1030">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="99f26-1031">Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-1031">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="99f26-1032">Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="99f26-1032">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="99f26-1033">Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="99f26-1033">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-1034">Mindestens eines der Argumente ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1034">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-1035">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1035">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-1036">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1036">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-1037">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1037">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-1038">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1038">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSeqNum">
          <span data-ttu-id="99f26-1039">Die neue Basissequenznummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1039">The new base sequence number.</span>
          </span>
          <span data-ttu-id="99f26-1040">Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1040">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="99f26-1041">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Neustartbereich verwendet werden sollte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1041">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-1042">Schreibt unter Verwendung einer Reservierung einen Neustartbereich in die <see cref="T:System.IO.Log.LogRecordSequence" /> und aktualisiert die Basissequenznummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1042">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> using a reservation, and updates the base sequence number.</span>
          </span>
          <span data-ttu-id="99f26-1043">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1043">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-1044">Die Sequenznummer des geschriebenen Neustartbereichs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1044">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-1045">Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern.</span><span class="sxs-lookup"><span data-stu-id="99f26-1045">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="99f26-1046">Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="99f26-1046">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="99f26-1047">Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation.</span><span class="sxs-lookup"><span data-stu-id="99f26-1047">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="99f26-1048">Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-1048">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="99f26-1049">Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-1049">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="99f26-1050">Wenn ein Neustartbereich geschrieben wird, werden die im Bytearraysegment enthaltenen Daten zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-1050">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-1051">Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-1051">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="99f26-1052">Wenn eine Reservierung angegeben wird, nimmt der geschriebene Neustartbereich, der zuvor mithilfe einer in der Auflistung enthaltenen Reservierung reserviert wurde, Speicherplatz ein.</span><span class="sxs-lookup"><span data-stu-id="99f26-1052">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="99f26-1053">Wenn diese Methode erfolgreich ist, wird die kleinstmögliche Reservierung verwendet, die die Daten aufnehmen kann. Diese Reservierung wird dann aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="99f26-1053">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="99f26-1054">Wenn diese Methode erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="99f26-1054">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="99f26-1055">Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-1055">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="99f26-1056">Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="99f26-1056">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="99f26-1057">Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="99f26-1057">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-1058">Mindestens eines der Argumente ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1058">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-1059">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1059">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-1060">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1060">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-1061">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1061">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservationCollection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="99f26-1062">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1062">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSeqNum">
          <span data-ttu-id="99f26-1063">Die neue Basissequenznummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1063">The new base sequence number.</span>
          </span>
          <span data-ttu-id="99f26-1064">Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1064">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="99f26-1065">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Neustartbereich verwendet werden sollte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1065">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="99f26-1066">Schreibt unter Verwendung einer Reservierung einen Neustartbereich in die <see cref="T:System.IO.Log.LogRecordSequence" /> und aktualisiert die Basissequenznummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1066">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> using a reservation, and updates the base sequence number.</span>
          </span>
          <span data-ttu-id="99f26-1067">Diese Methode kann nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1067">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="99f26-1068">Die Sequenznummer des geschriebenen Neustartbereichs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1068">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99f26-1069">Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern.</span><span class="sxs-lookup"><span data-stu-id="99f26-1069">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="99f26-1070">Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="99f26-1070">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="99f26-1071">Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation.</span><span class="sxs-lookup"><span data-stu-id="99f26-1071">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="99f26-1072">Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="99f26-1072">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="99f26-1073">Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-1073">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="99f26-1074">Wenn ein Neustartbereich geschrieben wird, werden die im Bytearraysegment enthaltenen Daten zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="99f26-1074">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="99f26-1075">Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="99f26-1075">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="99f26-1076">Wenn eine Reservierung angegeben wird, nimmt der geschriebene Neustartbereich, der zuvor mithilfe einer in der Auflistung enthaltenen Reservierung reserviert wurde, Speicherplatz ein.</span><span class="sxs-lookup"><span data-stu-id="99f26-1076">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="99f26-1077">Wenn diese Methode erfolgreich ist, wird die kleinstmögliche Reservierung verwendet, die die Daten aufnehmen kann. Diese Reservierung wird dann aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="99f26-1077">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="99f26-1078">Wenn diese Methode erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="99f26-1078">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="99f26-1079">Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="99f26-1079">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="99f26-1080">Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="99f26-1080">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="99f26-1081">Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="99f26-1081">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="99f26-1082">
            <paramref name="newBaseSeqNum" /> ist für diese Sequenz nicht gültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1082">
              <paramref name="newBaseSeqNum" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="99f26-1083">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1083">-or-</span>
          </span>
          <span data-ttu-id="99f26-1084">Die angegebene Sequenznummer für den Protokollenumerationsstart ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1084">The specified log enumeration start sequence number is invalid.</span>
          </span>
          <span data-ttu-id="99f26-1085">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1085">-or-</span>
          </span>
          <span data-ttu-id="99f26-1086">
            <paramref name="data" /> kann nicht angefügt werden, da die maximale Datensatzgröße überschritten wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1086">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="99f26-1087">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1087">-or-</span>
          </span>
          <span data-ttu-id="99f26-1088">
            <paramref name="reservationCollection" /> wurde nicht von dieser Datensatzsequenz erstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1088">
              <paramref name="reservationCollection" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="99f26-1089">Ein oder mehrere Parameter haben den Wert <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1089">One or more of the parameters is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="99f26-1090">Ein neues oder vorhandenes Archivende oder eine Basis des aktiven Protokolls ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1090">A new or existing archive tail or base of the active log is invalid.</span>
          </span>
          <span data-ttu-id="99f26-1091">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1091">-or-</span>
          </span>
          <span data-ttu-id="99f26-1092">
            <paramref name="newBaseSeqNum" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1092">
              <paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="99f26-1093">Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1093">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="99f26-1094">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1094">-or-</span>
          </span>
          <span data-ttu-id="99f26-1095">Die Anforderung konnte aufgrund eines E/A-Gerätefehlers nicht ausgeführt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1095">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="99f26-1096">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1096">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="99f26-1097">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1097">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="99f26-1098">Der Zugriff auf die angegebene Protokollsequenz wird vom Betriebssystem verweigert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1098">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="99f26-1099">Die Datensatzsequenz ist voll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="99f26-1099">The record sequence is full.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>