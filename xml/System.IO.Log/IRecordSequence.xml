<Type Name="IRecordSequence" FullName="System.IO.Log.IRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fa1a0f48f85197a7107ff489614d8108fdb6a668" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82312810" /></Metadata><TypeSignature Language="C#" Value="public interface IRecordSequence : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IRecordSequence implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.IRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public Interface IRecordSequence&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IRecordSequence : IDisposable" />
  <TypeSignature Language="F#" Value="type IRecordSequence = interface&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="ce57b-101">Stellt eine generische Schnittstelle zu einer Sequenz von Datensätzen bereit.</span><span class="sxs-lookup"><span data-stu-id="ce57b-101">Provides a generic interface to a sequence of records.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-102">Die <xref:System.IO.Log.IRecordSequence>-Schnittstelle stellt eine abstrakte Schnittstelle für einen datensatzorientierten Stream bereit.</span><span class="sxs-lookup"><span data-stu-id="ce57b-102">The <xref:System.IO.Log.IRecordSequence> interface provides an abstract interface to a record-oriented stream.</span></span> <span data-ttu-id="ce57b-103">Eine <xref:System.IO.Log.IRecordSequence>-Instanz kann verwendet werden, um Protokolldatensätze zu lesen und zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="ce57b-103">A <xref:System.IO.Log.IRecordSequence> instance can be used to read and write log records.</span></span>  
  
 <span data-ttu-id="ce57b-104">Die <xref:System.IO.Log.IRecordSequence>-Schnittstelle stellt die folgenden Funktionen bereit:</span><span class="sxs-lookup"><span data-stu-id="ce57b-104">The <xref:System.IO.Log.IRecordSequence> interface provides the following capabilities,</span></span>  
  
-   <span data-ttu-id="ce57b-105">Fügen Sie Protokolldatensätze mit den <xref:System.IO.Log.IRecordSequence.Append%2A>-Methoden an.</span><span class="sxs-lookup"><span data-stu-id="ce57b-105">Append log records using the <xref:System.IO.Log.IRecordSequence.Append%2A> methods.</span></span>  
  
-   <span data-ttu-id="ce57b-106">Lesen Sie die angefügten Datensätze mit der <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="ce57b-106">Read the appended records using the <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> method.</span></span>  
  
-   <span data-ttu-id="ce57b-107">Schreiben Sie einen speziellen Datensatz für den Neustart mit der <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="ce57b-107">Write a special restart record using the <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> method.</span></span>  
  
-   <span data-ttu-id="ce57b-108">Lesen Sie Datensätze für den Neustart vom zuletzt geschriebenen Neustartdatensatz mit der <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="ce57b-108">Read restart records from the most recently written restart record using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
-   <span data-ttu-id="ce57b-109">Übergeben Sie die Datensätze an den permanenten Speicher mit der <xref:System.IO.Log.IRecordSequence.Flush%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="ce57b-109">Flush the records to durable store using the  <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
-   <span data-ttu-id="ce57b-110">Reservieren Sie Speicherplatz zum Anfügen von Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="ce57b-110">Reserve space for appending records.</span></span>  
  
-   <span data-ttu-id="ce57b-111">Geben Sie Protokollspeicherplatz frei, indem Sie die Basis des Protokolls vorrücken.</span><span class="sxs-lookup"><span data-stu-id="ce57b-111">Free log space by advancing the base of the log.</span></span>  
  
-   <span data-ttu-id="ce57b-112">Empfangen Sie Benachrichtigungen zu <xref:System.IO.Log.IRecordSequence.TailPinned>-Ereignissen, um die Basis des Protokolls zu verschieben und Speicherplatz freizugeben.</span><span class="sxs-lookup"><span data-stu-id="ce57b-112">Receive <xref:System.IO.Log.IRecordSequence.TailPinned> event notifications to move the base of the log to free space.</span></span>  
  
 <span data-ttu-id="ce57b-113">Protokolldatensätze werden einer <xref:System.IO.Log.IRecordSequence>-Instanz angefügt, und jeder Protokolldatensatz erhält eine einmalige Sequenznummer.</span><span class="sxs-lookup"><span data-stu-id="ce57b-113">Log records are appended to a <xref:System.IO.Log.IRecordSequence> instance, and each log record is given a unique sequence number.</span></span> <span data-ttu-id="ce57b-114">Sequenznummern nehmen innerhalb einer angegebenen Datensatzsequenz immer gleichmäßig zu.</span><span class="sxs-lookup"><span data-stu-id="ce57b-114">Sequence numbers are strictly monotonically increasing within a given record sequence.</span></span> <span data-ttu-id="ce57b-115">Ein Protokolldatensatz besteht aus transparenten Daten, die in einer <xref:System.IO.Log.IRecordSequence> aus Arraysegmenten von Byte für eine <xref:System.Collections.IList>-Instanz bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-115">A log record consists of opaque data, supplied to the <xref:System.IO.Log.IRecordSequence> instance in an <xref:System.Collections.IList> of ArraySegments of bytes.</span></span>  
  
 <span data-ttu-id="ce57b-116">Die <xref:System.IO.Log.IRecordSequence>-Schnittstelle macht auch einige grundlegende Eigenschaften verfügbar, die Informationen über Protokollbegrenzungen liefern.</span><span class="sxs-lookup"><span data-stu-id="ce57b-116">The <xref:System.IO.Log.IRecordSequence> interface also exposes a few basic properties which provides information about log boundaries.</span></span>  
  
-   <span data-ttu-id="ce57b-117">Die <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>-Eigenschaft enthält die Sequenznummer des ersten gültigen Datensatzes in der Datensatzsequenz.</span><span class="sxs-lookup"><span data-stu-id="ce57b-117">The <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> property contains the sequence number of the first valid record in the record sequence.</span></span>  
  
-   <span data-ttu-id="ce57b-118">Die <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>-Eigenschaft enthält eine Sequenznummer, die in jedem Fall größer ist als die Sequenznummer des letzten angefügten Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="ce57b-118">The <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</span></span>  
  
-   <span data-ttu-id="ce57b-119">Die <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>-Eigenschaft enthält die Sequenznummer des letzten geschriebenen Neustartbereichs.</span><span class="sxs-lookup"><span data-stu-id="ce57b-119">The <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> property contains the sequence number of the last written restart area.</span></span>  
  
-   <span data-ttu-id="ce57b-120">Die <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>-Eigenschaft enthält die Größe des größten Datensatzes, der der Sequenz angefügt oder aus der Sequenz gelesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="ce57b-120">The <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> property contains the size of the largest record that can be appended to, or read from the sequence.</span></span>  
  
-   <span data-ttu-id="ce57b-121">Die <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>-Eigenschaft enthält die Gesamtgröße aller in dieser Datensatzsequenz vorgenommenen Reservierungen.</span><span class="sxs-lookup"><span data-stu-id="ce57b-121">The <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> property contains the total size of all reservations made in this record sequence.</span></span>  
  
-   <span data-ttu-id="ce57b-122">Wenn die <xref:System.IO.Log.IRecordSequence.RetryAppend%2A>-Eigenschaft auf `true` eingestellt ist und ein <xref:System.IO.Log.IRecordSequence.Append%2A>-Vorgang fehlschlägt, da die Sequenz nicht genügend Speicherplatz aufweist, versucht die Datensatzsequenz, Speicherplatz freizugeben und den Anfügevorgang zu wiederholen.</span><span class="sxs-lookup"><span data-stu-id="ce57b-122">If the <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> property is set to `true`, and an <xref:System.IO.Log.IRecordSequence.Append%2A> operation fails because there is no space in the sequence, the record sequence will attempt to free space, and retry the Append operation.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="iRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber"><span data-ttu-id="ce57b-123">Die neue Basissequenznummer der Datensatzsequenz.</span><span class="sxs-lookup"><span data-stu-id="ce57b-123">The new base sequence number of the record sequence.</span></span></param>
        <summary><span data-ttu-id="ce57b-124">Rückt die Basissequenznummer des Protokolls vor.</span><span class="sxs-lookup"><span data-stu-id="ce57b-124">Moves the base sequence number of the log forward.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-125">Wenn Sie eine <xref:System.IO.Log.LogRecordSequence>-Instanz verwenden und versuchen, die Sequenznummer vorzurücken, um Speicherplatz freizugeben, muss sich die neue Basissequenznummer in einem anderen Protokollwertebereich befinden, damit der vorherige Wertebereich als leer markiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="ce57b-125">When you use a <xref:System.IO.Log.LogRecordSequence> instance and try to advance the sequence number to free up space in the log, the new base sequence number must reside in a different log extent for the previous extent to be marked as empty.</span></span> <span data-ttu-id="ce57b-126">Das teilweise Freigeben von Wertebereichen wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ce57b-126">Freeing extents partially is not supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-127"><paramref name="newBaseSequenceNumber" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-127"><paramref name="newBaseSequenceNumber" /> is invalid.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ce57b-128"><paramref name="newBaseSequenceNumber" /> ist im Protokoll nicht aktiv.</span><span class="sxs-lookup"><span data-stu-id="ce57b-128"><paramref name="newBaseSequenceNumber" /> is not active in the log.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-129">Beim Bearbeiten der Sequenz ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-129">An I/O error occurred while modifying the sequence.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-130">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-130">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-131">Die Datensatzsequenz ist voll.</span><span class="sxs-lookup"><span data-stu-id="ce57b-131">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ce57b-132">Schreibt beim Überschreiben in einer abgeleiteten Klasse einen Protokolldatensatz in die <see cref="T:System.IO.Log.IRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="ce57b-132">When overridden in a derived class, writes a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-133">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-133">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="ce57b-134">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-134">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="ce57b-135">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-135">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="ce57b-136">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-136">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <summary><span data-ttu-id="ce57b-137">Schreibt beim Überschreiben in einer abgeleiteten Klasse einen Protokolldatensatz in die <see cref="T:System.IO.Log.IRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="ce57b-137">When overridden in a derived class, writes a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span></span></summary>
        <returns><span data-ttu-id="ce57b-138">Die Sequenznummer des angefügten Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="ce57b-138">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-139">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-139">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-140">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-140">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="ce57b-141">Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-141">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="ce57b-142">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.IRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="ce57b-142">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-143">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-143">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-144">Beim Anfügen des Datensatzes ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-144">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-145">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-145">The record sequence could not make enough free space to contain the new record.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-146">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-146">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-147">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-147">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="ce57b-148">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-148">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="ce57b-149">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-149">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="ce57b-150">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-150">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <summary><span data-ttu-id="ce57b-151">Fügt beim Überschreiben in einer abgeleiteten Klasse der <see cref="T:System.IO.Log.IRecordSequence" /> einen Protokolldatensatz an.</span><span class="sxs-lookup"><span data-stu-id="ce57b-151">When overridden in a derived class, appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span></span></summary>
        <returns><span data-ttu-id="ce57b-152">Die Sequenznummer des angefügten Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="ce57b-152">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-153">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-153">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-154">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-154">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="ce57b-155">Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-155">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="ce57b-156">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.IRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="ce57b-156">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-157">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-157">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-158">Beim Anfügen des Datensatzes ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-158">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-159">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-159">The record sequence could not make enough free space to contain the new record.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-160">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-160">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-161">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-161">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="ce57b-162">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-162">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="ce57b-163">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-163">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="ce57b-164">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-164">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservations"><span data-ttu-id="ce57b-165">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Datensatz verwendet werden sollte.</span><span class="sxs-lookup"><span data-stu-id="ce57b-165">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span></span></param>
        <summary><span data-ttu-id="ce57b-166">Fügt beim Überschreiben in einer abgeleiteten Klasse der <see cref="T:System.IO.Log.IRecordSequence" /> mithilfe von zuvor in der Sequenz reserviertem Speicherplatz einen Protokolldatensatz an.</span><span class="sxs-lookup"><span data-stu-id="ce57b-166">When overridden in a derived class, appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span></span></summary>
        <returns><span data-ttu-id="ce57b-167">Die Sequenznummer des angefügten Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="ce57b-167">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-168">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-168">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-169">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-169">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="ce57b-170">Der angefügte Datensatz, der zuvor mithilfe einer vom `reservations`-Parameter angegebenen Reservierung reserviert wurde, nimmt Speicherplatz ein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-170">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="ce57b-171">Wenn der Anfügevorgang erfolgreich ist, wird der kleinstmögliche Reservierungsbereich verwendet, der die Daten aufnehmen kann. Dieser Reservierungsbereich wird dann aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="ce57b-171">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="ce57b-172">Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-172">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="ce57b-173">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.IRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="ce57b-173">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-174">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-174">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-175">Beim Anfügen des Datensatzes ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-175">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-176">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-176">The record sequence could not make enough free space to contain the new record.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-177">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-177">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-178">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-178">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="ce57b-179">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-179">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="ce57b-180">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-180">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="ce57b-181">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-181">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservations"><span data-ttu-id="ce57b-182">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Datensatz verwendet werden sollte.</span><span class="sxs-lookup"><span data-stu-id="ce57b-182">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span></span></param>
        <summary><span data-ttu-id="ce57b-183">Fügt beim Überschreiben in einer abgeleiteten Klasse der <see cref="T:System.IO.Log.IRecordSequence" /> mithilfe von zuvor in der Sequenz reserviertem Speicherplatz einen Protokolldatensatz an.</span><span class="sxs-lookup"><span data-stu-id="ce57b-183">When overridden in a derived class, appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span></span></summary>
        <returns><span data-ttu-id="ce57b-184">Die Sequenznummer des angefügten Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="ce57b-184">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-185">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-185">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-186">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-186">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="ce57b-187">Der angefügte Datensatz, der zuvor mithilfe einer vom `reservations`-Parameter angegebenen Reservierung reserviert wurde, nimmt Speicherplatz ein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-187">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="ce57b-188">Wenn der Anfügevorgang erfolgreich ist, wird der kleinstmögliche Reservierungsbereich verwendet, der die Daten aufnehmen kann. Dieser Reservierungsbereich wird dann aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="ce57b-188">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="ce57b-189">Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-189">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="ce57b-190">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.IRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="ce57b-190">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-191">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-191">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-192">Beim Anfügen des Datensatzes ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-192">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-193">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-193">The record sequence could not make enough free space to contain the new record.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-194">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-194">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce57b-195">Ruft beim Überschreiben in einer abgeleiteten Klasse die Sequenznummer des ersten gültigen Datensatzes in der aktuellen <see cref="T:System.IO.Log.IRecordSequence" /> ab.</span><span class="sxs-lookup"><span data-stu-id="ce57b-195">When overridden in a derived class, gets the sequence number of the first valid record in the current <see cref="T:System.IO.Log.IRecordSequence" />.</span></span></summary>
        <value><span data-ttu-id="ce57b-196">Die niedrigste Sequenznummer, die einem gültigen Datensatz in der <see cref="T:System.IO.Log.IRecordSequence" /> entspricht.</span><span class="sxs-lookup"><span data-stu-id="ce57b-196">The lowest sequence number that corresponds to a valid record in the <see cref="T:System.IO.Log.IRecordSequence" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-197">Gültige Sequenznummern sind größer oder gleich <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> und kleiner als <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</span><span class="sxs-lookup"><span data-stu-id="ce57b-197">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</span></span>  
  
 <span data-ttu-id="ce57b-198">Der Wert dieser Eigenschaft kann durch Aufrufen der <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>-Methode oder der <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>-Methode geändert werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-198">The value of this property can be changed by calling the <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> or <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-199">Auf die Eigenschaft wurde zugegriffen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-199">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ce57b-200">Leitet beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Anfügevorgang ein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-200">When overridden in a derived class, begins an asynchronous append operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAppend (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-201">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-201">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="ce57b-202">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-202">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="ce57b-203">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-203">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="ce57b-204">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-204">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="callback"><span data-ttu-id="ce57b-205">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-205">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="ce57b-206">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-206">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="ce57b-207">Leitet beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Anfügevorgang ein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-207">When overridden in a derived class, begins an asynchronous append operation.</span></span></summary>
        <returns><span data-ttu-id="ce57b-208">Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Anfügevorgang darstellt, der möglicherweise noch aussteht.</span><span class="sxs-lookup"><span data-stu-id="ce57b-208">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-209">Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.IRecordSequence.EndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-209">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="ce57b-210">Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.IRecordSequence.EndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-210">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="ce57b-211">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-211">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-212">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-212">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="ce57b-213">Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-213">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="ce57b-214">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.IRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="ce57b-214">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-215">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-215">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-216">Beim Anfügen des Datensatzes ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-216">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-217">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-217">The record sequence could not make enough free space to contain the new record.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-218">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-218">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAppend (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-219">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-219">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="ce57b-220">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-220">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="ce57b-221">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-221">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="ce57b-222">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-222">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="callback"><span data-ttu-id="ce57b-223">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-223">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="ce57b-224">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-224">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="ce57b-225">Leitet beim Überschreiben in einer abgeleiteten Klasse einen Anfügevorgang ein, wobei der zuvor in der Sequenz reservierte Speicherplatz verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-225">When overridden in a derived class, begins an asynchronous append operation, using space previously reserved in the sequence.</span></span></summary>
        <returns><span data-ttu-id="ce57b-226">Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Anfügevorgang darstellt, der möglicherweise noch aussteht.</span><span class="sxs-lookup"><span data-stu-id="ce57b-226">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-227">Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.IRecordSequence.EndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-227">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="ce57b-228">Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.IRecordSequence.EndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-228">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="ce57b-229">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-229">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-230">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-230">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="ce57b-231">Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-231">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="ce57b-232">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.IRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="ce57b-232">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-233">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-233">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-234">Beim Anfügen des Datensatzes ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-234">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-235">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-235">The record sequence could not make enough free space to contain the new record.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-236">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-236">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAppend (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservations As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-237">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-237">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="ce57b-238">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-238">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="ce57b-239">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-239">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="ce57b-240">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-240">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservations"><span data-ttu-id="ce57b-241">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Datensatz verwendet werden sollte.</span><span class="sxs-lookup"><span data-stu-id="ce57b-241">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span></span></param>
        <param name="callback"><span data-ttu-id="ce57b-242">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-242">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="ce57b-243">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-243">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="ce57b-244">Leitet beim Überschreiben in einer abgeleiteten Klasse einen Anfügevorgang ein, wobei der zuvor in der Sequenz reservierte Speicherplatz verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-244">When overridden in a derived class, begins an asynchronous append operation using space previously reserved in the sequence.</span></span></summary>
        <returns><span data-ttu-id="ce57b-245">Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Anfügevorgang darstellt, der möglicherweise noch aussteht.</span><span class="sxs-lookup"><span data-stu-id="ce57b-245">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-246">Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.IRecordSequence.EndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-246">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="ce57b-247">Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.IRecordSequence.EndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-247">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="ce57b-248">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-248">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-249">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-249">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="ce57b-250">Der angefügte Datensatz, der zuvor mithilfe einer vom `reservations`-Parameter angegebenen Reservierung reserviert wurde, nimmt Speicherplatz ein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-250">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="ce57b-251">Wenn der Anfügevorgang erfolgreich ist, wird der kleinstmögliche Reservierungsbereich verwendet, der die Daten aufnehmen kann. Dieser Reservierungsbereich wird dann aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="ce57b-251">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="ce57b-252">Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-252">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="ce57b-253">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.IRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="ce57b-253">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-254">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-254">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-255">Beim Anfügen des Datensatzes ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-255">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-256">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-256">The record sequence could not make enough free space to contain the new record.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-257">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-257">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousUndoRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAppend (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousUndoRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservations As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousUndoRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousUndoRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-258">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-258">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="ce57b-259">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-259">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousUndoRecord"><span data-ttu-id="ce57b-260">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-260">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="ce57b-261">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-261">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservations"><span data-ttu-id="ce57b-262">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Datensatz verwendet werden sollte.</span><span class="sxs-lookup"><span data-stu-id="ce57b-262">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span></span></param>
        <param name="callback"><span data-ttu-id="ce57b-263">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-263">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="ce57b-264">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-264">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="ce57b-265">Leitet beim Überschreiben in einer abgeleiteten Klasse einen Anfügevorgang ein, wobei der zuvor in der Sequenz reservierte Speicherplatz verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-265">When overridden in a derived class, begins an asynchronous append operation, using space previously reserved in the sequence.</span></span></summary>
        <returns><span data-ttu-id="ce57b-266">Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Anfügevorgang darstellt, der möglicherweise noch aussteht.</span><span class="sxs-lookup"><span data-stu-id="ce57b-266">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-267">Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.IRecordSequence.EndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-267">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="ce57b-268">Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.IRecordSequence.EndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-268">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="ce57b-269">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-269">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-270">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-270">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="ce57b-271">Der angefügte Datensatz, der zuvor mithilfe einer vom `reservations`-Parameter angegebenen Reservierung reserviert wurde, nimmt Speicherplatz ein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-271">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="ce57b-272">Wenn der Anfügevorgang erfolgreich ist, wird der kleinstmögliche Reservierungsbereich verwendet, der die Daten aufnehmen kann. Dieser Reservierungsbereich wird dann aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="ce57b-272">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="ce57b-273">Normalerweise ist diese Methode abgeschlossen, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-273">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="ce57b-274">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.IRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="ce57b-274">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-275">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-275">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-276">Beim Anfügen des Datensatzes ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-276">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-277">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-277">The record sequence could not make enough free space to contain the new record.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-278">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-278">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (sequenceNumber As SequenceNumber, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber"><span data-ttu-id="ce57b-279">Die Sequenznummer des letzten Datensatzes, der geschrieben werden muss.</span><span class="sxs-lookup"><span data-stu-id="ce57b-279">The sequence number of the latest record that must be written.</span></span> <span data-ttu-id="ce57b-280">Wenn diese <see cref="T:System.IO.Log.SequenceNumber" /> ungültig ist, müssen alle Datensätze geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-280">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span></span></param>
        <param name="callback"><span data-ttu-id="ce57b-281">Ein optionaler asynchroner Rückruf, der nach Abschluss des Löschvorgangs aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-281">An optional asynchronous callback, to be called when the flush is complete.</span></span></param>
        <param name="state"><span data-ttu-id="ce57b-282">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Löschanforderung von anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-282">A user-provided object that distinguishes this particular asynchronous flush request from other requests.</span></span></param>
        <summary><span data-ttu-id="ce57b-283">Leitet beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Löschvorgang ein, wobei der zuvor in der Sequenz reservierte Speicherplatz verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-283">When overridden in a derived class, begins an asynchronous flush operation, using space previously reserved in the sequence.</span></span></summary>
        <returns><span data-ttu-id="ce57b-284">Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Löschvorgang darstellt, der möglicherweise noch aussteht.</span><span class="sxs-lookup"><span data-stu-id="ce57b-284">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous flush operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-285">Sie sollten das von der aktuellen Methode ausgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.IRecordSequence.EndFlush%2A>-Methode weiterleiten, um sicherzustellen, dass der Löschvorgang abgeschlossen wird und die Ressourcen korrekt freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-285">You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately.</span></span> <span data-ttu-id="ce57b-286">Wenn während eines asynchronen Löschvorgangs ein Fehler auftritt, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.IRecordSequence.EndFlush%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-286">If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="ce57b-287">Durch das Aufrufen dieser Methode wird sichergestellt, dass alle Datensätze, die der <xref:System.IO.Log.IRecordSequence> angefügt wurden, dauerhaft geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-287">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.IRecordSequence> are durably written.</span></span>  
  
 <span data-ttu-id="ce57b-288">Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="ce57b-288">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="ce57b-289">Bei einer asynchronen Löschanforderung auftretende Fehler, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.IRecordSequence.EndFlush%2A>-Methode Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="ce57b-289">Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-290">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-290">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-291">Beim Löschen der Daten ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-291">An I/O error occurred while flushing the data.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-292">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-292">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ce57b-293">Leitet beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Reservierungs- und Anfügevorgang ein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-293">When overridden in a derived class, begins an asynchronous reserve and append operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReserveAndAppend (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservationCollection As ReservationCollection, reservations As Long(), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-294">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-294">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="ce57b-295">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-295">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="ce57b-296">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-296">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="ce57b-297">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-297">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="ce57b-298">Die Reservierungsauflistung, in der Reservierungen vorgenommen werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-298">The reservation collection to make reservations in.</span></span></param>
        <param name="reservations"><span data-ttu-id="ce57b-299">Die vorzunehmenden Reservierungen in Byte.</span><span class="sxs-lookup"><span data-stu-id="ce57b-299">The reservations to make, in bytes.</span></span></param>
        <param name="callback"><span data-ttu-id="ce57b-300">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-300">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="ce57b-301">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-301">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="ce57b-302">Leitet beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Reservierungs- und Anfügevorgang ein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-302">When overridden in a derived class, begins an asynchronous reserve and append operation.</span></span></summary>
        <returns><span data-ttu-id="ce57b-303">Ein <see cref="T:System.IAsyncResult" />, das diesen asynchronen Vorgang darstellt, der möglicherweise noch aussteht.</span><span class="sxs-lookup"><span data-stu-id="ce57b-303">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-304">Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-304">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="ce57b-305">Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-305">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="ce57b-306">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-306">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-307">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-307">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="ce57b-308">Die angegebenen Reservierungen werden in einer atomaren Operation mit einem Vorgang zum Anfügen von Datensätzen der bereitgestellten Reservierungsauflistung hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="ce57b-308">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="ce57b-309">Wenn der Anfügevorgang scheitert, wird kein Speicherplatz reserviert.</span><span class="sxs-lookup"><span data-stu-id="ce57b-309">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="ce57b-310">Normalerweise kann diese Methode abgeschlossen werden, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-310">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="ce57b-311">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.IRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="ce57b-311">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="ce57b-312">Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="ce57b-312">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="ce57b-313">Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="ce57b-313">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-314">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-314">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-315">Beim Anfügen des Datensatzes ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-315">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-316">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten oder die Reservierung auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ce57b-316">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-317">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-317">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReserveAndAppend (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservationCollection As ReservationCollection, reservations As Long(), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-318">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-318">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="ce57b-319">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-319">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="ce57b-320">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-320">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="ce57b-321">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-321">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="ce57b-322">Die Reservierungsauflistung, in der Reservierungen vorgenommen werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-322">The reservation collection to make reservations in.</span></span></param>
        <param name="reservations"><span data-ttu-id="ce57b-323">Die vorzunehmenden Reservierungen in Byte.</span><span class="sxs-lookup"><span data-stu-id="ce57b-323">The reservations to make, in bytes.</span></span></param>
        <param name="callback"><span data-ttu-id="ce57b-324">Ein optionaler asynchroner Rückruf, der nach Abschluss des Anfügevorgangs aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-324">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="ce57b-325">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Anfügeanforderung von anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-325">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="ce57b-326">Leitet beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Reservierungs- und Anfügevorgang ein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-326">When overridden in a derived class, begins an asynchronous reserve and append operation.</span></span></summary>
        <returns><span data-ttu-id="ce57b-327">Ein <see cref="T:System.IAsyncResult" />, das diesen asynchronen Vorgang darstellt, der möglicherweise noch aussteht.</span><span class="sxs-lookup"><span data-stu-id="ce57b-327">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-328">Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>-Methode weiterleiten, um sicherzustellen, dass der Anfügevorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-328">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="ce57b-329">Wenn während eines asynchronen Anfügevorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-329">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="ce57b-330">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-330">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-331">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-331">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="ce57b-332">Die angegebenen Reservierungen werden in einer atomaren Operation mit einem Vorgang zum Anfügen von Datensätzen der bereitgestellten Reservierungsauflistung hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="ce57b-332">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="ce57b-333">Wenn der Anfügevorgang scheitert, wird kein Speicherplatz reserviert.</span><span class="sxs-lookup"><span data-stu-id="ce57b-333">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="ce57b-334">Normalerweise kann diese Methode abgeschlossen werden, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-334">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="ce57b-335">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.IRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="ce57b-335">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="ce57b-336">Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="ce57b-336">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="ce57b-337">Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="ce57b-337">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-338">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-338">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-339">Beim Anfügen des Datensatzes ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-339">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-340">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten oder die Reservierung auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ce57b-340">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-341">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-341">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ce57b-342">Löst beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Neustartbereich-Schreibvorgang aus.</span><span class="sxs-lookup"><span data-stu-id="ce57b-342">When overridden in a derived class, begins an asynchronous restart area write operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-343">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-343">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSequenceNumber"><span data-ttu-id="ce57b-344">Die neue Basissequenznummer.</span><span class="sxs-lookup"><span data-stu-id="ce57b-344">The new base sequence number.</span></span> <span data-ttu-id="ce57b-345">Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-345">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <param name="reservation"><span data-ttu-id="ce57b-346">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Neustartbereich verwendet werden sollte.</span><span class="sxs-lookup"><span data-stu-id="ce57b-346">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span></span></param>
        <param name="callback"><span data-ttu-id="ce57b-347">Ein optionaler asynchroner Rückruf, der nach Abschluss des Neustartbereich-Schreibvorgangs aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-347">An optional asynchronous callback, to be called when the restart area write is complete.</span></span></param>
        <param name="state"><span data-ttu-id="ce57b-348">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Neustartbereichschreibanforderung von anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-348">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span></span></param>
        <summary><span data-ttu-id="ce57b-349">Leitet beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Neustartbereich-Schreibvorgang ein, wobei der zuvor in der Sequenz reservierte Speicherplatz verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-349">When overridden in a derived class, begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span></span></summary>
        <returns><span data-ttu-id="ce57b-350">Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Neustartbereich-Schreibvorgang darstellt, der möglicherweise noch aussteht.</span><span class="sxs-lookup"><span data-stu-id="ce57b-350">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-351">Sie sollten das von der dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>-Methode weiterleiten, um sicherzustellen, dass der Neustartbereich-Schreibvorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-351">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method, to assure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="ce57b-352">Wenn während eines asynchronen Neustartbereich-Schreibvorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-352">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="ce57b-353">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-353">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-354">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-354">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="ce57b-355">Wenn die Operation erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="ce57b-355">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="ce57b-356">Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-356">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="ce57b-357">Wenn eine <xref:System.IO.Log.ReservationCollection> angegeben wird, nimmt der geschriebene Neustartbereich, der zuvor mithilfe einer in der Auflistung enthaltenen Reservierung reserviert wurde, Speicherplatz ein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-357">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="ce57b-358">Wenn diese Methode erfolgreich ist, wird die kleinstmögliche Reservierung verwendet, die die Daten aufnehmen kann. Diese Reservierung wird dann aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="ce57b-358">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="ce57b-359">Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="ce57b-359">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="ce57b-360">Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>-Methode Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="ce57b-360">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-361">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-361">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSequenceNumber"><span data-ttu-id="ce57b-362">Die neue Basissequenznummer.</span><span class="sxs-lookup"><span data-stu-id="ce57b-362">The new base sequence number.</span></span> <span data-ttu-id="ce57b-363">Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-363">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <param name="reservation"><span data-ttu-id="ce57b-364">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Neustartbereich verwendet werden sollte.</span><span class="sxs-lookup"><span data-stu-id="ce57b-364">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span></span></param>
        <param name="callback"><span data-ttu-id="ce57b-365">Ein optionaler asynchroner Rückruf, der nach Abschluss des Neustartbereich-Schreibvorgangs aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-365">An optional asynchronous callback, to be called when the restart area write is complete.</span></span></param>
        <param name="state"><span data-ttu-id="ce57b-366">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Neustartbereichschreibanforderung von anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-366">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span></span></param>
        <summary><span data-ttu-id="ce57b-367">Leitet beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Neustartbereich-Schreibvorgang ein, wobei der zuvor in der Sequenz reservierte Speicherplatz verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-367">When overridden in a derived class, begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span></span></summary>
        <returns><span data-ttu-id="ce57b-368">Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Neustartbereich-Schreibvorgang darstellt, der möglicherweise noch aussteht.</span><span class="sxs-lookup"><span data-stu-id="ce57b-368">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-369">Sie sollten das von dieser Methode zurückgegebene <xref:System.IAsyncResult> an die <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>-Methode weiterleiten, um sicherzustellen, dass der Neustartbereich-Schreibvorgang abgeschlossen ist und die Ressourcen korrekt freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-369">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="ce57b-370">Wenn während eines asynchronen Neustartbereich-Schreibvorgangs ein Fehler aufgetreten ist, wird erst dann eine Ausnahme ausgelöst, wenn die <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>-Methode mit dem von dieser Methode zurückgegebenen <xref:System.IAsyncResult> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-370">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="ce57b-371">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-371">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-372">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-372">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="ce57b-373">Wenn die Operation erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="ce57b-373">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="ce57b-374">Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-374">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="ce57b-375">Wenn eine <xref:System.IO.Log.ReservationCollection> angegeben wird, nimmt der geschriebene Neustartbereich, der zuvor mithilfe einer in der Auflistung enthaltenen Reservierung reserviert wurde, Speicherplatz ein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-375">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="ce57b-376">Wenn diese Methode erfolgreich ist, wird die kleinstmögliche Reservierung verwendet, die die Daten aufnehmen kann. Diese Reservierung wird dann aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="ce57b-376">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="ce57b-377">Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="ce57b-377">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="ce57b-378">Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>-Methode Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="ce57b-378">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-379">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-379">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-380">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-380">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-381">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-381">The record sequence could not make enough free space to contain the new record.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-382">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-382">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="iRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ce57b-383">Erstellt beim Überschreiben in einer abgeleiteten Klasse einen neuen <see cref="T:System.IO.Log.ReservationCollection" />.</span><span class="sxs-lookup"><span data-stu-id="ce57b-383">When overridden in a derived class, creates a new <see cref="T:System.IO.Log.ReservationCollection" />.</span></span></summary>
        <returns><span data-ttu-id="ce57b-384">Das neu erstellte <see cref="T:System.IO.Log.ReservationCollection" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="ce57b-384">The newly created <see cref="T:System.IO.Log.ReservationCollection" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-385">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-385">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="ce57b-386">Ein Verweis auf die ausstehende asynchrone E/A-Anforderung.</span><span class="sxs-lookup"><span data-stu-id="ce57b-386">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="ce57b-387">Beendet beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Anfügevorgang.</span><span class="sxs-lookup"><span data-stu-id="ce57b-387">When overridden in a derived class, ends an asynchronous append operation.</span></span></summary>
        <returns><span data-ttu-id="ce57b-388">Die Sequenznummer des angefügten Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="ce57b-388">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-389">Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ce57b-389">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="ce57b-390">Fehler, die während einer asynchronen Schreibanforderung auftreten, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, werden sichtbar, wenn <xref:System.IO.Log.IRecordSequence.EndAppend%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-390">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.IRecordSequence.EndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="ce57b-391">Diese Methode muss genau einmal für jedes <xref:System.IAsyncResult>, das von der <xref:System.IO.Log.IRecordSequence.BeginAppend%2A>-Methode zurückgegeben wird, aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-391">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-392">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-392">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-393">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-393">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="ce57b-394">Ein Verweis auf die ausstehende asynchrone E/A-Anforderung.</span><span class="sxs-lookup"><span data-stu-id="ce57b-394">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="ce57b-395">Beendet beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Löschvorgang.</span><span class="sxs-lookup"><span data-stu-id="ce57b-395">When overridden in a derived class, ends an asynchronous flush operation.</span></span></summary>
        <returns><span data-ttu-id="ce57b-396">Die Sequenznummer des letzten geschriebenen Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="ce57b-396">The sequence number of the last record written.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-397">Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ce57b-397">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="ce57b-398">Fehler, die während einer asynchronen Löschanforderung auftreten, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, werden sichtbar, wenn <xref:System.IO.Log.IRecordSequence.EndFlush%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-398">Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.IRecordSequence.EndFlush%2A> is called.</span></span>  
  
 <span data-ttu-id="ce57b-399">Diese Methode muss genau einmal für jedes <xref:System.IAsyncResult>, das von der <xref:System.IO.Log.IRecordSequence.BeginFlush%2A>-Methode zurückgegeben wird, aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-399">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginFlush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-400">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-400">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-401">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-401">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="ce57b-402">Ein Verweis auf die ausstehende asynchrone E/A-Anforderung.</span><span class="sxs-lookup"><span data-stu-id="ce57b-402">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="ce57b-403">Beendet beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Reservierungs- und Anfügevorgang.</span><span class="sxs-lookup"><span data-stu-id="ce57b-403">When overridden in a derived class, ends an asynchronous reserve and append operation.</span></span></summary>
        <returns><span data-ttu-id="ce57b-404">Die Sequenznummer des angefügten Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="ce57b-404">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-405">Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ce57b-405">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="ce57b-406">Fehler, die während einer asynchronen Schreibanforderung auftreten, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, werden sichtbar, wenn <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-406">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="ce57b-407">Diese Methode muss genau einmal für jedes <xref:System.IAsyncResult>, das von der <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>-Methode zurückgegeben wird, aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-407">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-408">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-408">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-409">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-409">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="ce57b-410">Ein Verweis auf die ausstehende asynchrone E/A-Anforderung.</span><span class="sxs-lookup"><span data-stu-id="ce57b-410">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="ce57b-411">Beendet beim Überschreiben in einer abgeleiteten Klasse einen asynchronen Neustartbereich-Schreibvorgang.</span><span class="sxs-lookup"><span data-stu-id="ce57b-411">When overridden in a derived class, ends an asynchronous restart area write operation.</span></span></summary>
        <returns><span data-ttu-id="ce57b-412">Die Sequenznummer des geschriebenen Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="ce57b-412">The sequence number of the written log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-413">Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ce57b-413">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="ce57b-414">Fehler, die während einer asynchronen Schreibanforderung auftreten, z. B. Fehler auf dem Datenträger während der E/A-Anforderung, werden sichtbar, wenn <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-414">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> is called.</span></span>  
  
 <span data-ttu-id="ce57b-415">Diese Methode muss genau einmal für jedes <xref:System.IAsyncResult>, das von der <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>-Methode zurückgegeben wird, aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-415">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-416">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-416">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-417">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-417">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ce57b-418">Bewirkt beim Überschreiben in einer abgeleiteten Klasse, dass angefügte Datensätze geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-418">When overridden in a derived class, causes appended records to be written.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ce57b-419">Stellt beim Überschreiben einer abgeleiteten Klasse sicher, dass alle angefügten Datensätze geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-419">When overridden in a derived class, ensures that all appended records have been written.</span></span></summary>
        <returns><span data-ttu-id="ce57b-420">Die Sequenznummer des letzten geschriebenen Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="ce57b-420">The sequence number of the last record written.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-421">Durch das Aufrufen dieser Methode wird sichergestellt, dass alle Datensätze, die der <xref:System.IO.Log.IRecordSequence> angefügt wurden, dauerhaft geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-421">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.IRecordSequence> have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-422">Beim Löschen der Daten ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-422">An I/O error occurred while flushing the data.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-423">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-423">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush (sequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber"><span data-ttu-id="ce57b-424">Die Sequenznummer des letzten Datensatzes, der geschrieben werden muss.</span><span class="sxs-lookup"><span data-stu-id="ce57b-424">The sequence number of the latest record that must be written.</span></span> <span data-ttu-id="ce57b-425">Wenn diese <see cref="T:System.IO.Log.SequenceNumber" /> ungültig ist, müssen alle Datensätze geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-425">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span></span></param>
        <summary><span data-ttu-id="ce57b-426">Stellt beim Überschreiben in einer abgeleiteten Klasse sicher, dass alle angefügten Datensätze bis zu dem Datensatz mit der angegebenen Sequenznummer dauerhaft geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-426">When overridden in a derived class, ensures that all appended records up to and including the record with the specified sequence number have been durably written.</span></span></summary>
        <returns><span data-ttu-id="ce57b-427">Die Sequenznummer des letzten geschriebenen Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="ce57b-427">The sequence number of the last record written.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-428">Durch das Aufrufen diese Methode wird sichergestellt, dass alle Datensätze mit Sequenznummern bis zu der angegebenen Sequenznummer dauerhaft geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-428">Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-429">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-429">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-430">Beim Löschen der Daten ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-430">An I/O error occurred while flushing the data.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-431">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-431">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce57b-432">Ruft beim Überschreiben in einer abgeleiteten Klasse die Sequenznummer ab, die größer als der letzte angefügte Datensatz ist.</span><span class="sxs-lookup"><span data-stu-id="ce57b-432">When overridden in a derived class, gets the sequence number which is greater than the last record appended.</span></span></summary>
        <value><span data-ttu-id="ce57b-433">Eine Sequenznummer, die größer ist als der letzte angefügte Datensatz.</span><span class="sxs-lookup"><span data-stu-id="ce57b-433">A sequence number which is greater than the last record appended.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-434">Diese Eigenschaft enthält eine Sequenznummer, die in jedem Fall größer ist als die Sequenznummer des letzten angefügten Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="ce57b-434">This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</span></span> <span data-ttu-id="ce57b-435">Gültige Sequenznummern sind größer oder gleich <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> und kleiner als <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</span><span class="sxs-lookup"><span data-stu-id="ce57b-435">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce57b-436">Beim Verwenden einer <xref:System.IO.Log.LogRecordSequence>-Instanz kann der <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>-Wert veraltet sein, bis Datensätze in das Protokoll übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-436">When using a <xref:System.IO.Log.LogRecordSequence> instance, the <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> value can become out of date until records are flushed to the log.</span></span> <span data-ttu-id="ce57b-437">Weitere Informationen zum leeren von Datensätzen finden Sie unter <xref:System.IO.Log.IRecordSequence.Flush%2A> und <xref:System.IO.Log.RecordAppendOptions>.</span><span class="sxs-lookup"><span data-stu-id="ce57b-437">See <xref:System.IO.Log.IRecordSequence.Flush%2A> and <xref:System.IO.Log.RecordAppendOptions> for more information on flushing records.</span></span> 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-438">Auf die Eigenschaft wurde zugegriffen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-438">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce57b-439">Ruft beim Überschreiben in einer abgeleiteten Klasse die Größe des größten Datensatzes in Byte ab, der dieser Sequenz angefügt oder aus ihr gelesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="ce57b-439">When overridden in a derived class, gets the size of the largest record that can be appended to or read from this sequence, in bytes.</span></span></summary>
        <value><span data-ttu-id="ce57b-440">Die Größe des größten Datensatzes in Byte, der der Sequenz angefügt oder aus der Sequenz gelesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="ce57b-440">The size of the largest record that can be appended to or read from this sequence, in bytes.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-441">Auf die Eigenschaft wurde zugegriffen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-441">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="ce57b-442">Die Sequenznummer des ersten Datensatzes, bei dem mit dem Lesen begonnen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-442">The sequence number of the first record where the reading starts.</span></span></param>
        <param name="logRecordEnum"><span data-ttu-id="ce57b-443">Ein gültiger <see cref="T:System.IO.Log.LogRecordEnumeratorType" />-Wert, der die Art (vorwärts oder rückwärts) angibt, in der Datensätze aus einer <see cref="T:System.IO.Log.LogRecordSequence" /> gelesen werden sollten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-443">A valid <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> value that specifies the manner (that is, forward or backward) in which records should be read from a <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span></param>
        <summary><span data-ttu-id="ce57b-444">Gibt beim Überschreiben in einer abgeleiteten Klasse eine zählbare Auflistung der Datensätze in der Sequenz zurück.</span><span class="sxs-lookup"><span data-stu-id="ce57b-444">When overridden in a derived class, returns an enumerable collection of records in the sequence.</span></span></summary>
        <returns><span data-ttu-id="ce57b-445">Eine zählbare Auflistung von Datensätzen in der Sequenz.</span><span class="sxs-lookup"><span data-stu-id="ce57b-445">An enumerable collection of records in the sequence.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-446">Gibt beim Überschreiben in einer abgeleiteten Klasse eine zählbare Auflistung der Datensätze in der Sequenz zurück.</span><span class="sxs-lookup"><span data-stu-id="ce57b-446">When overridden in a derived class, returns an enumerable collection of records in the sequence.</span></span> <span data-ttu-id="ce57b-447">Die Reihenfolge der aufgelisteten Datensätze hängt vom Wert des `logRecordEnum`-Parameters ab.</span><span class="sxs-lookup"><span data-stu-id="ce57b-447">The order of the enumerated records depends on the value of the `logRecordEnum` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce57b-448">Dieses Beispiel veranschaulicht die Verwendung der <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="ce57b-448">This sample demonstrates the use of the <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> method.</span></span>  
  
```csharp  
using System;  
 using System.IO;  
 using System.IO.Log;  
  
 class ReadRecordsSample  
 {  
     static SequenceNumber AppendRecord(IRecordSequence sequence,  
                                        string message,  
                                        SequenceNumber user,  
                                        SequenceNumber previous)  
     {  
         MemoryStream data = new MemoryStream();  
         BinaryWriter writer = new BinaryWriter(data);  
         writer.Write(message);  
  
         ArraySegment<byte>[] segments;  
         segments = new ArraySegment<byte>[1];  
         segments[0] = new ArraySegment(data.GetBuffer(),  
                                        0,  
                                        Data.Length);  
  
         return sequence.Append(segments,  
                                user,  
                                previous,  
                                WriteFlags.None);  
     }  
  
     public static void Main(string[] args)  
     {  
         IRecordSequence sequence;  
         sequence = new FileIRecordSequence(args[0]);  
  
         SequenceNumber a, b, c, d;  
  
         a = AppendRecord(sequence,  
                          "This is record A",  
                          SequenceNumber.Invalid,  
                          SequenceNumber.Invalid);  
         Console.WriteLine($"Record A has sequence number {a}");  
  
         b = AppendRecord(sequence,  
                          "This is record B",  
                          a,  
                          a);  
         Console.WriteLine($"Record B has sequence number {b}");  
  
         c = AppendRecord(sequence,  
                          "This is record C",  
                          a,  
                          a);  
         Console.WriteLine($"Record C has sequence number {c}");  
  
         d = AppendRecord(sequence,  
                          "This is record D",  
                          b,  
                          c);  
         Console.WriteLine($"Record D has sequence number {d}");  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(a, ReadDirection.Forward))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine($"{record.SequenceNumber}: {reader.ReadString()}");  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.User))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine($"{record.SequenceNumber}: {reader.ReadString()}");  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.Previous))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine($"{record.SequenceNumber}: {reader.ReadString()}");  
         }  
     }  
       }  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-449">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-449">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-450">Beim Lesen des Datensatzes ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-450">An I/O error occurred while reading the record.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-451">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-451">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ce57b-452">Gibt beim Überschreiben in einer abgeleiteten Klasse eine zählbare Auflistung der Neustartbereiche in der Sequenz zurück.</span><span class="sxs-lookup"><span data-stu-id="ce57b-452">When overridden in a derived class, returns an enumerable collection of the restart areas in the sequence.</span></span></summary>
        <returns><span data-ttu-id="ce57b-453">Eine zählbare Auflistung der Neustartbereiche in der Sequenz.</span><span class="sxs-lookup"><span data-stu-id="ce57b-453">An enumerable collection of the restart areas in the sequence.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-454">Die Neustartbereiche sind in umgekehrter Reihenfolge der Sequenznummern aufgelistet, von der höchsten bis zur niedrigsten Sequenznummer.</span><span class="sxs-lookup"><span data-stu-id="ce57b-454">The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number.</span></span> <span data-ttu-id="ce57b-455">Nur Neustartbereiche mit Sequenznummern zwischen der letzten Sequenznummer und der Basissequenznummer sind aufgelistet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-455">Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce57b-456">Wenn der Protokollwertebereich, der die <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> enthält, beschädigt ist, kann diese Methode eine <xref:System.IO.IOException> mit folgender Fehlermeldung ausgeben: "Die Anforderung konnte aufgrund einer unerwarteten E/A-Ausnahme nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-456">If the log extent containing the <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> becomes corrupted, this method can throw an <xref:System.IO.IOException> with the error message "The request could not be performed because of an unexpected I/O exception.</span></span> <span data-ttu-id="ce57b-457">Folgender Fehlercode wurde zurückgegeben: '80070026'".</span><span class="sxs-lookup"><span data-stu-id="ce57b-457">The following error code was returned: '80070026'".</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-458">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-458">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-459">Beim Lesen des Datensatzes ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-459">An I/O error occurred while reading the record.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-460">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-460">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ce57b-461">Führt beim Überschreiben in einer abgeleiteten Klasse automatisch eine einzelne Reservierung durch und fügt der Sequenz einen Datensatz an.</span><span class="sxs-lookup"><span data-stu-id="ce57b-461">When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ReserveAndAppend (data As ArraySegment(Of Byte), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservationCollection As ReservationCollection, ParamArray reservations As Long()) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-462">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-462">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="ce57b-463">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-463">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="ce57b-464">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-464">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="ce57b-465">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-465">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="ce57b-466">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Auflistung enthält, in der Reservierungen vorgenommen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-466">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the collection to make reservations in.</span></span></param>
        <param name="reservations"><span data-ttu-id="ce57b-467">Die vorzunehmenden Reservierungen in Byte.</span><span class="sxs-lookup"><span data-stu-id="ce57b-467">The reservations to make, in bytes.</span></span></param>
        <summary><span data-ttu-id="ce57b-468">Führt beim Überschreiben in einer abgeleiteten Klasse automatisch eine einzelne Reservierung durch und fügt der Sequenz einen Datensatz an.</span><span class="sxs-lookup"><span data-stu-id="ce57b-468">When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.</span></span></summary>
        <returns><span data-ttu-id="ce57b-469">Die Sequenznummer des angefügten Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="ce57b-469">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-470">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-470">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-471">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-471">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="ce57b-472">Die angegebenen Reservierungen werden in einer atomaren Operation mit einem Vorgang zum Anfügen von Datensätzen der bereitgestellten Reservierungsauflistung hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="ce57b-472">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="ce57b-473">Wenn der Anfügevorgang scheitert, wird kein Speicherplatz reserviert.</span><span class="sxs-lookup"><span data-stu-id="ce57b-473">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="ce57b-474">Normalerweise kann diese Methode abgeschlossen werden, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-474">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="ce57b-475">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.IRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="ce57b-475">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-476">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-476">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-477">Beim Anfügen des Datensatzes ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-477">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-478">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten oder die Reservierung auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ce57b-478">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-479">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-479">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ReserveAndAppend (data As IList(Of ArraySegment(Of Byte)), nextUndoRecord As SequenceNumber, previousRecord As SequenceNumber, recordAppendOptions As RecordAppendOptions, reservationCollection As ReservationCollection, ParamArray reservations As Long()) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-480">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-480">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="ce57b-481">Die Sequenznummer des nächsten Datensatzes in der vom Benutzer angegebenen Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-481">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="ce57b-482">Die Sequenznummer des nächsten Datensatzes in vorheriger Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="ce57b-482">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="ce57b-483">Ein gültiger Wert für <see cref="T:System.IO.Log.RecordAppendOptions" />, der angibt, wie die Daten geschrieben werden sollten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-483">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="ce57b-484">Die Reservierungsauflistung, in der Reservierungen vorgenommen werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-484">The reservation collection to make reservations in.</span></span></param>
        <param name="reservations"><span data-ttu-id="ce57b-485">Die vorzunehmenden Reservierungen in Byte.</span><span class="sxs-lookup"><span data-stu-id="ce57b-485">The reservations to make, in bytes.</span></span></param>
        <summary><span data-ttu-id="ce57b-486">Führt beim Überschreiben in einer abgeleiteten Klasse automatisch eine einzelne Reservierung durch und fügt der Sequenz einen Datensatz an.</span><span class="sxs-lookup"><span data-stu-id="ce57b-486">When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.</span></span></summary>
        <returns><span data-ttu-id="ce57b-487">Die Sequenznummer des angefügten Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="ce57b-487">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-488">Die im `data`-Parameter enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-488">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-489">Die Daten können jedoch nicht wieder in Arraysegmente aufgeteilt werden, nachdem der Datensatz gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-489">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="ce57b-490">Die angegebenen Reservierungen werden in einer atomaren Operation mit einem Vorgang zum Anfügen von Datensätzen der bereitgestellten Reservierungsauflistung hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="ce57b-490">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="ce57b-491">Wenn der Anfügevorgang scheitert, wird kein Speicherplatz reserviert.</span><span class="sxs-lookup"><span data-stu-id="ce57b-491">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="ce57b-492">Normalerweise kann diese Methode abgeschlossen werden, bevor der Datensatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-492">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="ce57b-493">Um sicherzustellen, dass ein Datensatz geschrieben wurde, geben Sie entweder das <xref:System.IO.Log.RecordAppendOptions.ForceFlush>-Flag mithilfe des `recordAppendOptions`-Parameters an, oder rufen Sie die <xref:System.IO.Log.IRecordSequence.Flush%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="ce57b-493">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-494">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-494">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-495">Beim Anfügen des Datensatzes ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-495">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-496">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Datensatz zu enthalten oder die Reservierung auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ce57b-496">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-497">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-497">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce57b-498">Ruft beim Überschreiben in einer abgeleiteten Klasse die Gesamtzahl von Byte ab, die reserviert wurden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-498">When overridden in a derived class, gets the total number of bytes that have been reserved.</span></span></summary>
        <value><span data-ttu-id="ce57b-499">Die Gesamtgröße aller in dieser Datensatzsequenz vorgenommenen Reservierungen.</span><span class="sxs-lookup"><span data-stu-id="ce57b-499">The total size of all reservations made in this record sequence.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-500">Auf die Eigenschaft wurde zugegriffen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-500">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce57b-501">Ruft beim Überschreiben in einer abgeleiteten Klasse die Sequenznummer des zuletzt geschriebenen Neustartbereichs ab.</span><span class="sxs-lookup"><span data-stu-id="ce57b-501">When overridden in a derived class, gets the sequence number of the most recently written restart area.</span></span></summary>
        <value><span data-ttu-id="ce57b-502">Die Sequenznummer des zuletzt geschriebenen Neustartbereichs.</span><span class="sxs-lookup"><span data-stu-id="ce57b-502">The sequence number of the most recently written restart area.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-503">Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern.</span><span class="sxs-lookup"><span data-stu-id="ce57b-503">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="ce57b-504">Wenn eine Wiederherstellung erforderlich ist, können Sie den Bereich analysieren, um alle Daten der letzten Prüfpunktoperation zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-504">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="ce57b-505">Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-505">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-506">Auf die Eigenschaft wurde zugegriffen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-506">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce57b-507">Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob Anfügevorgänge automatisch wiederholt werden, wenn das Protokoll voll ist.</span><span class="sxs-lookup"><span data-stu-id="ce57b-507">Gets or sets a value indicating whether appends are automatically retried if the log is full.</span></span></summary>
        <value><span data-ttu-id="ce57b-508"><see langword="true" />, wenn Anfügevorgänge automatisch wiederholt werden, wenn das Protokoll voll ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ce57b-508"><see langword="true" /> if appends are automatically retried if the log is full; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="ce57b-509">Der Standardwert lautet <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="ce57b-509">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-510">Wenn der Wert der Eigenschaft `true` lautet und ein <xref:System.IO.Log.IRecordSequence.Append%2A>-Abruf fehlschlägt, da die Sequenz nicht genügend Speicherplatz aufweist, versucht die Datensatzsequenz, Speicherplatz freizugeben und den Anfügevorgang zu wiederholen.</span><span class="sxs-lookup"><span data-stu-id="ce57b-510">If the value of this property is `true`, and an <xref:System.IO.Log.IRecordSequence.Append%2A> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-511">Auf die Eigenschaft wurde zugegriffen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-511">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.IRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce57b-512">Tritt auf, wenn die Datensatzsequenz bestimmt, dass das Ende vorgerückt werden muss.</span><span class="sxs-lookup"><span data-stu-id="ce57b-512">Occurs when the record sequence determines that the tail must be moved forward.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-513">Sie können dieses Ereignis auslösen, wenn der Datensatzsequenz Speicherplatz ausgegangen ist.</span><span class="sxs-lookup"><span data-stu-id="ce57b-513">You can fire this event when the record sequence has run out of space.</span></span> <span data-ttu-id="ce57b-514">Wenn dieses Ereignis ausgelöst wird, wird das Ende der Sequenz (die Basissequenznummer) nach vorn verschoben, um Speicherplatz freizugeben.</span><span class="sxs-lookup"><span data-stu-id="ce57b-514">When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ce57b-515">Schreibt beim Überschreiben in einer abgeleiteten Klasse einen Neustartbereich in die <see cref="T:System.IO.Log.IRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="ce57b-515">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-516">Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern.</span><span class="sxs-lookup"><span data-stu-id="ce57b-516">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="ce57b-517">Wenn eine Wiederherstellung erforderlich ist, können Sie den Bereich analysieren, um alle Daten der letzten Prüfpunktoperation zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-517">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="ce57b-518">Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-518">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="ce57b-519">Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-519">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-520">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-520">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <summary><span data-ttu-id="ce57b-521">Schreibt beim Überschreiben in einer abgeleiteten Klasse einen Neustartbereich in die <see cref="T:System.IO.Log.IRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="ce57b-521">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" />.</span></span></summary>
        <returns><span data-ttu-id="ce57b-522">Die Sequenznummer des geschriebenen Neustartbereichs.</span><span class="sxs-lookup"><span data-stu-id="ce57b-522">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-523">Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern.</span><span class="sxs-lookup"><span data-stu-id="ce57b-523">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="ce57b-524">Das CLFS (gemeinsames Protokolldateisystem) verwaltet zwei Neustartbereiche, um sicherzustellen, dass mindestens ein gültiger Bereich stets verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="ce57b-524">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="ce57b-525">Wenn eine Wiederherstellung erforderlich ist, liest das CLFS seinen Neustartbereich und alle Daten der letzten Prüfpunktoperation.</span><span class="sxs-lookup"><span data-stu-id="ce57b-525">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="ce57b-526">Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-526">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="ce57b-527">Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-527">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="ce57b-528">Die im Bytearraysegment enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-528">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-529">Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-529">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-530">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-530">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-531">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-531">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-532">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-532">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-533">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-533">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-534">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-534">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <summary><span data-ttu-id="ce57b-535">Schreibt beim Überschreiben in einer abgeleiteten Klasse einen Neustartbereich in die <see cref="T:System.IO.Log.IRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="ce57b-535">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" />.</span></span></summary>
        <returns><span data-ttu-id="ce57b-536">Die Sequenznummer des geschriebenen Neustartbereichs.</span><span class="sxs-lookup"><span data-stu-id="ce57b-536">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-537">Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern.</span><span class="sxs-lookup"><span data-stu-id="ce57b-537">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="ce57b-538">Wenn eine Wiederherstellung erforderlich ist, können Sie den Bereich analysieren, um alle Daten der letzten Prüfpunktoperation zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-538">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="ce57b-539">Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-539">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="ce57b-540">Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-540">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="ce57b-541">Die im Bytearraysegment enthaltenen Daten werden zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-541">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-542">Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-542">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-543">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-543">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-544">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-544">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-545">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-545">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-546">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-546">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-547">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-547">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSequenceNumber"><span data-ttu-id="ce57b-548">Die neue Basissequenznummer.</span><span class="sxs-lookup"><span data-stu-id="ce57b-548">The new base sequence number.</span></span> <span data-ttu-id="ce57b-549">Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-549">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <summary><span data-ttu-id="ce57b-550">Schreibt beim Überschreiben in einer abgeleiteten Klasse einen Neustartbereich in die <see cref="T:System.IO.Log.IRecordSequence" /> und aktualisiert die Basissequenznummer.</span><span class="sxs-lookup"><span data-stu-id="ce57b-550">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" /> and updates the base sequence number.</span></span></summary>
        <returns><span data-ttu-id="ce57b-551">Die Sequenznummer des geschriebenen Neustartbereichs.</span><span class="sxs-lookup"><span data-stu-id="ce57b-551">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-552">Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern.</span><span class="sxs-lookup"><span data-stu-id="ce57b-552">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="ce57b-553">Wenn eine Wiederherstellung erforderlich ist, können Sie den Bereich analysieren, um alle Daten der letzten Prüfpunktoperation zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-553">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="ce57b-554">Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-554">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="ce57b-555">Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-555">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="ce57b-556">Wenn ein Neustartbereich geschrieben wird, werden die im Bytearraysegment enthaltenen Daten zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-556">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-557">Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-557">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="ce57b-558">Wenn diese Methode erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="ce57b-558">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="ce57b-559">Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-559">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-560">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-560">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-561">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-561">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-562">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-562">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-563">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-563">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-564">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-564">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSequenceNumber"><span data-ttu-id="ce57b-565">Die neue Basissequenznummer.</span><span class="sxs-lookup"><span data-stu-id="ce57b-565">The new base sequence number.</span></span> <span data-ttu-id="ce57b-566">Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-566">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <summary><span data-ttu-id="ce57b-567">Schreibt beim Überschreiben in einer abgeleiteten Klasse einen Neustartbereich in die <see cref="T:System.IO.Log.IRecordSequence" /> und aktualisiert die Basissequenznummer.</span><span class="sxs-lookup"><span data-stu-id="ce57b-567">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" /> and updates the base sequence number.</span></span></summary>
        <returns><span data-ttu-id="ce57b-568">Die Sequenznummer des geschriebenen Neustartbereichs.</span><span class="sxs-lookup"><span data-stu-id="ce57b-568">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-569">Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern.</span><span class="sxs-lookup"><span data-stu-id="ce57b-569">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="ce57b-570">Wenn eine Wiederherstellung erforderlich ist, können Sie den Bereich analysieren, um alle Daten der letzten Prüfpunktoperation zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-570">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="ce57b-571">Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-571">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="ce57b-572">Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-572">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="ce57b-573">Wenn ein Neustartbereich geschrieben wird, werden die im Bytearraysegment enthaltenen Daten zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-573">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-574">Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-574">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="ce57b-575">Wenn diese Methode erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="ce57b-575">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="ce57b-576">Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-576">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-577">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-577">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-578">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-578">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-579">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-579">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-580">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-580">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-581">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-581">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSequenceNumber"><span data-ttu-id="ce57b-582">Die neue Basissequenznummer.</span><span class="sxs-lookup"><span data-stu-id="ce57b-582">The new base sequence number.</span></span> <span data-ttu-id="ce57b-583">Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-583">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <param name="reservation"><span data-ttu-id="ce57b-584">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Neustartbereich verwendet werden sollte.</span><span class="sxs-lookup"><span data-stu-id="ce57b-584">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span></span></param>
        <summary><span data-ttu-id="ce57b-585">Schreibt beim Überschreiben in einer abgeleiteten Klasse einen Neustartbereich in die <see cref="T:System.IO.Log.IRecordSequence" /> und aktualisiert die Basissequenznummer mithilfe einer Reservierung.</span><span class="sxs-lookup"><span data-stu-id="ce57b-585">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" /> using a reservation, and updates the base sequence number.</span></span></summary>
        <returns><span data-ttu-id="ce57b-586">Die Sequenznummer des geschriebenen Neustartbereichs.</span><span class="sxs-lookup"><span data-stu-id="ce57b-586">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-587">Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern.</span><span class="sxs-lookup"><span data-stu-id="ce57b-587">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="ce57b-588">Wenn eine Wiederherstellung erforderlich ist, können Sie den Bereich analysieren, um alle Daten der letzten Prüfpunktoperation zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-588">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="ce57b-589">Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-589">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="ce57b-590">Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-590">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="ce57b-591">Wenn ein Neustartbereich geschrieben wird, werden die im Bytearraysegment enthaltenen Daten zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-591">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-592">Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-592">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="ce57b-593">Wenn eine Reservierung angegeben wird, nimmt der geschriebene Neustartbereich, der zuvor mithilfe einer in der Auflistung enthaltenen Reservierung reserviert wurde, Speicherplatz ein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-593">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="ce57b-594">Wenn diese Methode erfolgreich ist, wird die kleinstmögliche Reservierung verwendet, die die Daten aufnehmen kann. Diese Reservierung wird dann aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="ce57b-594">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="ce57b-595">Wenn diese Methode erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="ce57b-595">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="ce57b-596">Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-596">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="ce57b-597">Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="ce57b-597">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="ce57b-598">Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="ce57b-598">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-599">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-599">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-600">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-600">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-601">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-601">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-602">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-602">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="ce57b-603">Eine Liste von Bytearraysegmenten, die verkettet und als Datensatz angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-603">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSequenceNumber"><span data-ttu-id="ce57b-604">Die neue Basissequenznummer.</span><span class="sxs-lookup"><span data-stu-id="ce57b-604">The new base sequence number.</span></span> <span data-ttu-id="ce57b-605">Die angegebene Sequenznummer muss größer oder gleich der aktuellen Basissequenznummer sein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-605">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <param name="reservation"><span data-ttu-id="ce57b-606">Eine <see cref="T:System.IO.Log.ReservationCollection" />, die die Reservierung enthält, die für diesen Neustartbereich verwendet werden sollte.</span><span class="sxs-lookup"><span data-stu-id="ce57b-606">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span></span></param>
        <summary><span data-ttu-id="ce57b-607">Schreibt beim Überschreiben in einer abgeleiteten Klasse einen Neustartbereich in die <see cref="T:System.IO.Log.IRecordSequence" /> und aktualisiert die Basissequenznummer mithilfe einer Reservierung.</span><span class="sxs-lookup"><span data-stu-id="ce57b-607">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" /> using a reservation, and updates the base sequence number.</span></span></summary>
        <returns><span data-ttu-id="ce57b-608">Die Sequenznummer des geschriebenen Neustartbereichs.</span><span class="sxs-lookup"><span data-stu-id="ce57b-608">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce57b-609">Ein Neustartbereich wird verwendet, um Informationen, die die letzte Prüfpunktoperation eines Clients enthalten, vorübergehend zu speichern.</span><span class="sxs-lookup"><span data-stu-id="ce57b-609">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="ce57b-610">Wenn eine Wiederherstellung erforderlich ist, können Sie den Bereich analysieren, um alle Daten der letzten Prüfpunktoperation zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-610">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="ce57b-611">Diese Daten initialisieren die Transaktionstabelle, die Tabelle mit den modifizierten Seiten ('Dirty Pages') und die Liste der geöffneten Dateien, damit diese im Wiederherstellungsprozess verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="ce57b-611">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="ce57b-612">Ein Neustartbereich kann mithilfe der <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>-Methode gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-612">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="ce57b-613">Wenn ein Neustartbereich geschrieben wird, werden die im Bytearraysegment enthaltenen Daten zum Anfügen als Datensatz in einem Array mit einem Byte verkettet.</span><span class="sxs-lookup"><span data-stu-id="ce57b-613">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="ce57b-614">Die Daten können nicht wieder in Arraysegmente aufgeteilt werden, wenn der Neustartbereich gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="ce57b-614">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="ce57b-615">Wenn eine Reservierung angegeben wird, nimmt der geschriebene Neustartbereich, der zuvor mithilfe einer in der Auflistung enthaltenen Reservierung reserviert wurde, Speicherplatz ein.</span><span class="sxs-lookup"><span data-stu-id="ce57b-615">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="ce57b-616">Wenn diese Methode erfolgreich ist, wird die kleinstmögliche Reservierung verwendet, die die Daten aufnehmen kann. Diese Reservierung wird dann aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="ce57b-616">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="ce57b-617">Wenn diese Methode erfolgreich abgeschlossen wird, wurde die Basissequenznummer aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="ce57b-617">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="ce57b-618">Auf alle Protokolldatensätze mit Sequenznummern, die kleiner als die neue Basissequenznummer sind, kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="ce57b-618">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="ce57b-619">Wenn eine Datensatzsequenz verworfen wurde oder wenn Sie ein ungültiges Argument weitergeben, werden unmittelbar während dieses Vorgangs Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="ce57b-619">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="ce57b-620">Während einer asynchronen Anfügeanforderung auftretende Fehler, z.&#160;B. Fehler auf dem Datenträger während der E/A-Anforderung, lösen beim Aufruf der <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>-Methode Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="ce57b-620">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce57b-621">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ce57b-621">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ce57b-622">Beim Schreiben des Neustartbereichs ist ein E/A-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-622">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="ce57b-623">Die Datensatzsequenz konnte nicht genügend freien Speicherplatz bereitstellen, um den neuen Neustartbereich zu enthalten.</span><span class="sxs-lookup"><span data-stu-id="ce57b-623">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ce57b-624">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="ce57b-624">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
