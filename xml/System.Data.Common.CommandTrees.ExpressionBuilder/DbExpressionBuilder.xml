<Type Name="DbExpressionBuilder" FullName="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6d8807c3ddb2e1e55233eaa58e13129f4c8116ed" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53493234" /></Metadata><TypeSignature Language="C#" Value="public static class DbExpressionBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit DbExpressionBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Module DbExpressionBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class DbExpressionBuilder abstract sealed" />
  <TypeSignature Language="F#" Value="type DbExpressionBuilder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine API bereit, um <see cref="T:System.Data.Common.CommandTrees.DbExpression" />s zu erstellen, und lässt zu, dass auf diese API als Erweiterungsmethoden für den Ausdruckstyp selbst zugegriffen werden kann.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Aggregate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionAggregate Aggregate (this System.Data.Metadata.Edm.EdmFunction function, System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionAggregate Aggregate(class System.Data.Metadata.Edm.EdmFunction function, class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Aggregate(System.Data.Metadata.Edm.EdmFunction,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate (function As EdmFunction, argument As DbExpression) As DbFunctionAggregate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFunctionAggregate ^ Aggregate(System::Data::Metadata::Edm::EdmFunction ^ function, System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Data.Metadata.Edm.EdmFunction * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbFunctionAggregate" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Aggregate (function, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionAggregate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="function">Die Funktion, die die Aggregatoperation definiert.</param>
        <param name="argument">Das Argument, über dem die Aggregatfunktion berechnet werden sollte.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbFunctionAggregate" />.</summary>
        <returns>Ein neues Funktionsaggregat mit einem Verweis auf das Argument und der angegebenen Funktion. Die Distinct-Eigenschaft des Funktionsaggregats wird den Wert <see langword="false" /> besitzen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> oder <paramref name="argument" /> NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="function" /> ist keine Aggregatfunktion oder weist mehrere Argumente auf, oder der Ergebnistyp von <paramref name="argument" /> ist nicht gleich dem Parametertyp von <paramref name="function" /> und kann auch nicht zu diesem heraufgestuft werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="AggregateDistinct">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionAggregate AggregateDistinct (this System.Data.Metadata.Edm.EdmFunction function, System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionAggregate AggregateDistinct(class System.Data.Metadata.Edm.EdmFunction function, class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.AggregateDistinct(System.Data.Metadata.Edm.EdmFunction,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AggregateDistinct (function As EdmFunction, argument As DbExpression) As DbFunctionAggregate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFunctionAggregate ^ AggregateDistinct(System::Data::Metadata::Edm::EdmFunction ^ function, System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member AggregateDistinct : System.Data.Metadata.Edm.EdmFunction * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbFunctionAggregate" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.AggregateDistinct (function, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionAggregate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="function">Die Funktion, die die Aggregatoperation definiert.</param>
        <param name="argument">Das Argument, über dem die Aggregatfunktion berechnet werden sollte.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbFunctionAggregate" />, das in einer unterschiedlichen Weise angewendet wird.</summary>
        <returns>Ein neues Funktionsaggregat mit einem Verweis auf das Argument und der angegebenen Funktion. Die Distinct-Eigenschaft des Funktionsaggregats wird den Wert <see langword="true" /> besitzen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> oder <paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="function" /> ist keine Aggregatfunktion oder weist mehrere Argumente auf, oder der Ergebnistyp von <paramref name="argument" /> ist nicht gleich dem Parametertyp von <paramref name="function" /> und kann auch nicht zu diesem heraufgestuft werden.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="All">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" />, der bestimmt, ob das angegebene Prädikat für alle Element des Eingabesets gültig ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression All (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression All(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.All(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All (source As DbExpression, predicate As Func(Of DbExpression, DbExpression)) As DbQuantifierExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbQuantifierExpression ^ All(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member All : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbQuantifierExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.All (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <param name="predicate">Eine Methode, die ein Prädikat darstellt, das für jeden Member des Eingabesets ausgewertet werden soll.    Diese Methode muss einen Ausdruck mit einem booleschen Ergebnistyp erzeugen, der die Prädikatlogik bereitstellt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" />, der bestimmt, ob das angegebene Prädikat für alle Element des Eingabesets gültig ist.</summary>
        <returns>Ein neues DbQuantifierExpression, das den All-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist NULL.

- oder - 

Der von <paramref name="predicate" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> weist keinen Auflistungsergebnistyp auf.

- oder - 

Der von <paramref name="Predicate" /> erzeugte Ausdruck besitzt keinen booleschen Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression All (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression All(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.All(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All (input As DbExpressionBinding, predicate As DbExpression) As DbQuantifierExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbQuantifierExpression ^ All(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpression ^ predicate);" />
      <MemberSignature Language="F#" Value="static member All : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbQuantifierExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.All (input, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="predicate" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Eine Ausdrucksbindung, die das Eingabeset angibt.</param>
        <param name="predicate">Ein Ausdruck, der ein Prädikat darstellt, das für jeden Member des Eingabesets ausgewertet werden soll.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" />, der bestimmt, ob das angegebene Prädikat für alle Element des Eingabesets gültig ist.</summary>
        <returns>Ein neues DbQuantifierExpression, das den All-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="predicate" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="predicate" /> weist keinen booleschen Ergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbAndExpression And (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbAndExpression And(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.And(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function And (left As DbExpression, right As DbExpression) As DbAndExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbAndExpression ^ And(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member And : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbAndExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.And (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbAndExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein boolescher Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein boolescher Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt einen <see cref="T:System.Data.Common.CommandTrees.DbAndExpression" />, der die logische AND-Operation für das linke und das rechte Argument ausführt.</summary>
        <returns>Ein neues DbAndExpression mit den angegebenen Argumenten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="left" /> und <paramref name="right" /> weisen keinen booleschen Ergebnistyp auf.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Any">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die bestimmt, ob das angegebene Mengenargument nicht leer ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpression Any (this System.Data.Common.CommandTrees.DbExpression source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpression Any(class System.Data.Common.CommandTrees.DbExpression source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any (source As DbExpression) As DbExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExpression ^ Any(System::Data::Common::CommandTrees::DbExpression ^ source);" />
      <MemberSignature Language="F#" Value="static member Any : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die bestimmt, ob das angegebene Mengenargument nicht leer ist.</summary>
        <returns>Ein neues <see cref="T:System.Data.Common.CommandTrees.DbNotExpression" />, angewendet auf ein neues <see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression" /> mit dem angegebenen Argument.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> weist keinen Auflistungsergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression Any (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression Any(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any (source As DbExpression, predicate As Func(Of DbExpression, DbExpression)) As DbQuantifierExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbQuantifierExpression ^ Any(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Any : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbQuantifierExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <param name="predicate">Eine Methode, die ein Prädikat darstellt, das für jeden Member des Eingabesets ausgewertet werden soll. Diese Methode muss einen Ausdruck mit einem booleschen Ergebnistyp erzeugen, der die Prädikatlogik bereitstellt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" />, die bestimmt, ob das angegebene Prädikat für jedes beliebige Element des Eingabesets gültig ist.</summary>
        <returns>Ein neues DbQuantifierExpression, das den Any-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist NULL.

- oder - 

Der von <paramref name="predicate" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> weist keinen Auflistungsergebnistyp auf.

- oder -  
Der von <paramref name="predicate" /> erzeugte Ausdruck besitzt keinen booleschen Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbQuantifierExpression Any (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbQuantifierExpression Any(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any (input As DbExpressionBinding, predicate As DbExpression) As DbQuantifierExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbQuantifierExpression ^ Any(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpression ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Any : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbQuantifierExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Any (input, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbQuantifierExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="predicate" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Eine Ausdrucksbindung, die das Eingabeset angibt.</param>
        <param name="predicate">Ein Ausdruck, der ein Prädikat darstellt, das für jeden Member des Eingabesets ausgewertet werden soll.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbQuantifierExpression" />, die bestimmt, ob das angegebene Prädikat für jedes beliebige Element des Eingabesets gültig ist.</summary>
        <returns>Ein neues DbQuantifierExpression, das den Any-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="predicate" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der von <paramref name="predicate" /> erzeugte Ausdruck besitzt keinen booleschen Ergebnistyp.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="As">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die angegebenen Argumente als Schlüssel-Wert-Paar-Objekt zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="As">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbAggregate&gt; As (this System.Data.Common.CommandTrees.DbAggregate value, string alias);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbAggregate&gt; As(class System.Data.Common.CommandTrees.DbAggregate value, string alias) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.As(System.Data.Common.CommandTrees.DbAggregate,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function As (value As DbAggregate, alias As String) As KeyValuePair(Of String, DbAggregate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbAggregate ^&gt; As(System::Data::Common::CommandTrees::DbAggregate ^ value, System::String ^ alias);" />
      <MemberSignature Language="F#" Value="static member As : System.Data.Common.CommandTrees.DbAggregate * string -&gt; System.Collections.Generic.KeyValuePair&lt;string, System.Data.Common.CommandTrees.DbAggregate&gt;" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.As (value, alias)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbAggregate&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.CommandTrees.DbAggregate" RefType="this" />
        <Parameter Name="alias" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert im Schlüssel-Wert-Paar.</param>
        <param name="alias">Der Schlüssel im Schlüssel-Wert-Paar.</param>
        <summary>Gibt die angegebenen Argumente als Schlüssel-Wert-Paar-Objekt zurück.</summary>
        <returns>Ein Schlüssel-Wert-Paar-Objekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="As">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt; As (this System.Data.Common.CommandTrees.DbExpression value, string alias);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt; As(class System.Data.Common.CommandTrees.DbExpression value, string alias) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.As(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function As (value As DbExpression, alias As String) As KeyValuePair(Of String, DbExpression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbExpression ^&gt; As(System::Data::Common::CommandTrees::DbExpression ^ value, System::String ^ alias);" />
      <MemberSignature Language="F#" Value="static member As : System.Data.Common.CommandTrees.DbExpression * string -&gt; System.Collections.Generic.KeyValuePair&lt;string, System.Data.Common.CommandTrees.DbExpression&gt;" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.As (value, alias)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="alias" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert im Schlüssel-Wert-Paar.</param>
        <param name="alias">Der Schlüssel im Schlüssel-Wert-Paar.</param>
        <summary>Gibt die angegebenen Argumente als Schlüssel-Wert-Paar-Objekt zurück.</summary>
        <returns>Ein Schlüssel-Wert-Paar-Objekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpressionBinding Bind (this System.Data.Common.CommandTrees.DbExpression input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpressionBinding Bind(class System.Data.Common.CommandTrees.DbExpression input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Bind(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Bind (input As DbExpression) As DbExpressionBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExpressionBinding ^ Bind(System::Data::Common::CommandTrees::DbExpression ^ input);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbExpressionBinding" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Bind input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="input">Der zu bindende Ausdruck.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" />, die den angegebene Ausdruck mithilfe eines generierten Variablennamens bindet.</summary>
        <returns>Eine neue Ausdrucksbindung mit dem angegebenen Ausdruck und einem generierten Variablennamen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="input" /> weist keinen Auflistungsergebnis auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="BindAs">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpressionBinding BindAs (this System.Data.Common.CommandTrees.DbExpression input, string varName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpressionBinding BindAs(class System.Data.Common.CommandTrees.DbExpression input, string varName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.BindAs(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BindAs (input As DbExpression, varName As String) As DbExpressionBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExpressionBinding ^ BindAs(System::Data::Common::CommandTrees::DbExpression ^ input, System::String ^ varName);" />
      <MemberSignature Language="F#" Value="static member BindAs : System.Data.Common.CommandTrees.DbExpression * string -&gt; System.Data.Common.CommandTrees.DbExpressionBinding" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.BindAs (input, varName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="varName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Der zu bindende Ausdruck.</param>
        <param name="varName">Der Variablenname, der für die Bindung verwendet werden soll.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" />, die den angegebene Ausdruck mithilfe eines angegebenen Variablennamens bindet.</summary>
        <returns>Eine neue Ausdrucksbindung mit dem angegebenen Ausdruck und dem Variablennamen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="varName" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="input" /> weist keinen Auflistungsergebnis auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="Case">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbCaseExpression Case (System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; whenExpressions, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; thenExpressions, System.Data.Common.CommandTrees.DbExpression elseExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbCaseExpression Case(class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; whenExpressions, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; thenExpressions, class System.Data.Common.CommandTrees.DbExpression elseExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Case(System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression},System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression},System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Function Case (whenExpressions As IEnumerable(Of DbExpression), thenExpressions As IEnumerable(Of DbExpression), elseExpression As DbExpression) As DbCaseExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbCaseExpression ^ Case(System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ whenExpressions, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ thenExpressions, System::Data::Common::CommandTrees::DbExpression ^ elseExpression);" />
      <MemberSignature Language="F#" Value="static member Case : seq&lt;System.Data.Common.CommandTrees.DbExpression&gt; * seq&lt;System.Data.Common.CommandTrees.DbExpression&gt; * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbCaseExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Case (whenExpressions, thenExpressions, elseExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbCaseExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="whenExpressions" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="thenExpressions" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="elseExpression" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="whenExpressions">Eine Liste von Ausdrücken, die die einzelnen case-Bedingungen bereitstellen.</param>
        <param name="thenExpressions">Eine Liste von Ausdrücken, die die Ergebnisse der einzelnen case-Bedingungen bereitstellen.</param>
        <param name="elseExpression">Ein Ausdruck, der das Ergebnis definiert, wenn keine case-Bedingung erfüllt wird.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbCaseExpression" />.</summary>
        <returns>Ein neues DbCaseExpression mit den angegebenen Fällen und dem standardmäßigen Ergebnis.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="whenExpressions" /> oder <paramref name="thenExpressions" /> ist NULL oder NULL enthält oder <paramref name="elseExpression" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="whenExpressions" /> oder <paramref name="thenExpressions" /> ist leer, oder <paramref name="whenExpressions" /> enthält einen Ausdruck mit einem nicht booleschen Ergebnistyp, oder es ist kein gemeinsamer Ergebnistyp für alle Ausdrücke in <paramref name="thenExpressions" /> und <paramref name="elseExpression" /> vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="CastTo">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbCastExpression CastTo (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage toType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbCastExpression CastTo(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage toType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CastTo(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CastTo (argument As DbExpression, toType As TypeUsage) As DbCastExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbCastExpression ^ CastTo(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ toType);" />
      <MemberSignature Language="F#" Value="static member CastTo : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.TypeUsage -&gt; System.Data.Common.CommandTrees.DbCastExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CastTo (argument, toType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbCastExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="toType" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Das Argument, das umgewandelt werden soll.</param>
        <param name="toType">Die Typmetadaten, die den umzuwandelnden Typ angeben.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbCastExpression" />, der eine Umwandlungsoperation auf ein polymorphes Argument anwendet.</summary>
        <returns>Ein neues DbCastExpression mit dem angegebenen Argument und dem Zieltyp.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="Argument" /> oder <paramref name="toType" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Die angegebene Umwandlung ist ungültig.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Constant (value As Object) As DbConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Constant : obj -&gt; System.Data.Common.CommandTrees.DbConstantExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Constant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Der darzustellende konstante Wert.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> mit dem angegebenen Konstantenwert.</summary>
        <returns>Ein neues DbConstantExpression mit dem angegebenen Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> ist keine Instanz eines gültigen konstanten Typs.</exception>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression Constant (this System.Data.Metadata.Edm.TypeUsage constantType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbConstantExpression Constant(class System.Data.Metadata.Edm.TypeUsage constantType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Constant(System.Data.Metadata.Edm.TypeUsage,System.Object)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Constant (constantType As TypeUsage, value As Object) As DbConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbConstantExpression ^ Constant(System::Data::Metadata::Edm::TypeUsage ^ constantType, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Constant : System.Data.Metadata.Edm.TypeUsage * obj -&gt; System.Data.Common.CommandTrees.DbConstantExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Constant (constantType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constantType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="constantType">Der Typ des konstanten Werts.</param>
        <param name="value">Der darzustellende konstante Wert.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> vom angegebenen primitiven Typ mit dem angegebenen konstanten Wert.</summary>
        <returns>Ein neues DbConstantExpression mit dem angegebenen Wert und einen Ergebnistyp <paramref name="constantType" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> oder <paramref name="constantType" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> ist keine Instanz eines gültigen konstanten Typs, <paramref name="constantType" /> stellt keinen primitiven Typ dar, oder <paramref name="value" /> ist von einem anderen primitiven Typ als dem durch <paramref name="constantType" /> dargestellten.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRef">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" />, der einen Verweis auf eine bestimmte Entität eines angegebenen Typs auf Grundlage von Schlüsselwerten codiert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ CreateRef(System::Data::Metadata::Edm::EntitySet ^ entitySet, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ keyValues);" />
      <MemberSignature Language="F#" Value="static member CreateRef : System.Data.Metadata.Edm.EntitySet * seq&lt;System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbRefExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef (entitySet, keyValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="entitySet">Die Entitätenmenge mit dem Element, auf das verwiesen wird.</param>
        <param name="keyValues">Eine Sammlung von <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die die Schlüsselwerte angeben. Diese Ausdrücke müssen (hinsichtlich Anzahl, Typ und Reihenfolge) mit den Schlüsseleigenschaften des Entitätstyps übereinstimmen, auf den verwiesen wird.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" />, das einen Verweis auf eine bestimmte Entität auf der Grundlage der Schlüsselwerte codiert.</summary>
        <returns>Ein neues DbRefExpression, das das Element mit den angegebenen Schlüsselwerten im angegebenen Entitätssatz verweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entitySet" /> ist NULL, oder <paramref name="keyValues" /> ist NULL bzw. enthält NULL.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl von <paramref name="keyValues" /> entspricht nicht der Anzahl von Hauptmembern, die vom Elementtyp von <paramref name="entitySet" /> deklariert wurde, oder <paramref name="keyValues" /> enthält einen Ausdruck mit einem Ergebnistyp, der nicht mit dem Typ des entsprechenden Hauptmembers kompatibel ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, params System.Data.Common.CommandTrees.DbExpression[] keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Common.CommandTrees.DbExpression[] keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ CreateRef(System::Data::Metadata::Edm::EntitySet ^ entitySet, ... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ keyValues);" />
      <MemberSignature Language="F#" Value="static member CreateRef : System.Data.Metadata.Edm.EntitySet * System.Data.Common.CommandTrees.DbExpression[] -&gt; System.Data.Common.CommandTrees.DbRefExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef (entitySet, keyValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyValues" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entitySet">Die Entitätenmenge mit dem Element, auf das verwiesen wird.</param>
        <param name="keyValues">Eine Sammlung von <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die die Schlüsselwerte angeben. Diese Ausdrücke müssen (hinsichtlich Anzahl, Typ und Reihenfolge) mit den Schlüsseleigenschaften des Entitätstyps übereinstimmen, auf den verwiesen wird.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" />, das einen Verweis auf eine bestimmte Entität auf der Grundlage der Schlüsselwerte codiert.</summary>
        <returns>Ein neues DbRefExpression, das das Element mit den angegebenen Schlüsselwerten im angegebenen Entitätssatz verweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entitySet" /> ist NULL, oder <paramref name="keyValues" /> ist NULL bzw. enthält NULL.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl von <paramref name="keyValues" /> entspricht nicht der Anzahl von Hauptmembern, die vom Elementtyp von <paramref name="entitySet" /> deklariert wurde, oder <paramref name="keyValues" /> enthält einen Ausdruck mit einem Ergebnistyp, der nicht mit dem Typ des entsprechenden Hauptmembers kompatibel ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Metadata.Edm.EntityType entityType, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Metadata.Edm.EntityType entityType, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Data.Metadata.Edm.EntityType,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ CreateRef(System::Data::Metadata::Edm::EntitySet ^ entitySet, System::Data::Metadata::Edm::EntityType ^ entityType, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ keyValues);" />
      <MemberSignature Language="F#" Value="static member CreateRef : System.Data.Metadata.Edm.EntitySet * System.Data.Metadata.Edm.EntityType * seq&lt;System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbRefExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef (entitySet, entityType, keyValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="entityType" Type="System.Data.Metadata.Edm.EntityType" />
        <Parameter Name="keyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="entitySet">Die Entitätenmenge mit dem Element, auf das verwiesen wird.</param>
        <param name="entityType">Der spezifische Typ der Entität, auf die verwiesen wird. Dies muss ein Entitätstyp aus der gleichen Hierarchie wie der Elementtyp der Entitätenmenge sein.</param>
        <param name="keyValues">Eine Sammlung von <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die die Schlüsselwerte angeben. Diese Ausdrücke müssen (hinsichtlich Anzahl, Typ und Reihenfolge) mit den Schlüsseleigenschaften des Entitätstyps übereinstimmen, auf den verwiesen wird.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" />, der einen Verweis auf eine bestimmte Entität eines angegebenen Typs auf Grundlage von Schlüsselwerten codiert.</summary>
        <returns>Ein neues DbRefExpression, das das Element mit den angegebenen Schlüsselwerten im angegebenen Entitätssatz verweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entitySet" /> oder <paramref name="entityType" /> ist NULL oder <paramref name="keyValues" /> ist NULL oder enthält NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="entityType" /> stammt nicht aus derselben Typhierarchie (Untertyp, Übertyp oder gleicher Typ) wie der Elementtyp von <paramref name="entitySet" />.

- oder - 

Die Anzahl von <paramref name="keyValues" /> entspricht nicht der Anzahl von Hauptmembern, die vom Elementtyp von <paramref name="entitySet" /> deklariert wurde, oder <paramref name="keyValues" /> enthält einen Ausdruck mit einem Ergebnistyp, der nicht mit dem Typ des entsprechenden Hauptmembers kompatibel ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression CreateRef (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Metadata.Edm.EntityType entityType, params System.Data.Common.CommandTrees.DbExpression[] keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression CreateRef(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Metadata.Edm.EntityType entityType, class System.Data.Common.CommandTrees.DbExpression[] keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef(System.Data.Metadata.Edm.EntitySet,System.Data.Metadata.Edm.EntityType,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ CreateRef(System::Data::Metadata::Edm::EntitySet ^ entitySet, System::Data::Metadata::Edm::EntityType ^ entityType, ... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ keyValues);" />
      <MemberSignature Language="F#" Value="static member CreateRef : System.Data.Metadata.Edm.EntitySet * System.Data.Metadata.Edm.EntityType * System.Data.Common.CommandTrees.DbExpression[] -&gt; System.Data.Common.CommandTrees.DbRefExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CreateRef (entitySet, entityType, keyValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="entityType" Type="System.Data.Metadata.Edm.EntityType" />
        <Parameter Name="keyValues" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entitySet">Die Entitätenmenge mit dem Element, auf das verwiesen wird.</param>
        <param name="entityType">Der spezifische Typ der Entität, auf die verwiesen wird. Dies muss ein Entitätstyp aus der gleichen Hierarchie wie der Elementtyp der Entitätenmenge sein.</param>
        <param name="keyValues">Eine Sammlung von <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die die Schlüsselwerte angeben. Diese Ausdrücke müssen (hinsichtlich Anzahl, Typ und Reihenfolge) mit den Schlüsseleigenschaften des Entitätstyps übereinstimmen, auf den verwiesen wird.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" />, der einen Verweis auf eine bestimmte Entität eines angegebenen Typs auf Grundlage von Schlüsselwerten codiert.</summary>
        <returns>Ein neues DbRefExpression, das das Element mit den angegebenen Schlüsselwerten im angegebenen Entitätssatz verweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entitySet" /> oder <paramref name="entityType" /> ist NULL oder <paramref name="keyValues" /> ist NULL oder enthält NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="entityType" /> stammt nicht aus derselben Typhierarchie (Untertyp, Übertyp oder gleicher Typ) wie der Elementtyp von <paramref name="entitySet" />.

- oder - 

Die Anzahl von <paramref name="keyValues" /> entspricht nicht der Anzahl von Hauptmembern, die vom Elementtyp von <paramref name="entitySet" /> deklariert wurde, oder <paramref name="keyValues" /> enthält einen Ausdruck mit einem Ergebnistyp, der nicht mit dem Typ des entsprechenden Hauptmembers kompatibel ist.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CrossApply">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" />, die den angegebenen <paramref name="apply" />-Ausdruck für jedes Element eines angegebenen Eingabesets einmal auswertet und eine Auflistung von Zeilen mit entsprechenden Eingabe- und apply-Spalten erzeugt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CrossApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression CrossApply (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression CrossApply(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossApply(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossApply (source As DbExpression, apply As Func(Of DbExpression, KeyValuePair(Of String, DbExpression))) As DbApplyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbApplyExpression ^ CrossApply(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbExpression ^&gt;&gt; ^ apply);" />
      <MemberSignature Language="F#" Value="static member CrossApply : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Collections.Generic.KeyValuePair&lt;string, System.Data.Common.CommandTrees.DbExpression&gt;&gt; -&gt; System.Data.Common.CommandTrees.DbApplyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossApply (source, apply)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die das Eingabeset angibt.</param>
        <param name="apply">Eine Methode, die die Logik angibt, die für jeden Member des Eingabesets einmal ausgewertet wird.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" />, die den angegebenen <paramref name="apply" />-Ausdruck für jedes Element eines angegebenen Eingabesets einmal auswertet und eine Auflistung von Zeilen mit entsprechenden Eingabe- und apply-Spalten erzeugt. Zeilen, für die <paramref name="apply" /> als leerer Satz ausgewertet wird, werden nicht eingeschlossen.</summary>
        <returns>Ein neues DbApplyExpression mit der angegebenen Eingabe und Anwenden von Bindungen und ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von CrossApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="apply" /> ist NULL.

- oder - 

Das Ergebnis von <paramref name="apply" /> enthält einen Namen oder Ausdruck, der Null ist.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> weist keinen Auflistungsergebnistyp auf.

- oder -  
Das Ergebnis von <paramref name="apply" /> enthält einen Namen oder Ausdruck, der in einer Ausdrucksbindung ungültig ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="CrossApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression CrossApply (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpressionBinding apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression CrossApply(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpressionBinding apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossApply(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CrossApply (input As DbExpressionBinding, apply As DbExpressionBinding) As DbApplyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbApplyExpression ^ CrossApply(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpressionBinding ^ apply);" />
      <MemberSignature Language="F#" Value="static member CrossApply : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpressionBinding -&gt; System.Data.Common.CommandTrees.DbApplyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossApply (input, apply)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="apply" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
      </Parameters>
      <Docs>
        <param name="input">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" />, der das Eingabeset angibt.</param>
        <param name="apply">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" />, die die Logik angibt, die für jeden Member des Eingabesets einmal ausgewertet wird.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" />, die den angegebenen <paramref name="apply" />-Ausdruck für jedes Element eines angegebenen Eingabesets einmal auswertet und eine Auflistung von Zeilen mit entsprechenden Eingabe- und apply-Spalten erzeugt. Zeilen, für die <paramref name="apply" /> als leerer Satz ausgewertet wird, werden nicht eingeschlossen.</summary>
        <returns>Ein neues DbApplyExpression mit der angegebenen Eingabe und Anwenden von Bindungen und ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von CrossApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="apply" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="CrossJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbCrossJoinExpression CrossJoin (System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpressionBinding&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbCrossJoinExpression CrossJoin(class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpressionBinding&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossJoin(System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpressionBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Function CrossJoin (inputs As IEnumerable(Of DbExpressionBinding)) As DbCrossJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbCrossJoinExpression ^ CrossJoin(System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpressionBinding ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="static member CrossJoin : seq&lt;System.Data.Common.CommandTrees.DbExpressionBinding&gt; -&gt; System.Data.Common.CommandTrees.DbCrossJoinExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.CrossJoin inputs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbCrossJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpressionBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="inputs">Eine Liste von Ausdrucksbindungen, die die Eingabesets angibt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbCrossJoinExpression" />, der die in der Liste der Eingabeausdrucksbindungen angegebenen Sets bedingungslos verknüpft.</summary>
        <returns>Ein neues DbCrossJoinExpression, mit einem <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von CrossJoin, das den unbedingten Join der Eingabesätze darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="inputs" /> ist NULL oder enthält NULL Element.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="inputs" /> enthält weniger als zwei Ausdrucksbindungen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deref">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbDerefExpression Deref (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbDerefExpression Deref(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Deref(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Deref (argument As DbExpression) As DbDerefExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbDerefExpression ^ Deref(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member Deref : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbDerefExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Deref argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbDerefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der den Verweis bereitstellt. Dieser Ausdruck muss einen Verweistyp aufweisen.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbDerefExpression" />, der eine bestimmte Entität abruft, wenn ein Verweisausdruck angegeben wird.</summary>
        <returns>Ein neues DbDerefExpression, das die angegebene Entität abruft.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="argument" /> weist keinen Verweisergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbDistinctExpression Distinct (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbDistinctExpression Distinct(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Distinct(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct (argument As DbExpression) As DbDistinctExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbDistinctExpression ^ Distinct(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member Distinct : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbDistinctExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Distinct argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbDistinctExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der die Menge definiert, über der die eindeutige Operation ausgeführt werden soll.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbDistinctExpression" />, der Duplikate aus dem angegebenen Mengenargument entfernt.</summary>
        <returns>Ein neues DbDistinctExpression, das den bestimmten Vorgang darstellt, der auf das angegebene Mengenargument angewendet wurde.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="argument" /> weist keinen Auflistungsergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Divide (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Divide(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Divide(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Divide (left As DbExpression, right As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Divide(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbArithmeticExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Divide (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" />, die das linke Argument durch das rechte Argument dividiert.</summary>
        <returns>Ein neues DbArithmeticExpression, der die Division darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Zwischen <paramref name="left" /> oder <paramref name="right" /> ist kein gemeinsamer numerischer Ergebnistyp vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Element">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbElementExpression Element (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbElementExpression Element(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Element(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Element (argument As DbExpression) As DbElementExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbElementExpression ^ Element(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member Element : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbElementExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Element argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbElementExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der das Eingabeset angibt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbElementExpression" />, der eine Menge in ein Singleton konvertiert.</summary>
        <returns>Eine DbElementExpression, die die Konvertierung des angegebenen Mengenarguments in ein Singleton darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="argument" /> weist keinen Auflistungsergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression Equal (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression Equal(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Equal(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Equal (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ Equal(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbComparisonExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Equal (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" />, die das linke und das rechte Argument auf Gleichheit vergleicht.</summary>
        <returns>Ein neues DbComparisonExpression, das den Gleichheitsvergleich darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Zwischen <paramref name="left" /> und <paramref name="right" /> ist kein allgemeiner, auf Gleichheit vergleichbarer Ergebnistyp vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExceptExpression Except (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExceptExpression Except(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Except(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except (left As DbExpression, right As DbExpression) As DbExceptExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExceptExpression ^ Except(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Except : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbExceptExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Except (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExceptExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Mengenargument definiert.</param>
        <param name="right">Ein Ausdruck, der das rechte Mengenargument definiert.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbExceptExpression" />, die das rechte Mengenargument vom linken Mengenargument subtrahiert.</summary>
        <returns>Ein neues DbExceptExpression, das den Unterschied zwischen dem linken und dem rechten Argument darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Zwischen <paramref name="left" /> und <paramref name="right" /> ist kein allgemeiner Auflistungsergebnistyp vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpression Exists (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpression Exists(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Exists(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Exists (argument As DbExpression) As DbExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExpression ^ Exists(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member Exists : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Exists argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der das Eingabeset angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die bestimmt, ob das angegebene Mengenargument nicht leer ist.</summary>
        <returns>Ein neues <see cref="T:System.Data.Common.CommandTrees.DbNotExpression" />, angewendet auf ein neues <see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression" /> mit dem angegebenen Argument.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="argument" /> weist keinen Auflistungsergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="False">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression False { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Data.Common.CommandTrees.DbConstantExpression False" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.False" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property False As DbConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Data::Common::CommandTrees::DbConstantExpression ^ False { System::Data::Common::CommandTrees::DbConstantExpression ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.False : System.Data.Common.CommandTrees.DbConstantExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.False" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> mit dem booleschen Wert <see langword="false" /> ab.</summary>
        <value>Eine <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> mit dem booleschen Wert <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFilterExpression Filter (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFilterExpression Filter(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Filter(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Filter (input As DbExpressionBinding, predicate As DbExpression) As DbFilterExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFilterExpression ^ Filter(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpression ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Filter : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbFilterExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Filter (input, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFilterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="predicate" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Eine Ausdrucksbindung, die das Eingabeset angibt.</param>
        <param name="predicate">Ein Ausdruck, der ein Prädikat darstellt, das für jeden Member des Eingabesets ausgewertet werden soll.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbFilterExpression" />, der die Elemente im angegebenen Eingabeset mithilfe des angegebenen Prädikats filtert.</summary>
        <returns>Ein neues DbFilterExpression, der die gefilterte Menge erzeugt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="predicate" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="predicate" /> weist keinen booleschen Ergebnistyp auf.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FullOuterJoin">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" />, der die durch den linken und rechten Ausdruck angegebenen set-Argumente bei der angegebenen Joinbedingung verknüpft und dabei FullOuterJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> verwendet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FullOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.FullOuterJoin(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FullOuterJoin (left As DbExpression, right As DbExpression, joinCondition As Func(Of DbExpression, DbExpression, DbExpression)) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ FullOuterJoin(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ joinCondition);" />
      <MemberSignature Language="F#" Value="static member FullOuterJoin : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbJoinExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.FullOuterJoin (left, right, joinCondition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="joinCondition" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der das linke set-Argument angibt.</param>
        <param name="right">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der das rechte set-Argument angibt.</param>
        <param name="joinCondition">Eine Methode, die die Bedingung darstellt, bei der die Verknüpfung stattfinden soll. Diese Methode muss einen Ausdruck mit einem booleschen Ergebnistyp erzeugen, der die Logik der Joinbedingung bereitstellt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" />, der die durch den linken und rechten Ausdruck angegebenen set-Argumente bei der angegebenen Joinbedingung verknüpft und dabei FullOuterJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> verwendet.</summary>
        <returns>Ein neuer DbJoinExpression mit FullOuterJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />, der den vollständigen äußeren Joinvorgang darstellt, der unter der angegebenen Joinbedingung auf das linke und rechte Eingabeset angewendet wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />, <paramref name="right" /> oder <paramref name="joinCondition" /> ist NULL.

- oder - 

Der von <paramref name="joinCondition" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="left" /> bzw. <paramref name="right" /> weist keinen Sammlungsergebnistyp auf.

- oder -  
Der von <paramref name="joinCondition" /> erzeugte Ausdruck besitzt keinen booleschen Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin (this System.Data.Common.CommandTrees.DbExpressionBinding left, System.Data.Common.CommandTrees.DbExpressionBinding right, System.Data.Common.CommandTrees.DbExpression joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression FullOuterJoin(class System.Data.Common.CommandTrees.DbExpressionBinding left, class System.Data.Common.CommandTrees.DbExpressionBinding right, class System.Data.Common.CommandTrees.DbExpression joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.FullOuterJoin(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FullOuterJoin (left As DbExpressionBinding, right As DbExpressionBinding, joinCondition As DbExpression) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ FullOuterJoin(System::Data::Common::CommandTrees::DbExpressionBinding ^ left, System::Data::Common::CommandTrees::DbExpressionBinding ^ right, System::Data::Common::CommandTrees::DbExpression ^ joinCondition);" />
      <MemberSignature Language="F#" Value="static member FullOuterJoin : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbJoinExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.FullOuterJoin (left, right, joinCondition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
        <Parameter Name="joinCondition" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" />, die das linke Mengenargument angibt.</param>
        <param name="right">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" />, die das rechte Mengenargument angibt.</param>
        <param name="joinCondition">Ein Ausdruck, der die Bedingung für den Join angibt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" />, der die von der linken und der rechten Ausdrucksbindung in der angegebenen Joinbedingung festgelegten Mengen verknüpft, indem FullOuterJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> verwendet wird.</summary>
        <returns>Eine neue DbJoinExpression-Klasse mit FullOuterJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />-Enumeration, die den vollständigen äußeren Joinvorgang darstellt, der unter der angegebenen Joinbedingung auf das linke und rechte Eingabeset angewendet wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />, <paramref name="right" /> oder <paramref name="joinCondition" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der von <paramref name="joinCondition" /> erzeugte Ausdruck besitzt keinen booleschen Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEntityRef">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbEntityRefExpression GetEntityRef (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbEntityRefExpression GetEntityRef(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GetEntityRef(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetEntityRef (argument As DbExpression) As DbEntityRefExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbEntityRefExpression ^ GetEntityRef(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member GetEntityRef : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbEntityRefExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GetEntityRef argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbEntityRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Der Ausdruck, der die Entität bereitstellt. Dieser Ausdruck muss einen Entitätsergebnistyp aufweisen.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbEntityRefExpression" />, die den Verweis der angegebenen Entität in struktureller Form abruft.</summary>
        <returns>Ein neues DbEntityRefExpression, das einen Verweis auf die angegebene Entität abruft.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="argument" /> weist keinen Entitätsergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRefKey">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefKeyExpression GetRefKey (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefKeyExpression GetRefKey(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GetRefKey(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetRefKey (argument As DbExpression) As DbRefKeyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefKeyExpression ^ GetRefKey(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member GetRefKey : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbRefKeyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GetRefKey argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefKeyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Der Ausdruck, der den Verweis bereitstellt. Dieser Ausdruck muss einen Verweistyp mit einem Entitätselementtyp aufweisen.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbRefKeyExpression" />, der die Schlüsselwerte des angegebenen Verweises in struktureller Form abruft.</summary>
        <returns>Ein neues DbRefKeyExpression, das die Schlüsselwerte des angegebenen Verweises abruft.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="argument" /> weist keinen Verweisergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression GreaterThan (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression GreaterThan(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GreaterThan(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GreaterThan (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ GreaterThan(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbComparisonExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GreaterThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" />, die bestimmt, ob das linke Argument größer als das rechte Argument ist.</summary>
        <returns>Ein neues DbComparisonExpression, das das Größer-als-Vergleich darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Zwischen <paramref name="left" /> und <paramref name="right" /> ist kein allgemeiner, auf Reihenfolge vergleichbarer Ergebnistyp vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression GreaterThanOrEqual (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression GreaterThanOrEqual(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GreaterThanOrEqual(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GreaterThanOrEqual (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ GreaterThanOrEqual(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbComparisonExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GreaterThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" />, die bestimmt, ob das linke Argument größer oder gleich dem rechten Argument ist.</summary>
        <returns>Ein neues DbComparisonExpression, das das Größer-als-oder-gleich-Vergleich darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Zwischen <paramref name="left" /> und <paramref name="right" /> ist kein allgemeiner, auf Reihenfolge vergleichbarer Ergebnistyp vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBind">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBind (this System.Data.Common.CommandTrees.DbExpression input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBind(class System.Data.Common.CommandTrees.DbExpression input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBind(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBind (input As DbExpression) As DbGroupExpressionBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbGroupExpressionBinding ^ GroupBind(System::Data::Common::CommandTrees::DbExpression ^ input);" />
      <MemberSignature Language="F#" Value="static member GroupBind : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbGroupExpressionBinding" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBind input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbGroupExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="input">Der zu bindende Ausdruck.</param>
        <summary>Erstellt eine neue Gruppenausdrucksbindung, die den angegebenen Ausdruck mithilfe generierter Variablen- und Gruppenvariablennamen bindet.</summary>
        <returns>Eine neue Gruppenausdrucksbindung mit dem angegebenen Ausdruck und einem generierten Variablennamen und Gruppenvariablennamen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="input" /> weist keinen Auflistungsergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBindAs">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBindAs (this System.Data.Common.CommandTrees.DbExpression input, string varName, string groupVarName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbGroupExpressionBinding GroupBindAs(class System.Data.Common.CommandTrees.DbExpression input, string varName, string groupVarName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBindAs(System.Data.Common.CommandTrees.DbExpression,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBindAs (input As DbExpression, varName As String, groupVarName As String) As DbGroupExpressionBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbGroupExpressionBinding ^ GroupBindAs(System::Data::Common::CommandTrees::DbExpression ^ input, System::String ^ varName, System::String ^ groupVarName);" />
      <MemberSignature Language="F#" Value="static member GroupBindAs : System.Data.Common.CommandTrees.DbExpression * string * string -&gt; System.Data.Common.CommandTrees.DbGroupExpressionBinding" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBindAs (input, varName, groupVarName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbGroupExpressionBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="varName" Type="System.String" />
        <Parameter Name="groupVarName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Der zu bindende Ausdruck.</param>
        <param name="varName">Der Variablenname, der für die Bindung verwendet werden soll.</param>
        <param name="groupVarName">Der Variablenname, der als Verweis auf die Gruppe verwendet werden soll, wenn die neue Gruppenausdrucksbindung in einem GROUP BY-Ausdruck verwendet wird.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbGroupExpressionBinding" />, die den angegebenen Ausdruck mithilfe des angegebenen Variablennamens und der angegebenen Gruppenvariablennamen bindet.</summary>
        <returns>Eine neue Gruppenausdrucksbindung mit dem angegebenen Ausdruck, mit dem Variablennamen und dem Gruppenvariablennamen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="varName" /> oder <paramref name="groupVarName" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="input" /> weist keinen Auflistungsergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbGroupByExpression GroupBy (this System.Data.Common.CommandTrees.DbGroupExpressionBinding input, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; keys, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbAggregate&gt;&gt; aggregates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbGroupByExpression GroupBy(class System.Data.Common.CommandTrees.DbGroupExpressionBinding input, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; keys, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbAggregate&gt;&gt; aggregates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBy(System.Data.Common.CommandTrees.DbGroupExpressionBinding,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbAggregate}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy (input As DbGroupExpressionBinding, keys As IEnumerable(Of KeyValuePair(Of String, DbExpression)), aggregates As IEnumerable(Of KeyValuePair(Of String, DbAggregate))) As DbGroupByExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbGroupByExpression ^ GroupBy(System::Data::Common::CommandTrees::DbGroupExpressionBinding ^ input, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbExpression ^&gt;&gt; ^ keys, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbAggregate ^&gt;&gt; ^ aggregates);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Data.Common.CommandTrees.DbGroupExpressionBinding * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, System.Data.Common.CommandTrees.DbExpression&gt;&gt; * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, System.Data.Common.CommandTrees.DbAggregate&gt;&gt; -&gt; System.Data.Common.CommandTrees.DbGroupByExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.GroupBy (input, keys, aggregates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbGroupByExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbGroupExpressionBinding" RefType="this" />
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
        <Parameter Name="aggregates" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbAggregate&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="input">Eine <see cref="T:System.Data.Common.CommandTrees.DbGroupExpressionBinding" />, die das Eingabeset angibt.</param>
        <param name="keys">Eine Liste von Zeichenfolge-Ausdruck-Paaren, die die Gruppierungsspalten definieren.</param>
        <param name="aggregates">Eine Liste von Ausdrücken, die anzuwendende Aggregate angeben.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbGroupByExpression" />, der die Elemente des Eingabesets nach den angegebenen Gruppenschlüsseln gruppiert und die angegebenen Aggregate anwendet.</summary>
        <returns>Ein neues DbGroupByExpression mit dem angegebenen Eingabeset, Gruppierungsschlüssel und Aggregate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 "DbGroupByExpression" ermöglicht es der Liste der Schlüssel oder die Liste der Aggregate leer sein, aber nicht beides.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="keys" /> oder <paramref name="aggregates" /> ist NULL, <paramref name="keys" /> enthält einen NULL-Spaltenschlüssel oder -Ausdruck, oder <paramref name="aggregates" /> enthält einen aggregierten NULL-Spaltennamen oder ein solches Aggregat.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keys" /> und auch <paramref name="aggregates" /> sind leer, oder ein ungültiger oder doppelter Spaltenname wurde angegeben.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="InnerJoin">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" />, der die vom linken und vom rechten Ausdruck in der angegebenen Joinbedingung festgelegten Mengen verknüpft, indem InnerJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> verwendet wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InnerJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression InnerJoin (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression InnerJoin(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.InnerJoin(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function InnerJoin (left As DbExpression, right As DbExpression, joinCondition As Func(Of DbExpression, DbExpression, DbExpression)) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ InnerJoin(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ joinCondition);" />
      <MemberSignature Language="F#" Value="static member InnerJoin : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbJoinExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.InnerJoin (left, right, joinCondition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="joinCondition" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der das linke set-Argument angibt.</param>
        <param name="right">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der das rechte set-Argument angibt.</param>
        <param name="joinCondition">Eine Methode, die die Bedingung darstellt, bei der die Verknüpfung stattfinden soll. Diese Methode muss einen Ausdruck mit einem booleschen Ergebnistyp erzeugen, der die Logik der Joinbedingung bereitstellt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" />, der die vom linken und vom rechten Ausdruck in der angegebenen Joinbedingung festgelegten Mengen verknüpft, indem InnerJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> verwendet wird.</summary>
        <returns>Ein neues DbJoinExpression, mit <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von FullOuterJoin, der den Vorgang des vollständigen äußeren Join darstellt, der auf den linken und rechten Eingabesets unter der angegebenen Joinbedingung angewendet wurde.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />, <paramref name="right" /> oder <paramref name="joinCondition" /> ist NULL.

- oder - 

Der von <paramref name="joinCondition" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="left" /> bzw. <paramref name="right" /> weist keinen Sammlungsergebnistyp auf.

- oder - 

Der von <paramref name="joinCondition" /> erzeugte Ausdruck besitzt keinen booleschen Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression InnerJoin (this System.Data.Common.CommandTrees.DbExpressionBinding left, System.Data.Common.CommandTrees.DbExpressionBinding right, System.Data.Common.CommandTrees.DbExpression joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression InnerJoin(class System.Data.Common.CommandTrees.DbExpressionBinding left, class System.Data.Common.CommandTrees.DbExpressionBinding right, class System.Data.Common.CommandTrees.DbExpression joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.InnerJoin(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function InnerJoin (left As DbExpressionBinding, right As DbExpressionBinding, joinCondition As DbExpression) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ InnerJoin(System::Data::Common::CommandTrees::DbExpressionBinding ^ left, System::Data::Common::CommandTrees::DbExpressionBinding ^ right, System::Data::Common::CommandTrees::DbExpression ^ joinCondition);" />
      <MemberSignature Language="F#" Value="static member InnerJoin : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbJoinExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.InnerJoin (left, right, joinCondition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
        <Parameter Name="joinCondition" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" />, die das linke Mengenargument angibt.</param>
        <param name="right">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" />, die das rechte Mengenargument angibt.</param>
        <param name="joinCondition">Ein Ausdruck, der die Bedingung für den Join angibt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" />, der die von der linken und der rechten Ausdrucksbindung in der angegebenen Joinbedingung festgelegten Mengen verknüpft, indem InnerJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> verwendet wird.</summary>
        <returns>Eine neue DbJoinExpression-Klasse, mit InnerJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />-Enumeration, die den Vorgang des vollständigen äußeren Joins darstellt, der auf den linken und rechten Eingabesets unter der angegebenen Joinbedingung angewendet wurde.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />, <paramref name="right" /> oder <paramref name="joinCondition" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="joinCondition" /> weist keinen booleschen Ergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIntersectExpression Intersect (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIntersectExpression Intersect(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Intersect(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect (left As DbExpression, right As DbExpression) As DbIntersectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbIntersectExpression ^ Intersect(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbIntersectExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Intersect (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIntersectExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Mengenargument definiert.</param>
        <param name="right">Ein Ausdruck, der das rechte Mengenargument definiert.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbIntersectExpression" />, die die Schnittmenge der linken und der rechten Mengenargumente berechnet.</summary>
        <returns>Ein neues DbIntersectExpression, das die Schnittmenge der linken und der rechten Argumente berechnet.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Zwischen <paramref name="left" /> oder <paramref name="right" /> ist kein allgemeiner Auflistungsergebnistyp vorhanden.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbLambdaExpression" />, der die Anwendung der angegebenen Lambda-Funktion auf die angegebenen Argumente darstellt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambdaExpression Invoke (this System.Data.Common.CommandTrees.DbLambda lambda, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambdaExpression Invoke(class System.Data.Common.CommandTrees.DbLambda lambda, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Common.CommandTrees.DbLambda,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Invoke (lambda As DbLambda, arguments As IEnumerable(Of DbExpression)) As DbLambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLambdaExpression ^ Invoke(System::Data::Common::CommandTrees::DbLambda ^ lambda, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Data.Common.CommandTrees.DbLambda * seq&lt;System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbLambdaExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke (lambda, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lambda" Type="System.Data.Common.CommandTrees.DbLambda" RefType="this" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="lambda">Eine <see cref="T:System.Data.Common.CommandTrees.DbLambda" />-Instanz, die die anzuwendende Lambda-Funktion darstellt.</param>
        <param name="arguments">Eine Liste von Ausdrücken, die die Argumente bereitstellen.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbLambdaExpression" />, der die Anwendung der angegebenen Lambda-Funktion auf die angegebenen Argumente darstellt.</summary>
        <returns>Ein neues DbLambdaExpression, das die Lambda-Funktions-Anwendung darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="lambda" /> oder <paramref name="arguments" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl von <paramref name="arguments" /> entspricht der Anzahl der Variablen nicht, die von <paramref name="lambda" /> deklariert wurde, oder <paramref name="arguments" /> enthält einen Ausdruck, der einen Ergebnistyp hat, der nicht gleich dem entsprechenden Variablentyp ist und auch nicht entsprechend heraufgestuft werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambdaExpression Invoke (this System.Data.Common.CommandTrees.DbLambda lambda, params System.Data.Common.CommandTrees.DbExpression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambdaExpression Invoke(class System.Data.Common.CommandTrees.DbLambda lambda, class System.Data.Common.CommandTrees.DbExpression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Common.CommandTrees.DbLambda,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Invoke (lambda As DbLambda, ParamArray arguments As DbExpression()) As DbLambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLambdaExpression ^ Invoke(System::Data::Common::CommandTrees::DbLambda ^ lambda, ... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Data.Common.CommandTrees.DbLambda * System.Data.Common.CommandTrees.DbExpression[] -&gt; System.Data.Common.CommandTrees.DbLambdaExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke (lambda, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lambda" Type="System.Data.Common.CommandTrees.DbLambda" RefType="this" />
        <Parameter Name="arguments" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="lambda">Eine <see cref="T:System.Data.Common.CommandTrees.DbLambda" />-Instanz, die die anzuwendende Lambda-Funktion darstellt.</param>
        <param name="arguments">Ausdrücke, die die Argumente bereitstellen.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbLambdaExpression" />, der die Anwendung der angegebenen Lambda-Funktion auf die angegebenen Argumente darstellt.</summary>
        <returns>Ein neues DbLambdaExpression, das die Lambda-Funktions-Anwendung darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="lambda" /> oder <paramref name="arguments" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl von <paramref name="arguments" /> entspricht der Anzahl der Variablen nicht, die von <paramref name="lambda" /> deklariert wurde, oder <paramref name="arguments" /> enthält einen Ausdruck, der einen Ergebnistyp hat, der nicht gleich dem entsprechenden Variablentyp ist und auch nicht entsprechend heraufgestuft werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionExpression Invoke (this System.Data.Metadata.Edm.EdmFunction function, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionExpression Invoke(class System.Data.Metadata.Edm.EdmFunction function, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Metadata.Edm.EdmFunction,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Invoke (function As EdmFunction, arguments As IEnumerable(Of DbExpression)) As DbFunctionExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFunctionExpression ^ Invoke(System::Data::Metadata::Edm::EdmFunction ^ function, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Data.Metadata.Edm.EdmFunction * seq&lt;System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbFunctionExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke (function, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Metadaten für die aufzurufende Funktion.</param>
        <param name="arguments">Eine Liste von Ausdrücken, die die Argumente für die Funktion bereitstellen.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbFunctionExpression" />, die den Aufruf der angegebenen Funktion mit den angegebenen Argumenten darstellt.</summary>
        <returns>Eine neue DbFunctionExpression, die den Funktionsaufruf darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> ist NULL, oder <paramref name="arguments" /> ist NULL bzw. enthält NULL.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der <paramref name="arguments" /> entspricht nicht der Anzahl der von <paramref name="function" /> deklarierten Parameter, oder <paramref name="arguments" /> enthält einen Ausdruck, dessen Ergebnistyp nicht gleich dem entsprechenden Funktionsparametertyp bzw. nicht dazu heraufstufbar ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFunctionExpression Invoke (this System.Data.Metadata.Edm.EdmFunction function, params System.Data.Common.CommandTrees.DbExpression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFunctionExpression Invoke(class System.Data.Metadata.Edm.EdmFunction function, class System.Data.Common.CommandTrees.DbExpression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke(System.Data.Metadata.Edm.EdmFunction,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Invoke (function As EdmFunction, ParamArray arguments As DbExpression()) As DbFunctionExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFunctionExpression ^ Invoke(System::Data::Metadata::Edm::EdmFunction ^ function, ... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Data.Metadata.Edm.EdmFunction * System.Data.Common.CommandTrees.DbExpression[] -&gt; System.Data.Common.CommandTrees.DbFunctionExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Invoke (function, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFunctionExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Data.Metadata.Edm.EdmFunction" RefType="this" />
        <Parameter Name="arguments" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="function">Metadaten für die aufzurufende Funktion.</param>
        <param name="arguments">Ausdrücke, die die Argumente für die Funktion bereitstellen.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbFunctionExpression" />, die den Aufruf der angegebenen Funktion mit den angegebenen Argumenten darstellt.</summary>
        <returns>Eine neue DbFunctionExpression, die den Funktionsaufruf darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> ist NULL, oder <paramref name="arguments" /> ist NULL bzw. enthält NULL.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der <paramref name="arguments" /> entspricht nicht der Anzahl der von <paramref name="function" /> deklarierten Parameter, oder <paramref name="arguments" /> enthält einen Ausdruck, dessen Ergebnistyp nicht gleich dem entsprechenden Funktionsparametertyp bzw. nicht dazu heraufstufbar ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsEmptyExpression IsEmpty (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsEmptyExpression IsEmpty(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsEmpty(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsEmpty (argument As DbExpression) As DbIsEmptyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbIsEmptyExpression ^ IsEmpty(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member IsEmpty : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbIsEmptyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsEmpty argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsEmptyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der das Eingabeset angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression" />, die bestimmt, ob das angegebene Mengenargument ein leerer Satz ist.</summary>
        <returns>Ein neues DbIsEmptyExpression mit dem angegebenen Argument.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="argument" /> weist keinen Auflistungsergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsNullExpression IsNull (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsNullExpression IsNull(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsNull(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsNull (argument As DbExpression) As DbIsNullExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbIsNullExpression ^ IsNull(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member IsNull : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbIsNullExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsNull argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsNullExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der das Argument angibt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbIsNullExpression" />, der bestimmt, ob das angegebene Argument NULL ist.</summary>
        <returns>Ein neues DbIsEmptyExpression mit dem angegebenen Argument.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="argument" /> weist einen Auflistungsergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsOf">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsOfExpression IsOf (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsOfExpression IsOf(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsOf(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsOf (argument As DbExpression, type As TypeUsage) As DbIsOfExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbIsOfExpression ^ IsOf(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ type);" />
      <MemberSignature Language="F#" Value="static member IsOf : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.TypeUsage -&gt; System.Data.Common.CommandTrees.DbIsOfExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsOf (argument, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsOfExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der die Instanz angibt.</param>
        <param name="type">Typmetadaten, die den Typ angeben, mit denen der Ergebnistyp der Instanz verglichen werden soll.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbIsOfExpression" />, die bestimmt, ob das angegebene Argument vom angegebenen Typ oder einem Untertyp ist.</summary>
        <returns>Ein neues DbIsOfExpression mit der angegebenen Instanz und dem Typ und DbExpressionKind IsOf.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbIsOfExpression erfordert, dass `argument` verfügt über einen polymorphen Ergebnistyp und, `type` ist ein Typ aus der gleichen Typhierarchie wie dieser Ergebnistyp.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> oder <paramref name="type" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> befindet sich nicht in der gleichen Typenhierarchie wie der Ergebnistyp von <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsOfOnly">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbIsOfExpression IsOfOnly (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbIsOfExpression IsOfOnly(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsOfOnly(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsOfOnly (argument As DbExpression, type As TypeUsage) As DbIsOfExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbIsOfExpression ^ IsOfOnly(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ type);" />
      <MemberSignature Language="F#" Value="static member IsOfOnly : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.TypeUsage -&gt; System.Data.Common.CommandTrees.DbIsOfExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.IsOfOnly (argument, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbIsOfExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der die Instanz angibt.</param>
        <param name="type">Typmetadaten, die den Typ angeben, mit denen der Ergebnistyp der Instanz verglichen werden soll.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbIsOfExpression" />-Ausdruck, der bestimmt, ob das angegebene Argument vom angegebenen Typ und ausschließlich von diesem Typ (kein Untertyp) ist.</summary>
        <returns>Ein neues DbIsOfExpression mit der angegebenen Instanz und dem Typ und DbExpressionKind IsOfOnly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbIsOfExpression erfordert, dass `argument` verfügt über einen polymorphen Ergebnistyp und, `type` ist ein Typ aus der gleichen Typhierarchie wie dieser Ergebnistyp.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> oder <paramref name="type" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> befindet sich nicht in der gleichen Typenhierarchie wie der Ergebnistyp von <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression Join (this System.Data.Common.CommandTrees.DbExpression outer, System.Data.Common.CommandTrees.DbExpression inner, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; outerKey, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; innerKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression Join(class System.Data.Common.CommandTrees.DbExpression outer, class System.Data.Common.CommandTrees.DbExpression inner, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; outerKey, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; innerKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Join(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join (outer As DbExpression, inner As DbExpression, outerKey As Func(Of DbExpression, DbExpression), innerKey As Func(Of DbExpression, DbExpression)) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ Join(System::Data::Common::CommandTrees::DbExpression ^ outer, System::Data::Common::CommandTrees::DbExpression ^ inner, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ outerKey, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ innerKey);" />
      <MemberSignature Language="F#" Value="static member Join : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbJoinExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Join (outer, inner, outerKey, innerKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="outer" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="inner" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="outerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="innerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="outer">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die das äußere Mengenargument angibt.</param>
        <param name="inner">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die das innere Mengenargument angibt.</param>
        <param name="outerKey">Eine Methode, die angibt, wie der Wert des äußeren Schlüssels von einem Element der äußeren Menge abgeleitet werden sollte.</param>
        <param name="innerKey">Eine Methode, die angibt, wie der Wert des inneren Schlüssels von einem Element der inneren Menge abgeleitet werden sollte.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" />, die die von den äußeren und inneren Ausdrücken angegebenen Mengen nach einer Gleichheitsbedingung zwischen den angegebenen äußeren und inneren Schlüsseln verknüpft, wobei InnerJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> verwendet wird.</summary>
        <returns>Eine neue DbJoinExpression mit einer <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von InnerJoin, die den Vorgang der inneren Verknüpfung darstellt, der auf den linken und rechten Eingabeset unter einer Verknüpfungsbedingung, die die Werte des äußeren und inneren Schlüssels auf Gleichheit vergleicht, angewendet wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKey" /> oder <paramref name="innerKey" /> ist NULL.

- oder -  
Der von <paramref name="outerKey" /> oder <paramref name="innerKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="outer" /> bzw. <paramref name="inner" /> weist keinen Sammlungsergebnistyp auf.

- oder - 

Die von <paramref name="outerKey" /> und <paramref name="innerKey" /> erzeugten Ausdrücke sind nicht auf Gleichheit vergleichbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TSelector&gt;">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression Join&lt;TSelector&gt; (this System.Data.Common.CommandTrees.DbExpression outer, System.Data.Common.CommandTrees.DbExpression inner, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; outerKey, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; innerKey, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression Join&lt;TSelector&gt;(class System.Data.Common.CommandTrees.DbExpression outer, class System.Data.Common.CommandTrees.DbExpression inner, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; outerKey, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; innerKey, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, !!TSelector&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Join``1(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TSelector) (outer As DbExpression, inner As DbExpression, outerKey As Func(Of DbExpression, DbExpression), innerKey As Func(Of DbExpression, DbExpression), selector As Func(Of DbExpression, DbExpression, TSelector)) As DbProjectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSelector&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbProjectExpression ^ Join(System::Data::Common::CommandTrees::DbExpression ^ outer, System::Data::Common::CommandTrees::DbExpression ^ inner, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ outerKey, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ innerKey, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^, TSelector&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Join : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression, 'Selector&gt; -&gt; System.Data.Common.CommandTrees.DbProjectExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Join (outer, inner, outerKey, innerKey, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSelector" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="inner" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="outerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="innerKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="selector" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSelector">Der Typ des <paramref name="selector" />.</typeparam>
        <param name="outer">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die das äußere Mengenargument angibt.</param>
        <param name="inner">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die das innere Mengenargument angibt.</param>
        <param name="outerKey">Eine Methode, die angibt, wie der Wert des äußeren Schlüssels von einem Element der äußeren Menge abgeleitet werden sollte.</param>
        <param name="innerKey">Eine Methode, die angibt, wie der Wert des inneren Schlüssels von einem Element der inneren Menge abgeleitet werden sollte.</param>
        <param name="selector">Eine Methode, die angibt, wie ein Element des Resultsets von Elementen der inneren und äußeren Menge abgeleitet werden sollte. Diese Methode muss eine Instanz eines Typs produzieren, der mit „Join“ kompatibel ist und in eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> aufgelöst werden kann. Anforderungen an die Kompatibilität für <c>TSelector</c> werden in den Hinweisen beschrieben.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" />, die den angegebenen Selektor über die von den äußeren und inneren Ausdrücken angegebenen Mengen projiziert, verknüpft nach einer Gleichheitsbedingung zwischen den angegebenen äußeren und inneren Schlüsseln, wobei InnerJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> verwendet wird.</summary>
        <returns>Eine neue DbProjectExpression mit dem angegebenen Selektor als Projektion und eine neue DbJoinExpression als Eingabe. Die eingegebene DbJoinExpression wird mit einer <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von InnerJoin erstellt, die den Vorgang der inneren Verknüpfung darstellt, der auf den linken und rechten Eingabeset unter einer Verknüpfungsbedingung, die die Werte des äußeren und inneren Schlüssels auf Gleichheit vergleicht, angewendet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Als kompatibel mit Join `TSelector` abgeleitet werden, von <xref:System.Data.Common.CommandTrees.DbExpression>, oder muss ein anonymer Typ mit von DbExpression abgeleiteten Eigenschaften. Im folgenden sind Beispiele für unterstützte Typen für `TSelector`:  
  
```  
outer.Join(inner, o => o.Property("ID"), i => i.Property("ID"), (o, i) => o.Property("Name"))  
```  
  
 (`TSelector` ist <xref:System.Data.Common.CommandTrees.DbPropertyExpression>).  
  
```  
outer.Join(inner, o => o.Property("ID"), i => i.Property("ID"), (o, i) => new { OName = o.Property("Name"), IName = i.Property("Name") })  
```  
  
 (`TSelector` ist ein anonymer Typ mit von DbExpression abgeleiteten Eigenschaften).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKey" />, <paramref name="innerKey" /> oder <paramref name="selector" /> ist NULL.

- oder - 

Der von <paramref name="outerKey" /> oder <paramref name="innerKey" /> erzeugte Ausdruck ist NULL.

- oder - 

Das Ergebnis von <paramref name="selector" /> nach der Konvertierung in DbExpression ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="outer" /> bzw. <paramref name="inner" /> weist keinen Sammlungsergebnistyp auf.

- oder - 

Die von <paramref name="outerKey" /> und <paramref name="innerKey" /> erzeugten Ausdrücke sind nicht auf Gleichheit vergleichbar.

- oder -  
Das Ergebnis von <paramref name="selector" /> ist nicht kompatibel mit SelectMany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> mit den angegebenen Inline-Lambda-Funktionsimplementierungs- und formalen Parametern.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambda Lambda (System.Data.Common.CommandTrees.DbExpression body, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambda Lambda(class System.Data.Common.CommandTrees.DbExpression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Lambda(System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbVariableReferenceExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Function Lambda (body As DbExpression, variables As IEnumerable(Of DbVariableReferenceExpression)) As DbLambda" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbLambda ^ Lambda(System::Data::Common::CommandTrees::DbExpression ^ body, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbVariableReferenceExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Data.Common.CommandTrees.DbExpression * seq&lt;System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt; -&gt; System.Data.Common.CommandTrees.DbLambda" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Lambda (body, variables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambda</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbVariableReferenceExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Ein Ausdruck, der die Logik der Lambda-Funktion definiert.</param>
        <param name="variables">Eine <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression" />-Sammlung, die die formalen Parameter der Lambda-Funktion darstellt. Die Verwendung dieser Variablen im <paramref name="body" />-Ausdruck ist zulässig.</param>
        <summary>Erstellt eine <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> mit den angegebenen Inline-Lambda-Funktionsimplementierungs- und formalen Parametern.</summary>
        <returns>Ein neues DbLambda, das eine Inline- Lambda-Funktion mit dem angegebenen Text und den formalen Parametern beschreibt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variables" /> ist NULL oder enthält NULL oder  <paramref name="body" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variables" /> enthält mehr als ein Element mit dem gleichen Variablennamen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLambda Lambda (System.Data.Common.CommandTrees.DbExpression body, params System.Data.Common.CommandTrees.DbVariableReferenceExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLambda Lambda(class System.Data.Common.CommandTrees.DbExpression body, class System.Data.Common.CommandTrees.DbVariableReferenceExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Lambda(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbVariableReferenceExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Lambda (body As DbExpression, ParamArray variables As DbVariableReferenceExpression()) As DbLambda" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbLambda ^ Lambda(System::Data::Common::CommandTrees::DbExpression ^ body, ... cli::array &lt;System::Data::Common::CommandTrees::DbVariableReferenceExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbVariableReferenceExpression[] -&gt; System.Data.Common.CommandTrees.DbLambda" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Lambda (body, variables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLambda</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="variables" Type="System.Data.Common.CommandTrees.DbVariableReferenceExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Ein Ausdruck, der die Logik der Lambda-Funktion definiert.</param>
        <param name="variables">Eine <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression" />-Sammlung, die die formalen Parameter der Lambda-Funktion darstellt. Die Verwendung dieser Variablen im <paramref name="body" />-Ausdruck ist zulässig.</param>
        <summary>Erstellt eine <see cref="T:System.Data.Common.CommandTrees.DbLambda" /> mit den angegebenen Inline-Lambda-Funktionsimplementierungs- und formalen Parametern.</summary>
        <returns>Ein neues DbLambda, das eine Inline- Lambda-Funktion mit dem angegebenen Text und den formalen Parametern beschreibt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variables" /> ist NULL oder enthält NULL oder  <paramref name="body" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variables" /> enthält mehr als ein Element mit dem gleichen Variablennamen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftOuterJoin">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" />, der die vom linken und vom rechten Ausdruck in der angegebenen Joinbedingung festgelegten Mengen verknüpft, indem LeftOuterJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> verwendet wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LeftOuterJoin(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LeftOuterJoin (left As DbExpression, right As DbExpression, joinCondition As Func(Of DbExpression, DbExpression, DbExpression)) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ LeftOuterJoin(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ joinCondition);" />
      <MemberSignature Language="F#" Value="static member LeftOuterJoin : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbJoinExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LeftOuterJoin (left, right, joinCondition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="joinCondition" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der das linke set-Argument angibt.</param>
        <param name="right">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der das rechte set-Argument angibt.</param>
        <param name="joinCondition">Eine Methode, die die Bedingung darstellt, bei der die Verknüpfung stattfinden soll. Diese Methode muss einen Ausdruck mit einem booleschen Ergebnistyp erzeugen, der die Logik der Joinbedingung bereitstellt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" />, der die vom linken und vom rechten Ausdruck in der angegebenen Joinbedingung festgelegten Mengen verknüpft, indem LeftOuterJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> verwendet wird.</summary>
        <returns>Ein neues DbJoinExpression, mit <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von LeftOuterJoin, der den Vorgang des linken äußeren Join darstellt, der auf den linken und rechten Eingabesets unter der angegebenen Joinbedingung angewendet wurde.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />, <paramref name="right" /> oder <paramref name="joinCondition" /> ist NULL.

- oder - 

Der von <paramref name="joinCondition" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="left" /> bzw. <paramref name="right" /> weist keinen Sammlungsergebnistyp auf.

- oder - 

Der von <paramref name="joinCondition" /> erzeugte Ausdruck besitzt keinen booleschen Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftOuterJoin">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin (this System.Data.Common.CommandTrees.DbExpressionBinding left, System.Data.Common.CommandTrees.DbExpressionBinding right, System.Data.Common.CommandTrees.DbExpression joinCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbJoinExpression LeftOuterJoin(class System.Data.Common.CommandTrees.DbExpressionBinding left, class System.Data.Common.CommandTrees.DbExpressionBinding right, class System.Data.Common.CommandTrees.DbExpression joinCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LeftOuterJoin(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LeftOuterJoin (left As DbExpressionBinding, right As DbExpressionBinding, joinCondition As DbExpression) As DbJoinExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbJoinExpression ^ LeftOuterJoin(System::Data::Common::CommandTrees::DbExpressionBinding ^ left, System::Data::Common::CommandTrees::DbExpressionBinding ^ right, System::Data::Common::CommandTrees::DbExpression ^ joinCondition);" />
      <MemberSignature Language="F#" Value="static member LeftOuterJoin : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbJoinExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LeftOuterJoin (left, right, joinCondition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbJoinExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
        <Parameter Name="joinCondition" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" />, die das linke Mengenargument angibt.</param>
        <param name="right">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" />, die das rechte Mengenargument angibt.</param>
        <param name="joinCondition">Ein Ausdruck, der die Bedingung für den Join angibt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbJoinExpression" />, der die von der linken und der rechten Ausdrucksbindung in der angegebenen Joinbedingung festgelegten Mengen verknüpft, indem LeftOuterJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> verwendet wird.</summary>
        <returns>Eine neue DbJoinExpression-Klasse, mit LeftOuterJoin als <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" />-Enumeration, die den Vorgang des linken äußeren Joins darstellt, der auf den linken und rechten Eingabesets unter der angegebenen Joinbedingung angewendet wurde.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" />, <paramref name="right" /> oder <paramref name="joinCondition" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="joinCondition" /> weist keinen booleschen Ergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression LessThan (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression LessThan(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LessThan(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LessThan (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ LessThan(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbComparisonExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LessThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" />, die bestimmt, ob das linke Argument kleiner als das rechte Argument ist.</summary>
        <returns>Ein neues DbComparisonExpression, das den Kleiner-als-Vergleich darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Zwischen <paramref name="left" /> und <paramref name="right" /> ist kein allgemeiner, auf Reihenfolge vergleichbarer Ergebnistyp vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression LessThanOrEqual (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression LessThanOrEqual(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LessThanOrEqual(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LessThanOrEqual (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ LessThanOrEqual(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbComparisonExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.LessThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" />, die bestimmt, ob das linke Argument kleiner oder gleich dem rechten Argument ist.</summary>
        <returns>Ein neues DbComparisonExpression, das das Kleiner-als-oder-gleich-Vergleich darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Zwischen <paramref name="left" /> und <paramref name="right" /> ist kein allgemeiner Ergebnistyp, der sowohl auf Gleichheit als auch auf Reihenfolge vergleichbar ist, vorhanden.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Like">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbLikeExpression" />, die die angegebene Eingabezeichenfolge mit dem angegebenen Muster vergleicht.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Like">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLikeExpression Like (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLikeExpression Like(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Like(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Like (argument As DbExpression, pattern As DbExpression) As DbLikeExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLikeExpression ^ Like(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Common::CommandTrees::DbExpression ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Like : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbLikeExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Like (argument, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLikeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="pattern" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der die Eingabezeichenfolge angibt.</param>
        <param name="pattern">Ein Ausdruck, der die Musterzeichenfolge angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbLikeExpression" />, die die angegebene Eingabezeichenfolge mit dem angegebenen Muster vergleicht.</summary>
        <returns>Ein neues DbLikeExpression mit der angegebenen Eingabe, Muster und einem Escapezeichen NULL.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="Argument" /> oder <paramref name="pattern" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="Argument" /> oder <paramref name="pattern" /> weist keinen Zeichenfolgenergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="Like">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLikeExpression Like (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression pattern, System.Data.Common.CommandTrees.DbExpression escape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLikeExpression Like(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression pattern, class System.Data.Common.CommandTrees.DbExpression escape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Like(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Like (argument As DbExpression, pattern As DbExpression, escape As DbExpression) As DbLikeExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLikeExpression ^ Like(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Common::CommandTrees::DbExpression ^ pattern, System::Data::Common::CommandTrees::DbExpression ^ escape);" />
      <MemberSignature Language="F#" Value="static member Like : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbLikeExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Like (argument, pattern, escape)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLikeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="pattern" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="escape" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der die Eingabezeichenfolge angibt.</param>
        <param name="pattern">Ein Ausdruck, der die Musterzeichenfolge angibt.</param>
        <param name="escape">Ein optionaler Ausdruck, der die Escapezeichenfolge angibt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbLikeExpression" />, der mithilfe der optionalen Escapezeichenfolge die angegebene Eingabezeichenfolge mit dem angegebenen Muster vergleicht.</summary>
        <returns>Ein neues DbLikeExpression mit der angegebenen Eingabe, Muster und einem Escapezeichen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" />, <paramref name="pattern" />, oder <paramref name="escape" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="argument" />, <paramref name="pattern" /> oder <paramref name="escape" /> weist keinen Zeichenfolgenergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="Limit">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLimitExpression Limit (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLimitExpression Limit(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Limit(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Limit (argument As DbExpression, count As DbExpression) As DbLimitExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLimitExpression ^ Limit(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Common::CommandTrees::DbExpression ^ count);" />
      <MemberSignature Language="F#" Value="static member Limit : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbLimitExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Limit (argument, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLimitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der die Eingabeauflistung angibt.</param>
        <param name="count">Ein Ausdruck, der den Grenzwert angibt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbLimitExpression" />, der die Anzahl der Elemente in der Argumentsammlung auf den angegebenen Zählgrenzwert beschränkt. Verknüpfte Ergebnisse sind nicht in der Ausgabe enthalten.</summary>
        <returns>Ein neues DbLimitExpression mit den angegebenen Argument- und Zählgrenzwerten, das verknüpfte Ergebnisse nicht einschließt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> oder <paramref name="count" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="argument" /> hat keinen Auflistungsergebnistyp, oder <paramref name="count" /> hat keinen Ergebnistyp, der gleich einem 64-Bit-Ganzzahl-Typ oder zu einem solchen heraufstufbar ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Minus">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Minus (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Minus(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Minus(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Minus (left As DbExpression, right As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Minus(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Minus : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbArithmeticExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Minus (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" />, die das rechte Argument vom linken Argument subtrahiert.</summary>
        <returns>Ein neues DbArithmeticExpression, der den Substraktionsvorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Zwischen <paramref name="left" /> und <paramref name="right" /> ist kein gemeinsamer numerischer Ergebnistyp vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Modulo (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Modulo(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Modulo(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Modulo (left As DbExpression, right As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Modulo(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbArithmeticExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Modulo (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" />, die den Rest der Division des linken Arguments durch das rechte Argument berechnet.</summary>
        <returns>Ein neues DbArithmeticExpression, der den Modulovorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Zwischen <paramref name="left" /> und <paramref name="right" /> ist kein gemeinsamer numerischer Ergebnistyp vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Multiply (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Multiply(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Multiply(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Multiply (left As DbExpression, right As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Multiply(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbArithmeticExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" />, die das linke Argument mit dem rechten Argument multipliziert.</summary>
        <returns>Ein neues DbArithmeticExpression, der die Multiplikation darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Zwischen <paramref name="left" /> und <paramref name="right" /> ist kein gemeinsamer numerischer Ergebnistyp vorhanden.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" />, der die Navigation einer Zusammensetzungs- oder Zuordnungsbeziehung darstellt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate (this System.Data.Common.CommandTrees.DbExpression navigateFrom, System.Data.Metadata.Edm.RelationshipEndMember fromEnd, System.Data.Metadata.Edm.RelationshipEndMember toEnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate(class System.Data.Common.CommandTrees.DbExpression navigateFrom, class System.Data.Metadata.Edm.RelationshipEndMember fromEnd, class System.Data.Metadata.Edm.RelationshipEndMember toEnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Navigate(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.RelationshipEndMember,System.Data.Metadata.Edm.RelationshipEndMember)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Navigate (navigateFrom As DbExpression, fromEnd As RelationshipEndMember, toEnd As RelationshipEndMember) As DbRelationshipNavigationExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRelationshipNavigationExpression ^ Navigate(System::Data::Common::CommandTrees::DbExpression ^ navigateFrom, System::Data::Metadata::Edm::RelationshipEndMember ^ fromEnd, System::Data::Metadata::Edm::RelationshipEndMember ^ toEnd);" />
      <MemberSignature Language="F#" Value="static member Navigate : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.RelationshipEndMember * System.Data.Metadata.Edm.RelationshipEndMember -&gt; System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Navigate (navigateFrom, fromEnd, toEnd)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRelationshipNavigationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigateFrom" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="fromEnd" Type="System.Data.Metadata.Edm.RelationshipEndMember" />
        <Parameter Name="toEnd" Type="System.Data.Metadata.Edm.RelationshipEndMember" />
      </Parameters>
      <Docs>
        <param name="navigateFrom">Ein Ausdruck, der die Instanz angibt, von der die Navigation erfolgen soll.</param>
        <param name="fromEnd">Metadaten für die Eigenschaft, die das Ende der Beziehung darstellt, von dem die Navigation erfolgen soll.</param>
        <param name="toEnd">Metadaten für die Eigenschaft, die das Ende der Beziehung darstellt, zu dem die Navigation erfolgen soll.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" />, der die Navigation einer Zusammensetzungs- oder Zuordnungsbeziehung darstellt.</summary>
        <returns>Ein neues DbRelationshipNavigationExpression, das die Navigation der angegebenen Von-und-Zu-Beziehungsenden des angegebenen Beziehungstyps aus der angegebenen Navigationsquell-Instanz darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression> erfordert, dass die Navigation immer aus einem Verweis zu erfolgt, weshalb `navigateFrom` immer einen Verweis-Ergebnistyp haben muss.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="fromEnd" />, <paramref name="toEnd" /> oder <paramref name="navigateFrom" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="fromEnd" /> und <paramref name="toEnd" /> werden nicht vom gleichen Beziehungstyp deklariert, oder <paramref name="navigateFrom" /> hat einen Ergebnistyp, der nicht kompatibel mit dem Eigenschaftstyp <paramref name="fromEnd" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate (this System.Data.Metadata.Edm.RelationshipType type, string fromEndName, string toEndName, System.Data.Common.CommandTrees.DbExpression navigateFrom);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRelationshipNavigationExpression Navigate(class System.Data.Metadata.Edm.RelationshipType type, string fromEndName, string toEndName, class System.Data.Common.CommandTrees.DbExpression navigateFrom) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Navigate(System.Data.Metadata.Edm.RelationshipType,System.String,System.String,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Navigate (type As RelationshipType, fromEndName As String, toEndName As String, navigateFrom As DbExpression) As DbRelationshipNavigationExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRelationshipNavigationExpression ^ Navigate(System::Data::Metadata::Edm::RelationshipType ^ type, System::String ^ fromEndName, System::String ^ toEndName, System::Data::Common::CommandTrees::DbExpression ^ navigateFrom);" />
      <MemberSignature Language="F#" Value="static member Navigate : System.Data.Metadata.Edm.RelationshipType * string * string * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Navigate (type, fromEndName, toEndName, navigateFrom)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRelationshipNavigationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Data.Metadata.Edm.RelationshipType" RefType="this" />
        <Parameter Name="fromEndName" Type="System.String" />
        <Parameter Name="toEndName" Type="System.String" />
        <Parameter Name="navigateFrom" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="type">Metadaten für den Beziehungstyp, der die Beziehung darstellt.</param>
        <param name="fromEndName">Der Name der Eigenschaft des Beziehungstyps, der das Ende der Beziehung darstellt, von der aus die Navigation erfolgen soll.</param>
        <param name="toEndName">Der Name der Eigenschaft des Beziehungstyps, der das Ende der Beziehung darstellt, zu der die Navigation erfolgen soll.</param>
        <param name="navigateFrom">Ein Ausdruck, der die Instanz angibt, von der die Navigation erfolgen soll.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression" />, der die Navigation einer Zusammensetzungs- oder Zuordnungsbeziehung darstellt.</summary>
        <returns>Ein neues DbRelationshipNavigationExpression, das die Navigation der angegebenen Von-und-Zu-Beziehungsenden des angegebenen Beziehungstyps aus der angegebenen Navigationsquell-Instanz darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression> erfordert, dass die Navigation immer aus einem Verweis zu erfolgt, weshalb `navigateFrom` immer einen Verweis-Ergebnistyp haben muss.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />, <paramref name="fromEndName" />, <paramref name="toEndName" /> oder <paramref name="navigateFrom" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> wird nicht dem Metadatenarbeitsbereich dieser Befehlsstruktur zugeordnet, oder <paramref name="navigateFrom" /> wird einer anderen Befehlsstruktur zugeordnet, oder <paramref name="type" /> deklariert keine Beziehungsendeigenschaft mit dem Namen <paramref name="toEndName" /> oder <paramref name="fromEndName" /> oder <paramref name="navigateFrom" /> verfügt über einen Ergebnistyp, der nicht mit dem Eigenschaftentyp der Beziehungsendeigenschaft mit dem Namen <paramref name="fromEndName" /> kompatibel ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Negate (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Negate(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Negate(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Negate (argument As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Negate(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbArithmeticExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Negate argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der das Argument angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" />, die den Wert des Arguments negiert.</summary>
        <returns>Ein neues DbArithmeticExpression, der den Negationsvorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Kein numerischer Ergebnistyp für <paramref name="argument" /> vorhanden.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression New (this System.Data.Metadata.Edm.TypeUsage instanceType, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression New(class System.Data.Metadata.Edm.TypeUsage instanceType, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.New(System.Data.Metadata.Edm.TypeUsage,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function New (instanceType As TypeUsage, arguments As IEnumerable(Of DbExpression)) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ New(System::Data::Metadata::Edm::TypeUsage ^ instanceType, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Data.Metadata.Edm.TypeUsage * seq&lt;System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbNewInstanceExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.New (instanceType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="instanceType">Der Typ der neuen Instanz.</param>
        <param name="arguments">Ausdrücke, die Werte der neuen Instanzen angeben, interpretiert gemäß dem Typ der Instanz.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />. Wenn das Typargument ein Auflistungstyp ist, geben die Argumente die Elemente der Auflistung an. Andernfalls werden die Argumente als Eigenschafts- oder Spaltenwerte in der neuen Instanz verwendet.</summary>
        <returns>Ein neues DbNewInstanceExpression mit dem angegebenen Typ und den Argumenten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `instanceType` einen Auflistungstyp ist jeder Ausdruck in `arguments` benötigen einen Ergebnistyp, der den Elementtyp des zu ist die `instanceType`. Wenn `instanceType` ist ein Zeilentyp `arguments` so viele Ausdrücke in den Zeilentyp Spalten vorhanden sind, und der Ergebnistyp des jeder Ausdruck muss in den Typ der entsprechenden Spalte gleich oder heraufstufbar sein darf. Ein Zeilentyp, der keine Spalten deklariert, ist ungültig. Wenn `instanceType` ein Entitätstyp, `arguments` muss enthalten, wie viele Ausdrücke wie Eigenschaften, die durch den Typ definiert sind, und der Ergebnistyp des jeder Ausdruck muss in den Typ der entsprechenden Eigenschaft diesem heraufstufbar sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="instanceType" /> oder <paramref name="arguments" /> ist NULL oder <paramref name="arguments" /> enthält NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="arguments" /> ist leer, oder die Ergebnistypen der enthaltenen Ausdrücke stimmen nicht mit den Anforderungen von <paramref name="instanceType" /> überein (wie im Abschnitt „Hinweise“ erläutert).</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression New (this System.Data.Metadata.Edm.TypeUsage instanceType, params System.Data.Common.CommandTrees.DbExpression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression New(class System.Data.Metadata.Edm.TypeUsage instanceType, class System.Data.Common.CommandTrees.DbExpression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.New(System.Data.Metadata.Edm.TypeUsage,System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function New (instanceType As TypeUsage, ParamArray arguments As DbExpression()) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ New(System::Data::Metadata::Edm::TypeUsage ^ instanceType, ... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Data.Metadata.Edm.TypeUsage * System.Data.Common.CommandTrees.DbExpression[] -&gt; System.Data.Common.CommandTrees.DbNewInstanceExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.New (instanceType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="arguments" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instanceType">Der Typ der neuen Instanz.</param>
        <param name="arguments">Ausdrücke, die Werte der neuen Instanzen angeben, interpretiert gemäß dem Typ der Instanz.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />. Wenn das Typargument ein Auflistungstyp ist, geben die Argumente die Elemente der Auflistung an. Andernfalls werden die Argumente als Eigenschafts- oder Spaltenwerte in der neuen Instanz verwendet.</summary>
        <returns>Ein neues DbNewInstanceExpression mit dem angegebenen Typ und den Argumenten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `instanceType` einen Auflistungstyp ist jeder Ausdruck in `arguments` benötigen einen Ergebnistyp, der den Elementtyp des zu ist die `instanceType`. Wenn `instanceType` ist ein Zeilentyp `arguments` so viele Ausdrücke in den Zeilentyp Spalten vorhanden sind, und der Ergebnistyp des jeder Ausdruck muss in den Typ der entsprechenden Spalte gleich oder heraufstufbar sein darf. Ein Zeilentyp, der keine Spalten deklariert, ist ungültig. Wenn `instanceType` ein Entitätstyp, `arguments` muss enthalten, wie viele Ausdrücke wie Eigenschaften, die durch den Typ definiert sind, und der Ergebnistyp des jeder Ausdruck muss in den Typ der entsprechenden Eigenschaft diesem heraufstufbar sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="instanceType" /> oder <paramref name="arguments" /> ist NULL oder <paramref name="arguments" /> enthält NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="arguments" /> ist leer, oder die Ergebnistypen der enthaltenen Ausdrücke stimmen nicht mit den Anforderungen von <paramref name="instanceType" /> überein (wie im Abschnitt „Hinweise“ erläutert).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewCollection">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />, der eine Sammlung mit den angegebenen Elementen erstellt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewCollection">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection (System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt; elements);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection(class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbExpression&gt; elements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewCollection(System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Function NewCollection (elements As IEnumerable(Of DbExpression)) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ NewCollection(System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ elements);" />
      <MemberSignature Language="F#" Value="static member NewCollection : seq&lt;System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbNewInstanceExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewCollection elements" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elements" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="elements">Eine Liste von Ausdrücken, die die Elemente der Auflistung bereitstellen.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />, der eine Sammlung mit den angegebenen Elementen erstellt. Der Typ der Auflistung basiert auf dem gemeinsamen Typ der Elemente. Wenn kein gemeinsamer Elementtyp vorhanden ist, wird eine Ausnahme ausgelöst.</summary>
        <returns>Ein neues DbNewInstanceExpression mit dem angegebenen Sammlungstyp und den Argumenten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elements" /> ist NULL oder enthält NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elements" /> ist leer oder enthält Ausdrücke, für die kein gemeinsamer Ergebnistyp vorhanden ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewCollection">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection (params System.Data.Common.CommandTrees.DbExpression[] elements);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewCollection(class System.Data.Common.CommandTrees.DbExpression[] elements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewCollection(System.Data.Common.CommandTrees.DbExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Function NewCollection (ParamArray elements As DbExpression()) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ NewCollection(... cli::array &lt;System::Data::Common::CommandTrees::DbExpression ^&gt; ^ elements);" />
      <MemberSignature Language="F#" Value="static member NewCollection : System.Data.Common.CommandTrees.DbExpression[] -&gt; System.Data.Common.CommandTrees.DbNewInstanceExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewCollection elements" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elements" Type="System.Data.Common.CommandTrees.DbExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elements">Eine Liste von Ausdrücken, die die Elemente der Auflistung bereitstellen.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />, der eine Sammlung mit den angegebenen Elementen erstellt. Der Typ der Auflistung basiert auf dem gemeinsamen Typ der Elemente. Wenn kein gemeinsamer Elementtyp vorhanden ist, wird eine Ausnahme ausgelöst.</summary>
        <returns>Ein neues DbNewInstanceExpression mit dem angegebenen Sammlungstyp und den Argumenten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elements" /> ist NULL oder enthält NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elements" /> ist leer oder enthält Ausdrücke, für die kein gemeinsamer Ergebnistyp vorhanden ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewEmptyCollection">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewEmptyCollection (this System.Data.Metadata.Edm.TypeUsage collectionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewEmptyCollection(class System.Data.Metadata.Edm.TypeUsage collectionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewEmptyCollection(System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NewEmptyCollection (collectionType As TypeUsage) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ NewEmptyCollection(System::Data::Metadata::Edm::TypeUsage ^ collectionType);" />
      <MemberSignature Language="F#" Value="static member NewEmptyCollection : System.Data.Metadata.Edm.TypeUsage -&gt; System.Data.Common.CommandTrees.DbNewInstanceExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewEmptyCollection collectionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
      </Parameters>
      <Docs>
        <param name="collectionType">Die Typmetadaten für die zu erstellende Auflistung.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />, die eine leere Auflistung vom angegebenen Auflistungstyp erstellt.</summary>
        <returns>Ein neues DbNewInstanceExpression mit dem angegebenen Sammlungstyp und einer leeren <paramref name="Arguments" />-Liste.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collectionType" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="collectionType" /> ist kein Auflistungstyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNewInstanceExpression NewRow (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; columnValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNewInstanceExpression NewRow(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; columnValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewRow(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}})" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow (columnValues As IEnumerable(Of KeyValuePair(Of String, DbExpression))) As DbNewInstanceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Data::Common::CommandTrees::DbNewInstanceExpression ^ NewRow(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbExpression ^&gt;&gt; ^ columnValues);" />
      <MemberSignature Language="F#" Value="static member NewRow : seq&lt;System.Collections.Generic.KeyValuePair&lt;string, System.Data.Common.CommandTrees.DbExpression&gt;&gt; -&gt; System.Data.Common.CommandTrees.DbNewInstanceExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NewRow columnValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNewInstanceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="columnValues" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="columnValues">Eine Liste von Zeichenfolge-DbExpression-Schlüssel-Wert-Paaren, die die Struktur und die Werte der Zeile definiert.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbNewInstanceExpression" />, die eine Zeile mit den angegebenen benannten Spalten und den angegebenen Werten erzeugt, die als Ausdrücke angegeben werden.</summary>
        <returns>Ein neues DbNewInstanceExpression, die die Konstruktion der Zeile darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="columnValues" /> ist NULL oder enthält ein Element mit einem NULL-Spaltennamen oder -Ausdruck.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="columnValues" /> ist leer oder enthält einen doppelten oder ungültigen Spaltennamen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNotExpression Not (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNotExpression Not(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Not(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Not (argument As DbExpression) As DbNotExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbNotExpression ^ Not(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member Not : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbNotExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Not argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNotExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein boolescher Ausdruck, der das Argument angibt.</param>
        <summary>Erstellt eine <see cref="T:System.Data.Common.CommandTrees.DbNotExpression" />, die die logische Negation des angegebenen Arguments ausführt.</summary>
        <returns>Ein neues DbNotExpression mit dem angegebenen Argument.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="argument" /> weist keinen booleschen Ergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbComparisonExpression NotEqual (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbComparisonExpression NotEqual(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NotEqual(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function NotEqual (left As DbExpression, right As DbExpression) As DbComparisonExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbComparisonExpression ^ NotEqual(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbComparisonExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.NotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbComparisonExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression" />, die das linke und das rechte Argument auf Ungleichheit vergleicht.</summary>
        <returns>Ein neues DbComparisonExpression, das den Ungleichheitsvergleich darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Zwischen <paramref name="left" /> und <paramref name="right" /> ist kein allgemeiner, auf Gleichheit vergleichbarer Ergebnistyp vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbNullExpression Null (this System.Data.Metadata.Edm.TypeUsage nullType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbNullExpression Null(class System.Data.Metadata.Edm.TypeUsage nullType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Null(System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Null (nullType As TypeUsage) As DbNullExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbNullExpression ^ Null(System::Data::Metadata::Edm::TypeUsage ^ nullType);" />
      <MemberSignature Language="F#" Value="static member Null : System.Data.Metadata.Edm.TypeUsage -&gt; System.Data.Common.CommandTrees.DbNullExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Null nullType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbNullExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nullType" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
      </Parameters>
      <Docs>
        <param name="nullType">Der Typ des Nullwerts.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbNullExpression" />, der einen typisierten NULL-Wert darstellt.</summary>
        <returns>Eine Instanz von DbNullExpression.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="nullType" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfType">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbOfTypeExpression OfType (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbOfTypeExpression OfType(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OfType(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfType (argument As DbExpression, type As TypeUsage) As DbOfTypeExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbOfTypeExpression ^ OfType(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ type);" />
      <MemberSignature Language="F#" Value="static member OfType : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.TypeUsage -&gt; System.Data.Common.CommandTrees.DbOfTypeExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OfType (argument, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbOfTypeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die das Eingabeset angibt.</param>
        <param name="type">Typmetadaten für den Typ, den Elemente des Eingabesets aufweisen müssen, damit sie in das Resultset eingeschlossen werden.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbOfTypeExpression" />, der einen Satz von Elementen des angegebenen Eingabesets erzeugt, die den angegebenen Typ aufweisen.</summary>
        <returns>Ein neues DbOfTypeExpression mit dem angegebenen Mengenargument und -typ und ein ExpressionKind von <see cref="F:System.Data.Common.CommandTrees.DbExpressionKind.OfType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbOfTypeExpression erfordert, dass `argument` verfügt über eine Sammlung Typ mit einem polymorphen Elementtyp aufweist, und führen `type` ist ein Typ aus der gleichen Typhierarchie wie dieser Elementtyp.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> oder <paramref name="type" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="argument" /> hat keinen Auflistungsergebnistyp, oder <paramref name="type" /> ist kein Typ in der gleichen Typhierarchie wie der Elementtyp des <paramref name="argument" />-Auflistungsergebnistyps.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfTypeOnly">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbOfTypeExpression OfTypeOnly (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbOfTypeExpression OfTypeOnly(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OfTypeOnly(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfTypeOnly (argument As DbExpression, type As TypeUsage) As DbOfTypeExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbOfTypeExpression ^ OfTypeOnly(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ type);" />
      <MemberSignature Language="F#" Value="static member OfTypeOnly : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.TypeUsage -&gt; System.Data.Common.CommandTrees.DbOfTypeExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OfTypeOnly (argument, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbOfTypeExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der das Eingabeset angibt.</param>
        <param name="type">Typmetadaten für den Typ, mit dem Elemente des Eingabesets genau übereinstimmen müssen, damit sie in das Resultset eingeschlossen werden.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbOfTypeExpression" />, der einen Satz von Elementen des angegebenen Eingabesets erzeugt, die genau den angegebenen Typ aufweisen.</summary>
        <returns>Ein neues DbOfTypeExpression mit dem angegebenen Mengenargument und -typ und ein ExpressionKind von <see cref="F:System.Data.Common.CommandTrees.DbExpressionKind.OfTypeOnly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbOfTypeExpression erfordert, dass `argument` verfügt über eine Sammlung Typ mit einem polymorphen Elementtyp aufweist, und führen `type` ist ein Typ aus der gleichen Typhierarchie wie dieser Elementtyp.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> oder <paramref name="type" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="argument" /> hat keinen Auflistungsergebnistyp, oder <paramref name="type" /> ist kein Typ in der gleichen Typhierarchie wie der Elementtyp des <paramref name="argument" />-Auflistungsergebnistyps.</exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbOrExpression Or (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbOrExpression Or(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Or(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Or (left As DbExpression, right As DbExpression) As DbOrExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbOrExpression ^ Or(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Or : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbOrExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Or (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbOrExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein boolescher Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein boolescher Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt einen <see cref="T:System.Data.Common.CommandTrees.DbOrExpression" />, der die logische OR-Operation für das linke und das rechte Argument ausführt.</summary>
        <returns>Ein neues DbOrExpression mit den angegebenen Argumenten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="left" /> oder <paramref name="right" /> weist keinen booleschen Ergebnistyp auf.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderBy">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" />, der das angegebene Eingabeset in aufsteigender Sortierreihenfolge und mit Standardsortierung nach dem angegebenen Sortierschlüssel sortiert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderBy (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderBy(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderBy(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy (source As DbExpression, sortKey As Func(Of DbExpression, DbExpression)) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ OrderBy(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderBy (source, sortKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <param name="sortKey">Eine Methode, die angibt, wie der Sortierschlüsselausdruck für einen angegebenen Member des Eingabesets abgeleitet wird. Diese Methode muss einen Ausdruck mit einem in der Reihenfolge vergleichbaren Ergebnistyp erzeugen, der die Sortierschlüsseldefinition bereitstellt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" />, der das angegebene Eingabeset in aufsteigender Sortierreihenfolge und mit Standardsortierung nach dem angegebenen Sortierschlüssel sortiert.</summary>
        <returns>Ein neues DbSortExpression, das den order-by-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="sortKey" /> ist NULL.

- oder - 

Der von <paramref name="sortKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> weist keinen Auflistungsergebnistyp auf.

- oder - 

Der Ausdruck, der von <paramref name="sortKey" /> erzeugt wurde, hat keinen in der Reihenfolge vergleichbaren Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderBy (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderBy(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderBy(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy (source As DbExpression, sortKey As Func(Of DbExpression, DbExpression), collation As String) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ OrderBy(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey, System::String ^ collation);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; * string -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderBy (source, sortKey, collation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <param name="sortKey">Eine Methode, die angibt, wie der Sortierschlüsselausdruck für einen angegebenen Member des Eingabesets abgeleitet wird. Diese Methode muss einen Ausdruck mit einem in der Reihenfolge vergleichbaren Ergebnistyp erzeugen, der die Sortierschlüsseldefinition bereitstellt.</param>
        <param name="collation">Die zu verwendende Sortierung.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" />, der das angegebene Eingabeset in aufsteigender Sortierreihenfolge und mit der angegebenen Sortierung nach dem angegebenen Sortierschlüssel sortiert.</summary>
        <returns>Ein neues DbSortExpression, das den order-by-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="sortKey" /> oder <paramref name="collation" /> ist NULL.

- oder -  
Der von <paramref name="sortKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> weist keinen Auflistungsergebnistyp auf.

- oder - 

Der Ausdruck, der von <paramref name="sortKey" /> erzeugt wurde, hat keinen in der Reihenfolge vergleichbaren Zeichenfolgenergebnistyp.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="collation" /> ist leer oder enthält nur Leerzeichen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderByDescending">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" />, der das angegebene Eingabeset in absteigender Sortierreihenfolge und mit Standardsortierung nach dem angegebenen Sortierschlüssel sortiert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderByDescending (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderByDescending(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderByDescending(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending (source As DbExpression, sortKey As Func(Of DbExpression, DbExpression)) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ OrderByDescending(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderByDescending (source, sortKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <param name="sortKey">Eine Methode, die angibt, wie der Sortierschlüsselausdruck für einen angegebenen Member des Eingabesets abgeleitet wird. Diese Methode muss einen Ausdruck mit einem in der Reihenfolge vergleichbaren Ergebnistyp erzeugen, der die Sortierschlüsseldefinition bereitstellt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" />, der das angegebene Eingabeset in absteigender Sortierreihenfolge und mit Standardsortierung nach dem angegebenen Sortierschlüssel sortiert.</summary>
        <returns>Ein neues DbSortExpression, das den order-by-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="sortKey" /> ist NULL.

- oder - 

Der von <paramref name="sortKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> weist keinen Auflistungsergebnistyp auf.

- oder - 

Der Ausdruck, der von <paramref name="sortKey" /> erzeugt wurde, hat keinen in der Reihenfolge vergleichbaren Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression OrderByDescending (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression OrderByDescending(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderByDescending(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending (source As DbExpression, sortKey As Func(Of DbExpression, DbExpression), collation As String) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ OrderByDescending(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey, System::String ^ collation);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; * string -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OrderByDescending (source, sortKey, collation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <param name="sortKey">Eine Methode, die angibt, wie der Sortierschlüsselausdruck für einen angegebenen Member des Eingabesets abgeleitet wird. Diese Methode muss einen Ausdruck mit einem in der Reihenfolge vergleichbaren Ergebnistyp erzeugen, der die Sortierschlüsseldefinition bereitstellt.</param>
        <param name="collation">Die zu verwendende Sortierung.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" />, der das angegebene Eingabeset in absteigender Sortierreihenfolge und mit der angegebenen Sortierung nach dem angegebenen Sortierschlüssel sortiert.</summary>
        <returns>Ein neues DbSortExpression, das den order-by-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="sortKey" /> oder <paramref name="collation" /> ist NULL.

- oder - 

Der von <paramref name="sortKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> weist keinen Auflistungsergebnistyp auf.

- oder - 

Der Ausdruck, der von <paramref name="sortKey" /> erzeugt wurde, hat keinen in der Reihenfolge vergleichbaren Zeichenfolgenergebnistyp.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="collation" /> ist leer oder enthält nur Leerzeichen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OuterApply">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" />, die den angegebenen <paramref name="apply" />-Ausdruck für jedes Element eines angegebenen Eingabesets einmal auswertet und eine Auflistung von Zeilen mit entsprechenden Eingabe- und apply-Spalten erzeugt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OuterApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression OuterApply (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;string,System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression OuterApply(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Data.Common.CommandTrees.DbExpression&gt;&gt; apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OuterApply(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair{System.String,System.Data.Common.CommandTrees.DbExpression}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OuterApply (source As DbExpression, apply As Func(Of DbExpression, KeyValuePair(Of String, DbExpression))) As DbApplyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbApplyExpression ^ OuterApply(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Data::Common::CommandTrees::DbExpression ^&gt;&gt; ^ apply);" />
      <MemberSignature Language="F#" Value="static member OuterApply : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Collections.Generic.KeyValuePair&lt;string, System.Data.Common.CommandTrees.DbExpression&gt;&gt; -&gt; System.Data.Common.CommandTrees.DbApplyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OuterApply (source, apply)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Collections.Generic.KeyValuePair&lt;System.String,System.Data.Common.CommandTrees.DbExpression&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die das Eingabeset angibt.</param>
        <param name="apply">Eine Methode, die die Logik angibt, die für jeden Member des Eingabesets einmal ausgewertet wird.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" />, die den angegebenen <paramref name="apply" />-Ausdruck für jedes Element eines angegebenen Eingabesets einmal auswertet und eine Auflistung von Zeilen mit entsprechenden Eingabe- und apply-Spalten erzeugt. Zeilen, für die <paramref name="apply" /> zu einem leeren Satz ausgewertet wird, weisen den Anwendungsspaltenwert <see langword="null" /> auf.</summary>
        <returns>Ein neues DbApplyExpression mit der angegebenen Eingabe und Anwenden von Bindungen und ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von OuterApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="apply" /> ist NULL.

- oder -  
Das Ergebnis von <paramref name="apply" /> enthält einen Namen oder Ausdruck, der Null ist.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="Source" /> weist keinen Auflistungsergebnistyp auf.

- oder - 

Das Ergebnis von <paramref name="apply" /> enthält einen Namen oder Ausdruck, der in einer Ausdrucksbindung ungültig ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="OuterApply">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbApplyExpression OuterApply (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpressionBinding apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbApplyExpression OuterApply(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpressionBinding apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OuterApply(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpressionBinding)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OuterApply (input As DbExpressionBinding, apply As DbExpressionBinding) As DbApplyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbApplyExpression ^ OuterApply(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpressionBinding ^ apply);" />
      <MemberSignature Language="F#" Value="static member OuterApply : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpressionBinding -&gt; System.Data.Common.CommandTrees.DbApplyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.OuterApply (input, apply)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbApplyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="apply" Type="System.Data.Common.CommandTrees.DbExpressionBinding" />
      </Parameters>
      <Docs>
        <param name="input">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" />, der das Eingabeset angibt.</param>
        <param name="apply">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpressionBinding" />, die die Logik angibt, die für jeden Member des Eingabesets einmal ausgewertet wird.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" />, die den angegebenen <paramref name="apply" />-Ausdruck für jedes Element eines angegebenen Eingabesets einmal auswertet und eine Auflistung von Zeilen mit entsprechenden Eingabe- und apply-Spalten erzeugt. Zeilen, für die <paramref name="apply" /> zu einem leeren Satz ausgewertet wird, weisen den Anwendungsspaltenwert <see langword="null" /> auf.</summary>
        <returns>Ein neues DbApplyExpression mit der angegebenen Eingabe und Anwenden von Bindungen und ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von OuterApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="apply" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbParameterReferenceExpression Parameter (this System.Data.Metadata.Edm.TypeUsage type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbParameterReferenceExpression Parameter(class System.Data.Metadata.Edm.TypeUsage type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Parameter(System.Data.Metadata.Edm.TypeUsage,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Parameter (type As TypeUsage, name As String) As DbParameterReferenceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbParameterReferenceExpression ^ Parameter(System::Data::Metadata::Edm::TypeUsage ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Parameter : System.Data.Metadata.Edm.TypeUsage * string -&gt; System.Data.Common.CommandTrees.DbParameterReferenceExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Parameter (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbParameterReferenceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des Parameters, auf den verwiesen wird.</param>
        <param name="name">Der Name des Parameters, auf den verwiesen wird.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbParameterReferenceExpression" />, die auf einen Parameter mit dem angegebenen Namen und Typ verweist.</summary>
        <returns>Ein DbParameterReferenceExpression, der einen Verweis auf einen Parameter mit dem angegebenen Namen und Typ darstellt. Der Ergebnistyp des Ausdrucks ist derselbe <paramref name="type" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Plus">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression Plus (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression Plus(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Plus(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Plus (left As DbExpression, right As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ Plus(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Plus : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbArithmeticExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Plus (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Argument angibt.</param>
        <param name="right">Ein Ausdruck, der das rechte Argument angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" />, die dem rechten Argument das linke Argument hinzufügt.</summary>
        <returns>Ein neues DbArithmeticExpression, der die Addition darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Zwischen <paramref name="left" /> und <paramref name="right" /> ist kein gemeinsamer numerischer Ergebnistyp vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Project">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression Project (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Data.Common.CommandTrees.DbExpression projection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression Project(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Data.Common.CommandTrees.DbExpression projection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Project(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Project (input As DbExpressionBinding, projection As DbExpression) As DbProjectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbProjectExpression ^ Project(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Data::Common::CommandTrees::DbExpression ^ projection);" />
      <MemberSignature Language="F#" Value="static member Project : System.Data.Common.CommandTrees.DbExpressionBinding * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbProjectExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Project (input, projection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="projection" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Eine Ausdrucksbindung, die das Eingabeset angibt.</param>
        <param name="projection">Ein Ausdruck, der über dem Satz projiziert werden soll.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" />, die den angegebenen Ausdruck über dem angegebenen Eingabeset projiziert.</summary>
        <returns>Ein neues DbProjectExpression, die den Projektionsvorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="projection" /> ist NULL.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" />, der den Abruf der angegebenen Eigenschaft darstellt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, System.Data.Metadata.Edm.EdmProperty propertyMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, class System.Data.Metadata.Edm.EdmProperty propertyMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.EdmProperty)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Property (instance As DbExpression, propertyMetadata As EdmProperty) As DbPropertyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbPropertyExpression ^ Property(System::Data::Common::CommandTrees::DbExpression ^ instance, System::Data::Metadata::Edm::EdmProperty ^ propertyMetadata);" />
      <MemberSignature Language="F#" Value="static member Property : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.EdmProperty -&gt; System.Data.Common.CommandTrees.DbPropertyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property (instance, propertyMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="propertyMetadata" Type="System.Data.Metadata.Edm.EdmProperty" />
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz, aus der die Eigenschaft abgerufen werden soll. Kann NULL sein, wenn die Eigenschaft statisch ist.</param>
        <param name="propertyMetadata">Metadaten für die abzurufende Eigenschaft.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" />, der den Abruf der angegebenen Eigenschaft darstellt.</summary>
        <returns>Ein neues DbPropertyExpression, das das Abrufen von Eigenschaften darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyMetadata" /> ist NULL oder <paramref name="instance" /> ist NULL, und die Eigenschaft ist nicht statisch.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, System.Data.Metadata.Edm.NavigationProperty navigationProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, class System.Data.Metadata.Edm.NavigationProperty navigationProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.NavigationProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbPropertyExpression ^ Property(System::Data::Common::CommandTrees::DbExpression ^ instance, System::Data::Metadata::Edm::NavigationProperty ^ navigationProperty);" />
      <MemberSignature Language="F#" Value="static member Property : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.NavigationProperty -&gt; System.Data.Common.CommandTrees.DbPropertyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property (instance, navigationProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="navigationProperty" Type="System.Data.Metadata.Edm.NavigationProperty" />
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz, aus der die Navigationseigenschaft abgerufen werden soll.</param>
        <param name="navigationProperty">Metadaten für die abzurufende Navigationseigenschaft.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" />, der den Abruf der angegebenen Navigationseigenschaft darstellt.</summary>
        <returns>Ein neues DbPropertyExpression, das das Abrufen von Navigationseigenschaften darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="navigationProperty" /> oder <paramref name="instance" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, System.Data.Metadata.Edm.RelationshipEndMember relationshipEnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, class System.Data.Metadata.Edm.RelationshipEndMember relationshipEnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.RelationshipEndMember)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Property (instance As DbExpression, relationshipEnd As RelationshipEndMember) As DbPropertyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbPropertyExpression ^ Property(System::Data::Common::CommandTrees::DbExpression ^ instance, System::Data::Metadata::Edm::RelationshipEndMember ^ relationshipEnd);" />
      <MemberSignature Language="F#" Value="static member Property : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.RelationshipEndMember -&gt; System.Data.Common.CommandTrees.DbPropertyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property (instance, relationshipEnd)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="relationshipEnd" Type="System.Data.Metadata.Edm.RelationshipEndMember" />
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz, aus der der Endmember der Beziehung abgerufen werden soll.</param>
        <param name="relationshipEnd">Metadaten für den abzurufenden Endmember der Beziehung.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" />, der den Abruf des angegebenen Endmembers der Beziehung darstellt.</summary>
        <returns>Ein neues DbPropertyExpression, das das Abrufen von Verhältnis und Member darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relationshipEnd" /> ist NULL oder <paramref name="instance" /> ist NULL, und die Eigenschaft ist nicht statisch.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbPropertyExpression Property (this System.Data.Common.CommandTrees.DbExpression instance, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbPropertyExpression Property(class System.Data.Common.CommandTrees.DbExpression instance, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Property (instance As DbExpression, propertyName As String) As DbPropertyExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbPropertyExpression ^ Property(System::Data::Common::CommandTrees::DbExpression ^ instance, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Data.Common.CommandTrees.DbExpression * string -&gt; System.Data.Common.CommandTrees.DbPropertyExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Property (instance, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbPropertyExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz, aus der die Eigenschaft abgerufen werden soll.</param>
        <param name="propertyName">Der Name der abzurufenden Eigenschaft.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression" />, der den Abruf der Instanzeigenschaft mit dem angegebenen Namen aus der angegebenen Instanz darstellt.</summary>
        <returns>Ein neues DbPropertyExpression, das das Abrufen von Eigenschaften darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyName" /> ist NULL oder <paramref name="instance" /> ist NULL, und die Eigenschaft ist nicht statisch.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Keine Eigenschaft mit dem angegebenen Namen wurde von diesem Typ <paramref name="instance" /> deklariert.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RefFromKey">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" />, das einen Verweis auf eine bestimmte Entität auf der Grundlage der Schlüsselwerte codiert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RefFromKey">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression RefFromKey (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Common.CommandTrees.DbExpression keyRow);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression RefFromKey(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Common.CommandTrees.DbExpression keyRow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.RefFromKey(System.Data.Metadata.Edm.EntitySet,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ RefFromKey(System::Data::Metadata::Edm::EntitySet ^ entitySet, System::Data::Common::CommandTrees::DbExpression ^ keyRow);" />
      <MemberSignature Language="F#" Value="static member RefFromKey : System.Data.Metadata.Edm.EntitySet * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbRefExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.RefFromKey (entitySet, keyRow)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyRow" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="entitySet">Die Entitätenmenge mit dem Element, auf das verwiesen wird.</param>
        <param name="keyRow">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der einen Datensatz mit Spalten erstellt, deren Anzahl, Typ und Reihenfolge mit den Schlüsseleigenschaften des Entitätstyps, auf den verwiesen wird, übereinstimmen.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" />, das einen Verweis auf eine bestimmte Entität auf der Grundlage der Schlüsselwerte codiert.</summary>
        <returns>Ein neues DbRefExpression, das das Element mit den angegebenen Schlüsselwerten im angegebenen Entitätssatz verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keyRow` Ein Ausdruck, der die Schlüsselwerte angibt, die die Entität verwiesen wird, innerhalb der angegebenen Entität zu identifizieren, festgelegt werden soll. Der Ergebnistyp des `keyRow` sollte eine entsprechende Spalte für jede Schlüsseleigenschaft von definierten enthalten `entitySet's` Entitätstyp.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entitySet" /> oder <paramref name="keyRow" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyRow" /> hat keinen Aufzeichnungsergebnistypen, der den Schlüsseleigenschaften des Entitätstyps der Entitätsmenge entspricht, auf den verwiesen wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="RefFromKey">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbRefExpression RefFromKey (this System.Data.Metadata.Edm.EntitySet entitySet, System.Data.Common.CommandTrees.DbExpression keyRow, System.Data.Metadata.Edm.EntityType entityType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbRefExpression RefFromKey(class System.Data.Metadata.Edm.EntitySet entitySet, class System.Data.Common.CommandTrees.DbExpression keyRow, class System.Data.Metadata.Edm.EntityType entityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.RefFromKey(System.Data.Metadata.Edm.EntitySet,System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.EntityType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbRefExpression ^ RefFromKey(System::Data::Metadata::Edm::EntitySet ^ entitySet, System::Data::Common::CommandTrees::DbExpression ^ keyRow, System::Data::Metadata::Edm::EntityType ^ entityType);" />
      <MemberSignature Language="F#" Value="static member RefFromKey : System.Data.Metadata.Edm.EntitySet * System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.EntityType -&gt; System.Data.Common.CommandTrees.DbRefExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.RefFromKey (entitySet, keyRow, entityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbRefExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="this" />
        <Parameter Name="keyRow" Type="System.Data.Common.CommandTrees.DbExpression" />
        <Parameter Name="entityType" Type="System.Data.Metadata.Edm.EntityType" />
      </Parameters>
      <Docs>
        <param name="entitySet">Die Entitätenmenge mit dem Element, auf das verwiesen wird.</param>
        <param name="keyRow">Ein <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der einen Datensatz mit Spalten erstellt, deren Anzahl, Typ und Reihenfolge mit den Schlüsseleigenschaften des Entitätstyps, auf den verwiesen wird, übereinstimmen.</param>
        <param name="entityType">Der Typ der Entität, auf die der Verweis zeigen sollte.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbRefExpression" />, das einen Verweis auf eine bestimmte Entität auf der Grundlage der Schlüsselwerte codiert.</summary>
        <returns>Ein neues DbRefExpression, das das Element mit den angegebenen Schlüsselwerten im angegebenen Entitätssatz verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keyRow` Ein Ausdruck, der die Schlüsselwerte angibt, die die Entität verwiesen wird, innerhalb der angegebenen Entität zu identifizieren, festgelegt werden soll. Der Ergebnistyp des `keyRow` sollte eine entsprechende Spalte für jede Schlüsseleigenschaft von definierten enthalten `entitySet's` Entitätstyp.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entitySet" />, <paramref name="keyRow" /> oder <paramref name="entityType" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="entityType" /> befindet sich nicht in derselben Typhierarchie wie der Entitätstyp des Entitätssatzes, oder <paramref name="keyRow" /> hat keinen Datensatzergebnistyp, der den Schlüsseleigenschaften des Entitätstyps der Entitätenmenge entspricht, auf den verwiesen wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scan">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbScanExpression Scan (this System.Data.Metadata.Edm.EntitySetBase targetSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbScanExpression Scan(class System.Data.Metadata.Edm.EntitySetBase targetSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Scan(System.Data.Metadata.Edm.EntitySetBase)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Scan (targetSet As EntitySetBase) As DbScanExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbScanExpression ^ Scan(System::Data::Metadata::Edm::EntitySetBase ^ targetSet);" />
      <MemberSignature Language="F#" Value="static member Scan : System.Data.Metadata.Edm.EntitySetBase -&gt; System.Data.Common.CommandTrees.DbScanExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Scan targetSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbScanExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetSet" Type="System.Data.Metadata.Edm.EntitySetBase" RefType="this" />
      </Parameters>
      <Docs>
        <param name="targetSet">Metadaten für die Entitätenmenge oder den Beziehungssatz, auf die bzw. den verwiesen werden soll.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbScanExpression" />, die auf die angegebene Entitätenmenge oder den angegebenen Beziehungssatz verweist.</summary>
        <returns>Ein neues DbScanExpression auf Grundlage des angegebenen Entitäts- oder Beziehungssatzes.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetSet" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TProjection&gt;">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression Select&lt;TProjection&gt; (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,TProjection&gt; projection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression Select&lt;TProjection&gt;(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, !!TProjection&gt; projection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Select``1(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TProjection) (source As DbExpression, projection As Func(Of DbExpression, TProjection)) As DbProjectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TProjection&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbProjectExpression ^ Select(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, TProjection&gt; ^ projection);" />
      <MemberSignature Language="F#" Value="static member Select : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, 'Projection&gt; -&gt; System.Data.Common.CommandTrees.DbProjectExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Select (source, projection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TProjection" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="projection" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,TProjection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TProjection">Der Methodenergebnistyp von <paramref name="projection" />.</typeparam>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <param name="projection">Eine Methode, die angibt, wie der Projektionsausdruck von einem Member des Eingabesets abgeleitet wird. Diese Methode muss eine Instanz eines Typs erzeugen, der mit Select kompatibel ist und in eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> aufgelöst werden kann. Anforderungen an die Kompatibilität für <c>TProjection</c> werden in den Hinweisen beschrieben.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" />, der den angegebenen Ausdruck über das angegebene Eingabeset auswählt.</summary>
        <returns>Ein neues DbProjectExpression, die den ausgewählten Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kompatibel mit Select-Anweisung, `TProjection` abgeleitet werden, von <xref:System.Data.Common.CommandTrees.DbExpression>, oder muss ein anonymer Typ mit von DbExpression abgeleiteten Eigenschaften. Im folgenden sind Beispiele für unterstützte Typen für `TProjection`:  
  
```  
source.Select(x => x.Property("Name"))  
```  
  
 `TProjection` ist <xref:System.Data.Common.CommandTrees.DbPropertyExpression>).  
  
```  
source.Select(x => new { Name = x.Property("Name") })  
```  
  
 (`TProjection` ist ein anonymer Typ mit einer Eigenschaft DbExpression abgeleiteten).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="projection" /> ist NULL.

- oder - 

Das Ergebnis von <paramref name="projection" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression SelectMany (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; apply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression SelectMany(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; apply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.SelectMany(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany (source As DbExpression, apply As Func(Of DbExpression, DbExpression)) As DbProjectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbProjectExpression ^ SelectMany(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ apply);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbProjectExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.SelectMany (source, apply)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die das Eingabeset angibt.</param>
        <param name="apply">Eine Methode, die die Logik darstellt, die für jeden Member des Eingabesets einmal ausgewertet wird.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" />, die den angegebenen <paramref name="apply" />-Ausdruck für jedes Element eines angegebenen Eingabesets einmal auswertet und eine Auflistung von Zeilen mit entsprechenden Eingabe- und apply-Spalten erzeugt. Zeilen, für die <paramref name="apply" /> als leerer Satz ausgewertet wird, werden nicht eingeschlossen. Eine <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> wird dann erstellt, die die <paramref name="apply" />-Spalte in jeder Zeile auswählt und die Gesamtauflistung der <paramref name="apply" />-Ergebnisse erzeugt.</summary>
        <returns>Ein neues DbProjectExpression, das die Spalte Übernehmen von einem neuen DbApplyExpression mit der angegebenen Eingabe auswählt und Bindungen anwendet und ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von CrossApply.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="apply" /> ist NULL.

- oder - 

Der von <paramref name="apply" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> weist keinen Auflistungsergebnistyp auf.

- oder - 

Der von <paramref name="apply" /> erzeugte Ausdruck hat keinen Auflistungstyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSelector&gt;">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbProjectExpression SelectMany&lt;TSelector&gt; (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; apply, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbProjectExpression SelectMany&lt;TSelector&gt;(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; apply, class System.Func`3&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression, !!TSelector&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.SelectMany``1(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSelector) (source As DbExpression, apply As Func(Of DbExpression, DbExpression), selector As Func(Of DbExpression, DbExpression, TSelector)) As DbProjectExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSelector&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbProjectExpression ^ SelectMany(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ apply, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^, TSelector&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression, 'Selector&gt; -&gt; System.Data.Common.CommandTrees.DbProjectExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.SelectMany (source, apply, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbProjectExpression</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSelector" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="apply" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="selector" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,TSelector&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSelector">Der Methodenergebnistyp von <paramref name="selector" />.</typeparam>
        <param name="source">Eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, die das Eingabeset angibt.</param>
        <param name="apply">Eine Methode, die die Logik darstellt, die für jeden Member des Eingabesets einmal ausgewertet wird.</param>
        <param name="selector">Eine Methode, die angibt, wie ein Element des Resultsets bei Angabe eines Elements des Eingabe- und Anwendungssets abgeleitet werden soll. Diese Methode muss eine Instanz eines Typs erzeugen, der mit SelectMany kompatibel ist und in eine <see cref="T:System.Data.Common.CommandTrees.DbExpression" /> aufgelöst werden kann. Anforderungen an die Kompatibilität für <typeparamref name="TSelector" /> werden in den Hinweisen beschrieben.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbApplyExpression" />, die den angegebenen <paramref name="apply" />-Ausdruck für jedes Element eines angegebenen Eingabesets einmal auswertet und eine Auflistung von Zeilen mit entsprechenden Eingabe- und apply-Spalten erzeugt. Zeilen, für die <paramref name="apply" /> als leerer Satz ausgewertet wird, werden nicht eingeschlossen. Eine <see cref="T:System.Data.Common.CommandTrees.DbProjectExpression" /> wird dann erstellt, die den angegebenen <paramref name="selector" /> für jede Zeile auswählt und die Gesamtauflistung der Ergebnisse erzeugt.</summary>
        <returns>Ein neues DbProjectExpression, das das Ergebnis des angegebenen Selektors aus einem neuen DbApplyExpression mit der angegebenen Eingabe auswählt und Bindungen anwendet und ein <see cref="T:System.Data.Common.CommandTrees.DbExpressionKind" /> von CrossApply.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kompatibel mit SelectMany, `TSelector` abgeleitet werden, von <xref:System.Data.Common.CommandTrees.DbExpression>, oder muss ein anonymer Typ mit von DbExpression abgeleiteten Eigenschaften. Im folgenden sind Beispiele für unterstützte Typen für `TSelector`:  
  
```  
source.SelectMany(x => x.Property("RelatedCollection"), (source, apply) => apply.Property("Name"))  
```  
  
 (`TSelector` ist <xref:System.Data.Common.CommandTrees.DbPropertyExpression>).  
  
```  
source.SelectMany(x => x.Property("RelatedCollection"), (source, apply) => new { SourceName = source.Property("Name"), RelatedName = apply.Property("Name") })  
```  
  
 (`TSelector` ist ein anonymer Typ mit von DbExpression abgeleiteten Eigenschaften).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="apply" /> oder <paramref name="selector" /> ist NULL.

- oder - 

Der von <paramref name="apply" /> erzeugte Ausdruck ist NULL.

- oder - 

Das Ergebnis von <paramref name="selector" /> ist bei Umwandlung in DbExpression NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> weist keinen Auflistungsergebnistyp auf.

- oder -  
Der von <paramref name="apply" /> erzeugte Ausdruck hat keinen Auflistungstyp. weist keinen Auflistungstyp auf.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Skip">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbSkipExpression" />, die das angegebene Eingabeset nach den angegebenen Sortiervorschriften sortiert, bevor die angegebene Anzahl von Elementen übersprungen wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSkipExpression Skip (this System.Data.Common.CommandTrees.DbSortExpression argument, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSkipExpression Skip(class System.Data.Common.CommandTrees.DbSortExpression argument, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Skip(System.Data.Common.CommandTrees.DbSortExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip (argument As DbSortExpression, count As DbExpression) As DbSkipExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSkipExpression ^ Skip(System::Data::Common::CommandTrees::DbSortExpression ^ argument, System::Data::Common::CommandTrees::DbExpression ^ count);" />
      <MemberSignature Language="F#" Value="static member Skip : System.Data.Common.CommandTrees.DbSortExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbSkipExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Skip (argument, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSkipExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Eine <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" />, die das sortierte Eingabeset angibt.</param>
        <param name="count">Ein Ausdruck, der die Anzahl der zu überspringenden Elemente des geordneten Satzes angibt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbSkipExpression" />, der die angegebene Anzahl von Elementen aus dem angegebenen sortierten Eingabeset überspringt.</summary>
        <returns>Ein neues DbSkipExpression, das den Vorgang des Überspringens darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> oder <paramref name="count" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="count" /> ist nicht <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> oder <see cref="T:System.Data.Common.CommandTrees.DbParameterReferenceExpression" /> oder weist einen Ergebnistyp auf, der nicht gleich einem 64-Bit-Ganzzahl-Typ und nicht zu einem solchen heraufstufbar ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSkipExpression Skip (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSkipExpression Skip(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Skip(System.Data.Common.CommandTrees.DbExpressionBinding,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbSortClause},System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip (input As DbExpressionBinding, sortOrder As IEnumerable(Of DbSortClause), count As DbExpression) As DbSkipExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSkipExpression ^ Skip(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbSortClause ^&gt; ^ sortOrder, System::Data::Common::CommandTrees::DbExpression ^ count);" />
      <MemberSignature Language="F#" Value="static member Skip : System.Data.Common.CommandTrees.DbExpressionBinding * seq&lt;System.Data.Common.CommandTrees.DbSortClause&gt; * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbSkipExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Skip (input, sortOrder, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSkipExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="sortOrder" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt;" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="input">Eine Ausdrucksbindung, die das Eingabeset angibt.</param>
        <param name="sortOrder">Eine Liste der Sortiervorschriften, die bestimmen, wie die Elemente des Eingabesets sortiert werden sollen.</param>
        <param name="count">Ein Ausdruck, der die Anzahl der zu überspringenden Elemente des geordneten Satzes angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbSkipExpression" />, die das angegebene Eingabeset nach den angegebenen Sortiervorschriften sortiert, bevor die angegebene Anzahl von Elementen übersprungen wird.</summary>
        <returns>Ein neues DbSkipExpression, das den Vorgang des Überspringens darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="sortOrder" /> oder <paramref name="count" /> ist NULL oder <paramref name="sortOrder" /> enthält NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sortOrder" /> ist leer oder <paramref name="count" /> ist es nicht oder <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> oder <see cref="T:System.Data.Common.CommandTrees.DbParameterReferenceExpression" /> weist einen Ergebnistyp auf, der nicht gleich einem 64-Bit-Ganzzahl-Typ und nicht zu einem solchen heraufstufbar ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression Sort (this System.Data.Common.CommandTrees.DbExpressionBinding input, System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression Sort(class System.Data.Common.CommandTrees.DbExpressionBinding input, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.Common.CommandTrees.DbSortClause&gt; sortOrder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Sort(System.Data.Common.CommandTrees.DbExpressionBinding,System.Collections.Generic.IEnumerable{System.Data.Common.CommandTrees.DbSortClause})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sort (input As DbExpressionBinding, sortOrder As IEnumerable(Of DbSortClause)) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ Sort(System::Data::Common::CommandTrees::DbExpressionBinding ^ input, System::Collections::Generic::IEnumerable&lt;System::Data::Common::CommandTrees::DbSortClause ^&gt; ^ sortOrder);" />
      <MemberSignature Language="F#" Value="static member Sort : System.Data.Common.CommandTrees.DbExpressionBinding * seq&lt;System.Data.Common.CommandTrees.DbSortClause&gt; -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Sort (input, sortOrder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Data.Common.CommandTrees.DbExpressionBinding" RefType="this" />
        <Parameter Name="sortOrder" Type="System.Collections.Generic.IEnumerable&lt;System.Data.Common.CommandTrees.DbSortClause&gt;" />
      </Parameters>
      <Docs>
        <param name="input">Eine Ausdrucksbindung, die das Eingabeset angibt.</param>
        <param name="sortOrder">Eine Liste der Sortiervorschriften, die bestimmen, wie die Elemente des Eingabesets sortiert werden sollen.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" />, die das angegebene Eingabeset nach den angegebenen Sortiervorschriften sortiert.</summary>
        <returns>Ein neues DbSortExpression, das den Sortiervorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="sortOrder" /> ist NULL oder <paramref name="sortOrder" /> enthält NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sortOrder" /> ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbLimitExpression Take (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Common.CommandTrees.DbExpression count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbLimitExpression Take(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Common.CommandTrees.DbExpression count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Take(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Take (argument As DbExpression, count As DbExpression) As DbLimitExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbLimitExpression ^ Take(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Common::CommandTrees::DbExpression ^ count);" />
      <MemberSignature Language="F#" Value="static member Take : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbLimitExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Take (argument, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbLimitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="count" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der die Eingabeauflistung angibt.</param>
        <param name="count">Ein Ausdruck, der den Grenzwert angibt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbLimitExpression" />, der die Anzahl der Elemente in der Argumentsammlung auf den angegebenen Zählgrenzwert beschränkt. Verknüpfte Ergebnisse sind nicht in der Ausgabe enthalten.</summary>
        <returns>Ein neues DbLimitExpression mit den angegebenen Argument- und Zählgrenzwerten, das verknüpfte Ergebnisse nicht einschließt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> oder <paramref name="count" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="argument" /> hat keinen Auflistungsergebnistyp, oder <paramref name="count" /> hat keinen Ergebnistyp, der gleich einem 64-Bit-Ganzzahl-Typ oder zu einem solchen heraufstufbar ist.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenBy">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" />, das die Sortierreihenfolge der angegebenen Eingabereihenfolge zusammen mit dem angegebenen Sortierschlüssel in aufsteigender Sortierreihenfolge und mit Standardsortierung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenBy (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenBy(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenBy(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy (source As DbSortExpression, sortKey As Func(Of DbExpression, DbExpression)) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ ThenBy(System::Data::Common::CommandTrees::DbSortExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Data.Common.CommandTrees.DbSortExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenBy (source, sortKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Eine DbSortExpression, die das geordnete Eingabeset angibt.</param>
        <param name="sortKey">Eine Methode, die angibt, wie der zusätzliche Sortierschlüsselausdruck für einen angegebenen Member des Eingabesets abgeleitet wird. Diese Methode muss einen Ausdruck mit einem in der Reihenfolge vergleichbaren Ergebnistyp erzeugen, der die Sortierschlüsseldefinition bereitstellt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" />, das die Sortierreihenfolge der angegebenen Eingabereihenfolge zusammen mit dem angegebenen Sortierschlüssel in aufsteigender Sortierreihenfolge und mit Standardsortierung.</summary>
        <returns>Ein neues DbSortExpression, das den neuen gesamten ORDER-BY-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="sortKey" /> ist NULL.

- oder - 

Der von <paramref name="sortKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> weist keinen Auflistungsergebnistyp auf.

- oder - 

<paramref name="sortKey" /> weist keinen in der Reihenfolge vergleichbaren Zeichenfolgen-Ergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenBy (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenBy(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenBy(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy (source As DbSortExpression, sortKey As Func(Of DbExpression, DbExpression), collation As String) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ ThenBy(System::Data::Common::CommandTrees::DbSortExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey, System::String ^ collation);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Data.Common.CommandTrees.DbSortExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; * string -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenBy (source, sortKey, collation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Eine DbSortExpression, die das geordnete Eingabeset angibt.</param>
        <param name="sortKey">Eine Methode, die angibt, wie der zusätzliche Sortierschlüsselausdruck für einen angegebenen Member des Eingabesets abgeleitet wird. Diese Methode muss einen Ausdruck mit einem in der Reihenfolge vergleichbaren Ergebnistyp erzeugen, der die Sortierschlüsseldefinition bereitstellt.</param>
        <param name="collation">Die zu verwendende Sortierung.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" />, das die Sortierreihenfolge der angegebenen Eingabereihenfolge zusammen mit dem angegebenen Sortierschlüssel in aufsteigender Sortierreihenfolge und mit der angegebenen Standardsortierung.</summary>
        <returns>Ein neues DbSortExpression, das den neuen gesamten ORDER-BY-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="sortKey" /> oder <paramref name="collation" /> ist NULL.

- oder -  
Der von <paramref name="sortKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> weist keinen Auflistungsergebnistyp auf.

- oder - 

Der Ausdruck, der von <paramref name="sortKey" /> erzeugt wurde, hat keinen in der Reihenfolge vergleichbaren Zeichenfolgenergebnistyp.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="collation" /> ist leer oder enthält nur Leerzeichen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenByDescending">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" />, das die Sortierreihenfolge der angegebenen Eingabereihenfolge zusammen mit dem angegebenen Sortierschlüssel in absteigender Sortierreihenfolge und mit Standardsortierung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenByDescending (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenByDescending(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenByDescending(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending (source As DbSortExpression, sortKey As Func(Of DbExpression, DbExpression)) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ ThenByDescending(System::Data::Common::CommandTrees::DbSortExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Data.Common.CommandTrees.DbSortExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenByDescending (source, sortKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Eine DbSortExpression, die das geordnete Eingabeset angibt.</param>
        <param name="sortKey">Eine Methode, die angibt, wie der zusätzliche Sortierschlüsselausdruck für einen angegebenen Member des Eingabesets abgeleitet wird. Diese Methode muss einen Ausdruck mit einem in der Reihenfolge vergleichbaren Ergebnistyp erzeugen, der die Sortierschlüsseldefinition bereitstellt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" />, das die Sortierreihenfolge der angegebenen Eingabereihenfolge zusammen mit dem angegebenen Sortierschlüssel in absteigender Sortierreihenfolge und mit Standardsortierung.</summary>
        <returns>Ein neues DbSortExpression, das den neuen gesamten ORDER-BY-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="sortKey" /> ist NULL.

- oder - 

Der von <paramref name="sortKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> weist keinen Auflistungsergebnistyp auf.

- oder -  
Der Ausdruck, der von <paramref name="sortKey" /> erzeugt wurde, hat keinen in der Reihenfolge vergleichbaren Ergebnistyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortExpression ThenByDescending (this System.Data.Common.CommandTrees.DbSortExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortExpression ThenByDescending(class System.Data.Common.CommandTrees.DbSortExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; sortKey, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenByDescending(System.Data.Common.CommandTrees.DbSortExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression},System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending (source As DbSortExpression, sortKey As Func(Of DbExpression, DbExpression), collation As String) As DbSortExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortExpression ^ ThenByDescending(System::Data::Common::CommandTrees::DbSortExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ sortKey, System::String ^ collation);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Data.Common.CommandTrees.DbSortExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; * string -&gt; System.Data.Common.CommandTrees.DbSortExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ThenByDescending (source, sortKey, collation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbSortExpression" RefType="this" />
        <Parameter Name="sortKey" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Eine DbSortExpression, die das geordnete Eingabeset angibt.</param>
        <param name="sortKey">Eine Methode, die angibt, wie der zusätzliche Sortierschlüsselausdruck für einen angegebenen Member des Eingabesets abgeleitet wird. Diese Methode muss einen Ausdruck mit einem in der Reihenfolge vergleichbaren Ergebnistyp erzeugen, der die Sortierschlüsseldefinition bereitstellt.</param>
        <param name="collation">Die zu verwendende Sortierung.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbSortExpression" />, das die Sortierreihenfolge der angegebenen Eingabereihenfolge zusammen mit dem angegebenen Sortierschlüssel in absteigender Sortierreihenfolge und mit der angegebenen Standardsortierung.</summary>
        <returns>Ein neues DbSortExpression, das den neuen gesamten ORDER-BY-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="sortKey" /> oder <paramref name="collation" /> ist NULL.

- oder - 

Der von <paramref name="sortKey" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> weist keinen Auflistungsergebnistyp auf.

- oder -  
Der Ausdruck, der von <paramref name="sortKey" /> erzeugt wurde, hat keinen in der Reihenfolge vergleichbaren Zeichenfolgenergebnistyp.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="collation" /> ist leer oder enthält nur Leerzeichen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToSortClause">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> mit aufsteigender Sortierreihenfolge und Standardsortierung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToSortClause">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClause (this System.Data.Common.CommandTrees.DbExpression key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClause(class System.Data.Common.CommandTrees.DbExpression key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClause(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToSortClause (key As DbExpression) As DbSortClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortClause ^ ToSortClause(System::Data::Common::CommandTrees::DbExpression ^ key);" />
      <MemberSignature Language="F#" Value="static member ToSortClause : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbSortClause" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClause key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="key">Der Ausdruck, der den Sortierschlüssel definiert.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> mit aufsteigender Sortierreihenfolge und Standardsortierung.</summary>
        <returns>Eine neue Sortierungsklausel mit dem angegebenen Sortierschlüssel und aufsteigender Sortierreihenfolge.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="key" /> weist keinen in der Reihenfolge vergleichbaren Zeichenfolgen-Ergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSortClause">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClause (this System.Data.Common.CommandTrees.DbExpression key, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClause(class System.Data.Common.CommandTrees.DbExpression key, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClause(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToSortClause (key As DbExpression, collation As String) As DbSortClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortClause ^ ToSortClause(System::Data::Common::CommandTrees::DbExpression ^ key, System::String ^ collation);" />
      <MemberSignature Language="F#" Value="static member ToSortClause : System.Data.Common.CommandTrees.DbExpression * string -&gt; System.Data.Common.CommandTrees.DbSortClause" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClause (key, collation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Ausdruck, der den Sortierschlüssel definiert.</param>
        <param name="collation">Die zu verwendende Sortierung.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> mit aufsteigender Sortierreihenfolge und der angegebenen Sortierung.</summary>
        <returns>Eine neue Sortierungsklausel mit dem angegebenen Sortierschlüssel, Sortierreihenfolge und aufsteigenden Sortierreihenfolge.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="collation" /> ist leer oder enthält nur Leerzeichen.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="key" /> weist keinen in der Reihenfolge vergleichbaren Zeichenfolgen-Ergebnistyp auf.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToSortClauseDescending">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> mit absteigender Sortierreihenfolge und Standardsortierung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToSortClauseDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending (this System.Data.Common.CommandTrees.DbExpression key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending(class System.Data.Common.CommandTrees.DbExpression key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClauseDescending(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToSortClauseDescending (key As DbExpression) As DbSortClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortClause ^ ToSortClauseDescending(System::Data::Common::CommandTrees::DbExpression ^ key);" />
      <MemberSignature Language="F#" Value="static member ToSortClauseDescending : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbSortClause" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClauseDescending key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="key">Der Ausdruck, der den Sortierschlüssel definiert.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> mit absteigender Sortierreihenfolge und Standardsortierung.</summary>
        <returns>Eine neue Sortierungsklausel mit dem angegebenen Sortierschlüssel und absteigender Sortierreihenfolge.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="key" /> weist keinen in der Reihenfolge vergleichbaren Zeichenfolgen-Ergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSortClauseDescending">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending (this System.Data.Common.CommandTrees.DbExpression key, string collation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbSortClause ToSortClauseDescending(class System.Data.Common.CommandTrees.DbExpression key, string collation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClauseDescending(System.Data.Common.CommandTrees.DbExpression,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToSortClauseDescending (key As DbExpression, collation As String) As DbSortClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbSortClause ^ ToSortClauseDescending(System::Data::Common::CommandTrees::DbExpression ^ key, System::String ^ collation);" />
      <MemberSignature Language="F#" Value="static member ToSortClauseDescending : System.Data.Common.CommandTrees.DbExpression * string -&gt; System.Data.Common.CommandTrees.DbSortClause" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.ToSortClauseDescending (key, collation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbSortClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="collation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Ausdruck, der den Sortierschlüssel definiert.</param>
        <param name="collation">Die zu verwendende Sortierung.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbSortClause" /> mit absteigender Sortierreihenfolge und der angegebenen Sortierung.</summary>
        <returns>Eine neue Sortierungsklausel mit dem angegebenen Sortierschlüssel, Sortierreihenfolge und absteigender Sortierreihenfolge.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="collation" /> ist leer oder enthält nur Leerzeichen.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="key" /> weist keinen in der Reihenfolge vergleichbaren Zeichenfolgen-Ergebnistyp auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="TreatAs">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbTreatExpression TreatAs (this System.Data.Common.CommandTrees.DbExpression argument, System.Data.Metadata.Edm.TypeUsage treatType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbTreatExpression TreatAs(class System.Data.Common.CommandTrees.DbExpression argument, class System.Data.Metadata.Edm.TypeUsage treatType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.TreatAs(System.Data.Common.CommandTrees.DbExpression,System.Data.Metadata.Edm.TypeUsage)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TreatAs (argument As DbExpression, treatType As TypeUsage) As DbTreatExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbTreatExpression ^ TreatAs(System::Data::Common::CommandTrees::DbExpression ^ argument, System::Data::Metadata::Edm::TypeUsage ^ treatType);" />
      <MemberSignature Language="F#" Value="static member TreatAs : System.Data.Common.CommandTrees.DbExpression * System.Data.Metadata.Edm.TypeUsage -&gt; System.Data.Common.CommandTrees.DbTreatExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.TreatAs (argument, treatType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbTreatExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="treatType" Type="System.Data.Metadata.Edm.TypeUsage" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der die Instanz angibt.</param>
        <param name="treatType">Typmetadaten für den mit treat as angegebenen Typ.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbTreatExpression" />.</summary>
        <returns>Ein neues DbTreatExpression mit dem angegebenen Argument und Typ.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DbTreatExpression erfordert, dass `argument` verfügt über einen polymorphen Ergebnistyp und, `treatType` ist ein Typ aus der gleichen Typhierarchie wie dieser Ergebnistyp.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> oder <paramref name="treatType" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="treatType" /> befindet sich nicht in der gleichen Typenhierarchie wie der Ergebnistyp von <paramref name="argument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="True">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbConstantExpression True { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Data.Common.CommandTrees.DbConstantExpression True" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.True" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property True As DbConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Data::Common::CommandTrees::DbConstantExpression ^ True { System::Data::Common::CommandTrees::DbConstantExpression ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.True : System.Data.Common.CommandTrees.DbConstantExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.True" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbConstantExpression</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> mit dem booleschen Wert <see langword="true" /> ab.</summary>
        <value>Eine <see cref="T:System.Data.Common.CommandTrees.DbConstantExpression" /> mit dem booleschen Wert <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnaryMinus">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbArithmeticExpression UnaryMinus (this System.Data.Common.CommandTrees.DbExpression argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbArithmeticExpression UnaryMinus(class System.Data.Common.CommandTrees.DbExpression argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.UnaryMinus(System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function UnaryMinus (argument As DbExpression) As DbArithmeticExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbArithmeticExpression ^ UnaryMinus(System::Data::Common::CommandTrees::DbExpression ^ argument);" />
      <MemberSignature Language="F#" Value="static member UnaryMinus : System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbArithmeticExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.UnaryMinus argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbArithmeticExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Ausdruck, der das Argument angibt.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbArithmeticExpression" />, die den Wert des Arguments negiert.</summary>
        <returns>Ein neues DbArithmeticExpression, der den Negationsvorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="argument" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Kein numerischer Ergebnistyp für <paramref name="argument" /> vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbExpression Union (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbExpression Union(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Union(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union (left As DbExpression, right As DbExpression) As DbExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbExpression ^ Union(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member Union : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Union (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Mengenargument definiert.</param>
        <param name="right">Ein Ausdruck, der das rechte Mengenargument definiert.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbExpression" />, der die Gesamtmenge der linken und der rechten Mengenargumente ohne Duplikate berechnet.</summary>
        <returns>Ein neues DbExpression-Objekt, das die Gesamtmenge, ohne Duplikate, aus den linken und rechten Argumenten berechnet.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Zwischen <paramref name="left" /> und <paramref name="right" /> ist kein allgemeiner Auflistungsergebnistyp mit einem auf Gleichheit vergleichbaren Elementtyp vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnionAll">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbUnionAllExpression UnionAll (this System.Data.Common.CommandTrees.DbExpression left, System.Data.Common.CommandTrees.DbExpression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbUnionAllExpression UnionAll(class System.Data.Common.CommandTrees.DbExpression left, class System.Data.Common.CommandTrees.DbExpression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.UnionAll(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function UnionAll (left As DbExpression, right As DbExpression) As DbUnionAllExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbUnionAllExpression ^ UnionAll(System::Data::Common::CommandTrees::DbExpression ^ left, System::Data::Common::CommandTrees::DbExpression ^ right);" />
      <MemberSignature Language="F#" Value="static member UnionAll : System.Data.Common.CommandTrees.DbExpression * System.Data.Common.CommandTrees.DbExpression -&gt; System.Data.Common.CommandTrees.DbUnionAllExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.UnionAll (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbUnionAllExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="right" Type="System.Data.Common.CommandTrees.DbExpression" />
      </Parameters>
      <Docs>
        <param name="left">Ein Ausdruck, der das linke Mengenargument definiert.</param>
        <param name="right">Ein Ausdruck, der das rechte Mengenargument definiert.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbUnionAllExpression" />, die die Gesamtmenge der linken und der rechten Mengenargumente berechnet, ohne Duplikate zu entfernen.</summary>
        <returns>Ein neues DbUnionAllExpression-Objekt als Vereinigung, einschließlich Duplikate, der Gesamtmenge der linken und rechten Argumente.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> oder <paramref name="right" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Zwischen <paramref name="left" /> und <paramref name="right" /> ist kein allgemeiner Auflistungsergebnistyp mit einem auf Gleichheit vergleichbaren Elementtyp vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbVariableReferenceExpression Variable (this System.Data.Metadata.Edm.TypeUsage type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbVariableReferenceExpression Variable(class System.Data.Metadata.Edm.TypeUsage type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Variable(System.Data.Metadata.Edm.TypeUsage,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Variable (type As TypeUsage, name As String) As DbVariableReferenceExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbVariableReferenceExpression ^ Variable(System::Data::Metadata::Edm::TypeUsage ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Variable : System.Data.Metadata.Edm.TypeUsage * string -&gt; System.Data.Common.CommandTrees.DbVariableReferenceExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Variable (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbVariableReferenceExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Data.Metadata.Edm.TypeUsage" RefType="this" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ der Variablen, auf die verwiesen wird.</param>
        <param name="name">Der Name der Variable, auf die verwiesen wird.</param>
        <summary>Erstellt eine neue <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression" />, die auf eine Variable mit dem angegebenen Namen und Typ verweist.</summary>
        <returns>Ein DbVariableReferenceExpression, der einen Verweis auf eine Variable mit dem angegebenen Namen und Typ darstellt. Der Ergebnistyp des Ausdrucks ist derselbe <paramref name="type" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Where">
      <MemberSignature Language="C#" Value="public static System.Data.Common.CommandTrees.DbFilterExpression Where (this System.Data.Common.CommandTrees.DbExpression source, Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Data.Common.CommandTrees.DbFilterExpression Where(class System.Data.Common.CommandTrees.DbExpression source, class System.Func`2&lt;class System.Data.Common.CommandTrees.DbExpression, class System.Data.Common.CommandTrees.DbExpression&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Where(System.Data.Common.CommandTrees.DbExpression,System.Func{System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where (source As DbExpression, predicate As Func(Of DbExpression, DbExpression)) As DbFilterExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Data::Common::CommandTrees::DbFilterExpression ^ Where(System::Data::Common::CommandTrees::DbExpression ^ source, Func&lt;System::Data::Common::CommandTrees::DbExpression ^, System::Data::Common::CommandTrees::DbExpression ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : System.Data.Common.CommandTrees.DbExpression * Func&lt;System.Data.Common.CommandTrees.DbExpression, System.Data.Common.CommandTrees.DbExpression&gt; -&gt; System.Data.Common.CommandTrees.DbFilterExpression" Usage="System.Data.Common.CommandTrees.ExpressionBuilder.DbExpressionBuilder.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.CommandTrees.DbFilterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.Common.CommandTrees.DbExpression" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Ein Ausdruck, der das Eingabeset angibt.</param>
        <param name="predicate">Eine Methode, die ein Prädikat darstellt, das für jeden Member des Eingabesets ausgewertet werden soll.    Diese Methode muss einen Ausdruck mit einem booleschen Ergebnistyp erzeugen, der die Prädikatlogik bereitstellt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Data.Common.CommandTrees.DbFilterExpression" />, der die Elemente im angegebenen Eingabeset mithilfe des angegebenen Prädikats filtert.</summary>
        <returns>Ein neues DbQuantifierExpression, das den Any-Vorgang darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist NULL.

- oder -  
Der von <paramref name="predicate" /> erzeugte Ausdruck ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Der von <paramref name="predicate" /> erzeugte Ausdruck besitzt keinen booleschen Ergebnistyp.</exception>
      </Docs>
    </Member>
  </Members>
</Type>