<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="dfbd83b435486357a91721f19b050fdc1e7aa258" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52611160" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type MessageEnumerator = class&#xA;    inherit MarshalByRefObject&#xA;    interface IEnumerator&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt einen Vorwärtscursor zum Aufzählen der Nachrichten in einer Nachrichtenwarteschlange bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Messaging.MessageEnumerator> dynamische Interaktion mit Nachrichten in einer Warteschlange. Methoden zur Verfügung, über die <xref:System.Messaging.MessageQueue> Klasse zurückgeben kann eine <xref:System.Messaging.MessageEnumerator> verweist auf eine dynamische Liste von Nachrichten in der Warteschlange oder ein Array, das eine Kopie zu einem angegebenen Zeitpunkt – eine Momentaufnahme - der Warteschlange enthält, die zum Zeitpunkt der angegebenen Methode aufgerufen wurde.  
  
 Im Gegensatz zu der eine statische Momentaufnahme kann ein Enumerator die Auflistung geändert werden. Mit einem <xref:System.Messaging.MessageEnumerator>, können Sie Nachrichten aus der Warteschlange entfernen und in der Warteschlange wird die Änderung sofort übernommen.  
  
 Ein Enumerator wird nicht die Nachrichten aus der Warteschlange entfernt, beim Abfragen der Warteschlange. Gibt Informationen über die Nachricht an der aktuellen Cursorposition zurück, aber es bleibt die Nachricht in der Warteschlange.  
  
 Ein <xref:System.Messaging.MessageEnumerator> wird ein Cursor, an den Anfang einer dynamischen Liste initialisiert. Die Reihenfolge der Liste ist identisch mit der Reihenfolge der Nachrichten in der Warteschlange nach Nachrichtenpriorität. Sie können den Cursor in die erste Nachricht in die Warteschlange verschieben, durch den Aufruf <xref:System.Messaging.MessageEnumerator.MoveNext%2A>. Nachdem der Enumerator initialisiert wurde, können Sie <xref:System.Messaging.MessageEnumerator.MoveNext%2A> vorwärts zu durchlaufen, bis die verbleibenden Nachrichten. Sie können angeben, ob warten, bis eine Nachricht verfügbar sind, übergeben Sie einen Timeout in der <xref:System.Messaging.MessageEnumerator.MoveNext%2A> Methode.  
  
 Da der Enumerator dynamisch ist, kann eine Nachricht, die angefügt wird, außerhalb der aktuellen Cursorposition (z. B. aufgrund mit niedriger Priorität), zugegriffen werden vom Enumerator. Eine Meldung, die eingefügt wird, bevor der aktuellen Cursorposition nicht zugegriffen werden kann. Es ist nicht möglich, auf eine <xref:System.Messaging.MessageEnumerator>. Ein Cursor kann nur vorwärts bewegt werden. Die <xref:System.Messaging.MessageEnumerator.Reset%2A> Methode können Sie den Cursor wieder an den Anfang der Warteschlange zu platzieren.  
  
 Instanzen von <xref:System.Messaging.MessageEnumerator> für eine Warteschlange sind voneinander unabhängig. Erstellen Sie zwei <xref:System.Messaging.MessageEnumerator> Instanzen, die für dieselbe Warteschlange gelten. Die Änderungen, dass ein <xref:System.Messaging.MessageEnumerator> nutzt, um die Nachrichten in der Warteschlange werden sofort in eine zweite Enumerator Wenn der zweite Enumerator vor dem ersten positioniert ist. Jedoch, wenn zwei Enumeratoren die gleiche Position haben und einer von ihnen die Nachricht an dieser Position entfernt, eine Ausnahme wird ausgelöst, wenn der Enumerator andere versucht, den Wert der abzurufenden der <xref:System.Messaging.MessageEnumerator.Current%2A> Eigenschaft für die Nachricht bereits gelöschte.  
  
> [!NOTE]
>  Bei der Erstellung einer Instanz von <xref:System.Messaging.MessageQueue> mit <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> festgelegt `true`, keiner anderen Anwendung kann die Nachrichten in Ihrem Enumerator ändern, während Sie die Verbindung mit der Warteschlange haben.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft eine dynamische Liste von Nachrichten in einer Warteschlange ab und zählt alle Nachrichten mit der <xref:System.Messaging.Message.Priority%2A> -Eigenschaftensatz auf <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageEnumerator.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die dem Enumerator zugeordneten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem behält ein geöffnetes Handle an die Warteschlange, während der Lebensdauer des Cursors. Wenn Sie die Arbeit mit dem Enumerator abgeschlossen haben, rufen Sie <xref:System.Messaging.MessageEnumerator.Close%2A> , die dem Handle zugeordneten Ressourcen freizugeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Messaging.Message" Usage="System.Messaging.MessageEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das aktuelle <see cref="T:System.Messaging.Message" /> ab, auf das dieser Enumerator zeigt.</summary>
        <value>Die aktuelle Meldung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Enumerator erstellt wird, zeigt es an den Anfang der Warteschlange, an einer Position vor der ersten Meldung. In diesem Fall <xref:System.Messaging.MessageEnumerator.Current%2A> ist ungültig und löst eine Ausnahme aus, wenn auf sie zugegriffen wird. Rufen Sie <xref:System.Messaging.MessageEnumerator.MoveNext%2A> zur Positionierung des Cursors auf die erste Nachricht in der Warteschlange.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Messaging.MessageEnumerator.Current" /> wurde vor dem ersten Aufruf von <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> aufgerufen. Der Cursor befindet sich vor dem ersten Element der Meldungsenumeration.  
  
- oder -  
<see cref="P:System.Messaging.MessageEnumerator.Current" /> wurde aufgerufen, nachdem bei einem Aufruf von <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> der Wert <see langword="false" /> zurückgegeben wurde. (Dies bedeutet, dass sich der Cursor hinter dem letzten Element der Meldungsenumeration befindet.)</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Meldung, auf die der Enumerator gegenwärtig zeigt, ist nicht mehr vorhanden. Es wurde möglicherweise gelöscht.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.CursorHandle : nativeint" Usage="System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das systemeigene Cursorhandle von Message Queuing ab, das zum Durchsuchen von Meldungen in der Warteschlange verwendet wird.</summary>
        <value>Das systemeigene Cursorhandle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft enthält das systemeigene Handle für die Enumeration. Wenn Sie die Arbeit mit dem Enumerator abgeschlossen haben, rufen Sie <xref:System.Messaging.MessageEnumerator.Close%2A> dieser Ressource freigibt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Das Handle ist nicht vorhanden.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die von der <see cref="T:System.Messaging.MessageEnumerator" /> verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="messageEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle vom <see cref="T:System.Messaging.MessageEnumerator" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Messaging.MessageEnumerator.Dispose%2A> können die Ressourcen, die von verwendet die <xref:System.Messaging.MessageEnumerator> , für andere Zwecke verschoben werden. Weitere Informationen zu <xref:System.Messaging.MessageEnumerator.Dispose%2A>, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Bereinigen von nicht verwalteten Ressourcen</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageEnumerator.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.Messaging.MessageEnumerator" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der öffentlichen <xref:System.Messaging.MessageEnumerator.Dispose%2A> Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose()` Ruft die geschützte `Dispose(Boolean)` -Methode mit dem `disposing` Parametersatz zu `true`. <xref:System.Object.Finalize%2A> Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Messaging.MessageEnumerator> verweist. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see langword="Dispose(Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see langword="Dispose" /> freigegeben wurden. Weitere Informationen zur Implementierung <see langword="Dispose" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Weitere Informationen zu <see langword="Dispose" /> und <see langword="Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementieren einer Dispose-Methode</related>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Bereinigen von nicht verwalteten Ressourcen</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="messageEnumerator.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die von diesem Enumerator reservierten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Diese Methode überschreibt <xref:System.Object.Finalize>. Anwendungscode sollte diese Methode nicht aufgerufen. Finalize-Methode eines Objekts wird automatisch während der Garbagecollection aufgerufen, Beendigung vom Garbage Collector durch einen Aufruf von deaktiviert wurde die <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> Methode.

Weitere Informationen finden Sie unter [Finalize-Methoden und Destruktoren](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v=vs.100)), [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md), und [Überschreiben der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Setzt den Enumerator auf die nächste Meldung in der Warteschlange.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="messageEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den Enumerator auf die nächste Meldung in der Warteschlange, sofern eine Meldung verfügbar ist.</summary>
        <returns>
          <see langword="true" />, wenn der Enumerator erfolgreich auf die nächste Meldung gesetzt wurde. <see langword="false" />, wenn der Enumerator das Ende der Warteschlange erreicht hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird sofort zurückgegeben, wenn keine Meldung in der Warteschlange vorhanden ist. Es gibt eine andere Überladung, die wartet, eine angegebene <xref:System.TimeSpan> für eine Nachricht eintrifft.  
  
 Wenn eine Nachricht nicht derzeit verfügbar ist, weil die Warteschlange leer ist oder Sie hinter dem letzten Element in der Auflistung verschoben haben <xref:System.Messaging.MessageEnumerator.MoveNext%2A> gibt `false` an die aufrufende Methode.  
  
 Bei der Erstellung einer konzeptionell Enumerator wird vor der ersten Nachricht der Warteschlange und der erste Aufruf <xref:System.Messaging.MessageEnumerator.MoveNext%2A> zeigt die erste Nachricht der Warteschlange an.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Es wurde eine Message Queuing-spezifische Ausnahme ausgelöst.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.MoveNext : TimeSpan -&gt; bool" Usage="messageEnumerator.MoveNext timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Die <see cref="T:System.TimeSpan" /> gibt die Zeitspanne an, innerhalb derer eine Meldung eingehen muss, wenn der Enumerator auf das Ende der Warteschlange zeigt.</param>
        <summary>Setzt den Enumerator auf die nächste Meldung in der Warteschlange. Wenn sich der Enumerator am Ende der Warteschlange befindet, wartet <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />, bis eine Meldung verfügbar ist oder der angegebene Timeout überschritten wird.</summary>
        <returns>
          <see langword="true" />, wenn der Enumerator erfolgreich auf die nächste Meldung gesetzt wurde. <see langword="false" />, wenn der Enumerator das Ende der Warteschlange erreicht hat und innerhalb der im <paramref name="timeout" />-Parameter angegebenen Zeit keine Meldung eingeht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wartet, wenn keine Meldung in der Warteschlange vorhanden ist oder wenn der Cursor am Ende der Warteschlange erreicht hat. Wenn eine Nachricht nicht derzeit verfügbar ist, weil die Warteschlange leer ist oder Sie hinter dem letzten Element in der Auflistung verschoben haben <xref:System.Messaging.MessageEnumerator.MoveNext%2A> das angegebene Timeout.  
  
 Wenn der Cursor ist bereits am Ende der Warteschlange ist <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nur gibt `true` bei Empfang die neue Nachricht innerhalb des angegebenen Zeitintervalls derzeit hat eine niedrigere Priorität als alle Nachrichten in der Warteschlange und wird am Ende der Warteschlange platziert. Eine Überladung ohne Parameter gibt sofort zurück, wenn keine weiteren Nachrichten in der Warteschlange befinden.  
  
 Bei der Erstellung einer konzeptionell Enumerator wird vor der ersten Nachricht von der Enumeration und dem ersten Aufruf von <xref:System.Messaging.MessageEnumerator.MoveNext%2A> die erste Meldung in der Enumeration in der Ansicht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den Timeoutparameter angegebene Wert ist ungültig. Eventuell wurde ein negativer Wert angegeben.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Es wurde eine Message Queuing-spezifische Ausnahme ausgelöst.  
  
- oder -  
Der Timeout wurde überschritten.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt die aktuelle Meldung aus der Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Durch das Entfernen einer Meldung wird diese aus der Warteschlange gelöscht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für diese Überladungen beschriebene Verhalten gilt nur, wenn die <xref:System.Messaging.MessageEnumerator> Instanz abgerufen wird, mithilfe der <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>. Verwenden Sie keine <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> zum Abrufen einer Instanz von <xref:System.Messaging.MessageEnumerator> wie diese Methode wurde als veraltet markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt die aktuelle Meldung aus einer transaktionalen oder nicht transaktionalen Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Für das Eintreffen einer Meldung in der Warteschlange ist kein Timeout festgelegt.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an der aktuellen Cursorposition zurück.  
  
 Wenn Sie Warteschlange Journaling verwenden, Entfernen der Nachricht führt dazu, dass eine Kopie in der Journalwarteschlange gespeichert werden sollen, wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Meldung verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Wenn Sie diese Überladung für eine transaktionale Warteschlange aufrufen, erstellt das Message Queuing eine einzelne internen Transaktion aus.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Dieses <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt stellt die Transaktion dar, innerhalb der die Meldung entfernt wird.</param>
        <summary>Entfernt die aktuelle Meldung aus einer transaktionalen Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Für das Eintreffen einer Meldung in der Warteschlange ist kein Timeout festgelegt.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an die Position des Cursors, mithilfe von definierten internen Transaktionskontext die `transaction` Parameter.  
  
 Wenn Sie Warteschlange Journaling verwenden, Entfernen der Nachricht führt dazu, dass eine Kopie in der Journalwarteschlange gespeichert werden sollen, wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Bei der Arbeit mit Transaktionswarteschlangen ein Rollback einer Transaktion führt dazu, dass alle Nachrichten, die durch einen Aufruf von entfernt <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> an die Warteschlange zurückgegeben werden. Die Entfernung ist nicht nicht rückgängig gemacht werden, bis die Transaktion ein Commit ausgeführt wird.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Meldung verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Entfernt die aktuelle Meldung aus einer Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Für das Eintreffen einer Meldung in der Warteschlange ist kein Timeout festgelegt.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an die Position des Cursors, mithilfe von definierten Transaktionskontext der `transactionType` Parameter.  
  
 Geben Sie `Automatic` für die `transactionType` -Parameters, wenn es bereits ein externer Transaktionskontext ist an den Thread angefügt, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` sollten Sie die Nachricht als eine interne Transaktion empfangen. Sie können angeben, `None` sollten Sie eine Nachricht aus einer transaktionalen Warteschlange außerhalb eines Transaktionskontexts zu empfangen.  
  
 Wenn Sie Warteschlange Journaling verwenden, Entfernen der Nachricht führt dazu, dass eine Kopie in der Journalwarteschlange gespeichert werden sollen, wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Bei der Arbeit mit Transaktionswarteschlangen ein Rollback einer Transaktion führt dazu, dass alle Nachrichten, die durch einen Aufruf von entfernt <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> an die Warteschlange zurückgegeben werden. Die Entfernung ist nicht nicht rückgängig gemacht werden, bis die Transaktion ein Commit ausgeführt wird.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Meldung verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Die Zeit, die auf das Eintreffen einer Meldung gewartet werden soll.</param>
        <summary>Entfernt die aktuelle Meldung aus der Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Wenn eine vorhandene Meldung entfernt werden kann, wird diese von der Methode sofort zurückgegeben. Andernfalls wartet die Methode auf das Eingehen einer neuen Meldung, bis der angegebene Timeout überschritten wird.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an der aktuellen Cursorposition zurück. Wenn der Cursor am Ende der Warteschlange befindet, wird diese Überladung der Methode wartet, bis eine Meldung verfügbar ist oder das Intervall angegeben wird, indem die `timeout` Parameter ist abgelaufen.  
  
 Wenn Sie Warteschlange Journaling verwenden, Entfernen der Nachricht führt dazu, dass eine Kopie in der Journalwarteschlange gespeichert werden sollen, wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Meldung verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Wenn Sie diese Überladung für eine transaktionale Warteschlange aufrufen, erstellt das Message Queuing eine einzelne internen Transaktion aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Der Timeout wurde überschritten.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Die Zeitspanne, in der die zu entfernende Meldung eingehen muss.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt, das den Transaktionskontext für diese Meldung angibt.</param>
        <summary>Entfernt die aktuelle Meldung aus einer transaktionalen Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Wenn eine vorhandene Meldung entfernt werden kann, wird diese von der Methode sofort zurückgegeben. Andernfalls wartet die Methode auf das Eingehen einer neuen Meldung, bis der angegebene Timeout überschritten wird.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an der aktuellen Cursorposition zurück. Wenn der Cursor am Ende der Warteschlange befindet, wird diese Überladung der Methode wartet, bis eine Meldung verfügbar ist oder das Intervall angegeben wird, indem die `timeout` Parameter ist abgelaufen.  
  
 Bei der Arbeit mit Transaktionswarteschlangen ein Rollback einer Transaktion führt dazu, dass alle Nachrichten, die durch einen Aufruf von entfernt <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> an die Warteschlange zurückgegeben werden. Die Entfernung ist nicht nicht rückgängig gemacht werden, bis die Transaktion ein Commit ausgeführt wird.  
  
 Wenn Sie Warteschlange Journaling verwenden, Entfernen der Nachricht führt dazu, dass eine Kopie in der Journalwarteschlange gespeichert werden sollen, wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Meldung verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Der Timeout wurde überschritten.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Die Zeitspanne, in der die zu entfernende Meldung eingehen muss.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Entfernt die aktuelle Meldung aus einer Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Wenn eine vorhandene Meldung entfernt werden kann, wird diese von der Methode sofort zurückgegeben. Andernfalls wartet die Methode auf das Eingehen einer neuen Meldung, bis der angegebene Timeout überschritten wird.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an die Position des Cursors, mithilfe von definierten Transaktionskontext der `transactionType` Parameter. Wenn der Cursor am Ende der Warteschlange befindet, wird diese Überladung der Methode wartet, bis eine Meldung verfügbar ist oder das Intervall angegeben wird, indem die `timeout` Parameter ist abgelaufen.  
  
 Geben Sie `Automatic` für die `transactionType` -Parameters, wenn es bereits ein externer Transaktionskontext ist an den Thread angefügt, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` sollten Sie die Nachricht als eine interne Transaktion empfangen. Sie können angeben, `None` sollten Sie eine Nachricht aus einer transaktionalen Warteschlange außerhalb eines Transaktionskontexts zu empfangen.  
  
 Wenn Sie Warteschlange Journaling verwenden, Entfernen der Nachricht führt dazu, dass eine Kopie in der Journalwarteschlange gespeichert werden sollen, wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Bei der Arbeit mit Transaktionswarteschlangen ein Rollback einer Transaktion führt dazu, dass alle Nachrichten, die durch einen Aufruf von entfernt <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> an die Warteschlange zurückgegeben werden. Die Entfernung ist nicht nicht rückgängig gemacht werden, bis die Transaktion ein Commit ausgeführt wird.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Meldung verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Der Timeout wurde überschritten.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="messageEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den aktuellen Enumerator auf den Anfang der Warteschlange zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Enumerator kann nur vorwärts verschoben werden. Verwenden Sie diese Methode am Anfang der Warteschlange beginnen.  
  
 Nach dem Aufruf <xref:System.Messaging.MessageEnumerator.Reset%2A>, zeigt der Cursor auf die erste Nachricht. Sie müssen nicht aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.Reset%2A> auf den Cursor auf die erste Meldung in der Warteschlange zu setzen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt eine <see cref="T:System.Messaging.Message" /> zurück, die auf die Meldung an der aktuellen Cursorposition verweist.</summary>
        <value>Eine <see cref="T:System.Messaging.Message" />, die auf die Meldung an der aktuellen Cursorposition verweist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>