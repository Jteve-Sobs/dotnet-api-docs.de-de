<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8efdebcdda0d244a01f27597d636c3a6bc61870e" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83953895" /></Metadata><TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type MessageEnumerator = class&#xA;    inherit MarshalByRefObject&#xA;    interface IEnumerator&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="f8603-101">Stellt einen Vorwärtscursor zum Aufzählen der Nachrichten in einer Nachrichtenwarteschlange bereit.</span><span class="sxs-lookup"><span data-stu-id="f8603-101">Provides a forward-only cursor to enumerate through messages in a message queue.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8603-102">Verwenden Sie <xref:System.Messaging.MessageEnumerator> für die dynamische Interaktion mit Nachrichten in einer Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="f8603-102">Use <xref:System.Messaging.MessageEnumerator> for dynamic interaction with messages in a queue.</span></span> <span data-ttu-id="f8603-103">Methoden, die über die <xref:System.Messaging.MessageQueue>-Klasse verfügbar sind, können entweder eine <xref:System.Messaging.MessageEnumerator> zurückgeben, die auf eine dynamische Liste von Nachrichten in der Warteschlange zeigt, oder ein Array, das eine Kopie zu einem bestimmten Zeitpunkt enthält: eine Momentaufnahme der Warteschlange zu dem Zeitpunkt, als die angegebene Methode aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="f8603-103">Methods available through the <xref:System.Messaging.MessageQueue> class can return either a <xref:System.Messaging.MessageEnumerator> pointing to a dynamic list of messages in the queue, or an array that contains a copy at a given instant - a snapshot - of the queue at the time the specified method was called.</span></span>  
  
 <span data-ttu-id="f8603-104">Anders als eine statische Momentaufnahme ermöglicht ein Enumerator das Ändern der Auflistung.</span><span class="sxs-lookup"><span data-stu-id="f8603-104">Unlike a static snapshot, an enumerator allows you to modify the collection.</span></span> <span data-ttu-id="f8603-105">Mithilfe eines <xref:System.Messaging.MessageEnumerator>können Sie Nachrichten aus der Warteschlange entfernen, und die Änderung wird sofort in der Warteschlange widergespiegelt.</span><span class="sxs-lookup"><span data-stu-id="f8603-105">Using a <xref:System.Messaging.MessageEnumerator>, you can remove messages from the queue, and the change is immediately reflected in the queue.</span></span>  
  
 <span data-ttu-id="f8603-106">Ein Enumerator entfernt die Nachrichten nicht aus der Warteschlange, wenn er die Warteschlange abfragt.</span><span class="sxs-lookup"><span data-stu-id="f8603-106">An enumerator does not remove the messages from the queue when it queries the queue.</span></span> <span data-ttu-id="f8603-107">Sie gibt Informationen über die Nachricht an der aktuellen Cursorposition zurück, aber die Nachricht wird in der Warteschlange belassen.</span><span class="sxs-lookup"><span data-stu-id="f8603-107">It returns information about the message at the current cursor position, but it leaves the message in the queue.</span></span>  
  
 <span data-ttu-id="f8603-108">Ein <xref:System.Messaging.MessageEnumerator> ist ein Cursor, der mit dem Anfang einer dynamischen Liste initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="f8603-108">A <xref:System.Messaging.MessageEnumerator> is a cursor, initialized to the head of a dynamic list.</span></span> <span data-ttu-id="f8603-109">Die Reihenfolge der Listen ist mit der Reihenfolge der Nachrichten in der Warteschlange entsprechend der Nachrichten Priorität identisch.</span><span class="sxs-lookup"><span data-stu-id="f8603-109">The list order is the same as the order of the messages in the queue, according to message priority.</span></span> <span data-ttu-id="f8603-110">Sie können den Cursor zur ersten Nachricht in der Warteschlange bewegen, indem Sie <xref:System.Messaging.MessageEnumerator.MoveNext%2A>aufrufen.</span><span class="sxs-lookup"><span data-stu-id="f8603-110">You can move the cursor to the first message in the queue by calling <xref:System.Messaging.MessageEnumerator.MoveNext%2A>.</span></span> <span data-ttu-id="f8603-111">Nachdem der Enumerator initialisiert wurde, können Sie <xref:System.Messaging.MessageEnumerator.MoveNext%2A> verwenden, um die verbleibenden Nachrichten schrittweise zu durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="f8603-111">After the enumerator has been initialized, you can use <xref:System.Messaging.MessageEnumerator.MoveNext%2A> to step forward through the remaining messages.</span></span> <span data-ttu-id="f8603-112">Sie können angeben, ob auf die Verfügbarkeit einer Nachricht gewartet werden soll, indem Sie ein Timeout an die <xref:System.Messaging.MessageEnumerator.MoveNext%2A> Methode übergeben.</span><span class="sxs-lookup"><span data-stu-id="f8603-112">You can specify whether to wait for a message to become available by passing a timeout into the <xref:System.Messaging.MessageEnumerator.MoveNext%2A> method.</span></span>  
  
 <span data-ttu-id="f8603-113">Da der Enumerator dynamisch ist, kann eine Nachricht, die über die aktuelle Position des Cursors (z. b. aufgrund niedriger Priorität) angefügt wird, durch den Enumerator aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="f8603-113">Because the enumerator is dynamic, a message that is appended beyond the cursor's current position (for example, due to low priority), can be accessed by the enumerator.</span></span> <span data-ttu-id="f8603-114">Auf eine Meldung, die vor der aktuellen Position des Cursors eingefügt wird, kann nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="f8603-114">A message that is inserted before the cursor's current position cannot be accessed.</span></span> <span data-ttu-id="f8603-115">Es ist nicht möglich, mit einer <xref:System.Messaging.MessageEnumerator>rückwärts zu wechseln.</span><span class="sxs-lookup"><span data-stu-id="f8603-115">It is not possible to step backward with a <xref:System.Messaging.MessageEnumerator>.</span></span> <span data-ttu-id="f8603-116">Ein Cursor ermöglicht Vorwärtsbewegung.</span><span class="sxs-lookup"><span data-stu-id="f8603-116">A cursor allows forward-only movement.</span></span> <span data-ttu-id="f8603-117">Mit der <xref:System.Messaging.MessageEnumerator.Reset%2A>-Methode können Sie den Cursor am Anfang der Warteschlange wieder platzieren.</span><span class="sxs-lookup"><span data-stu-id="f8603-117">The <xref:System.Messaging.MessageEnumerator.Reset%2A> method enables you to place the cursor back at the beginning of the queue.</span></span>  
  
 <span data-ttu-id="f8603-118">Instanzen von <xref:System.Messaging.MessageEnumerator> für eine bestimmte Warteschlange funktionieren unabhängig voneinander.</span><span class="sxs-lookup"><span data-stu-id="f8603-118">Instances of <xref:System.Messaging.MessageEnumerator> for a given queue work independently.</span></span> <span data-ttu-id="f8603-119">Sie können zwei <xref:System.Messaging.MessageEnumerator> Instanzen erstellen, die für dieselbe Warteschlange gelten.</span><span class="sxs-lookup"><span data-stu-id="f8603-119">You can create two <xref:System.Messaging.MessageEnumerator> instances that apply to the same queue.</span></span> <span data-ttu-id="f8603-120">Die Änderungen, die eine <xref:System.Messaging.MessageEnumerator> an den Nachrichten in der Warteschlange vornimmt, werden sofort in einem zweiten Enumerator reflektiert, wenn der zweite Enumerator vor dem ersten positioniert wird.</span><span class="sxs-lookup"><span data-stu-id="f8603-120">The changes that one <xref:System.Messaging.MessageEnumerator> makes to the messages in the queue will be reflected immediately in a second enumerator if the second enumerator is positioned before the first.</span></span> <span data-ttu-id="f8603-121">Wenn jedoch zwei Enumeratoren dieselbe Position haben und eine von Ihnen an dieser Position entfernt wird, wird eine Ausnahme ausgelöst, wenn der andere Enumerator versucht, den Wert der <xref:System.Messaging.MessageEnumerator.Current%2A>-Eigenschaft für die nun gelöschte Nachricht zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="f8603-121">However, if two enumerators have the same position and one of them removes the message at that position, an exception is thrown if the other enumerator attempts to get the value of the <xref:System.Messaging.MessageEnumerator.Current%2A> property on the now-deleted message.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f8603-122">Wenn Sie eine Instanz von <xref:System.Messaging.MessageQueue> erstellen, bei der <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> auf `true`festgelegt ist, kann keine andere Anwendung die Nachrichten in Ihrem Enumerator ändern, während Sie über die Verbindung mit der Warteschlange verfügen.</span><span class="sxs-lookup"><span data-stu-id="f8603-122">If you create an instance of <xref:System.Messaging.MessageQueue> with <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> set to `true`, no other application can modify the messages in your enumerator while you have the connection to the queue.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f8603-123">Im folgenden Beispiel wird eine dynamische Liste von Nachrichten in einer Warteschlange abgerufen und alle Nachrichten gezählt, deren <xref:System.Messaging.Message.Priority%2A>-Eigenschaft auf <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="f8603-123">The following example gets a dynamic list of messages in a queue and counts all messages with the <xref:System.Messaging.Message.Priority%2A> property set to <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.</span></span>  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageEnumerator.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f8603-124">Gibt die dem Enumerator zugeordneten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="f8603-124">Frees the resources associated with the enumerator.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8603-125">Das Betriebssystem behält während der Lebensdauer des Cursors ein geöffnetes Handle für die Warteschlange bei.</span><span class="sxs-lookup"><span data-stu-id="f8603-125">The operating system retains an open handle to the queue during the lifetime of the cursor.</span></span> <span data-ttu-id="f8603-126">Wenn Sie die Arbeit mit dem Enumerator abgeschlossen haben, können Sie <xref:System.Messaging.MessageEnumerator.Close%2A> abrufen, um die dem Handle zugeordneten Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="f8603-126">When you have finished working with the enumerator, call <xref:System.Messaging.MessageEnumerator.Close%2A> to release the resources associated with the handle.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Messaging.Message" Usage="System.Messaging.MessageEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f8603-127">Ruft das aktuelle <see cref="T:System.Messaging.Message" /> ab, auf das dieser Enumerator zeigt.</span><span class="sxs-lookup"><span data-stu-id="f8603-127">Gets the current <see cref="T:System.Messaging.Message" /> that this enumerator points to.</span></span></summary>
        <value><span data-ttu-id="f8603-128">Die aktuelle Meldung.</span><span class="sxs-lookup"><span data-stu-id="f8603-128">The current message.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8603-129">Wenn der Enumerator erstellt wird, verweist er an einer Position vor der ersten Nachricht auf den Anfang der Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="f8603-129">When the enumerator is created, it points to the head of the queue, at a location before the first message.</span></span> <span data-ttu-id="f8603-130">In diesem Fall ist <xref:System.Messaging.MessageEnumerator.Current%2A> ungültig und löst eine Ausnahme aus, wenn darauf zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="f8603-130">In this case, <xref:System.Messaging.MessageEnumerator.Current%2A> is not valid and will throw an exception if it is accessed.</span></span> <span data-ttu-id="f8603-131">Sie müssen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> aufgerufen werden, um den Cursor an der ersten Nachricht in der Warteschlange zu positionieren.</span><span class="sxs-lookup"><span data-stu-id="f8603-131">You must call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> to position the cursor at the first message in the queue.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f8603-132"><see cref="P:System.Messaging.MessageEnumerator.Current" /> wurde vor dem ersten Aufruf von <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="f8603-132">You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> before the first call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />.</span></span> <span data-ttu-id="f8603-133">Der Cursor befindet sich vor dem ersten Element der Meldungsenumeration.</span><span class="sxs-lookup"><span data-stu-id="f8603-133">The cursor is located before the first element of the message enumeration.</span></span>  
  
<span data-ttu-id="f8603-134">Oder</span><span class="sxs-lookup"><span data-stu-id="f8603-134">-or-</span></span> 
<span data-ttu-id="f8603-135"><see cref="P:System.Messaging.MessageEnumerator.Current" /> wurde aufgerufen, nachdem bei einem Aufruf von <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> der Wert <see langword="false" /> zurückgegeben wurde. (Dies bedeutet, dass sich der Cursor hinter dem letzten Element der Meldungsenumeration befindet.)</span><span class="sxs-lookup"><span data-stu-id="f8603-135">You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> after a call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> had returned <see langword="false" /> (indicating the cursor is located after the last element of the message enumeration.)</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="f8603-136">Die Meldung, auf die der Enumerator gegenwärtig zeigt, ist nicht mehr vorhanden.</span><span class="sxs-lookup"><span data-stu-id="f8603-136">The message the enumerator is currently pointing to no longer exists.</span></span> <span data-ttu-id="f8603-137">Es wurde möglicherweise gelöscht.</span><span class="sxs-lookup"><span data-stu-id="f8603-137">It might have been deleted.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.CursorHandle : nativeint" Usage="System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f8603-138">Ruft das systemeigene Cursorhandle von Message Queuing ab, das zum Durchsuchen von Meldungen in der Warteschlange verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="f8603-138">Gets the native Message Queuing cursor handle used to browse messages in the queue.</span></span></summary>
        <value><span data-ttu-id="f8603-139">Das systemeigene Cursorhandle.</span><span class="sxs-lookup"><span data-stu-id="f8603-139">The native cursor handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8603-140">Diese Eigenschaft enthält das Native Handle der-Enumeration.</span><span class="sxs-lookup"><span data-stu-id="f8603-140">This property contains the native handle to the enumeration.</span></span> <span data-ttu-id="f8603-141">Wenn Sie die Arbeit mit dem Enumerator abgeschlossen haben, wenden Sie <xref:System.Messaging.MessageEnumerator.Close%2A> an, um diese Ressource freizugeben.</span><span class="sxs-lookup"><span data-stu-id="f8603-141">When you have finished working with the enumerator, call <xref:System.Messaging.MessageEnumerator.Close%2A> to release this resource.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="f8603-142">Das Handle ist nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="f8603-142">The handle does not exist.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f8603-143">Gibt die von <see cref="T:System.Messaging.MessageEnumerator" /> verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="f8603-143">Releases the resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="messageEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f8603-144">Gibt alle von <see cref="T:System.Messaging.MessageEnumerator" /> verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="f8603-144">Releases all resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8603-145">Durch Aufrufen von <xref:System.Messaging.MessageEnumerator.Dispose%2A> können die Ressourcen, die vom <xref:System.Messaging.MessageEnumerator> verwendet werden, für andere Zwecke neu zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="f8603-145">Calling <xref:System.Messaging.MessageEnumerator.Dispose%2A> allows the resources used by the <xref:System.Messaging.MessageEnumerator> to be reallocated for other purposes.</span></span> <span data-ttu-id="f8603-146">Weitere Informationen zu <xref:System.Messaging.MessageEnumerator.Dispose%2A>finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](/dotnet/standard/garbage-collection/unmanaged).</span><span class="sxs-lookup"><span data-stu-id="f8603-146">For more information about <xref:System.Messaging.MessageEnumerator.Dispose%2A>, see [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/garbage-collection/unmanaged"><span data-ttu-id="f8603-147">Bereinigen von nicht verwalteten Ressourcen</span><span class="sxs-lookup"><span data-stu-id="f8603-147">Cleaning Up Unmanaged Resources</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageEnumerator.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="f8603-148"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben. <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="f8603-148"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="f8603-149">Gibt die von <see cref="T:System.Messaging.MessageEnumerator" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="f8603-149">Releases the unmanaged resources used by the <see cref="T:System.Messaging.MessageEnumerator" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8603-150">Diese Methode wird von der öffentlichen <xref:System.Messaging.MessageEnumerator.Dispose%2A>-Methode und der <xref:System.Object.Finalize%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="f8603-150">This method is called by the public <xref:System.Messaging.MessageEnumerator.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="f8603-151">`Dispose()` Ruft die geschützte `Dispose(Boolean)` Methode auf, wobei der `disposing`-Parameter auf `true`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="f8603-151">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="f8603-152"><xref:System.Object.Finalize%2A> ruft `Dispose` auf, bei dem `disposing` auf `false`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="f8603-152"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="f8603-153">Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Messaging.MessageEnumerator> verweist.</span><span class="sxs-lookup"><span data-stu-id="f8603-153">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Messaging.MessageEnumerator> references.</span></span> <span data-ttu-id="f8603-154">Diese Methode ruft die `Dispose()`-Methode jedes referenzierten Objekts auf.</span><span class="sxs-lookup"><span data-stu-id="f8603-154">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="f8603-155">
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="f8603-155">
            <see langword="Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="f8603-156">Beim Überschreiben von <see langword="Dispose(Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see langword="Dispose" /> freigegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="f8603-156">When overriding <see langword="Dispose(Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span></span> <span data-ttu-id="f8603-157">Weitere Informationen zum Implementieren von <see langword="Dispose" />finden Sie unter [Implementieren einer](/dotnet/standard/garbage-collection/implementing-dispose)verwerfen-Methode.</span><span class="sxs-lookup"><span data-stu-id="f8603-157">For more information about how to implement <see langword="Dispose" />, see [Implementing a Dispose Method](/dotnet/standard/garbage-collection/implementing-dispose).</span></span>  
  
<span data-ttu-id="f8603-158">Weitere Informationen zu <see langword="Dispose" /> und <see langword="Finalize" />finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](/dotnet/standard/garbage-collection/unmanaged) und überschreiben [der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="f8603-158">For more information about <see langword="Dispose" /> and <see langword="Finalize" />, see [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged) and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span></span></para></block>
        <related type="Article" href="/dotnet/standard/garbage-collection/implementing-dispose"><span data-ttu-id="f8603-159">Implementieren einer Dispose-Methode</span><span class="sxs-lookup"><span data-stu-id="f8603-159">Implementing a Dispose method</span></span></related>
        <related type="Article" href="/dotnet/standard/garbage-collection/unmanaged"><span data-ttu-id="f8603-160">Bereinigen von nicht verwalteten Ressourcen</span><span class="sxs-lookup"><span data-stu-id="f8603-160">Cleaning Up Unmanaged Resources</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="messageEnumerator.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f8603-161">Gibt die von diesem Enumerator reservierten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="f8603-161">Releases the resources held by the enumerator.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="f8603-162">Diese Methode überschreibt <xref:System.Object.Finalize>.</span><span class="sxs-lookup"><span data-stu-id="f8603-162">This method overrides <xref:System.Object.Finalize>.</span></span> <span data-ttu-id="f8603-163">Der Anwendungscode sollte diese Methode nicht aufzurufen. die Finalize-Methode eines Objekts wird automatisch während Garbage Collection aufgerufen, es sei denn, die Garbage Collector wurde durch einen Aufruf der <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>-Methode deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="f8603-163">Application code should not call this method; an object's Finalize method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="f8603-164">Weitere Informationen finden Sie unter [Finalize-Methoden und debugtoren](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v=vs.100)), [Bereinigen von nicht verwalteten Ressourcen](/dotnet/standard/garbage-collection/unmanaged)und überschreiben [der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="f8603-164">For more information, see [Finalize Methods and Destructors](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v=vs.100)), [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged), and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f8603-165">Setzt den Enumerator auf die nächste Meldung in der Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="f8603-165">Advances the enumerator to the next message in the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="messageEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f8603-166">Setzt den Enumerator auf die nächste Meldung in der Warteschlange, sofern eine Meldung verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="f8603-166">Advances the enumerator to the next message in the queue, if one is currently available.</span></span></summary>
        <returns><span data-ttu-id="f8603-167"><see langword="true" />, wenn der Enumerator erfolgreich auf die nächste Meldung gesetzt wurde. <see langword="false" />, wenn der Enumerator das Ende der Warteschlange erreicht hat.</span><span class="sxs-lookup"><span data-stu-id="f8603-167"><see langword="true" /> if the enumerator was successfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8603-168">Diese Überladung wird sofort zurückgegeben, wenn keine Meldung in der Warteschlange vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="f8603-168">This overload returns immediately if there is no message in the queue.</span></span> <span data-ttu-id="f8603-169">Es gibt eine andere Überladung, die eine angegebene <xref:System.TimeSpan> auf das Eintreffen einer Nachricht wartet.</span><span class="sxs-lookup"><span data-stu-id="f8603-169">There is another overload that waits a specified <xref:System.TimeSpan> for a message to arrive.</span></span>  
  
 <span data-ttu-id="f8603-170">Wenn eine Nachricht zurzeit nicht verfügbar ist, weil die Warteschlange leer ist oder Sie über das letzte Element in der Auflistung hinaus verschoben haben, wird <xref:System.Messaging.MessageEnumerator.MoveNext%2A> `false` an die Aufruf Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="f8603-170">If a message is not currently available because the queue is empty or because you have moved beyond the last element in the collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> returns `false` to the calling method.</span></span>  
  
 <span data-ttu-id="f8603-171">Bei der Erstellung wird ein Enumerator konzeptionell vor der ersten Nachricht der Warteschlange positioniert, und der erste <xref:System.Messaging.MessageEnumerator.MoveNext%2A>-Aufrufe führt die erste Nachricht der Warteschlange ein.</span><span class="sxs-lookup"><span data-stu-id="f8603-171">Upon creation, an enumerator is conceptually positioned before the first message of the queue, and the first call to <xref:System.Messaging.MessageEnumerator.MoveNext%2A> brings the first message of the queue into view.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="f8603-172">Es wurde eine Message Queuing-spezifische Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="f8603-172">An exception specific to Message Queuing was thrown.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.MoveNext : TimeSpan -&gt; bool" Usage="messageEnumerator.MoveNext timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="f8603-173">Die <see cref="T:System.TimeSpan" /> gibt die Zeitspanne an, innerhalb derer eine Meldung eingehen muss, wenn der Enumerator auf das Ende der Warteschlange zeigt.</span><span class="sxs-lookup"><span data-stu-id="f8603-173">The <see cref="T:System.TimeSpan" /> to wait for a message to be available if the enumerator is positioned at the end of the queue.</span></span></param>
        <summary><span data-ttu-id="f8603-174">Setzt den Enumerator auf die nächste Meldung in der Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="f8603-174">Advances the enumerator to the next message in the queue.</span></span> <span data-ttu-id="f8603-175">Wenn sich der Enumerator am Ende der Warteschlange befindet, wartet <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />, bis eine Meldung verfügbar ist oder der angegebene Timeout überschritten wird.</span><span class="sxs-lookup"><span data-stu-id="f8603-175">If the enumerator is positioned at the end of the queue, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> waits until a message is available or the given timeout expires.</span></span></summary>
        <returns><span data-ttu-id="f8603-176"><see langword="true" />, wenn der Enumerator erfolgreich auf die nächste Meldung gesetzt wurde. <see langword="false" />, wenn der Enumerator das Ende der Warteschlange erreicht hat und innerhalb der im <paramref name="timeout" />-Parameter angegebenen Zeit keine Meldung eingeht.</span><span class="sxs-lookup"><span data-stu-id="f8603-176"><see langword="true" /> if the enumerator successfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue and a message does not become available within the time specified by the <paramref name="timeout" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8603-177">Diese Überladung wartet, wenn keine Nachricht in der Warteschlange vorhanden ist oder wenn der Cursor das Ende der Warteschlange erreicht hat.</span><span class="sxs-lookup"><span data-stu-id="f8603-177">This overload waits if there is no message in the queue or if the cursor has reached the end of the queue.</span></span> <span data-ttu-id="f8603-178">Wenn eine Nachricht zurzeit nicht verfügbar ist, weil die Warteschlange leer ist oder Sie über das letzte Element in der Auflistung hinaus verschoben haben, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> auf das angegebene Timeout warten.</span><span class="sxs-lookup"><span data-stu-id="f8603-178">If a message is not currently available because the queue is empty or because you have moved beyond the last element in the collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> waits the specified timeout.</span></span>  
  
 <span data-ttu-id="f8603-179">Wenn sich der Cursor bereits am Ende der Warteschlange befindet, gibt <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nur `true` zurück, wenn die neue Nachricht innerhalb des angegebenen Zeitintervalls eintrifft, eine niedrigere Priorität als alle derzeit in der Warteschlange enthaltenen Nachrichten aufweist und am Ende der Warteschlange platziert wird.</span><span class="sxs-lookup"><span data-stu-id="f8603-179">If the cursor is already at the end of the queue, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> only returns `true` if the new message arrives within the specified time interval, has lower priority than all messages currently in the queue and is placed at the end of the queue.</span></span> <span data-ttu-id="f8603-180">Eine Überladung ohne Parameter wird sofort zurückgegeben, wenn sich keine weiteren Nachrichten in der Warteschlange befinden.</span><span class="sxs-lookup"><span data-stu-id="f8603-180">An overload with no parameter returns immediately if no further messages are in the queue.</span></span>  
  
 <span data-ttu-id="f8603-181">Bei der Erstellung wird ein Enumerator konzeptionell vor der ersten Nachricht der-Enumeration positioniert, und der erste <xref:System.Messaging.MessageEnumerator.MoveNext%2A>-Aufrufe führt die erste Meldung der-Enumeration in die Ansicht ein.</span><span class="sxs-lookup"><span data-stu-id="f8603-181">Upon creation, an enumerator is conceptually positioned before the first message of the enumeration, and the first call to <xref:System.Messaging.MessageEnumerator.MoveNext%2A> brings the first message of the enumeration into view.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f8603-182">Der für den Timeoutparameter angegebene Wert ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="f8603-182">The value specified for the timeout parameter is invalid.</span></span> <span data-ttu-id="f8603-183">Eventuell wurde ein negativer Wert angegeben.</span><span class="sxs-lookup"><span data-stu-id="f8603-183">It might represent a negative number.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="f8603-184">Es wurde eine Message Queuing-spezifische Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="f8603-184">An exception specific to Message Queuing was thrown.</span></span>  
  
 <span data-ttu-id="f8603-185">Oder</span><span class="sxs-lookup"><span data-stu-id="f8603-185">-or-</span></span>  
  
 <span data-ttu-id="f8603-186">Der Timeout wurde überschritten.</span><span class="sxs-lookup"><span data-stu-id="f8603-186">The timeout has expired.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f8603-187">Entfernt die aktuelle Meldung aus der Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück.</span><span class="sxs-lookup"><span data-stu-id="f8603-187">Removes the current message from the queue and returns the message to the calling application.</span></span> <span data-ttu-id="f8603-188">Durch das Entfernen einer Meldung wird diese aus der Warteschlange gelöscht.</span><span class="sxs-lookup"><span data-stu-id="f8603-188">Removing the message deletes it from the queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8603-189">Das für diese über Ladungen beschriebene Verhalten gilt nur, wenn die <xref:System.Messaging.MessageEnumerator> Instanz mithilfe des <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="f8603-189">The behavior described for these overloads is applicable only if the <xref:System.Messaging.MessageEnumerator> instance is retrieved by using the <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>.</span></span> <span data-ttu-id="f8603-190">Verwenden Sie <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> nicht, um eine Instanz von <xref:System.Messaging.MessageEnumerator> abzurufen, da diese Methode veraltet ist.</span><span class="sxs-lookup"><span data-stu-id="f8603-190">Do not use <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> to retrieve an instance of <xref:System.Messaging.MessageEnumerator> as this method has been deprecated.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f8603-191">Entfernt die aktuelle Meldung aus einer transaktionalen oder nicht transaktionalen Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück.</span><span class="sxs-lookup"><span data-stu-id="f8603-191">Removes the current message from a transactional or non-transactional queue and returns the message to the calling application.</span></span> <span data-ttu-id="f8603-192">Für das Eintreffen einer Meldung in der Warteschlange ist kein Timeout festgelegt.</span><span class="sxs-lookup"><span data-stu-id="f8603-192">There is no timeout specified for a message to arrive in the queue.</span></span></summary>
        <returns><span data-ttu-id="f8603-193">Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</span><span class="sxs-lookup"><span data-stu-id="f8603-193">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8603-194"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt die Meldung an der aktuellen Position des Cursors und gibt Sie zurück.</span><span class="sxs-lookup"><span data-stu-id="f8603-194"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span>  
  
 <span data-ttu-id="f8603-195">Wenn Sie das journalisieren von Warteschlangen verwenden, bewirkt das Entfernen der Nachricht, dass eine Kopie in der Journal Warteschlange gespeichert wird, so wie es bei der <xref:System.Messaging.MessageQueue.Receive%2A> Methode der <xref:System.Messaging.MessageQueue> Klasse der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="f8603-195">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="f8603-196">Wenn Sie die aktuelle Meldung entfernen, wird der Cursor in die nächste Meldung verschoben.</span><span class="sxs-lookup"><span data-stu-id="f8603-196">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="f8603-197">Sie müssen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nicht aufrufen, nachdem Sie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>aufgerufen haben.</span><span class="sxs-lookup"><span data-stu-id="f8603-197">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 <span data-ttu-id="f8603-198">Wenn Sie diese Überladung für eine transaktionale Warteschlange aufrufen, erstellt Message Queuing eine einzelne interne Transaktion.</span><span class="sxs-lookup"><span data-stu-id="f8603-198">If you call this overload on a transactional queue, Message Queuing creates a single internal transaction.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction"><span data-ttu-id="f8603-199">Dieses <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt stellt die Transaktion dar, innerhalb der die Meldung entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="f8603-199">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction in which the message will be removed.</span></span></param>
        <summary><span data-ttu-id="f8603-200">Entfernt die aktuelle Meldung aus einer transaktionalen Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück.</span><span class="sxs-lookup"><span data-stu-id="f8603-200">Removes the current message from a transactional queue and returns the message to the calling application.</span></span> <span data-ttu-id="f8603-201">Für das Eintreffen einer Meldung in der Warteschlange ist kein Timeout festgelegt.</span><span class="sxs-lookup"><span data-stu-id="f8603-201">There is no timeout specified for a message to arrive in the queue.</span></span></summary>
        <returns><span data-ttu-id="f8603-202">Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</span><span class="sxs-lookup"><span data-stu-id="f8603-202">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8603-203"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt die Nachricht an der aktuellen Position des Cursors und gibt Sie zurück, wobei der interne Transaktionskontext verwendet wird, der durch den `transaction`-Parameter definiert wird.</span><span class="sxs-lookup"><span data-stu-id="f8603-203"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using the internal transaction context defined by the `transaction` parameter.</span></span>  
  
 <span data-ttu-id="f8603-204">Wenn Sie das journalisieren von Warteschlangen verwenden, bewirkt das Entfernen der Nachricht, dass eine Kopie in der Journal Warteschlange gespeichert wird, so wie es bei der <xref:System.Messaging.MessageQueue.Receive%2A> Methode der <xref:System.Messaging.MessageQueue> Klasse der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="f8603-204">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="f8603-205">Beim Arbeiten mit Transaktions Warteschlangen bewirkt ein Rollback einer Transaktion, dass alle Nachrichten, die durch einen-<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt wurden, an die Warteschlange zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="f8603-205">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="f8603-206">Der Entfernungs Vorgang kann erst wieder rückgängig gemacht werden</span><span class="sxs-lookup"><span data-stu-id="f8603-206">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="f8603-207">Wenn Sie die aktuelle Meldung entfernen, wird der Cursor in die nächste Meldung verschoben.</span><span class="sxs-lookup"><span data-stu-id="f8603-207">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="f8603-208">Sie müssen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nicht aufrufen, nachdem Sie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>aufgerufen haben.</span><span class="sxs-lookup"><span data-stu-id="f8603-208">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f8603-209">Der Parameter <paramref name="transaction" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f8603-209">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType"><span data-ttu-id="f8603-210">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f8603-210">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="f8603-211">Entfernt die aktuelle Meldung aus einer Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück.</span><span class="sxs-lookup"><span data-stu-id="f8603-211">Removes the current message from a queue and returns the message to the calling application.</span></span> <span data-ttu-id="f8603-212">Für das Eintreffen einer Meldung in der Warteschlange ist kein Timeout festgelegt.</span><span class="sxs-lookup"><span data-stu-id="f8603-212">There is no timeout specified for a message to arrive in the queue.</span></span></summary>
        <returns><span data-ttu-id="f8603-213">Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</span><span class="sxs-lookup"><span data-stu-id="f8603-213">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8603-214"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt die Nachricht an der aktuellen Position des Cursors und gibt Sie mit einem Transaktionskontext zurück, der durch den `transactionType`-Parameter definiert wird.</span><span class="sxs-lookup"><span data-stu-id="f8603-214"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using a transaction context defined by the `transactionType` parameter.</span></span>  
  
 <span data-ttu-id="f8603-215">Geben Sie `Automatic` für den `transactionType` Parameter an, wenn bereits ein externer Transaktionskontext an den Thread angefügt ist, den Sie zum Empfangen der Nachricht verwenden möchten.</span><span class="sxs-lookup"><span data-stu-id="f8603-215">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="f8603-216">Geben Sie `Single` an, wenn die Nachricht als einzelne interne Transaktion empfangen werden soll.</span><span class="sxs-lookup"><span data-stu-id="f8603-216">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="f8603-217">Sie können `None` angeben, wenn Sie eine Nachricht von einer Transaktions Warteschlange außerhalb eines Transaktions Kontexts empfangen möchten.</span><span class="sxs-lookup"><span data-stu-id="f8603-217">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="f8603-218">Wenn Sie das journalisieren von Warteschlangen verwenden, bewirkt das Entfernen der Nachricht, dass eine Kopie in der Journal Warteschlange gespeichert wird, so wie es bei der <xref:System.Messaging.MessageQueue.Receive%2A> Methode der <xref:System.Messaging.MessageQueue> Klasse der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="f8603-218">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="f8603-219">Beim Arbeiten mit Transaktions Warteschlangen bewirkt ein Rollback einer Transaktion, dass alle Nachrichten, die durch einen-<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt wurden, an die Warteschlange zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="f8603-219">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="f8603-220">Der Entfernungs Vorgang kann erst wieder rückgängig gemacht werden</span><span class="sxs-lookup"><span data-stu-id="f8603-220">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="f8603-221">Wenn Sie die aktuelle Meldung entfernen, wird der Cursor in die nächste Meldung verschoben.</span><span class="sxs-lookup"><span data-stu-id="f8603-221">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="f8603-222">Sie müssen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nicht aufrufen, nachdem Sie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>aufgerufen haben.</span><span class="sxs-lookup"><span data-stu-id="f8603-222">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="f8603-223">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</span><span class="sxs-lookup"><span data-stu-id="f8603-223">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="f8603-224">Die Zeit, die auf das Eintreffen einer Meldung gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f8603-224">The interval of time to wait for a message to arrive in the queue.</span></span></param>
        <summary><span data-ttu-id="f8603-225">Entfernt die aktuelle Meldung aus der Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück.</span><span class="sxs-lookup"><span data-stu-id="f8603-225">Removes the current message from the queue and returns the message to the calling application.</span></span> <span data-ttu-id="f8603-226">Wenn eine vorhandene Meldung entfernt werden kann, wird diese von der Methode sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="f8603-226">If there is a message to remove, the method returns it immediately.</span></span> <span data-ttu-id="f8603-227">Andernfalls wartet die Methode auf das Eingehen einer neuen Meldung, bis der angegebene Timeout überschritten wird.</span><span class="sxs-lookup"><span data-stu-id="f8603-227">Otherwise, the method waits the specified timeout for a new message to arrive.</span></span></summary>
        <returns><span data-ttu-id="f8603-228">Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</span><span class="sxs-lookup"><span data-stu-id="f8603-228">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8603-229"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt die Meldung an der aktuellen Position des Cursors und gibt Sie zurück.</span><span class="sxs-lookup"><span data-stu-id="f8603-229"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span> <span data-ttu-id="f8603-230">Wenn sich der Cursor am Ende der Warteschlange befindet, wartet diese Überladung der-Methode, bis eine Meldung verfügbar ist oder das durch den `timeout`-Parameter angegebene Intervall abgelaufen ist.</span><span class="sxs-lookup"><span data-stu-id="f8603-230">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="f8603-231">Wenn Sie das journalisieren von Warteschlangen verwenden, bewirkt das Entfernen der Nachricht, dass eine Kopie in der Journal Warteschlange gespeichert wird, so wie es bei der <xref:System.Messaging.MessageQueue.Receive%2A> Methode der <xref:System.Messaging.MessageQueue> Klasse der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="f8603-231">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="f8603-232">Wenn Sie die aktuelle Meldung entfernen, wird der Cursor in die nächste Meldung verschoben.</span><span class="sxs-lookup"><span data-stu-id="f8603-232">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="f8603-233">Sie müssen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nicht aufrufen, nachdem Sie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>aufgerufen haben.</span><span class="sxs-lookup"><span data-stu-id="f8603-233">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 <span data-ttu-id="f8603-234">Wenn Sie diese Überladung für eine transaktionale Warteschlange aufrufen, erstellt Message Queuing eine einzelne interne Transaktion.</span><span class="sxs-lookup"><span data-stu-id="f8603-234">If you call this overload on a transactional queue, Message Queuing creates a single internal transaction.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f8603-235">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="f8603-235">The value specified for the <paramref name="timeout" /> parameter is invalid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="f8603-236">Der Timeout wurde überschritten.</span><span class="sxs-lookup"><span data-stu-id="f8603-236">The timeout has expired.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="f8603-237">Die Zeitspanne, in der die zu entfernende Meldung eingehen muss.</span><span class="sxs-lookup"><span data-stu-id="f8603-237">The interval of time to wait for the message to be removed.</span></span></param>
        <param name="transaction"><span data-ttu-id="f8603-238">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt, das den Transaktionskontext für diese Meldung angibt.</span><span class="sxs-lookup"><span data-stu-id="f8603-238">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction context for the message.</span></span></param>
        <summary><span data-ttu-id="f8603-239">Entfernt die aktuelle Meldung aus einer transaktionalen Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück.</span><span class="sxs-lookup"><span data-stu-id="f8603-239">Removes the current message from a transactional queue and returns the message to the calling application.</span></span> <span data-ttu-id="f8603-240">Wenn eine vorhandene Meldung entfernt werden kann, wird diese von der Methode sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="f8603-240">If there is a message to remove, the method returns it immediately.</span></span> <span data-ttu-id="f8603-241">Andernfalls wartet die Methode auf das Eingehen einer neuen Meldung, bis der angegebene Timeout überschritten wird.</span><span class="sxs-lookup"><span data-stu-id="f8603-241">Otherwise, the method waits the specified timeout for a new message to arrive.</span></span></summary>
        <returns><span data-ttu-id="f8603-242">Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</span><span class="sxs-lookup"><span data-stu-id="f8603-242">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8603-243"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt die Meldung an der aktuellen Position des Cursors und gibt Sie zurück.</span><span class="sxs-lookup"><span data-stu-id="f8603-243"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span> <span data-ttu-id="f8603-244">Wenn sich der Cursor am Ende der Warteschlange befindet, wartet diese Überladung der-Methode, bis eine Meldung verfügbar ist oder das durch den `timeout`-Parameter angegebene Intervall abgelaufen ist.</span><span class="sxs-lookup"><span data-stu-id="f8603-244">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="f8603-245">Beim Arbeiten mit Transaktions Warteschlangen bewirkt ein Rollback einer Transaktion, dass alle Nachrichten, die durch einen-<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt wurden, an die Warteschlange zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="f8603-245">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="f8603-246">Der Entfernungs Vorgang kann erst wieder rückgängig gemacht werden</span><span class="sxs-lookup"><span data-stu-id="f8603-246">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="f8603-247">Wenn Sie das journalisieren von Warteschlangen verwenden, bewirkt das Entfernen der Nachricht, dass eine Kopie in der Journal Warteschlange gespeichert wird, so wie es bei der <xref:System.Messaging.MessageQueue.Receive%2A> Methode der <xref:System.Messaging.MessageQueue> Klasse der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="f8603-247">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="f8603-248">Wenn Sie die aktuelle Meldung entfernen, wird der Cursor in die nächste Meldung verschoben.</span><span class="sxs-lookup"><span data-stu-id="f8603-248">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="f8603-249">Sie müssen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nicht aufrufen, nachdem Sie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>aufgerufen haben.</span><span class="sxs-lookup"><span data-stu-id="f8603-249">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f8603-250">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="f8603-250">The value specified for the <paramref name="timeout" /> parameter is invalid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f8603-251">Der Parameter <paramref name="transaction" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f8603-251">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="f8603-252">Der Timeout wurde überschritten.</span><span class="sxs-lookup"><span data-stu-id="f8603-252">The timeout has expired.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="f8603-253">Die Zeitspanne, in der die zu entfernende Meldung eingehen muss.</span><span class="sxs-lookup"><span data-stu-id="f8603-253">The interval of time to wait for the message to be removed.</span></span></param>
        <param name="transactionType"><span data-ttu-id="f8603-254">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</span><span class="sxs-lookup"><span data-stu-id="f8603-254">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="f8603-255">Entfernt die aktuelle Meldung aus einer Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück.</span><span class="sxs-lookup"><span data-stu-id="f8603-255">Removes the current message from a queue and returns the message to the calling application.</span></span> <span data-ttu-id="f8603-256">Wenn eine vorhandene Meldung entfernt werden kann, wird diese von der Methode sofort zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="f8603-256">If there is a message to remove, the method returns it immediately.</span></span> <span data-ttu-id="f8603-257">Andernfalls wartet die Methode auf das Eingehen einer neuen Meldung, bis der angegebene Timeout überschritten wird.</span><span class="sxs-lookup"><span data-stu-id="f8603-257">Otherwise, the method waits the specified timeout for a new message to arrive.</span></span></summary>
        <returns><span data-ttu-id="f8603-258">Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</span><span class="sxs-lookup"><span data-stu-id="f8603-258">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8603-259"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt die Nachricht an der aktuellen Position des Cursors und gibt Sie mit einem Transaktionskontext zurück, der durch den `transactionType`-Parameter definiert wird.</span><span class="sxs-lookup"><span data-stu-id="f8603-259"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using a transaction context defined by the `transactionType` parameter.</span></span> <span data-ttu-id="f8603-260">Wenn sich der Cursor am Ende der Warteschlange befindet, wartet diese Überladung der-Methode, bis eine Meldung verfügbar ist oder das durch den `timeout`-Parameter angegebene Intervall abgelaufen ist.</span><span class="sxs-lookup"><span data-stu-id="f8603-260">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="f8603-261">Geben Sie `Automatic` für den `transactionType` Parameter an, wenn bereits ein externer Transaktionskontext an den Thread angefügt ist, den Sie zum Empfangen der Nachricht verwenden möchten.</span><span class="sxs-lookup"><span data-stu-id="f8603-261">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="f8603-262">Geben Sie `Single` an, wenn die Nachricht als einzelne interne Transaktion empfangen werden soll.</span><span class="sxs-lookup"><span data-stu-id="f8603-262">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="f8603-263">Sie können `None` angeben, wenn Sie eine Nachricht von einer Transaktions Warteschlange außerhalb eines Transaktions Kontexts empfangen möchten.</span><span class="sxs-lookup"><span data-stu-id="f8603-263">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="f8603-264">Wenn Sie das journalisieren von Warteschlangen verwenden, bewirkt das Entfernen der Nachricht, dass eine Kopie in der Journal Warteschlange gespeichert wird, so wie es bei der <xref:System.Messaging.MessageQueue.Receive%2A> Methode der <xref:System.Messaging.MessageQueue> Klasse der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="f8603-264">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="f8603-265">Beim Arbeiten mit Transaktions Warteschlangen bewirkt ein Rollback einer Transaktion, dass alle Nachrichten, die durch einen-<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt wurden, an die Warteschlange zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="f8603-265">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="f8603-266">Der Entfernungs Vorgang kann erst wieder rückgängig gemacht werden</span><span class="sxs-lookup"><span data-stu-id="f8603-266">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="f8603-267">Wenn Sie die aktuelle Meldung entfernen, wird der Cursor in die nächste Meldung verschoben.</span><span class="sxs-lookup"><span data-stu-id="f8603-267">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="f8603-268">Sie müssen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nicht aufrufen, nachdem Sie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>aufgerufen haben.</span><span class="sxs-lookup"><span data-stu-id="f8603-268">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f8603-269">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="f8603-269">The value specified for the <paramref name="timeout" /> parameter is invalid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="f8603-270">Der Timeout wurde überschritten.</span><span class="sxs-lookup"><span data-stu-id="f8603-270">The timeout has expired.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="f8603-271">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</span><span class="sxs-lookup"><span data-stu-id="f8603-271">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="messageEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f8603-272">Setzt den aktuellen Enumerator auf den Anfang der Warteschlange zurück.</span><span class="sxs-lookup"><span data-stu-id="f8603-272">Resets the current enumerator so it points to the head of the queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f8603-273">Ein Enumerator kann nur vorwärts verschoben werden.</span><span class="sxs-lookup"><span data-stu-id="f8603-273">An enumerator can only move in a forward direction.</span></span> <span data-ttu-id="f8603-274">Verwenden Sie diese Methode, um am Anfang der Warteschlange zu beginnen.</span><span class="sxs-lookup"><span data-stu-id="f8603-274">Use this method to start over at the beginning of the queue.</span></span>  
  
 <span data-ttu-id="f8603-275">Nach dem Aufrufen von <xref:System.Messaging.MessageEnumerator.Reset%2A>zeigt der Cursor auf die erste Nachricht.</span><span class="sxs-lookup"><span data-stu-id="f8603-275">After calling <xref:System.Messaging.MessageEnumerator.Reset%2A>, the cursor points to the first message.</span></span> <span data-ttu-id="f8603-276">Sie müssen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufrufen von <xref:System.Messaging.MessageEnumerator.Reset%2A> nicht aufrufen, um den Cursor auf die erste Nachricht in der Warteschlange zu verschieben.</span><span class="sxs-lookup"><span data-stu-id="f8603-276">You do not need to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.Reset%2A> to move the cursor forward to the first message in the queue.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IEnumerator.Current : obj" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f8603-277">Gibt eine <see cref="T:System.Messaging.Message" /> zurück, die auf die Meldung an der aktuellen Cursorposition verweist.</span><span class="sxs-lookup"><span data-stu-id="f8603-277">Returns a <see cref="T:System.Messaging.Message" /> that references the message at the current cursor position.</span></span></summary>
        <value><span data-ttu-id="f8603-278">Eine <see cref="T:System.Messaging.Message" />, die auf die Meldung an der aktuellen Cursorposition verweist.</span><span class="sxs-lookup"><span data-stu-id="f8603-278">A <see cref="T:System.Messaging.Message" /> that references the message at the current cursor position.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f8603-279">Sie haben vor dem ersten Aufruf von <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> auf diese Eigenschaft zugegriffen.</span><span class="sxs-lookup"><span data-stu-id="f8603-279">You accessed this property before the first call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />.</span></span> <span data-ttu-id="f8603-280">Der Cursor befindet sich vor dem ersten Element der Nachrichtenenumeration, oder Sie haben auf diese Eigenschaft zugegriffen, nachdem bei einem Aufruf von <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> FALSE zurückgegeben wurde (wodurch angegeben wird, dass sich der Cursor hinter dem letzten Element der Nachrichtenenumeration befindet).</span><span class="sxs-lookup"><span data-stu-id="f8603-280">The cursor is located before the first element of the message enumeration.-or- You accessed this property after a call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> had returned false (indicating the cursor is located after the last element of the message enumeration.)</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="f8603-281">Die Meldung, auf die der Enumerator gegenwärtig zeigt, ist nicht mehr vorhanden.</span><span class="sxs-lookup"><span data-stu-id="f8603-281">The message the enumerator is currently pointing to no longer exists.</span></span> <span data-ttu-id="f8603-282">Es wurde möglicherweise gelöscht.</span><span class="sxs-lookup"><span data-stu-id="f8603-282">It might have been deleted.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
