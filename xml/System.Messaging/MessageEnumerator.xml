<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6a3039a11d941cd3db611cb997eb17835525e4da" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30460814" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt einen Vorwärtscursor zum Aufzählen der Nachrichten in einer Nachrichtenwarteschlange bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Messaging.MessageEnumerator> für dynamische Interaktion mit Nachrichten in einer Warteschlange. Methoden zur Verfügung, über die <xref:System.Messaging.MessageQueue> Klasse kann entweder Zurückgeben einer <xref:System.Messaging.MessageEnumerator> verweist auf eine dynamische Liste von Nachrichten in der Warteschlange oder ein Array, das eine Kopie zu einem angegebenen Zeitpunkt - eine Momentaufnahme - der Warteschlange enthält, die zum Zeitpunkt der angegebenen Methode wurde aufgerufen.  
  
 Ein Enumerator kann im Gegensatz zu einem statischen Snapshot Sie zum Ändern der Auflistung. Mit einem <xref:System.Messaging.MessageEnumerator>, können Sie Nachrichten aus der Warteschlange entfernt und in der Warteschlange wird die Änderung sofort übernommen.  
  
 Ein Enumerator entfernt nicht die Nachrichten aus der Warteschlange, beim Abfragen der Warteschlangenobjekts. Gibt Informationen über die Meldung an der aktuellen Cursorposition eingefügt, aber es bleibt die Nachricht in der Warteschlange.  
  
 Ein <xref:System.Messaging.MessageEnumerator> ist ein Cursor, der an den Anfang einer dynamischen Liste initialisiert. Die Reihenfolge der Liste entspricht der Reihenfolge der Nachrichten in der Warteschlange gemäß der Priorität der Nachricht. Bewegen des Cursors auf die erste Nachricht in die Warteschlange durch Aufrufen von <xref:System.Messaging.MessageEnumerator.MoveNext%2A>. Nachdem der Enumerator initialisiert wurde, können Sie <xref:System.Messaging.MessageEnumerator.MoveNext%2A> um die verbleibenden Nachrichten vorwärts zu durchlaufen. Sie können angeben, ob warten, bis eine Nachricht verfügbar wird durch das Übergeben eines Timeouts in der <xref:System.Messaging.MessageEnumerator.MoveNext%2A> Methode.  
  
 Da der Enumerator dynamisch ist, eine Nachricht, die hinter der aktuellen Cursorposition (z. B. aufgrund mit niedriger Priorität), angefügt wird möglich vom Enumerator. Eine Meldung, die eingefügt wird, bevor der aktuellen Cursorposition kann nicht zugegriffen werden. Es ist nicht möglich, auf eine <xref:System.Messaging.MessageEnumerator>. Ein Cursor kann nur vorwärts bewegt. Die <xref:System.Messaging.MessageEnumerator.Reset%2A> Methode können Sie den Cursor wieder an den Anfang der Warteschlange zu platzieren.  
  
 Instanzen von <xref:System.Messaging.MessageEnumerator> für eine bestimmte Warteschlange unabhängig arbeiten. Erstellen Sie zwei <xref:System.Messaging.MessageEnumerator> Instanzen, die für dieselbe Warteschlange gelten. Die Änderungen, dass eine <xref:System.Messaging.MessageEnumerator> macht die Nachrichten in der Warteschlange werden sofort in eine zweite Enumerator Wenn der zweite Enumerator vor dem ersten positioniert ist. Jedoch wenn zwei Enumeratoren die gleiche Position haben und einer von ihnen die Meldung an dieser Position entfernt, eine Ausnahme wird ausgelöst, wenn versucht wird, dass der anderen Enumerator Abrufen des Werts der <xref:System.Messaging.MessageEnumerator.Current%2A> Eigenschaft für die Nachricht sofort gelöscht.  
  
> [!NOTE]
>  Bei der Erstellung einer Instanz von <xref:System.Messaging.MessageQueue> mit <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> festgelegt `true`, keine andere Anwendung kann die Nachrichten in einen Enumerator ändern, während Sie die Verbindung mit der Warteschlange haben.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft eine dynamische Liste von Nachrichten in einer Warteschlange ab und zählt alle Meldungen mit der <xref:System.Messaging.Message.Priority%2A> -Eigenschaftensatz auf <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die dem Enumerator zugeordneten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem behält ein geöffnetes Handle an die Warteschlange, während der Lebensdauer des Cursors. Wenn Sie die Arbeit mit dem Enumerator abgeschlossen haben, rufen <xref:System.Messaging.MessageEnumerator.Close%2A> , die dem Handle zugeordneten Ressourcen freizugeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das aktuelle <see cref="T:System.Messaging.Message" /> ab, auf das dieser Enumerator zeigt.</summary>
        <value>Die aktuelle Meldung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Enumerator erstellt wird, zeigt es an den Anfang der Warteschlange, an einer Position vor der ersten Meldung. In diesem Fall <xref:System.Messaging.MessageEnumerator.Current%2A> ist ungültig und löst eine Ausnahme aus, wenn darauf zugegriffen wird. Rufen Sie <xref:System.Messaging.MessageEnumerator.MoveNext%2A> um den Cursor an die erste Nachricht in die Warteschlange einzufügen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Messaging.MessageEnumerator.Current" /> wurde vor dem ersten Aufruf von <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> aufgerufen. Der Cursor befindet sich vor dem ersten Element der Meldungsenumeration.  
  
 - oder -   
  
 <see cref="P:System.Messaging.MessageEnumerator.Current" /> wurde aufgerufen, nachdem bei einem Aufruf von <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> der Wert <see langword="false" /> zurückgegeben wurde. (Dies bedeutet, dass sich der Cursor hinter dem letzten Element der Meldungsenumeration befindet.)</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Meldung, auf die der Enumerator gegenwärtig zeigt, ist nicht mehr vorhanden. Es wurde möglicherweise gelöscht.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das systemeigene Cursorhandle von Message Queuing ab, das zum Durchsuchen von Meldungen in der Warteschlange verwendet wird.</summary>
        <value>Das systemeigene Cursorhandle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft enthält das systemeigene Handle der Enumeration. Wenn Sie die Arbeit mit dem Enumerator abgeschlossen haben, rufen <xref:System.Messaging.MessageEnumerator.Close%2A> dieser Ressource freigegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Das Handle ist nicht vorhanden.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die von der <see cref="T:System.Messaging.MessageEnumerator" /> verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle vom <see cref="T:System.Messaging.MessageEnumerator" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Messaging.MessageEnumerator.Dispose%2A> können Ressourcen von der <xref:System.Messaging.MessageEnumerator> neu für andere Zwecke reserviert werden. Weitere Informationen zu <xref:System.Messaging.MessageEnumerator.Dispose%2A>, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.Messaging.MessageEnumerator" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, der öffentlich <xref:System.Messaging.MessageEnumerator.Dispose%2A> Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose()` Ruft die geschützte `Dispose(Boolean)` Methode mit dem `disposing` Parametersatz auf `true`. <xref:System.Object.Finalize%2A> Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Messaging.MessageEnumerator> verweist. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see langword="Dispose(Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see langword="Dispose" /> freigegeben wurden. Weitere Informationen zum Implementieren <see langword="Dispose" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Weitere Informationen zu <see langword="Dispose" /> und <see langword="Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Setzt den Enumerator auf die nächste Meldung in der Warteschlange.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den Enumerator auf die nächste Meldung in der Warteschlange, sofern eine Meldung verfügbar ist.</summary>
        <returns>
          <see langword="true" />, wenn der Enumerator erfolgreich auf die nächste Meldung gesetzt wurde. <see langword="false" />, wenn der Enumerator das Ende der Warteschlange erreicht hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird sofort zurückgegeben, wenn keine Meldung in der Warteschlange vorhanden ist. Es wird eine andere Überladung, die ein angegebenes wartet <xref:System.TimeSpan> für eine Nachricht eintrifft.  
  
 Wenn eine Nachricht nicht verfügbar ist, weil die Warteschlange leer ist oder Sie hinter dem letzten Element in der Auflistung verschoben haben <xref:System.Messaging.MessageEnumerator.MoveNext%2A> gibt `false` an die aufrufende Methode.  
  
 Bei der Erstellung einer konzeptionell Enumerator wird vor die erste Nachricht der Warteschlange und der erste Aufruf von <xref:System.Messaging.MessageEnumerator.MoveNext%2A> zeigt die erste Nachricht der Warteschlange an.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Es wurde eine Message Queuing-spezifische Ausnahme ausgelöst.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Die <see cref="T:System.TimeSpan" /> gibt die Zeitspanne an, innerhalb derer eine Meldung eingehen muss, wenn der Enumerator auf das Ende der Warteschlange zeigt.</param>
        <summary>Setzt den Enumerator auf die nächste Meldung in der Warteschlange. Wenn sich der Enumerator am Ende der Warteschlange befindet, wartet <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />, bis eine Meldung verfügbar ist oder der angegebene Timeout überschritten wird.</summary>
        <returns>
          <see langword="true" />, wenn der Enumerator erfolgreich auf die nächste Meldung gesetzt wurde. <see langword="false" />, wenn der Enumerator das Ende der Warteschlange erreicht hat und innerhalb der im <paramref name="timeout" />-Parameter angegebenen Zeit keine Meldung eingeht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wartet, wenn keine Meldung in der Warteschlange vorhanden ist oder wenn der Cursor am Ende der Warteschlange erreicht hat. Wenn eine Nachricht nicht verfügbar ist, weil die Warteschlange leer ist oder Sie hinter dem letzten Element in der Auflistung verschoben haben <xref:System.Messaging.MessageEnumerator.MoveNext%2A> wartet das festgelegte Timeout.  
  
 Wenn der Cursor bereits am Ende der Warteschlange <xref:System.Messaging.MessageEnumerator.MoveNext%2A> gibt nur `true` Wenn innerhalb des angegebenen Zeitintervalls die neue Nachricht eingeht, derzeit hat eine niedrigere Priorität als alle Nachrichten in der Warteschlange und wird am Ende der Warteschlange platziert. Eine Überladung ohne Parameter wird sofort zurückgegeben, wenn keine weiteren Nachrichten in der Warteschlange befinden.  
  
 Bei der Erstellung einer konzeptionell Enumerator wird vor die erste Nachricht der Enumeration und der erste Aufruf von <xref:System.Messaging.MessageEnumerator.MoveNext%2A> Schaltet die erste Nachricht der Enumeration in der Ansicht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den Timeoutparameter angegebene Wert ist ungültig. Eventuell wurde ein negativer Wert angegeben.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Es wurde eine Message Queuing-spezifische Ausnahme ausgelöst.  
  
 - oder -   
  
 Der Timeout wurde überschritten.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt die aktuelle Meldung aus der Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Durch das Entfernen einer Meldung wird diese aus der Warteschlange gelöscht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für diese Überladungen beschriebene Verhalten gilt nur, wenn die <xref:System.Messaging.MessageEnumerator> Instanz abgerufen, indem die <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>. Verwenden Sie keine <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> zum Abrufen einer Instanz von <xref:System.Messaging.MessageEnumerator> wie diese Methode wurde als veraltet markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt die aktuelle Meldung aus einer transaktionalen oder nicht transaktionalen Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Für das Eintreffen einer Meldung in der Warteschlange ist kein Timeout festgelegt.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an der aktuellen Cursorposition.  
  
 Bei Verwendung von Warteschlange Journaling Entfernen der Nachricht wird eine Kopie, die in der Journalwarteschlange gespeichert sind, ebenso wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode hat.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Nachricht verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Wenn Sie diese Überladung für eine transaktionale Warteschlange aufrufen, erstellt das Message Queuing eine einzelne, interne Transaktion aus.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Dieses <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt stellt die Transaktion dar, innerhalb der die Meldung entfernt wird.</param>
        <summary>Entfernt die aktuelle Meldung aus einer transaktionalen Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Für das Eintreffen einer Meldung in der Warteschlange ist kein Timeout festgelegt.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an der aktuellen Cursorposition, mit der internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter.  
  
 Bei Verwendung von Warteschlange Journaling Entfernen der Nachricht wird eine Kopie, die in der Journalwarteschlange gespeichert sind, ebenso wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode hat.  
  
 Bei der Arbeit mit Transaktionswarteschlangen ein Rollback einer Transaktion bewirkt, dass alle Nachrichten, die durch einen Aufruf von entfernt <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> an die Warteschlange zurückgegeben werden sollen. Die Entfernung ist nicht nicht rückgängig gemacht werden, bevor die Transaktion ein Commit ausgeführt wird.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Nachricht verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Entfernt die aktuelle Meldung aus einer Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Für das Eintreffen einer Meldung in der Warteschlange ist kein Timeout festgelegt.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an der aktuellen Cursorposition, verwenden einen bereits verwendeten Transaktionskontext durch definiert die `transactionType` Parameter.  
  
 Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Bei Verwendung von Warteschlange Journaling Entfernen der Nachricht wird eine Kopie, die in der Journalwarteschlange gespeichert sind, ebenso wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode hat.  
  
 Bei der Arbeit mit Transaktionswarteschlangen ein Rollback einer Transaktion bewirkt, dass alle Nachrichten, die durch einen Aufruf von entfernt <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> an die Warteschlange zurückgegeben werden sollen. Die Entfernung ist nicht nicht rückgängig gemacht werden, bevor die Transaktion ein Commit ausgeführt wird.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Nachricht verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Die Zeit, die auf das Eintreffen einer Meldung gewartet werden soll.</param>
        <summary>Entfernt die aktuelle Meldung aus der Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Wenn eine vorhandene Meldung entfernt werden kann, wird diese von der Methode sofort zurückgegeben. Andernfalls wartet die Methode auf das Eingehen einer neuen Meldung, bis der angegebene Timeout überschritten wird.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an der aktuellen Cursorposition. Wenn der Cursor am Ende der Warteschlange befindet, wird diese Überladung der Methode wartet, bis eine Nachricht verfügbar ist oder das Intervall angegeben wird, indem die `timeout` Parameter ist abgelaufen.  
  
 Bei Verwendung von Warteschlange Journaling Entfernen der Nachricht wird eine Kopie, die in der Journalwarteschlange gespeichert sind, ebenso wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode hat.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Nachricht verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Wenn Sie diese Überladung für eine transaktionale Warteschlange aufrufen, erstellt das Message Queuing eine einzelne, interne Transaktion aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Der Timeout wurde überschritten.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Die Zeitspanne, in der die zu entfernende Meldung eingehen muss.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt, das den Transaktionskontext für diese Meldung angibt.</param>
        <summary>Entfernt die aktuelle Meldung aus einer transaktionalen Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Wenn eine vorhandene Meldung entfernt werden kann, wird diese von der Methode sofort zurückgegeben. Andernfalls wartet die Methode auf das Eingehen einer neuen Meldung, bis der angegebene Timeout überschritten wird.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an der aktuellen Cursorposition. Wenn der Cursor am Ende der Warteschlange befindet, wird diese Überladung der Methode wartet, bis eine Nachricht verfügbar ist oder das Intervall angegeben wird, indem die `timeout` Parameter ist abgelaufen.  
  
 Bei der Arbeit mit Transaktionswarteschlangen ein Rollback einer Transaktion bewirkt, dass alle Nachrichten, die durch einen Aufruf von entfernt <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> an die Warteschlange zurückgegeben werden sollen. Die Entfernung ist nicht nicht rückgängig gemacht werden, bevor die Transaktion ein Commit ausgeführt wird.  
  
 Bei Verwendung von Warteschlange Journaling Entfernen der Nachricht wird eine Kopie, die in der Journalwarteschlange gespeichert sind, ebenso wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode hat.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Nachricht verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Der Timeout wurde überschritten.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Die Zeitspanne, in der die zu entfernende Meldung eingehen muss.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Entfernt die aktuelle Meldung aus einer Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Wenn eine vorhandene Meldung entfernt werden kann, wird diese von der Methode sofort zurückgegeben. Andernfalls wartet die Methode auf das Eingehen einer neuen Meldung, bis der angegebene Timeout überschritten wird.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an der aktuellen Cursorposition, verwenden einen bereits verwendeten Transaktionskontext durch definiert die `transactionType` Parameter. Wenn der Cursor am Ende der Warteschlange befindet, wird diese Überladung der Methode wartet, bis eine Nachricht verfügbar ist oder das Intervall angegeben wird, indem die `timeout` Parameter ist abgelaufen.  
  
 Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Bei Verwendung von Warteschlange Journaling Entfernen der Nachricht wird eine Kopie, die in der Journalwarteschlange gespeichert sind, ebenso wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode hat.  
  
 Bei der Arbeit mit Transaktionswarteschlangen ein Rollback einer Transaktion bewirkt, dass alle Nachrichten, die durch einen Aufruf von entfernt <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> an die Warteschlange zurückgegeben werden sollen. Die Entfernung ist nicht nicht rückgängig gemacht werden, bevor die Transaktion ein Commit ausgeführt wird.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Nachricht verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Der Timeout wurde überschritten.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den aktuellen Enumerator auf den Anfang der Warteschlange zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Enumerator kann nur vorwärts verschoben werden. Verwenden Sie diese Methode am Anfang der Warteschlangenobjekts beginnen.  
  
 Nach dem Aufruf <xref:System.Messaging.MessageEnumerator.Reset%2A>, der Cursor auf die erste Nachricht verweist. Sie müssen nicht aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.Reset%2A> auf den Cursor in die erste Nachricht in der Warteschlange zu verschieben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IEnumerator.Current { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt eine <see cref="T:System.Messaging.Message" /> zurück, die auf die Meldung an der aktuellen Cursorposition verweist.</summary>
        <value>Eine <see cref="T:System.Messaging.Message" />, die auf die Meldung an der aktuellen Cursorposition verweist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>