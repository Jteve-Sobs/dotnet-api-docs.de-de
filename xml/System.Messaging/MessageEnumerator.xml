<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4096f6ae9125cd6cd98cc1be09adad375d1ea992" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37647572" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type MessageEnumerator = class&#xA;    inherit MarshalByRefObject&#xA;    interface IEnumerator&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Provides a forward-only cursor to enumerate through messages in a message queue.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Messaging.MessageEnumerator> dynamische Interaktion mit Nachrichten in einer Warteschlange. Methoden zur Verfügung, über die <xref:System.Messaging.MessageQueue> Klasse zurückgeben kann eine <xref:System.Messaging.MessageEnumerator> verweist auf eine dynamische Liste von Nachrichten in der Warteschlange oder ein Array, das eine Kopie zu einem angegebenen Zeitpunkt – eine Momentaufnahme - der Warteschlange enthält, die zum Zeitpunkt der angegebenen Methode aufgerufen wurde.  
  
 Im Gegensatz zu der eine statische Momentaufnahme kann ein Enumerator die Auflistung geändert werden. Mit einem <xref:System.Messaging.MessageEnumerator>, können Sie Nachrichten aus der Warteschlange entfernen und in der Warteschlange wird die Änderung sofort übernommen.  
  
 Ein Enumerator wird nicht die Nachrichten aus der Warteschlange entfernt, beim Abfragen der Warteschlange. Gibt Informationen über die Nachricht an der aktuellen Cursorposition zurück, aber es bleibt die Nachricht in der Warteschlange.  
  
 Ein <xref:System.Messaging.MessageEnumerator> wird ein Cursor, an den Anfang einer dynamischen Liste initialisiert. Die Reihenfolge der Liste ist identisch mit der Reihenfolge der Nachrichten in der Warteschlange nach Nachrichtenpriorität. Sie können den Cursor in die erste Nachricht in die Warteschlange verschieben, durch den Aufruf <xref:System.Messaging.MessageEnumerator.MoveNext%2A>. Nachdem der Enumerator initialisiert wurde, können Sie <xref:System.Messaging.MessageEnumerator.MoveNext%2A> vorwärts zu durchlaufen, bis die verbleibenden Nachrichten. Sie können angeben, ob warten, bis eine Nachricht verfügbar sind, übergeben Sie einen Timeout in der <xref:System.Messaging.MessageEnumerator.MoveNext%2A> Methode.  
  
 Da der Enumerator dynamisch ist, kann eine Nachricht, die angefügt wird, außerhalb der aktuellen Cursorposition (z. B. aufgrund mit niedriger Priorität), zugegriffen werden vom Enumerator. Eine Meldung, die eingefügt wird, bevor der aktuellen Cursorposition nicht zugegriffen werden kann. Es ist nicht möglich, auf eine <xref:System.Messaging.MessageEnumerator>. Ein Cursor kann nur vorwärts bewegt werden. Die <xref:System.Messaging.MessageEnumerator.Reset%2A> Methode können Sie den Cursor wieder an den Anfang der Warteschlange zu platzieren.  
  
 Instanzen von <xref:System.Messaging.MessageEnumerator> für eine Warteschlange sind voneinander unabhängig. Erstellen Sie zwei <xref:System.Messaging.MessageEnumerator> Instanzen, die für dieselbe Warteschlange gelten. Die Änderungen, dass ein <xref:System.Messaging.MessageEnumerator> nutzt, um die Nachrichten in der Warteschlange werden sofort in eine zweite Enumerator Wenn der zweite Enumerator vor dem ersten positioniert ist. Jedoch, wenn zwei Enumeratoren die gleiche Position haben und einer von ihnen die Nachricht an dieser Position entfernt, eine Ausnahme wird ausgelöst, wenn der Enumerator andere versucht, den Wert der abzurufenden der <xref:System.Messaging.MessageEnumerator.Current%2A> Eigenschaft für die Nachricht bereits gelöschte.  
  
> [!NOTE]
>  Bei der Erstellung einer Instanz von <xref:System.Messaging.MessageQueue> mit <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> festgelegt `true`, keiner anderen Anwendung kann die Nachrichten in Ihrem Enumerator ändern, während Sie die Verbindung mit der Warteschlange haben.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft eine dynamische Liste von Nachrichten in einer Warteschlange ab und zählt alle Nachrichten mit der <xref:System.Messaging.Message.Priority%2A> -Eigenschaftensatz auf <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageEnumerator.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Frees the resources associated with the enumerator.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem behält ein geöffnetes Handle an die Warteschlange, während der Lebensdauer des Cursors. Wenn Sie die Arbeit mit dem Enumerator abgeschlossen haben, rufen Sie <xref:System.Messaging.MessageEnumerator.Close%2A> , die dem Handle zugeordneten Ressourcen freizugeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Messaging.Message" Usage="System.Messaging.MessageEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current <see cref="T:System.Messaging.Message" /> that this enumerator points to.</summary>
        <value>Die aktuelle Meldung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Enumerator erstellt wird, zeigt es an den Anfang der Warteschlange, an einer Position vor der ersten Meldung. In diesem Fall <xref:System.Messaging.MessageEnumerator.Current%2A> ist ungültig und löst eine Ausnahme aus, wenn auf sie zugegriffen wird. Rufen Sie <xref:System.Messaging.MessageEnumerator.MoveNext%2A> zur Positionierung des Cursors auf die erste Nachricht in der Warteschlange.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> before the first call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />. The cursor is located before the first element of the message enumeration.  -or-  You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> after a call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> had returned <see langword="false" /> (indicating the cursor is located after the last element of the message enumeration.)</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The message the enumerator is currently pointing to no longer exists. It might have been deleted.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.CursorHandle : nativeint" Usage="System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native Message Queuing cursor handle used to browse messages in the queue.</summary>
        <value>Das systemeigene Cursorhandle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft enthält das systemeigene Handle für die Enumeration. Wenn Sie die Arbeit mit dem Enumerator abgeschlossen haben, rufen Sie <xref:System.Messaging.MessageEnumerator.Close%2A> dieser Ressource freigibt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">The handle does not exist.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Releases the resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="messageEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Messaging.MessageEnumerator.Dispose%2A> können die Ressourcen, die von verwendet die <xref:System.Messaging.MessageEnumerator> , für andere Zwecke verschoben werden. Weitere Informationen zu <xref:System.Messaging.MessageEnumerator.Dispose%2A>, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageEnumerator.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Releases the unmanaged resources used by the <see cref="T:System.Messaging.MessageEnumerator" /> and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der öffentlichen <xref:System.Messaging.MessageEnumerator.Dispose%2A> Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose()` Ruft die geschützte `Dispose(Boolean)` -Methode mit dem `disposing` Parametersatz zu `true`. <xref:System.Object.Finalize%2A> Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Messaging.MessageEnumerator> verweist. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see langword="Dispose(Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see langword="Dispose" /> freigegeben wurden. Weitere Informationen zur Implementierung <see langword="Dispose" />, finden Sie unter [Implementieren einer Dispose-Method](~/docs/standard/garbage-collection/implementing-dispose.md).  Weitere Informationen zu <see langword="Dispose" /> und <see langword="Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Resources](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode.] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="messageEnumerator.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Advances the enumerator to the next message in the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="messageEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Advances the enumerator to the next message in the queue, if one is currently available.</summary>
        <returns>
          <see langword="true" /> if the enumerator was succesfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird sofort zurückgegeben, wenn keine Meldung in der Warteschlange vorhanden ist. Es gibt eine andere Überladung, die wartet, eine angegebene <xref:System.TimeSpan> für eine Nachricht eintrifft.  
  
 Wenn eine Nachricht nicht derzeit verfügbar ist, weil die Warteschlange leer ist oder Sie hinter dem letzten Element in der Auflistung verschoben haben <xref:System.Messaging.MessageEnumerator.MoveNext%2A> gibt `false` an die aufrufende Methode.  
  
 Bei der Erstellung einer konzeptionell Enumerator wird vor der ersten Nachricht der Warteschlange und der erste Aufruf <xref:System.Messaging.MessageEnumerator.MoveNext%2A> zeigt die erste Nachricht der Warteschlange an.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An exception specific to Message Queuing was thrown.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.MoveNext : TimeSpan -&gt; bool" Usage="messageEnumerator.MoveNext timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">The <see cref="T:System.TimeSpan" /> to wait for a message to be available if the enumerator is positioned at the end of the queue.</param>
        <summary>Advances the enumerator to the next message in the queue. If the enumerator is positioned at the end of the queue, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> waits until a message is available or the given timeout expires.</summary>
        <returns>
          <see langword="true" /> if the enumerator successfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue and a message does not become available within the time specified by the <paramref name="timeout" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wartet, wenn keine Meldung in der Warteschlange vorhanden ist oder wenn der Cursor am Ende der Warteschlange erreicht hat. Wenn eine Nachricht nicht derzeit verfügbar ist, weil die Warteschlange leer ist oder Sie hinter dem letzten Element in der Auflistung verschoben haben <xref:System.Messaging.MessageEnumerator.MoveNext%2A> das angegebene Timeout.  
  
 Wenn der Cursor ist bereits am Ende der Warteschlange ist <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nur gibt `true` bei Empfang die neue Nachricht innerhalb des angegebenen Zeitintervalls derzeit hat eine niedrigere Priorität als alle Nachrichten in der Warteschlange und wird am Ende der Warteschlange platziert. Eine Überladung ohne Parameter gibt sofort zurück, wenn keine weiteren Nachrichten in der Warteschlange befinden.  
  
 Bei der Erstellung einer konzeptionell Enumerator wird vor der ersten Nachricht von der Enumeration und dem ersten Aufruf von <xref:System.Messaging.MessageEnumerator.MoveNext%2A> die erste Meldung in der Enumeration in der Ansicht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the timeout parameter is invalid. It might represent a negative number.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An exception specific to Message Queuing was thrown.  -or-  The timeout has expired.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Removes the current message from the queue and returns the message to the calling application. Removing the message deletes it from the queue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für diese Überladungen beschriebene Verhalten gilt nur, wenn die <xref:System.Messaging.MessageEnumerator> Instanz abgerufen wird, mithilfe der <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>. Verwenden Sie keine <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> zum Abrufen einer Instanz von <xref:System.Messaging.MessageEnumerator> wie diese Methode wurde als veraltet markiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes the current message from a transactional or non-transactional queue and returns the message to the calling application. There is no timeout specified for a message to arrive in the queue.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an der aktuellen Cursorposition zurück.  
  
 Wenn Sie Warteschlange Journaling verwenden, Entfernen der Nachricht führt dazu, dass eine Kopie in der Journalwarteschlange gespeichert werden sollen, wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Meldung verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Wenn Sie diese Überladung für eine transaktionale Warteschlange aufrufen, erstellt das Message Queuing eine einzelne internen Transaktion aus.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction in which the message will be removed.</param>
        <summary>Removes the current message from a transactional queue and returns the message to the calling application. There is no timeout specified for a message to arrive in the queue.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an die Position des Cursors, mithilfe von definierten internen Transaktionskontext die `transaction` Parameter.  
  
 Wenn Sie Warteschlange Journaling verwenden, Entfernen der Nachricht führt dazu, dass eine Kopie in der Journalwarteschlange gespeichert werden sollen, wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Bei der Arbeit mit Transaktionswarteschlangen ein Rollback einer Transaktion führt dazu, dass alle Nachrichten, die durch einen Aufruf von entfernt <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> an die Warteschlange zurückgegeben werden. Die Entfernung ist nicht nicht rückgängig gemacht werden, bis die Transaktion ein Commit ausgeführt wird.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Meldung verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Removes the current message from a queue and returns the message to the calling application. There is no timeout specified for a message to arrive in the queue.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an die Position des Cursors, mithilfe von definierten Transaktionskontext der `transactionType` Parameter.  
  
 Geben Sie `Automatic` für die `transactionType` -Parameters, wenn es bereits ein externer Transaktionskontext ist an den Thread angefügt, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` sollten Sie die Nachricht als eine interne Transaktion empfangen. Sie können angeben, `None` sollten Sie eine Nachricht aus einer transaktionalen Warteschlange außerhalb eines Transaktionskontexts zu empfangen.  
  
 Wenn Sie Warteschlange Journaling verwenden, Entfernen der Nachricht führt dazu, dass eine Kopie in der Journalwarteschlange gespeichert werden sollen, wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Bei der Arbeit mit Transaktionswarteschlangen ein Rollback einer Transaktion führt dazu, dass alle Nachrichten, die durch einen Aufruf von entfernt <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> an die Warteschlange zurückgegeben werden. Die Entfernung ist nicht nicht rückgängig gemacht werden, bis die Transaktion ein Commit ausgeführt wird.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Meldung verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">The interval of time to wait for a message to arrive in the queue.</param>
        <summary>Removes the current message from the queue and returns the message to the calling application. If there is a message to remove, the method returns it immediately. Otherwise, the method waits the specified timeout for a new message to arrive.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an der aktuellen Cursorposition zurück. Wenn der Cursor am Ende der Warteschlange befindet, wird diese Überladung der Methode wartet, bis eine Meldung verfügbar ist oder das Intervall angegeben wird, indem die `timeout` Parameter ist abgelaufen.  
  
 Wenn Sie Warteschlange Journaling verwenden, Entfernen der Nachricht führt dazu, dass eine Kopie in der Journalwarteschlange gespeichert werden sollen, wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Meldung verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Wenn Sie diese Überladung für eine transaktionale Warteschlange aufrufen, erstellt das Message Queuing eine einzelne internen Transaktion aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is invalid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The timeout has expired.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">The interval of time to wait for the message to be removed.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction context for the message.</param>
        <summary>Removes the current message from a transactional queue and returns the message to the calling application. If there is a message to remove, the method returns it immediately. Otherwise, the method waits the specified timeout for a new message to arrive.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an der aktuellen Cursorposition zurück. Wenn der Cursor am Ende der Warteschlange befindet, wird diese Überladung der Methode wartet, bis eine Meldung verfügbar ist oder das Intervall angegeben wird, indem die `timeout` Parameter ist abgelaufen.  
  
 Bei der Arbeit mit Transaktionswarteschlangen ein Rollback einer Transaktion führt dazu, dass alle Nachrichten, die durch einen Aufruf von entfernt <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> an die Warteschlange zurückgegeben werden. Die Entfernung ist nicht nicht rückgängig gemacht werden, bis die Transaktion ein Commit ausgeführt wird.  
  
 Wenn Sie Warteschlange Journaling verwenden, Entfernen der Nachricht führt dazu, dass eine Kopie in der Journalwarteschlange gespeichert werden sollen, wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Meldung verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is invalid.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The timeout has expired.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">The interval of time to wait for the message to be removed.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Removes the current message from a queue and returns the message to the calling application. If there is a message to remove, the method returns it immediately. Otherwise, the method waits the specified timeout for a new message to arrive.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt, und gibt die Meldung an die Position des Cursors, mithilfe von definierten Transaktionskontext der `transactionType` Parameter. Wenn der Cursor am Ende der Warteschlange befindet, wird diese Überladung der Methode wartet, bis eine Meldung verfügbar ist oder das Intervall angegeben wird, indem die `timeout` Parameter ist abgelaufen.  
  
 Geben Sie `Automatic` für die `transactionType` -Parameters, wenn es bereits ein externer Transaktionskontext ist an den Thread angefügt, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` sollten Sie die Nachricht als eine interne Transaktion empfangen. Sie können angeben, `None` sollten Sie eine Nachricht aus einer transaktionalen Warteschlange außerhalb eines Transaktionskontexts zu empfangen.  
  
 Wenn Sie Warteschlange Journaling verwenden, Entfernen der Nachricht führt dazu, dass eine Kopie in der Journalwarteschlange gespeichert werden sollen, wie die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Bei der Arbeit mit Transaktionswarteschlangen ein Rollback einer Transaktion führt dazu, dass alle Nachrichten, die durch einen Aufruf von entfernt <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> an die Warteschlange zurückgegeben werden. Die Entfernung ist nicht nicht rückgängig gemacht werden, bis die Transaktion ein Commit ausgeführt wird.  
  
 Wenn Sie die aktuelle Nachricht entfernen, wird der Cursor auf die nächste Meldung verschoben. Sie müssen keine Aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is invalid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The timeout has expired.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="messageEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resets the current enumerator so it points to the head of the queue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Enumerator kann nur vorwärts verschoben werden. Verwenden Sie diese Methode am Anfang der Warteschlange beginnen.  
  
 Nach dem Aufruf <xref:System.Messaging.MessageEnumerator.Reset%2A>, zeigt der Cursor auf die erste Nachricht. Sie müssen nicht aufrufen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufruf <xref:System.Messaging.MessageEnumerator.Reset%2A> auf den Cursor auf die erste Meldung in der Warteschlange zu setzen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IEnumerator.Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Messaging.MessageEnumerator.System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a <see cref="T:System.Messaging.Message" /> that references the message at the current cursor position.</summary>
        <value>Ein <see cref="T:System.Messaging.Message" /> , die auf die Nachricht an der aktuellen Cursorposition verweist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>