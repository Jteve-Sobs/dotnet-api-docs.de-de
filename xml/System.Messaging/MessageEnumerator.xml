<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8efdebcdda0d244a01f27597d636c3a6bc61870e" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83953895" /></Metadata><TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type MessageEnumerator = class&#xA;    inherit MarshalByRefObject&#xA;    interface IEnumerator&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt einen Vorwärtscursor zum Aufzählen der Nachrichten in einer Nachrichtenwarteschlange bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.Messaging.MessageEnumerator> für die dynamische Interaktion mit Nachrichten in einer Warteschlange. Methoden, die über die <xref:System.Messaging.MessageQueue>-Klasse verfügbar sind, können entweder eine <xref:System.Messaging.MessageEnumerator> zurückgeben, die auf eine dynamische Liste von Nachrichten in der Warteschlange zeigt, oder ein Array, das eine Kopie zu einem bestimmten Zeitpunkt enthält: eine Momentaufnahme der Warteschlange zu dem Zeitpunkt, als die angegebene Methode aufgerufen wurde.  
  
 Anders als eine statische Momentaufnahme ermöglicht ein Enumerator das Ändern der Auflistung. Mithilfe eines <xref:System.Messaging.MessageEnumerator>können Sie Nachrichten aus der Warteschlange entfernen, und die Änderung wird sofort in der Warteschlange widergespiegelt.  
  
 Ein Enumerator entfernt die Nachrichten nicht aus der Warteschlange, wenn er die Warteschlange abfragt. Sie gibt Informationen über die Nachricht an der aktuellen Cursorposition zurück, aber die Nachricht wird in der Warteschlange belassen.  
  
 Ein <xref:System.Messaging.MessageEnumerator> ist ein Cursor, der mit dem Anfang einer dynamischen Liste initialisiert wird. Die Reihenfolge der Listen ist mit der Reihenfolge der Nachrichten in der Warteschlange entsprechend der Nachrichten Priorität identisch. Sie können den Cursor zur ersten Nachricht in der Warteschlange bewegen, indem Sie <xref:System.Messaging.MessageEnumerator.MoveNext%2A>aufrufen. Nachdem der Enumerator initialisiert wurde, können Sie <xref:System.Messaging.MessageEnumerator.MoveNext%2A> verwenden, um die verbleibenden Nachrichten schrittweise zu durchlaufen. Sie können angeben, ob auf die Verfügbarkeit einer Nachricht gewartet werden soll, indem Sie ein Timeout an die <xref:System.Messaging.MessageEnumerator.MoveNext%2A> Methode übergeben.  
  
 Da der Enumerator dynamisch ist, kann eine Nachricht, die über die aktuelle Position des Cursors (z. b. aufgrund niedriger Priorität) angefügt wird, durch den Enumerator aufgerufen werden. Auf eine Meldung, die vor der aktuellen Position des Cursors eingefügt wird, kann nicht zugegriffen werden. Es ist nicht möglich, mit einer <xref:System.Messaging.MessageEnumerator>rückwärts zu wechseln. Ein Cursor ermöglicht Vorwärtsbewegung. Mit der <xref:System.Messaging.MessageEnumerator.Reset%2A>-Methode können Sie den Cursor am Anfang der Warteschlange wieder platzieren.  
  
 Instanzen von <xref:System.Messaging.MessageEnumerator> für eine bestimmte Warteschlange funktionieren unabhängig voneinander. Sie können zwei <xref:System.Messaging.MessageEnumerator> Instanzen erstellen, die für dieselbe Warteschlange gelten. Die Änderungen, die eine <xref:System.Messaging.MessageEnumerator> an den Nachrichten in der Warteschlange vornimmt, werden sofort in einem zweiten Enumerator reflektiert, wenn der zweite Enumerator vor dem ersten positioniert wird. Wenn jedoch zwei Enumeratoren dieselbe Position haben und eine von Ihnen an dieser Position entfernt wird, wird eine Ausnahme ausgelöst, wenn der andere Enumerator versucht, den Wert der <xref:System.Messaging.MessageEnumerator.Current%2A>-Eigenschaft für die nun gelöschte Nachricht zu erhalten.  
  
> [!NOTE]
>  Wenn Sie eine Instanz von <xref:System.Messaging.MessageQueue> erstellen, bei der <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> auf `true`festgelegt ist, kann keine andere Anwendung die Nachrichten in Ihrem Enumerator ändern, während Sie über die Verbindung mit der Warteschlange verfügen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine dynamische Liste von Nachrichten in einer Warteschlange abgerufen und alle Nachrichten gezählt, deren <xref:System.Messaging.Message.Priority%2A>-Eigenschaft auf <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>festgelegt ist.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageEnumerator.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die dem Enumerator zugeordneten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem behält während der Lebensdauer des Cursors ein geöffnetes Handle für die Warteschlange bei. Wenn Sie die Arbeit mit dem Enumerator abgeschlossen haben, können Sie <xref:System.Messaging.MessageEnumerator.Close%2A> abrufen, um die dem Handle zugeordneten Ressourcen freizugeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Messaging.Message" Usage="System.Messaging.MessageEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das aktuelle <see cref="T:System.Messaging.Message" /> ab, auf das dieser Enumerator zeigt.</summary>
        <value>Die aktuelle Meldung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Enumerator erstellt wird, verweist er an einer Position vor der ersten Nachricht auf den Anfang der Warteschlange. In diesem Fall ist <xref:System.Messaging.MessageEnumerator.Current%2A> ungültig und löst eine Ausnahme aus, wenn darauf zugegriffen wird. Sie müssen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> aufgerufen werden, um den Cursor an der ersten Nachricht in der Warteschlange zu positionieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Messaging.MessageEnumerator.Current" /> wurde vor dem ersten Aufruf von <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> aufgerufen. Der Cursor befindet sich vor dem ersten Element der Meldungsenumeration.  
  
Oder 
<see cref="P:System.Messaging.MessageEnumerator.Current" /> wurde aufgerufen, nachdem bei einem Aufruf von <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> der Wert <see langword="false" /> zurückgegeben wurde. (Dies bedeutet, dass sich der Cursor hinter dem letzten Element der Meldungsenumeration befindet.)</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Meldung, auf die der Enumerator gegenwärtig zeigt, ist nicht mehr vorhanden. Es wurde möglicherweise gelöscht.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.CursorHandle : nativeint" Usage="System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das systemeigene Cursorhandle von Message Queuing ab, das zum Durchsuchen von Meldungen in der Warteschlange verwendet wird.</summary>
        <value>Das systemeigene Cursorhandle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft enthält das Native Handle der-Enumeration. Wenn Sie die Arbeit mit dem Enumerator abgeschlossen haben, wenden Sie <xref:System.Messaging.MessageEnumerator.Close%2A> an, um diese Ressource freizugeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Das Handle ist nicht vorhanden.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die von <see cref="T:System.Messaging.MessageEnumerator" /> verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="messageEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von <see cref="T:System.Messaging.MessageEnumerator" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Aufrufen von <xref:System.Messaging.MessageEnumerator.Dispose%2A> können die Ressourcen, die vom <xref:System.Messaging.MessageEnumerator> verwendet werden, für andere Zwecke neu zugeordnet werden. Weitere Informationen zu <xref:System.Messaging.MessageEnumerator.Dispose%2A>finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](/dotnet/standard/garbage-collection/unmanaged).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/garbage-collection/unmanaged">Bereinigen von nicht verwalteten Ressourcen</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageEnumerator.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben. <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.Messaging.MessageEnumerator" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der öffentlichen <xref:System.Messaging.MessageEnumerator.Dispose%2A>-Methode und der <xref:System.Object.Finalize%2A>-Methode aufgerufen. `Dispose()` Ruft die geschützte `Dispose(Boolean)` Methode auf, wobei der `disposing`-Parameter auf `true`festgelegt ist. <xref:System.Object.Finalize%2A> ruft `Dispose` auf, bei dem `disposing` auf `false`festgelegt ist.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Messaging.MessageEnumerator> verweist. Diese Methode ruft die `Dispose()`-Methode jedes referenzierten Objekts auf.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see langword="Dispose(Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see langword="Dispose" /> freigegeben wurden. Weitere Informationen zum Implementieren von <see langword="Dispose" />finden Sie unter [Implementieren einer](/dotnet/standard/garbage-collection/implementing-dispose)verwerfen-Methode.  
  
Weitere Informationen zu <see langword="Dispose" /> und <see langword="Finalize" />finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](/dotnet/standard/garbage-collection/unmanaged) und überschreiben [der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
        <related type="Article" href="/dotnet/standard/garbage-collection/implementing-dispose">Implementieren einer Dispose-Methode</related>
        <related type="Article" href="/dotnet/standard/garbage-collection/unmanaged">Bereinigen von nicht verwalteten Ressourcen</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="messageEnumerator.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die von diesem Enumerator reservierten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Diese Methode überschreibt <xref:System.Object.Finalize>. Der Anwendungscode sollte diese Methode nicht aufzurufen. die Finalize-Methode eines Objekts wird automatisch während Garbage Collection aufgerufen, es sei denn, die Garbage Collector wurde durch einen Aufruf der <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>-Methode deaktiviert.

Weitere Informationen finden Sie unter [Finalize-Methoden und debugtoren](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v=vs.100)), [Bereinigen von nicht verwalteten Ressourcen](/dotnet/standard/garbage-collection/unmanaged)und überschreiben [der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Setzt den Enumerator auf die nächste Meldung in der Warteschlange.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="messageEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den Enumerator auf die nächste Meldung in der Warteschlange, sofern eine Meldung verfügbar ist.</summary>
        <returns><see langword="true" />, wenn der Enumerator erfolgreich auf die nächste Meldung gesetzt wurde. <see langword="false" />, wenn der Enumerator das Ende der Warteschlange erreicht hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird sofort zurückgegeben, wenn keine Meldung in der Warteschlange vorhanden ist. Es gibt eine andere Überladung, die eine angegebene <xref:System.TimeSpan> auf das Eintreffen einer Nachricht wartet.  
  
 Wenn eine Nachricht zurzeit nicht verfügbar ist, weil die Warteschlange leer ist oder Sie über das letzte Element in der Auflistung hinaus verschoben haben, wird <xref:System.Messaging.MessageEnumerator.MoveNext%2A> `false` an die Aufruf Methode zurückgegeben.  
  
 Bei der Erstellung wird ein Enumerator konzeptionell vor der ersten Nachricht der Warteschlange positioniert, und der erste <xref:System.Messaging.MessageEnumerator.MoveNext%2A>-Aufrufe führt die erste Nachricht der Warteschlange ein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Es wurde eine Message Queuing-spezifische Ausnahme ausgelöst.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.MoveNext : TimeSpan -&gt; bool" Usage="messageEnumerator.MoveNext timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Die <see cref="T:System.TimeSpan" /> gibt die Zeitspanne an, innerhalb derer eine Meldung eingehen muss, wenn der Enumerator auf das Ende der Warteschlange zeigt.</param>
        <summary>Setzt den Enumerator auf die nächste Meldung in der Warteschlange. Wenn sich der Enumerator am Ende der Warteschlange befindet, wartet <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />, bis eine Meldung verfügbar ist oder der angegebene Timeout überschritten wird.</summary>
        <returns><see langword="true" />, wenn der Enumerator erfolgreich auf die nächste Meldung gesetzt wurde. <see langword="false" />, wenn der Enumerator das Ende der Warteschlange erreicht hat und innerhalb der im <paramref name="timeout" />-Parameter angegebenen Zeit keine Meldung eingeht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wartet, wenn keine Nachricht in der Warteschlange vorhanden ist oder wenn der Cursor das Ende der Warteschlange erreicht hat. Wenn eine Nachricht zurzeit nicht verfügbar ist, weil die Warteschlange leer ist oder Sie über das letzte Element in der Auflistung hinaus verschoben haben, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> auf das angegebene Timeout warten.  
  
 Wenn sich der Cursor bereits am Ende der Warteschlange befindet, gibt <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nur `true` zurück, wenn die neue Nachricht innerhalb des angegebenen Zeitintervalls eintrifft, eine niedrigere Priorität als alle derzeit in der Warteschlange enthaltenen Nachrichten aufweist und am Ende der Warteschlange platziert wird. Eine Überladung ohne Parameter wird sofort zurückgegeben, wenn sich keine weiteren Nachrichten in der Warteschlange befinden.  
  
 Bei der Erstellung wird ein Enumerator konzeptionell vor der ersten Nachricht der-Enumeration positioniert, und der erste <xref:System.Messaging.MessageEnumerator.MoveNext%2A>-Aufrufe führt die erste Meldung der-Enumeration in die Ansicht ein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den Timeoutparameter angegebene Wert ist ungültig. Eventuell wurde ein negativer Wert angegeben.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Es wurde eine Message Queuing-spezifische Ausnahme ausgelöst.  
  
 Oder  
  
 Der Timeout wurde überschritten.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt die aktuelle Meldung aus der Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Durch das Entfernen einer Meldung wird diese aus der Warteschlange gelöscht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das für diese über Ladungen beschriebene Verhalten gilt nur, wenn die <xref:System.Messaging.MessageEnumerator> Instanz mithilfe des <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>abgerufen wird. Verwenden Sie <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> nicht, um eine Instanz von <xref:System.Messaging.MessageEnumerator> abzurufen, da diese Methode veraltet ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt die aktuelle Meldung aus einer transaktionalen oder nicht transaktionalen Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Für das Eintreffen einer Meldung in der Warteschlange ist kein Timeout festgelegt.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt die Meldung an der aktuellen Position des Cursors und gibt Sie zurück.  
  
 Wenn Sie das journalisieren von Warteschlangen verwenden, bewirkt das Entfernen der Nachricht, dass eine Kopie in der Journal Warteschlange gespeichert wird, so wie es bei der <xref:System.Messaging.MessageQueue.Receive%2A> Methode der <xref:System.Messaging.MessageQueue> Klasse der Fall ist.  
  
 Wenn Sie die aktuelle Meldung entfernen, wird der Cursor in die nächste Meldung verschoben. Sie müssen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nicht aufrufen, nachdem Sie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>aufgerufen haben.  
  
 Wenn Sie diese Überladung für eine transaktionale Warteschlange aufrufen, erstellt Message Queuing eine einzelne interne Transaktion.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Dieses <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt stellt die Transaktion dar, innerhalb der die Meldung entfernt wird.</param>
        <summary>Entfernt die aktuelle Meldung aus einer transaktionalen Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Für das Eintreffen einer Meldung in der Warteschlange ist kein Timeout festgelegt.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt die Nachricht an der aktuellen Position des Cursors und gibt Sie zurück, wobei der interne Transaktionskontext verwendet wird, der durch den `transaction`-Parameter definiert wird.  
  
 Wenn Sie das journalisieren von Warteschlangen verwenden, bewirkt das Entfernen der Nachricht, dass eine Kopie in der Journal Warteschlange gespeichert wird, so wie es bei der <xref:System.Messaging.MessageQueue.Receive%2A> Methode der <xref:System.Messaging.MessageQueue> Klasse der Fall ist.  
  
 Beim Arbeiten mit Transaktions Warteschlangen bewirkt ein Rollback einer Transaktion, dass alle Nachrichten, die durch einen-<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt wurden, an die Warteschlange zurückgegeben werden. Der Entfernungs Vorgang kann erst wieder rückgängig gemacht werden  
  
 Wenn Sie die aktuelle Meldung entfernen, wird der Cursor in die nächste Meldung verschoben. Sie müssen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nicht aufrufen, nachdem Sie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>aufgerufen haben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="transaction" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Entfernt die aktuelle Meldung aus einer Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Für das Eintreffen einer Meldung in der Warteschlange ist kein Timeout festgelegt.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt die Nachricht an der aktuellen Position des Cursors und gibt Sie mit einem Transaktionskontext zurück, der durch den `transactionType`-Parameter definiert wird.  
  
 Geben Sie `Automatic` für den `transactionType` Parameter an, wenn bereits ein externer Transaktionskontext an den Thread angefügt ist, den Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` an, wenn die Nachricht als einzelne interne Transaktion empfangen werden soll. Sie können `None` angeben, wenn Sie eine Nachricht von einer Transaktions Warteschlange außerhalb eines Transaktions Kontexts empfangen möchten.  
  
 Wenn Sie das journalisieren von Warteschlangen verwenden, bewirkt das Entfernen der Nachricht, dass eine Kopie in der Journal Warteschlange gespeichert wird, so wie es bei der <xref:System.Messaging.MessageQueue.Receive%2A> Methode der <xref:System.Messaging.MessageQueue> Klasse der Fall ist.  
  
 Beim Arbeiten mit Transaktions Warteschlangen bewirkt ein Rollback einer Transaktion, dass alle Nachrichten, die durch einen-<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt wurden, an die Warteschlange zurückgegeben werden. Der Entfernungs Vorgang kann erst wieder rückgängig gemacht werden  
  
 Wenn Sie die aktuelle Meldung entfernen, wird der Cursor in die nächste Meldung verschoben. Sie müssen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nicht aufrufen, nachdem Sie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>aufgerufen haben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Die Zeit, die auf das Eintreffen einer Meldung gewartet werden soll.</param>
        <summary>Entfernt die aktuelle Meldung aus der Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Wenn eine vorhandene Meldung entfernt werden kann, wird diese von der Methode sofort zurückgegeben. Andernfalls wartet die Methode auf das Eingehen einer neuen Meldung, bis der angegebene Timeout überschritten wird.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt die Meldung an der aktuellen Position des Cursors und gibt Sie zurück. Wenn sich der Cursor am Ende der Warteschlange befindet, wartet diese Überladung der-Methode, bis eine Meldung verfügbar ist oder das durch den `timeout`-Parameter angegebene Intervall abgelaufen ist.  
  
 Wenn Sie das journalisieren von Warteschlangen verwenden, bewirkt das Entfernen der Nachricht, dass eine Kopie in der Journal Warteschlange gespeichert wird, so wie es bei der <xref:System.Messaging.MessageQueue.Receive%2A> Methode der <xref:System.Messaging.MessageQueue> Klasse der Fall ist.  
  
 Wenn Sie die aktuelle Meldung entfernen, wird der Cursor in die nächste Meldung verschoben. Sie müssen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nicht aufrufen, nachdem Sie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>aufgerufen haben.  
  
 Wenn Sie diese Überladung für eine transaktionale Warteschlange aufrufen, erstellt Message Queuing eine einzelne interne Transaktion.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Der Timeout wurde überschritten.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Die Zeitspanne, in der die zu entfernende Meldung eingehen muss.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt, das den Transaktionskontext für diese Meldung angibt.</param>
        <summary>Entfernt die aktuelle Meldung aus einer transaktionalen Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Wenn eine vorhandene Meldung entfernt werden kann, wird diese von der Methode sofort zurückgegeben. Andernfalls wartet die Methode auf das Eingehen einer neuen Meldung, bis der angegebene Timeout überschritten wird.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt die Meldung an der aktuellen Position des Cursors und gibt Sie zurück. Wenn sich der Cursor am Ende der Warteschlange befindet, wartet diese Überladung der-Methode, bis eine Meldung verfügbar ist oder das durch den `timeout`-Parameter angegebene Intervall abgelaufen ist.  
  
 Beim Arbeiten mit Transaktions Warteschlangen bewirkt ein Rollback einer Transaktion, dass alle Nachrichten, die durch einen-<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt wurden, an die Warteschlange zurückgegeben werden. Der Entfernungs Vorgang kann erst wieder rückgängig gemacht werden  
  
 Wenn Sie das journalisieren von Warteschlangen verwenden, bewirkt das Entfernen der Nachricht, dass eine Kopie in der Journal Warteschlange gespeichert wird, so wie es bei der <xref:System.Messaging.MessageQueue.Receive%2A> Methode der <xref:System.Messaging.MessageQueue> Klasse der Fall ist.  
  
 Wenn Sie die aktuelle Meldung entfernen, wird der Cursor in die nächste Meldung verschoben. Sie müssen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nicht aufrufen, nachdem Sie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>aufgerufen haben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="transaction" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Der Timeout wurde überschritten.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Die Zeitspanne, in der die zu entfernende Meldung eingehen muss.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Entfernt die aktuelle Meldung aus einer Warteschlange und gibt die Meldung an die aufrufende Anwendung zurück. Wenn eine vorhandene Meldung entfernt werden kann, wird diese von der Methode sofort zurückgegeben. Andernfalls wartet die Methode auf das Eingehen einer neuen Meldung, bis der angegebene Timeout überschritten wird.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt die Nachricht an der aktuellen Position des Cursors und gibt Sie mit einem Transaktionskontext zurück, der durch den `transactionType`-Parameter definiert wird. Wenn sich der Cursor am Ende der Warteschlange befindet, wartet diese Überladung der-Methode, bis eine Meldung verfügbar ist oder das durch den `timeout`-Parameter angegebene Intervall abgelaufen ist.  
  
 Geben Sie `Automatic` für den `transactionType` Parameter an, wenn bereits ein externer Transaktionskontext an den Thread angefügt ist, den Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` an, wenn die Nachricht als einzelne interne Transaktion empfangen werden soll. Sie können `None` angeben, wenn Sie eine Nachricht von einer Transaktions Warteschlange außerhalb eines Transaktions Kontexts empfangen möchten.  
  
 Wenn Sie das journalisieren von Warteschlangen verwenden, bewirkt das Entfernen der Nachricht, dass eine Kopie in der Journal Warteschlange gespeichert wird, so wie es bei der <xref:System.Messaging.MessageQueue.Receive%2A> Methode der <xref:System.Messaging.MessageQueue> Klasse der Fall ist.  
  
 Beim Arbeiten mit Transaktions Warteschlangen bewirkt ein Rollback einer Transaktion, dass alle Nachrichten, die durch einen-<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> entfernt wurden, an die Warteschlange zurückgegeben werden. Der Entfernungs Vorgang kann erst wieder rückgängig gemacht werden  
  
 Wenn Sie die aktuelle Meldung entfernen, wird der Cursor in die nächste Meldung verschoben. Sie müssen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nicht aufrufen, nachdem Sie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>aufgerufen haben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Der Timeout wurde überschritten.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="messageEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den aktuellen Enumerator auf den Anfang der Warteschlange zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Enumerator kann nur vorwärts verschoben werden. Verwenden Sie diese Methode, um am Anfang der Warteschlange zu beginnen.  
  
 Nach dem Aufrufen von <xref:System.Messaging.MessageEnumerator.Reset%2A>zeigt der Cursor auf die erste Nachricht. Sie müssen <xref:System.Messaging.MessageEnumerator.MoveNext%2A> nach dem Aufrufen von <xref:System.Messaging.MessageEnumerator.Reset%2A> nicht aufrufen, um den Cursor auf die erste Nachricht in der Warteschlange zu verschieben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IEnumerator.Current : obj" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt eine <see cref="T:System.Messaging.Message" /> zurück, die auf die Meldung an der aktuellen Cursorposition verweist.</summary>
        <value>Eine <see cref="T:System.Messaging.Message" />, die auf die Meldung an der aktuellen Cursorposition verweist.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Sie haben vor dem ersten Aufruf von <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> auf diese Eigenschaft zugegriffen. Der Cursor befindet sich vor dem ersten Element der Nachrichtenenumeration, oder Sie haben auf diese Eigenschaft zugegriffen, nachdem bei einem Aufruf von <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> FALSE zurückgegeben wurde (wodurch angegeben wird, dass sich der Cursor hinter dem letzten Element der Nachrichtenenumeration befindet).</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Meldung, auf die der Enumerator gegenwärtig zeigt, ist nicht mehr vorhanden. Es wurde möglicherweise gelöscht.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
