<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2ac649709a4c7d130153f9dfe2ec4240375f7c09" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39732429" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Message = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt den Zugriff auf die Eigenschaften bereit, die zur Definition einer Message Queuing-Meldung erforderlich sind.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Messaging.Message> Klasse einsehen oder Empfangen von Nachrichten aus einer Warteschlange, oder um genaue Kontrolle über den Eigenschaften der Nachricht beim Senden einer Nachricht an eine Warteschlange zu erhalten.  
  
 <xref:System.Messaging.MessageQueue> verwendet die <xref:System.Messaging.Message> Klasse beim eingesehen oder Empfangen von Nachrichten aus der Warteschlange, da sowohl die <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType> und <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType> Methoden erstellen eine neue Instanz der dem <xref:System.Messaging.Message> Klasse, und legen Sie die Eigenschaften der Instanz. Die <xref:System.Messaging.Message> Klasse schreibgeschützte Eigenschaften gelten für das Abrufen von Nachrichten aus einer Warteschlange, während die Lese-/Schreibzugriff-Eigenschaften gelten für das Senden und Empfangen von Nachrichten. Wenn <xref:System.Messaging.MessageQueue> einsieht oder eine Nachricht aus einer Warteschlange empfängt die <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> Eigenschaft bestimmt, welche die Eigenschaften der Nachricht abgerufen werden.  
  
 Die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Send%2A> Methode können Sie an einen beliebigen Objekttyp für eine Nachricht an diese Warteschlange gesendet werden. Können Sie die <xref:System.Messaging.MessageQueue> Instanz <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft, um Einstellungen für generische an die Warteschlange gesendeten Nachrichten anzugeben. Die Einstellungen zählen Formatierer, Label, Verschlüsselung und Authentifizierung. Sie können auch angeben, die Werte für die entsprechende <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member, wenn Sie Ihre messaging-Anwendung auf Bestätigungs- und Berichtsnachrichten Nachrichten Antworten zu koordinieren. Mit einem <xref:System.Messaging.Message> Instanz zum Senden einer Nachricht an die Warteschlange bietet Ihnen die Flexibilität zum Zugreifen auf und ändern viele dieser Eigenschaften – entweder für eine einzelne Nachricht oder eine Message-Meldungen. <xref:System.Messaging.Message> Eigenschaften haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.  
  
 Nachrichtendaten befindet sich in der <xref:System.Messaging.Message.Body%2A> Eigenschaft und in geringerem Maße, die <xref:System.Messaging.Message.AppSpecific%2A> und <xref:System.Messaging.Message.Extension%2A> Eigenschaften. Wenn Nachrichtendaten ist verschlüsselt, serialisiert oder deserialisiert, nur der Inhalt des der <xref:System.Messaging.Message.Body%2A> -Eigenschaft beeinflusst werden.  
  
 Den Inhalt der <xref:System.Messaging.Message.Body%2A> Eigenschaft werden serialisiert, wenn die Nachricht gesendet wird, verwenden, die <xref:System.Messaging.Message.Formatter%2A> Eigenschaft, die Sie angeben. Der serialisierte Inhalt befinden sich die <xref:System.Messaging.Message.BodyStream%2A> Eigenschaft. Sie können auch Festlegen der <xref:System.Messaging.Message.BodyStream%2A> Eigenschaft direkt, um beispielsweise eine Datei als der Dateninhalt einer Nachricht zu senden. Sie können ändern, die <xref:System.Messaging.Message.Body%2A> oder <xref:System.Messaging.Message.Formatter%2A> Eigenschaften zu einem beliebigen Zeitpunkt vor dem Senden der Nachricht, und die Daten werden entsprechend serialisiert werden, wenn Sie aufrufen <xref:System.Messaging.MessageQueue.Send%2A>.  
  
 Die Eigenschaften von definiert die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType> Eigenschaft gelten nur für Nachrichten, die nicht vom Typ <xref:System.Messaging.Message>. Bei Angabe der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> -Eigenschaft für eine <xref:System.Messaging.MessageQueue>, die identisch benannte Eigenschaften in einer <xref:System.Messaging.Message> Instanz an die Warteschlange gesendeten diese Standardeigenschaften ignoriert werden soll.  
  
 Eine Liste der anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.Messaging.Message>, finden Sie unter den <xref:System.Messaging.Message.%23ctor%2A> Konstruktor.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, Formatieren eines Nachrichtentexts mit <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, Formatieren eines Nachrichtentexts mit <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.Message" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.Message" />-Klasse mit einem leeren Meldungstext.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Überladung können Sie eine neue Instanz der erstellen die <xref:System.Messaging.Message> -Klasse, die einem leeren Meldungstext.  
  
 Geben Sie entweder die <xref:System.Messaging.Message.Body%2A> Eigenschaft oder das <xref:System.Messaging.Message.BodyStream%2A> Eigenschaft vor dem Senden der <xref:System.Messaging.Message> Objekt. Die <xref:System.Messaging.Message.Body%2A> Eigenschaft kann jedes Objekt, das serialisiert werden kann, z. B. eine Zeichenfolge, ein Strukturobjekt, eine Instanz der Klasse oder ein eingebettetes Objekt sein.  
  
 Es sei denn, Sie direkt auf den Inhalt der Nachricht schreiben die <xref:System.Messaging.Message.BodyStream%2A> Eigenschaftensatz, der <xref:System.Messaging.Message.Formatter%2A> Eigenschaft vor dem Senden der Nachricht. Der Nachrichtentext serialisiert wird, mit der <xref:System.Messaging.Message.Formatter%2A> Eigenschaftswert zum Zeitpunkt der <xref:System.Messaging.MessageQueue.Send%2A> Methode wird aufgerufen, auf die <xref:System.Messaging.MessageQueue> Instanz.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> lose verknüpft, daher es nicht notwendig ist, das gleiche Objekt, das Absender und Empfänger geben Sie bei diesem Format haben. Die <xref:System.Messaging.ActiveXMessageFormatter> und <xref:System.Messaging.BinaryMessageFormatter> serialisieren Sie die Daten in eine binäre Darstellung. Die <xref:System.Messaging.ActiveXMessageFormatter> wird beim Senden oder Empfangen von COM-Komponenten verwendet.  
  
 In der folgende Tabelle werden die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.Message>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider Version 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Ein Array der Länge 0 (null) Bytes|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Ein Array der Länge 0 (null) Bytes|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Ein Array der Länge 0 (null) Bytes|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Ein Array der Länge 0 (null) Bytes|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird zwei Nachrichten unterschiedliche Prioritäten an die Warteschlange gesendet und anschließend abgerufen.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj -&gt; System.Messaging.Message" Usage="new System.Messaging.Message body" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">Das Objekt, das in den Meldungstext serialisiert werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.Message" />-Klasse, wobei das angegebene Objekt mithilfe des <see cref="T:System.Messaging.XmlMessageFormatter" /> in den Meldungstext serialisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Überladung können Sie eine neue Instanz der erstellen die <xref:System.Messaging.Message> Klasse enthält die <xref:System.Messaging.Message.Body%2A> gemäß der `body` Parameter. Die `body` Parameter kann jedes Objekt, das serialisiert werden kann, z. B. eine Zeichenfolge, ein Strukturobjekt, eine Instanz der Klasse oder ein eingebettetes Objekt sein. Der Nachrichtentext serialisiert wird, mit der <xref:System.Messaging.XmlMessageFormatter> es sei denn, Sie ändern die <xref:System.Messaging.Message.Formatter%2A> Eigenschaft, bevor Sie die <xref:System.Messaging.Message> wird gesendet. Wenn Sie ändern die <xref:System.Messaging.Message.Body%2A> oder <xref:System.Messaging.Message.Formatter%2A> Eigenschaft zu einem beliebigen Zeitpunkt vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%2A>, die Nachricht wird gemäß der neue Eigenschaftswert serialisiert werden.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> lose verknüpft, daher es nicht notwendig ist, das gleiche Objekt, das Absender und Empfänger geben Sie bei diesem Format haben. Die <xref:System.Messaging.ActiveXMessageFormatter> und <xref:System.Messaging.BinaryMessageFormatter> serialisieren Sie die Daten in eine binäre Darstellung. Die <xref:System.Messaging.ActiveXMessageFormatter> wird beim Senden oder Empfangen von COM-Komponenten verwendet.  
  
 In der folgende Tabelle werden die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.Message>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider Version 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Der `body`-Parameter.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Ein Array der Länge 0 (null) Bytes|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Ein Array der Länge 0 (null) Bytes|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Ein Array der Länge 0 (null) Bytes|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Ein Array der Länge 0 (null) Bytes|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine neue Warteschlange erstellt, sendet eine Nachricht, die eine Bestellung, enthält, und dann abgerufen.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj * System.Messaging.IMessageFormatter -&gt; System.Messaging.Message" Usage="new System.Messaging.Message (body, formatter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">Das Objekt, das in den Meldungstext serialisiert werden soll.</param>
        <param name="formatter">Der <see cref="T:System.Messaging.IMessageFormatter" /> gibt den Formatierer an, mit dem die Serialisierung in den Meldungstext erfolgen soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.Message" />-Klasse, wobei das angegebene Objekt mithilfe des angegebenen Formatierers in den Meldungstext serialisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Überladung können Sie eine neue Instanz der erstellen die <xref:System.Messaging.Message> Klasse enthält die <xref:System.Messaging.Message.Body%2A> gemäß der `body` und einen gültigen Formatierer zum Serialisieren des Textkörpers verwendet. Die `body` -Parameter ist jedes Objekt, das serialisiert werden kann, z. B. eine Zeichenfolge, ein Strukturobjekt, eine Instanz der Klasse oder ein eingebettetes Objekt. Wenn Sie ändern die <xref:System.Messaging.Message.Body%2A> oder <xref:System.Messaging.Message.Formatter%2A> Eigenschaft zu einem beliebigen Zeitpunkt vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%2A>, die Nachricht wird gemäß der neue Eigenschaftswert serialisiert werden.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> lose verknüpft, daher es nicht notwendig ist, das gleiche Objekt, das Absender und Empfänger geben Sie bei diesem Format haben. Die <xref:System.Messaging.ActiveXMessageFormatter> und <xref:System.Messaging.BinaryMessageFormatter> serialisieren Sie die Daten in eine binäre Darstellung. Die <xref:System.Messaging.ActiveXMessageFormatter> wird beim Senden oder Empfangen von COM-Komponenten verwendet.  
  
 In der folgende Tabelle werden die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.Message>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider Version 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Der `body`-Parameter.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Ein Array der Länge 0 (null) Bytes|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Ein Array der Länge 0 (null) Bytes|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Ein Array der Länge 0 (null) Bytes|  
|<xref:System.Messaging.Message.Formatter%2A>|Der `formatter`-Parameter.|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Ein Array der Länge 0 (null) Bytes|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgeType : System.Messaging.AcknowledgeTypes with get, set" Usage="System.Messaging.Message.AcknowledgeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ der Bestätigungsmeldung ab, die an die sendende Anwendung zurückgegeben werden soll, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.AcknowledgeTypes" />-Werte, die sowohl die Typen der Bestätigungsmeldungen darstellen, die das System in die Verwaltungswarteschlange stellt, als auch die Bedingungen, unter denen Bestätigungsmeldungen an die sendende Anwendung zurückgegeben werden. Der Standardwert ist <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.AcknowledgeType%2A> Eigenschaft gibt den Typ der Bestätigungsnachricht an, die von der sendenden Anwendung angefordert. Legen Sie die <xref:System.Messaging.Message.AcknowledgeType%2A> Eigenschaft vor dem Senden der Nachricht zum Anfordern von Benachrichtigungen über bestimmte Vorkommen – z. B. eine Nachricht die Zielwarteschlange, eine Nachricht abgerufen wird oder ein Timeout, die verhindern, dass einer Nachricht zu erreichen oder aus dieser abgerufen werden die Zielwarteschlange.  
  
 Message Queuing gibt Benachrichtigung zurück, durch Senden von bestätigungsmeldungen an die <xref:System.Messaging.Message.AdministrationQueue%2A> von der ursprünglichen Nachricht angegebene Eigenschaft. Einer Bestätigungsnachricht <xref:System.Messaging.Message.Acknowledgment%2A> Eigenschaft gibt den Typ der Bestätigung, die es darstellt. Angenommen, eine Bestätigungsnachricht gesendet wurde, da es sich bei eine Nachricht vor dem Ziel nicht erreicht hatten die <xref:System.Messaging.Message.TimeToReachQueue%2A> Intervall abgelaufen ist, die <xref:System.Messaging.Message.Acknowledgment%2A> -Eigenschaft der Bestätigungsnachricht enthält den Wert `ReachQueueTimeout`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht mit einer Bestellung in und aus einer Warteschlange. Eine positive Bestätigung sie ausdrücklich angefordert, wenn die ursprüngliche Nachricht erreicht wurde oder wird aus der Warteschlange abgerufen.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AcknowledgeType" />-Eigenschaft wird aufgrund eines für die Meldung gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberSignature Language="F#" Value="member this.Acknowledgment : System.Messaging.Acknowledgment" Usage="System.Messaging.Message.Acknowledgment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Klassifikation für die Bestätigung ab, die diese Meldung darstellt.</summary>
        <value>Einer der <see cref="T:System.Messaging.Acknowledgment" />-Enumerationswerte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Nachricht von einer Verwaltungswarteschlange erhalten, lesen Sie die <xref:System.Messaging.Message.Acknowledgment%2A> Eigenschaft, um den Status der ursprünglichen Nachricht zu überprüfen.  
  
 Wenn eine Nachricht an die Zielwarteschlange gesendet wird, kann Message Queuing-angefordert werden, um eine Bestätigungsnachricht. Eine solche Nachricht kann, z. B. angeben, ob die Nachricht angekommen ist und innerhalb der angegebenen Timeouts abgerufen wurde, oder sie angeben können, im Fall von Zustellfehler auswachsen. Die Zielwarteschlange gibt Bestätigung Nachrichten und übermittelt sie an die Verwaltungswarteschlange, die in der ursprünglichen Nachricht angegebene <xref:System.Messaging.Message.AdministrationQueue%2A> Eigenschaft. Die <xref:System.Messaging.Message.Id%2A> Eigenschaft eine Bestätigungsnachricht identifiziert die Bestätigungsnachricht, nicht die ursprüngliche Nachricht. Den Bezeichner der ursprünglichen Nachricht finden Sie in der Bestätigung <xref:System.Messaging.Message> Instanz <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft.  
  
 Wenn diese <xref:System.Messaging.Message> Instanz stellt eine Bestätigungsnachricht, die <xref:System.Messaging.Message.Acknowledgment%2A> Eigenschaft gibt den Typ der Bestätigung. Andernfalls die <xref:System.Messaging.Message.Acknowledgment%2A> Eigenschaft enthält den Wert `Normal`.  
  
 Verwenden der <xref:System.Messaging.Message.AcknowledgeType%2A> -Eigenschaft der ursprünglichen Nachricht an die Umstände, unter dem Bestätigungen zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder -  
Die <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AdministrationQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.AdministrationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Warteschlange ab, die die von Message Queuing erzeugten Bestätigungsmeldungen empfängt, oder legt diese fest.</summary>
        <value>Die <see cref="T:System.Messaging.MessageQueue" />, die die Verwaltungswarteschlange für Bestätigungsmeldungen des Systems angibt. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Warteschlange, die im angegebenen die <xref:System.Messaging.Message.AdministrationQueue%2A> Eigenschaft kann nicht transaktionale Warteschlange sein. In den an die Verwaltungswarteschlange gesendeten Bestätigungsnachrichten kann angezeigt werden, ob die ursprüngliche Nachricht ihre Zielwarteschlange erreicht hat und aus der Warteschlange entfernt wurde.  
  
 Wenn die <xref:System.Messaging.Message.AcknowledgeType%2A> Eigenschaft verfügt über einen beliebigen Wert außer `None`, die sendende Anwendung muss die Warteschlange angeben, die als die Verwaltungswarteschlange verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht mit einer Bestellung in und aus einer Warteschlange. Eine positive Bestätigung sie ausdrücklich angefordert, wenn die ursprüngliche Nachricht erreicht wurde oder wird aus der Warteschlange abgerufen.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AdministrationQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AppSpecific : int with get, set" Usage="System.Messaging.Message.AppSpecific" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft zusätzliche anwendungsspezifische Daten ab oder legt diese fest.</summary>
        <value>Anwendungsspezifische Daten. Der Standardwert ist 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.AppSpecific%2A> Eigenschaft enthält anwendungsspezifische Informationen, die Sie verwenden können, um verschiedene Nachrichtentypen zu organisieren. So können beispielsweise anwendungsspezifische Indizes verwendet werden. Es liegt in der Verantwortung der Anwendung interpretiert <xref:System.Messaging.Message.AppSpecific%2A> Eigenschafteninformationen.  
  
 Sie sollten zunächst Nachrichtendaten im Text der Nachricht einschließen, wann immer möglich, anstelle der <xref:System.Messaging.Message.AppSpecific%2A> Eigenschaft.  
  
 Verwenden Sie bei der Arbeit mit fremde Warteschlangen die <xref:System.Messaging.Message.Extension%2A> Eigenschaft angeben, Message Queuing-Nachrichteneigenschaften, die nicht vorhanden sind. Wie bei der <xref:System.Messaging.Message.AppSpecific%2A> -Eigenschaft, es liegt in der Verantwortung der Anwendung den Inhalt der zu der <xref:System.Messaging.Message.Extension%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AppSpecific" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ArrivedTime : DateTime" Usage="System.Messaging.Message.ArrivedTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zeitpunkt ab, zu dem die Meldung von der Zielwarteschlange empfangen wurde.</summary>
        <value>Die <see cref="T:System.DateTime" /> stellt die Eingangszeit der Meldung in der Zielwarteschlange dar. Die Zeit wird von GMT in die lokale Zeit des Computers umgerechnet, auf dem sich die Zielwarteschlange befindet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Nachrichteneigenschaft <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschaft gibt an, wie schnell die Nachricht aus der Zielwarteschlange empfangen werden muss. Die <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschaft-Timer beginnt, wenn die Nachricht gesendet wird, nicht verwendet werden, wenn die Nachricht in der Warteschlange eintrifft,.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert von der Nachricht <xref:System.Messaging.Message.ArrivedTime%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.ArrivedTime" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AttachSenderId : bool with get, set" Usage="System.Messaging.Message.AttachSenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Sender-ID an die Meldung angehängt werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die <see cref="P:System.Messaging.Message.SenderId" /> an die Meldung angehängt werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.SenderId%2A> -Eigenschaft ist ein Array von Bytes, die den Bezeichner des sendenden Benutzers darstellt. Die Absender-ID wird vom Message Queuing festgelegt und wird verwendet, von der empfangenden Warteschlangen-Manager um zu überprüfen, ob der Absender über Zugriffsrechte für eine Warteschlange verfügt.  
  
 Das Fehlen der Sender ID eine Angabe über das von der sendenden Anwendung liegt darin, dass nicht den Absender der Nachricht überprüfen oder Überprüfen des Absenders des Zugriffs auf sollten Message Queuing-Rechte an die empfangende Warteschlange. Die <xref:System.Messaging.Message.SenderId%2A> vertrauenswürdig, nur dann, wenn die Nachricht authentifiziert wurde, wenn sie die Zielwarteschlange erreicht ist. Die Nachricht wird zurückgewiesen, wenn sie die Zielwarteschlange erreicht, wenn die Warteschlange nur authentifizierte Nachrichten und entweder akzeptiert die <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A> oder <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> Eigenschaft `false`.  
  
> [!CAUTION]
>  Wenn eine Nachricht abgelehnt wird, wird es entweder an die Dead Letter-Warteschlange gesendet (Wenn <xref:System.Messaging.Message.UseDeadLetterQueue%2A> ist `true`), oder es wird ignoriert. Sie können Bestätigungen anfordern, wenn eine Nachricht ein Fehler auftritt, eine Warteschlange zu erreichen. Andernfalls gilt bei <xref:System.Messaging.Message.UseDeadLetterQueue%2A> ist `false` die Nachricht möglicherweise ohne Warnung verloren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert für einer Nachricht <xref:System.Messaging.Message.AttachSenderId%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AttachSenderId" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Authenticated : bool" Usage="System.Messaging.Message.Authenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Nachricht authentifiziert wurde.</summary>
        <value>
          <see langword="true" />, wenn beim Erreichen der Warteschlange eine Authentifizierung für die Meldung angefordert wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.Authenticated%2A> Eigenschaft wird nur von der Anwendung verwendet, während es Interaktion mit der Nachricht und versucht zu bestimmen, ob eine Authentifizierung angefordert wurde. Wenn die Nachricht in der Warteschlange, wurde die Nachricht authentifiziert. Im Gegensatz dazu, wenn die <xref:System.Messaging.Message.Authenticated%2A> Eigenschaft `true`, empfangenden Warteschlangen-Manager die Meldung authentifiziert, wenn sie diese Nachricht empfangen.  
  
 Sie können nicht feststellen, ob eine Meldung Fehler bei der Authentifizierung anhand der Eigenschaften. Message Queuing verwirft Nachrichten, die Authentifizierung fehl, bevor sie an die Warteschlange übermittelt werden. Allerdings können Sie anfordern, dass eine Bestätigungsnachricht gesendet werden, wenn ein Zustellungsfehler verhindert, dass die Nachricht in der Warteschlange eingeht.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert von der Nachricht <xref:System.Messaging.Message.Authenticated%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.Authenticated" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderName : string with get, set" Usage="System.Messaging.Message.AuthenticationProviderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Kryptografieanbieters ab, der zum Generieren der digitalen Signatur für die Meldung verwendet wird.</summary>
        <value>Der Name des Kryptografieanbieters, mit dem die digitale Signatur erzeugt wird. Die Standardeinstellung ist Microsoft Base Cryptographic Provider, Version 1.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel die <xref:System.Messaging.Message.AuthenticationProviderName%2A> bei der Arbeit mit fremde Warteschlangen. Message Queuing ist erforderlich, der Name des Authentifizierungsanbieters und der Authentifizierung-Anbietertyp des Kryptografieanbieters (Authentifizierungsanbieter) zum Überprüfen der digitalen Signatures von Nachrichten an eine fremde Warteschlange gesendet und Nachrichten in der Nachricht Queuing von einer fremden Warteschlange.  
  
 Beim Senden einer Nachricht festlegen, die immer die <xref:System.Messaging.Message.AuthenticationProviderName%2A> und <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaften zusammen. Wenn die Nachricht gesendet wird, ignoriert das Message Queuing-der Name des Authentifizierungsanbieters, wenn der Connector-Typ nicht festgelegt wurde.  
  
 Die <xref:System.Messaging.Message.AuthenticationProviderName%2A> Eigenschaft darf nicht sein `null`, aber es kann sein, eine leere Zeichenfolge ("").  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AuthenticationProviderName" />-Eigenschaft konnte nicht festgelegt werden.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.AuthenticationProviderName" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">Der <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> wurde auf <see langword="null" /> festgelegt.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderType : System.Messaging.CryptographicProviderType with get, set" Usage="System.Messaging.Message.AuthenticationProviderType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des Kryptografieanbieters ab, mit dem die digitale Signatur der Meldung generiert wird, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.CryptographicProviderType" />-Werte. Der Standardwert ist <see langword="RSA_FULL" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel die <xref:System.Messaging.Message.AuthenticationProviderType%2A> Eigenschaft bei der Arbeit mit fremde Warteschlangen, um anzugeben, welche Kryptografiedienstanbieter Nachricht zugeordnet ist. Message Queuing ist erforderlich, der Name des Authentifizierungsanbieters und der Authentifizierung-Anbietertyp des Kryptografieanbieters (Authentifizierungsanbieter) zum Überprüfen der digitalen Signatures von Nachrichten an eine fremde Warteschlange gesendet und Nachrichten in der Nachricht Queuing von einer fremden Warteschlange.  
  
 Nur `RsaFull` mit messaging verwendet werden soll.  
  
 Beim Senden einer Nachricht festlegen, die immer die <xref:System.Messaging.Message.AuthenticationProviderType%2A> und <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaften zusammen. Wenn die Nachricht gesendet wird, ignoriert das Message Queuing den Authentifizierungstyp für den Anbieter, wenn der Connector-Typ nicht festgelegt wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AuthenticationProviderType" />-Eigenschaft konnte nicht festgelegt werden.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.AuthenticationProviderType" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Body : obj with get, set" Usage="System.Messaging.Message.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Inhalt der Nachricht ab oder legt diesen fest.</summary>
        <value>Ein Objekt, das den Inhalt der Meldung enthält. Das Objekt kann eine Zeichenfolge, ein Datum, eine Währung, eine Zahl, ein Bytearray oder ein beliebiges verwaltetes Objekt sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Nachrichteneigenschaft <xref:System.Messaging.Message.Body%2A> Eigenschaft enthält in der Regel die Daten, die der Nachricht zugeordnet. Obwohl Sie auch anwendungsspezifische Daten, in senden können der <xref:System.Messaging.Message.AppSpecific%2A> und <xref:System.Messaging.Message.Extension%2A> Eigenschaften von aufzunehmen Nachrichtendaten in das <xref:System.Messaging.Message.Body%2A> der Nachricht nach Möglichkeit. Nur die <xref:System.Messaging.Message.Body%2A> Inhalt-Eigenschaft, die serialisiert oder verschlüsselt sind.  
  
 Die <xref:System.Messaging.Message.Body%2A> Eigenschaft darf jedes beliebige Objekt, dessen Größe 4 MB nicht überschreitet. Bei Verwendung von <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType> auf ein Objekt zu senden, die nicht vom Typ <xref:System.Messaging.Message> auf die <xref:System.Messaging.MessageQueue>, befindet sich das Objekt der <xref:System.Messaging.Message.Body%2A> Eigenschaft der <xref:System.Messaging.Message> vom zurückgegebene Instanz <xref:System.Messaging.MessageQueue.Peek%2A> oder <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 Das Zeichenfolgenargument in `MessageQueue.Send("hello.")` ist ein Beispiel für solche ein generisches Objekt.  
  
 Die <xref:System.Messaging.Message.BodyType%2A> Eigenschaft gibt an, die Art der Informationen, die im Nachrichtentext gespeichert sind. Message Queuing verwendet diese Informationen, um den Typ des zu identifizieren die <xref:System.Messaging.Message.Body%2A> Inhalt-Eigenschaft.  
  
 Geben Sie entweder die <xref:System.Messaging.Message.Body%2A> Eigenschaft oder das <xref:System.Messaging.Message.BodyStream%2A> Eigenschaft vor dem Senden der <xref:System.Messaging.Message> Objekt. Die <xref:System.Messaging.Message.Body%2A> Eigenschaft kann sein, alle serialisierbaren Objekts, z. B. eine Zeichenfolge, Strukturobjekts, Instanz der Klasse oder eingebettetes Objekt.  
  
 Es sei denn, Sie direkt auf den Inhalt der Nachricht schreiben die <xref:System.Messaging.Message.BodyStream%2A> Eigenschaftensatz, der <xref:System.Messaging.Message.Formatter%2A> Eigenschaft vor dem Senden der Nachricht. Wenn die <xref:System.Messaging.MessageQueue.Send%2A> Methode wird aufgerufen, auf die <xref:System.Messaging.MessageQueue> Instanz, die Text serialisiert wird, mithilfe des Formatierers in enthaltenen der <xref:System.Messaging.Message.Formatter%2A> Eigenschaft. Wenn Sie die Nachricht senden, ohne einen Wert für die <xref:System.Messaging.Message.Formatter%2A> -Eigenschaft der Standardformatierer <xref:System.Messaging.XmlMessageFormatter>.  
  
> [!NOTE]
>  Beim Festlegen des Texts einer Nachricht an <xref:System.Decimal.MaxValue> führt dazu, dass eine <xref:System.OverflowException> beim der `Send` -Methode der der <xref:System.Messaging.MessageQueue> -Klasse aufgerufen wird und die <xref:System.Messaging.ActiveXMessageFormatter> wird verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird zwei Nachrichten unterschiedliche Prioritäten an die Warteschlange gesendet und anschließend abgerufen.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Formatter" />-Eigenschaft ist <see langword="null" />.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.Body" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BodyStream : System.IO.Stream with get, set" Usage="System.Messaging.Message.BodyStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Daten im Meldungstext ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.IO.Stream" />, der die serialisierten Daten aus dem <see cref="P:System.Messaging.Message.Body" /> der Meldung enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Text einer Nachricht kann jede Art von Informationen bestehen, z. B. eine Zeichenfolge, ein Datum, Währung, eine Zahl, ein Array von Bytes, oder ein verwaltetes Objekt. Diese Informationen in serialisiert wird eine <xref:System.IO.Stream> an die Warteschlange übergeben werden.  
  
 Geben Sie entweder die <xref:System.Messaging.Message.Body%2A> Eigenschaft oder das <xref:System.Messaging.Message.BodyStream%2A> Eigenschaft vor dem Senden der <xref:System.Messaging.Message> Objekt. Setzen Sie die <xref:System.Messaging.Message.Body%2A> -Eigenschaft, in der Inhalt serialisiert werden die <xref:System.Messaging.Message.BodyStream%2A> Eigenschaft. Sie können jedoch auswählen, zum Schreiben der <xref:System.Messaging.Message.BodyStream%2A> -Eigenschaft direkt. Dies empfiehlt sich beispielsweise, wenn Sie eine Verbindung mit einer Datei zu öffnen und dessen Inhalt als Text der Nachricht zu streamen möchten.  
  
 Es sei denn, Sie direkt auf den Inhalt der Nachricht schreiben die <xref:System.Messaging.Message.BodyStream%2A> Eigenschaftensatz, der <xref:System.Messaging.Message.Formatter%2A> Eigenschaft vor dem Senden der Nachricht. Wenn die <xref:System.Messaging.MessageQueue.Send%2A> Methode wird aufgerufen, auf die <xref:System.Messaging.MessageQueue> Instanz, die Text serialisiert wird, mithilfe des Formatierers in enthaltenen der <xref:System.Messaging.Message.Formatter%2A> Eigenschaft. Wenn Sie die Nachricht senden, ohne einen Wert für die <xref:System.Messaging.Message.Formatter%2A> -Eigenschaft der Standardformatierer <xref:System.Messaging.XmlMessageFormatter>.  
  
 Setzen Sie die <xref:System.Messaging.Message.UseEncryption%2A> Eigenschaft `true` für den Text dieser Nachricht, die Nachricht verschlüsselt wird, wenn es gesendet wird, nicht verwendet werden, wenn Sie festlegen, die <xref:System.Messaging.Message.Body%2A> Eigenschaft. Aus diesem Grund die <xref:System.Messaging.Message.BodyStream%2A> Eigenschaft ist nie verschlüsselt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Body" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BodyType : int with get, set" Usage="System.Messaging.Message.BodyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ der im Nachrichtenkörper enthaltenen Daten ab oder legt diesen fest.</summary>
        <value>Der tatsächliche Typ des Meldungstexts, z. B. Zeichenfolge, Datum, Währung oder Zahl.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing erkennt der Textinhalt als Objekt oder als serialisierten Stream. Die <xref:System.Messaging.Message.BodyType%2A> -Eigenschaft gibt den Typ des Objekts in der <xref:System.Messaging.Message.Body%2A> -Eigenschaft der Nachricht.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> führt eine Bindung zwischen nativen Typen und das Objekt in einen Nachrichtentext. Bei Verwendung der <xref:System.Messaging.XmlMessageFormatter>, diesen festgelegt die <xref:System.Messaging.Message.BodyType%2A> -Eigenschaft für Sie.  
  
 Andere Formatierungsprogramme bieten Bindungsfunktionalität auch, wie im folgenden C#-Code dargestellt.  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert von der Nachricht <xref:System.Messaging.Message.BodyType%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Body" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectorType : Guid with get, set" Usage="System.Messaging.Message.ConnectorType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der anzeigt, dass einige Meldungseigenschaften, die normalerweise von Message Queuing festgelegt werden, durch die sendende Anwendung festgelegt wurden, oder legt diesen fest.</summary>
        <value>Eine von der Anwendung definierte <see cref="T:System.Guid" />, die in Verbindung mit Connectoranwendungen oder der Meldungsverschlüsselung verwendet wird. Mithilfe der <see cref="T:System.Guid" /> kann eine empfangende Anwendung Meldungseigenschaften interpretieren, die normalerweise von Message Queuing festgelegt werden, in diesem Fall jedoch durch eine sendende Anwendung überschrieben wurden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing erfordert die <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaft festgelegt werden, wenn eine Anwendung eine Message-Eigenschaft festlegt, die normalerweise von Message Queuing festgelegt ist. Eine Anwendung in der Regel verwendet eine <xref:System.Messaging.Message.ConnectorType%2A> in den folgenden zwei Fällen:  
  
-   Eine Connectoranwendung übergibt jedes Mal, wenn eine Meldung. Die <xref:System.Messaging.Message.ConnectorType%2A> teilt den sendenden und empfangenden Anwendungen wie die Sicherheit und die Bestätigung der Nachricht zu interpretieren.  
  
-   Die sendende Anwendung, anstatt in Message Queuing, verschlüsselt jedes Mal, wenn eine Nachricht auf. Die <xref:System.Messaging.Message.ConnectorType%2A> teilt Message Queuing verwendet den <xref:System.Messaging.Message.DestinationSymmetricKey%2A> Eigenschaftswert zum Entschlüsseln der Nachricht.  
  
 Sie müssen festlegen, die <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaft, wenn Sie die folgenden Eigenschaften festlegen (andernfalls werden diese Eigenschaften beim Senden der Nachricht wird von die Warteschlange ignoriert):  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.ConnectorType" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CorrelationId : string with get, set" Usage="System.Messaging.Message.CorrelationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die in Bestätigungs-, Berichts- und Antwortnachrichten für den Verweis auf die ursprüngliche Nachricht verwendete Nachrichten-ID ab oder legt diese fest.</summary>
        <value>Die in der <see cref="P:System.Messaging.Message.Id" />-Eigenschaft der ursprünglichen Nachricht angegebene Meldungs-ID. Die Korrelations-ID wird in Message Queuing beim Erzeugen von Bestätigungs- oder Berichtsmeldungen sowie in Anwendungen beim Erzeugen von Antwortmeldungen verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Message Queuing eine Bestätigungs- oder berichtsnachricht generiert, verwendet die Korrelations-ID-Eigenschaft, um die Nachrichten-ID der ursprünglichen Nachricht festzulegen. Auf diese Weise bindet die Korrelations-ID die Berichts- oder Bestätigungsnachricht an die ursprüngliche Nachricht.  
  
 Die sendende Anwendung kann dann die Bestätigung oder den Bericht mit der ursprünglichen Nachricht mithilfe von Zuordnen der <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft, um der ursprünglichen Nachricht identifizieren <xref:System.Messaging.Message.Id%2A> Eigenschaft.  
  
 Connectoranwendungen auch müssen Festlegen der <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft der Bestätigungs- und Berichtsnachrichten Nachrichten, die die Nachrichten-ID der ursprünglichen Nachricht.  
  
 Wenn Ihre Anwendung eine Antwortnachricht an die sendende Anwendung sendet, Sie können festlegen, die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft der Response-Nachricht an die Nachrichten-ID der ursprünglichen Nachricht. Die sendende Anwendung kann dann die Response-Nachricht an die Meldung anpassen, die gesendet wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht, die eine Bestellung in und aus einer Warteschlange enthält. Eine positive Bestätigung sie ausdrücklich angefordert, wenn die ursprüngliche Nachricht erreicht wurde oder wird aus der Warteschlange abgerufen.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.CorrelationId" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.CorrelationId" /> ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DestinationQueue : System.Messaging.MessageQueue" Usage="System.Messaging.Message.DestinationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die für eine Meldung angegebene Zielwarteschlange ab.</summary>
        <value>Die <see cref="T:System.Messaging.MessageQueue" />, die die für die Meldung angegebene Zielwarteschlange angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.DestinationQueue%2A> Eigenschaft wird am häufigsten verwendet, um das ursprüngliche Ziel einer Nachricht zu bestimmen, die in einer Journalwarteschlange oder für unzustellbare Nachrichten-Warteschlange empfangen. In der Regel müssen nicht Sie diese Eigenschaft zu überprüfen, da Sie in der Regel die Nachricht aus der Zielwarteschlange abzurufen.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert von der Nachricht <xref:System.Messaging.Message.DestinationQueue%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.DestinationQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DestinationSymmetricKey : byte[] with get, set" Usage="System.Messaging.Message.DestinationSymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den symmetrischen Schlüssel für Meldungen ab, die in einer Anwendung oder für die Übermittlung an fremde Warteschlangen verschlüsselt werden.</summary>
        <value>Ein Bytearray, das den zur Verschlüsselung der Meldung verwendeten symmetrischen Zielschlüssel angibt. Der Standardwert ist ein Array der Länge 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei Szenarien müssen Sie verwenden die <xref:System.Messaging.Message.DestinationSymmetricKey%2A> Eigenschaft. Die erste ist, wenn Ihre Anwendung, anstatt Message Queuing eine Nachricht verschlüsselt. Das zweite ist, wenn Sie eine verschlüsselte Nachricht an die nicht von Message Queuing-senden.  
  
 Bevor Sie diese Eigenschaft festlegen, müssen Sie den symmetrischen Schlüssel mit dem öffentlichen Schlüssel der empfangende Warteschlangenmanager verschlüsseln. Wenn Sie eine Anwendung verschlüsselte Nachricht senden, verwendet der empfangende Warteschlangenmanager den symmetrischen Schlüssel zum Entschlüsseln der Nachricht vor dem Senden an die Zielwarteschlange an.  
  
 Wenn Sie eine Nachricht an eine fremde Warteschlange senden, ist von der entsprechenden Connector-Anwendung, die die verschlüsselte Nachricht mit dem angefügten symmetrischen Schlüssel an die empfangende Anwendung weiterleitet, zuerst die Nachricht empfangen. Es ist dann die Verantwortung für die empfangende Anwendung zum Entschlüsseln der Nachricht, die mit dem symmetrischen Schlüssel.  
  
 Beim Festlegen der <xref:System.Messaging.Message.DestinationSymmetricKey%2A> -Eigenschaft, müssen Sie auch Festlegen der <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaft. Wenn die Nachricht gesendet wird, Message Queuing ignoriert den <xref:System.Messaging.Message.DestinationSymmetricKey%2A> Eigenschaft Wenn die <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaft nicht festgelegt.  
  
 Die <xref:System.Messaging.Message.DestinationSymmetricKey%2A> Eigenschaft verfügt über eine maximale Größe von 256.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.DestinationSymmetricKey" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DigitalSignature : byte[] with get, set" Usage="System.Messaging.Message.DigitalSignature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die digitale Signatur ab, mit der Message Queuing die Meldung authentifiziert, oder legt diese fest.</summary>
        <value>Ein Bytearray, das die zur Authentifizierung der Meldung verwendete digitale Signatur von Message Queuing 1.0 enthält. Der Standardwert ist ein Array der Länge 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing verwendet die digitale Signatur beim Authentifizieren von Meldungen, die von Message Queuing, Version 1.0 gesendet wurden. In den meisten Fällen generiert Message Queuing und legt die <xref:System.Messaging.Message.DigitalSignature%2A> Eigenschaft, wenn die sendende Anwendung Authentifizierung anfordert. Die empfangende Anwendung verwendet diese Eigenschaft, um die digitale Signatur der Nachricht abzurufen.  
  
 Können Sie nur die <xref:System.Messaging.Message.DigitalSignature%2A> Eigenschaft, wenn Message Queuing, Version 2.0 ausgeführt wird. Wenn Authentifizierung anfordert, muss die sendende Anwendung Version 1.0-Message Queuing-Signaturen angeben. Wenn eine Signatur für die Message Queuing-Version 2.0 von die sendende Anwendung gesendet werden, enthält diese Eigenschaft einen Puffer von 4 Bytes, mit dem Wert 0.  
  
 Die <xref:System.Messaging.Message.DigitalSignature%2A> Eigenschaft zusammen mit den <xref:System.Messaging.Message.SenderCertificate%2A> -Eigenschaft wird auch von Connectoranwendungen verwendet, wenn eine Nachricht gesendet wird. In diesem Szenario wird die Connector-Anwendung – anstatt die Message Queuing, generiert die digitale Signatur, die für das Zertifikat des Benutzers senden der Nachricht basieren.  
  
 Die <xref:System.Messaging.Message.DigitalSignature%2A> Eigenschaft verfügt über eine maximale Größe von 256.  
  
 Beim Festlegen der <xref:System.Messaging.Message.DigitalSignature%2A> -Eigenschaft, müssen Sie auch Festlegen der <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaft. Wenn eine Nachricht gesendet wird, Message Queuing ignoriert den <xref:System.Messaging.Message.DigitalSignature%2A> Eigenschaft Wenn die <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaft nicht festgelegt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.DigitalSignature" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.Message.DigitalSignature" />-Eigenschaft ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionAlgorithm : System.Messaging.EncryptionAlgorithm with get, set" Usage="System.Messaging.Message.EncryptionAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Verschlüsselungsalgorithmus ab, der zum Verschlüsseln des Meldungstextes einer privaten Meldung verwendet wird, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.EncryptionAlgorithm" />-Enumerationswerte. Der Standardwert ist <see langword="RC2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Nachricht privat ist (verschlüsselt), wird sie verschlüsselt, bevor sie gesendet und beim Empfang entschlüsselt wird. Die <xref:System.Messaging.Message.EncryptionAlgorithm%2A> Eigenschaft gibt an, den Verschlüsselungsalgorithmus an dem der Nachrichtentext einer privaten Nachricht verschlüsselt.  
  
 Eine Warteschlange kann erfordern, dass eingehende Nachrichten verschlüsselt werden. Wenn eine Anwendung sendet eine Nachricht für nicht verschlüsselte (privaten) an eine Warteschlange, die nur private Nachrichten akzeptiert werden, oder wenn sie eine private Nachricht an eine Warteschlange sendet, die nur nicht Private Nachrichten akzeptiert, lehnt die Nachricht von die Warteschlange ab. Die sendende Anwendung kann anfordern, eine negative Bestätigung-Nachricht in einem solchen Fall zurückgegeben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.EncryptionAlgorithm" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Extension : byte[] with get, set" Usage="System.Messaging.Message.Extension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft weitere anwendungsspezifische, der Nachricht zugeordnete Informationen ab oder legt diese fest.</summary>
        <value>Ein Bytearray, das anwendungsspezifische, der Meldung zugeordnete Informationen bereitstellt. Der Standardwert ist ein Array der Länge 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.Extension%2A> Eigenschaft enthält anwendungsspezifische Informationen, z. B. ein großes binäres Objekt, das der Meldung zugeordnet ist. Es ist die Verantwortung für die empfangende Anwendung zum Interpretieren des Inhalts von der <xref:System.Messaging.Message.Extension%2A> Eigenschaft.  
  
 Wenn möglich, sollte Sie Nachrichtendaten in enthalten die <xref:System.Messaging.Message.Body%2A> -Eigenschaft der Nachricht statt der <xref:System.Messaging.Message.Extension%2A> Eigenschaft.  
  
 Verwenden Sie bei der Arbeit mit fremde Warteschlangen die <xref:System.Messaging.Message.Extension%2A> Eigenschaft angeben, Message Queuing-Nachrichteneigenschaften, die nicht vorhanden sind.  
  
 Eine fremde sind Warteschlangen nicht von Microsoft Message Queuing. Message Queuing kommuniziert mit diesen Warteschlangen über einen Connector-Anwendung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Extension" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.Message.Extension" />-Eigenschaft ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.Message.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Formatierer ab, der zum Serialisieren und Deserialisieren eines Objekts in bzw. aus dem Nachrichtenkörper verwendet wird.</summary>
        <value>Der <see cref="T:System.Messaging.IMessageFormatter" />, der den Stream erstellt, der in den Meldungstext geschrieben oder aus diesem gelesen werden soll. Der Standardwert ist <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Messaging.Message.Formatter%2A> Eigenschaft, die beim Lesen und Schreiben einer Nachricht. Wenn eine Nachricht an die Warteschlange gesendet wird, serialisiert der Formatierer den <xref:System.Messaging.Message.Body%2A> Eigenschaft in einen Stream, der an die Meldungswarteschlange gesendet werden kann. Beim Lesen aus einer Warteschlange deserialisiert das Formatierungsprogramm die Nachrichtendaten in das <xref:System.Messaging.Message.Body%2A> Eigenschaft.  
  
 Es sei denn, Sie direkt auf den Inhalt der Nachricht schreiben die <xref:System.Messaging.Message.BodyStream%2A> Eigenschaftensatz, der <xref:System.Messaging.Message.Formatter%2A> Eigenschaft vor dem Senden der Nachricht. Wenn die <xref:System.Messaging.MessageQueue.Send%2A> Methode wird aufgerufen, auf die <xref:System.Messaging.MessageQueue> Instanz, die Text serialisiert wird, mithilfe des Formatierers in enthaltenen der <xref:System.Messaging.Message.Formatter%2A> Eigenschaft. Wenn Sie die Nachricht senden, ohne einen Wert für die <xref:System.Messaging.Message.Formatter%2A> -Eigenschaft der Standardformatierer <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> lose verknüpft, daher es nicht notwendig ist, das gleiche Objekt, das Absender und Empfänger geben Sie bei diesem Format haben. Die <xref:System.Messaging.ActiveXMessageFormatter> und <xref:System.Messaging.BinaryMessageFormatter> serialisieren Sie die Daten in eine binäre Darstellung. Die <xref:System.Messaging.ActiveXMessageFormatter> wird beim Senden oder Empfangen von COM-Komponenten verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, Formatieren eines Nachrichtentexts mit <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, Formatieren eines Nachrichtentexts mit <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.Message.Formatter" />-Eigenschaft ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Messaging.HashAlgorithm with get, set" Usage="System.Messaging.Message.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zur Authentifizierung oder zur Erzeugung der digitalen Signatur einer Meldung von Message Queuing verwendeten Hashalgorithmus ab oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.HashAlgorithm" />-Enumerationswerte. Der Standardwert für Windows XP lautet <see langword="SHA" />. Andernfalls ist <see langword="MD5" /> der Standardwert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auf dem Quellcomputer verwendet Message Queuing-Hashalgorithmus beim Erstellen einer digitalen Signatur für eine Nachricht. Das Ziel-Warteschlangen-Manager verwendet denselben Hashalgorithmus klicken Sie dann zur Authentifizierung der Meldung, wenn sie empfangen wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.HashAlgorithm" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : string" Usage="System.Messaging.Message.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die ID der Nachricht ab.</summary>
        <value>Die eindeutige Meldungs-ID, die von Message Queuing generiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing generiert eine Nachrichten-ID auf, wenn die Nachricht gesendet wird. Der Bezeichner besteht aus 20 Bytes und enthält zwei Elemente: der Computer <xref:System.Guid> des sendenden Computers und einen eindeutigen Bezeichner für die Nachricht auf dem Computer. Die Kombination beider Elemente liefert eine im Netzwerk eindeutige Nachrichten-ID.  
  
 Message Queuing generiert für alle Nachrichten, einschließlich Bestätigungs- und Berichtsnachrichten Nachrichten. Eine Bestätigungsnachricht wird von Message Queuing in der Regel als Reaktion auf den Empfang oder die Unzustellbarkeit einer ursprünglichen, gesendete Nachricht gesendet. Finden Sie die <xref:System.Messaging.Message.Id%2A> Eigenschaftswert, der die ursprüngliche Nachricht die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft eine Bestätigungsnachricht.  
  
 Sie können auch die <xref:System.Messaging.Message.Id%2A> Eigenschaft beim Senden einer Antwort an eine Antwortwarteschlange. Um den Bezeichner der ursprünglichen Nachricht in einer Antwortnachricht einzubeziehen, legen die <xref:System.Messaging.Message.CorrelationId%2A> -Eigenschaft der Antwortnachricht als auf die <xref:System.Messaging.Message.Id%2A> -Eigenschaft der ursprünglichen Nachricht. Die Anwendung, liest die Response-Nachricht kann Klicken Sie dann die Korrelations-ID der Antwortnachricht verwenden, um die ursprüngliche Nachricht zu identifizieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht mit einer Bestellung in und aus einer Warteschlange. Eine positive Bestätigung sie ausdrücklich angefordert, wenn die ursprüngliche Nachricht erreicht wurde oder wird aus der Warteschlange abgerufen.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.Id" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.Message.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass kein Timeout vorhanden ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> und <xref:System.Messaging.Message.TimeToReachQueue%2A> muss einen Wert, einen Timeout angibt. Für die ehemalige, ist das Timeout für die maximale Zeitspanne für eine Nachricht aus der Warteschlange empfangen werden. In letzterem Fall ist das Timeout für die zulässige Zeit für eine Nachricht an das Erreichen der Warteschlange. In beiden Fällen können Sie das Timeout als eine Anzahl von Sekunden angeben oder verwenden <xref:System.Messaging.Message.InfiniteTimeout> um anzugeben, dass kein Timeout vorhanden ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Messaging.Message.InfiniteTimeout> Feld.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFirstInTransaction : bool" Usage="System.Messaging.Message.IsFirstInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Meldung als erste Meldung in einer Transaktion gesendet wurde.</summary>
        <value>
          <see langword="true" />, wenn die Meldung als erste Meldung in einer Transaktion gesendet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Empfangen von Anwendungen verwenden die <xref:System.Messaging.Message.IsFirstInTransaction%2A> Eigenschaft, um sicherzustellen, dass eine Nachricht die erste Nachricht in einer einzelnen Transaktion mit einer einzelnen Warteschlange gesendet wurde.  
  
 Diese Eigenschaft ist nur mit Message Queuing-Version 2.0 und höher verfügbar.  
  
 Um Transaktionsgrenzen zu überprüfen, können Sie die <xref:System.Messaging.Message.IsFirstInTransaction%2A> Eigenschaft zusammen mit anderen zwei Eigenschaften: <xref:System.Messaging.Message.IsLastInTransaction%2A> und <xref:System.Messaging.Message.TransactionId%2A>. Verwenden Sie Ersteres, um zu überprüfen, ob eine Meldung als letzte Meldung in der Transaktion gesendet wurde, und verwenden Sie die zweite, um den Bezeichner der Transaktion abzurufen.  
  
 Wenn nur eine Nachricht in einer Transaktion gesendet wird die <xref:System.Messaging.Message.IsFirstInTransaction%2A> und <xref:System.Messaging.Message.IsLastInTransaction%2A> Eigenschaften auf festlegen `true`.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert von der Nachricht <xref:System.Messaging.Message.IsFirstInTransaction%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.IsFirstInTransaction" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLastInTransaction : bool" Usage="System.Messaging.Message.IsLastInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Meldung als letzte Meldung in einer Transaktion gesendet wurde.</summary>
        <value>
          <see langword="true" />, wenn die Meldung als letzte Meldung in einer Transaktion gesendet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Empfangen von Anwendungen verwenden die <xref:System.Messaging.Message.IsLastInTransaction%2A> Eigenschaft, um sicherzustellen, dass eine Meldung als letzte Meldung in einer einzelnen Transaktion mit einer einzelnen Warteschlange gesendet wurde.  
  
 Diese Eigenschaft ist nur mit Message Queuing-Version 2.0 und höher verfügbar.  
  
 Um Transaktionsgrenzen zu überprüfen, können Sie die <xref:System.Messaging.Message.IsLastInTransaction%2A> Eigenschaft zusammen mit anderen zwei Eigenschaften: <xref:System.Messaging.Message.IsFirstInTransaction%2A> und <xref:System.Messaging.Message.TransactionId%2A>. Verwenden Sie Ersteres, um zu überprüfen, ob eine Nachricht die erste Nachricht, die innerhalb einer Transaktion gesendet wurde, und verwenden Sie die zweite, um den Bezeichner der Transaktion abzurufen.  
  
 Wenn nur eine Nachricht in einer Transaktion gesendet wird die <xref:System.Messaging.Message.IsFirstInTransaction%2A> und <xref:System.Messaging.Message.IsLastInTransaction%2A> Eigenschaften auf festlegen `true`.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert von der Nachricht <xref:System.Messaging.Message.IsLastInTransaction%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.IsLastInTransaction" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.Message.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine von der Anwendung definierte Unicode-Zeichenfolge ab, die die Nachricht beschreibt, oder legt diese fest.</summary>
        <value>Die Meldungsbezeichnung. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können eine Nachrichtenbezeichnung für mehrere Zwecke verwenden. Die Bezeichnung einer Nachricht kann beispielsweise angezeigt oder für die Verarbeitung einer von der Bezeichnung abhängigen Nachrichtenauswahl verwendet werden. Die Bezeichnung muss nicht über Nachrichten hinweg eindeutig sein.  
  
 Bezeichnungen für Nachrichtenwarteschlangen und Nachrichten sind Werte, die von der Anwendung definiert werden und die Identifikation einer Warteschlange oder Nachricht über eine Textbeschreibung ermöglichen. Es ist die Verantwortung für die Anwendung auf den Inhalt der Bezeichnung interpretiert, in denen keine systeminterne Bedeutung für die Message Queuing-Anwendung haben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert für einer Nachricht <xref:System.Messaging.Message.Label%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Label" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LookupId : int64" Usage="System.Messaging.Message.LookupId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eingeführt in MSMQ 3.0. Ruft den Suchbezeichner der Meldung ab.</summary>
        <value>Der von Message Queuing generierte Suchbezeichner der Meldung ist für die Warteschlange eindeutig, in der sich die Meldung befindet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft bietet schreibgeschützten Zugriff auf Nachschlage-ID der Nachricht. Der Nachschlage-ID, eingeführt in MSMQ 3.0 ist ein 64-Bit-Bezeichner, der vom Message Queuing generiert und auf jede Nachricht zugewiesen wird, wenn die Nachricht in der Warteschlange platziert wird. Die Nachschlage-ID ist nicht identisch mit der Nachrichten-ID, die generiert wird, wenn die Nachricht gesendet wird.  
  
 Message Queuing generiert eine Nachschlage-ID für alle Nachrichten, die in einer beliebigen Warteschlange, einschließlich der Anwendung generierte Ziel, Verwaltung und Berichtswarteschlangen sowie vom System generierte Journal, unzustellbar, Connector und ausgehenden Warteschlangen platziert werden. Das heißt, schließt dies sowohl von sendenden Anwendungen und von Message Queuing-Nachrichten. Die Nachschlage-ID ist eindeutig, in die Warteschlange und hat keine Bedeutung, außerhalb der Warteschlange.  
  
 Wenn eine Nachricht an verschiedene Zielwarteschlangen gesendet wird oder wenn eine Kopie einer Nachricht in einem Computerjournal oder Warteschlangenjournals gespeichert ist, wird jede Kopie der Nachricht eigene Nachschlage-ID haben, wenn sie in der entsprechenden Warteschlange platziert wird.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft kann nur für Nachrichten, die aus einer Warteschlange abgerufene gelesen werden.  
  
 Eine Nachschlage-ID wird verwendet, um eine bestimmte Nachricht in der Warteschlange zu lesen. Nach der Nachschlage-ID einer Nachricht, kann die empfangende Anwendung durch Aufrufen der <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> oder <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> Funktion, die direkt an die Nachricht und einsehen oder Abrufen aus der Warteschlange, im Gegensatz zum Cursor, die am Anfang der Warteschlange beginnen muss und Navigieren Sie zum Ende der Warteschlange,  
  
 Erhalten die Lookup-IDs der Nachrichten in der Warteschlange liegt in der Verantwortung der Anwendung. Eine Möglichkeit zum Abrufen der Lookup-Bezeichner ist, erstellen Sie einen Trigger für die Zielwarteschlange, die eine Komponente aufruft, die die IDs der einzelnen Nachrichten speichert, wie sie in der Warteschlange platziert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.LookupId" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageType : System.Messaging.MessageType" Usage="System.Messaging.Message.MessageType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Nachrichtentyp ab: <see langword="Normal" />, <see langword="Acknowledgment" /> oder <see langword="Report" />.</summary>
        <value>Einer der <see cref="P:System.Messaging.Message.MessageType" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing wird diese Eigenschaft in der Regel, wenn er die Nachricht sendet. Eine Message Queuing-Nachricht kann als einer der folgenden Typen definiert sein:  
  
-   `Normal`, die wird entweder eine typische Nachricht gesendet, von einer Anwendung an eine Warteschlange oder eine Antwortnachricht an die sendende Anwendung zurückgegeben.  
  
-   `Acknowledgement`, die Message Queuing generiert, wenn der sendenden Anwendung angefordert. Message Queuing kann positive oder negative Nachrichten erzeugen und hierdurch anzeigen, ob die ursprüngliche Nachricht empfangen oder gelesen wurde. Message Queuing sendet die entsprechende Bestätigungsnachricht an die von der sendenden Anwendung festgelegte Verwaltungswarteschlange zurück.  
  
-   `Report`, die Message Queuing generiert, wenn an der Quelle Warteschlangen-Manager eine Berichtswarteschlange definiert ist. Wenn die Verfolgung aktiviert ist, sendet Message Queuing eine Berichtsnachricht an die Message Queuing-Berichtswarteschlange, sobald die ursprüngliche Nachricht von einem Message Queuing-Server empfangen oder weitergeleitet wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert von der Nachricht <xref:System.Messaging.Message.MessageType%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.MessageType" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Messaging.MessagePriority with get, set" Usage="System.Messaging.Message.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Nachrichtenpriorität ab, die die Position der Nachricht in der Warteschlange bestimmt, oder legt diese fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.MessagePriority" />-Enumerationswerte, die die Prioritätsebenen für nicht transaktionale Meldungen darstellen. Der Standardwert ist <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.Priority%2A> Eigenschaft beeinflusst die Behandlung Message Queuing die Meldung während des Routings und es das Ziel erreicht hat. Nachrichten höherer Priorität werden beim Routing bevorzugt und gegen Anfang der Zielwarteschlange eingefügt. Nachrichten mit der gleichen Priorität werden entsprechend ihrer Ankunftszeit in der Warteschlange platziert.  
  
 Sie können nur für nicht transaktionale Nachrichten eine sinnvolle Priorität festlegen. Message Queuing wird automatisch die Priorität von Transaktionsnachrichten an `Lowest`, wodurch Transaktionsnachricht Priorität ignoriert werden soll.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird zwei Nachrichten unterschiedliche Prioritäten an die Warteschlange gesendet und anschließend abgerufen.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Priority" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Recoverable : bool with get, set" Usage="System.Messaging.Message.Recoverable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Zustellung einer Meldung im Falle eines Computerfehlers oder Netzwerkproblems sichergestellt ist, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die Übermittlung der Meldung durch Speichern auf der Festplatte während des Sendens sichergestellt wird, <see langword="false" />, wenn die Übermittlung nicht sichergestellt wird. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.Recoverable%2A> Eigenschaft gibt an, ob die Übermittlung einer Nachricht garantiert – selbst wenn ein Computerausfall, solange die Nachricht an die Zielwarteschlange ist.  
  
 Wenn Übermittlung einer Nachricht garantiert ist, wird die Nachricht lokal bei jedem Schritt entlang der Route gespeichert, bis die Nachricht erfolgreich an den nächsten Computer weitergeleitet wird. Festlegen der <xref:System.Messaging.Message.Recoverable%2A> Eigenschaft `true` kann der Durchsatz beeinträchtigt.  
  
 Wenn die Nachricht auf transaktional festgelegt ist, die Nachricht automatisch als behebbar ist, unabhängig vom Wert des behandelt Message Queuing den <xref:System.Messaging.Message.Recoverable%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert für einer Nachricht <xref:System.Messaging.Message.Recoverable%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Recoverable" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.ResponseQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Warteschlange ab, die von einer Anwendung generierte Antwortnachrichten empfängt, oder legt diese fest.</summary>
        <value>Die <see cref="T:System.Messaging.MessageQueue" />, an die die von einer Anwendung generierten Antwortmeldungen zurückgesendet werden. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.ResponseQueue%2A> Eigenschaft kennzeichnet die Warteschlange, die Anwendung generierte Antwortnachrichten empfängt, die die empfangende Anwendung an die sendende Anwendung zurückgibt. Die sendende Anwendung gibt die Antwortwarteschlangen beim Senden von Nachrichten an. Jede verfügbare Warteschlange kann als Antwortwarteschlange ausgewählt werden.  
  
 An die Antwortwarteschlange zurückgesendete Nachrichten sind anwendungsspezifisch. Die Anwendung muss sowohl den Inhalt der Nachrichten als auch die beim Empfang durchzuführenden Aktionen festlegen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert für einer Nachricht <xref:System.Messaging.Message.ResponseQueue%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.ResponseQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityContext : System.Messaging.SecurityContext with get, set" Usage="System.Messaging.Message.SecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Sicherheitskontext für eine Meldung ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Messaging.SecurityContext" />-Objekt, das den Sicherheitskontext für eine Meldung enthält, wenn die Eigenschaft zuvor festgelegt wurde, andernfalls NULL.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SenderCertificate : byte[] with get, set" Usage="System.Messaging.Message.SenderCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das zum Authentifizieren von Meldungen verwendete Sicherheitszertifikat ab oder legt dieses fest.</summary>
        <value>Ein Bytearray, das das Sicherheitszertifikat darstellt, anhand dessen Message Queuing den Sender einer Meldung überprüft. Der Standardwert ist ein Array der Länge 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die empfangende Anwendung verwendet die <xref:System.Messaging.Message.SenderCertificate%2A> Eigenschaft, wenn die Nachricht über ein externes Sicherheitszertifikat enthält.  
  
 Message Queuing kann einer Nachricht mit einem internen oder externen Sicherheitszertifikat authentifizieren. Message Queuing bietet interner Zertifikate, die verwendet werden, um die Nachrichtenintegrität sicherzustellen. Eine Zertifizierungsstelle stellt ein externes Zertifikat, das Sie über zugreifen können die <xref:System.Messaging.Message.SenderCertificate%2A> -Eigenschaft der Nachricht. Zusätzlich zu Message Queuing zum Authentifizieren der Nachricht ermöglicht wird, ermöglicht ein externes Zertifikat, um zu den Absender überprüfen die empfangende Anwendung. Ein internes Zertifikat verfügt über keine verwendbaren Wert an eine empfangende Anwendung.  
  
 Ein externes Zertifikat muss mit dem Verzeichnisdienst von Message Queuing-System registriert werden. Ein externes Zertifikat enthält Informationen zu der Zertifizierungsstelle, die dem Zertifikatsbenutzer, die Gültigkeitsdauer des Zertifikats, den öffentlichen Schlüssel des Benutzers Zertifikat, und der Zertifizierungsstelle der Signatur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.SenderCertificate" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderId : byte[]" Usage="System.Messaging.Message.SenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die ID des sendenden Benutzers ab.</summary>
        <value>Ein Bytearray, das den Benutzer identifiziert. Der empfangende Warteschlangenmanager überprüft bei der Authentifizierung einer Meldung den Sender und seine Zugriffsrechte für die Warteschlange anhand der ID.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Messaging.Message.AttachSenderId%2A> -Eigenschaft ist `false`, die Sender-ID angegeben, der <xref:System.Messaging.Message.SenderId%2A> Eigenschaft ist nicht an die Nachricht angefügt, wenn diese gesendet werden. Dies zeigt Message Queuing, dass der Absender nicht überprüft werden soll, wenn er die Nachricht an die Zielwarteschlange sendet. Wenn die <xref:System.Messaging.Message.AttachSenderId%2A> Eigenschaft `true`, <xref:System.Messaging.Message.SenderId%2A> -Eigenschaftswert ist trustworthy nur dann, wenn die Nachricht authentifiziert wurde. Verwenden der <xref:System.Messaging.Message.Authenticated%2A> Eigenschaft in Verbindung mit der <xref:System.Messaging.Message.SenderId%2A> Eigenschaft, um die Zugriffsrechte des Absenders zu überprüfen.  
  
 Eine Connector-Anwendung ist eine Anwendung, die einen Connectorserver verwendet, um die Kommunikation zwischen Message Queuing und andere warteschlangensysteme bereitstellen. Message Queuing erfordert Connectoranwendungen Absenderidentifikation bereitstellen. Sie müssen festlegen, die <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaft beim Senden einer Nachricht über einen Connector-Anwendung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.SenderId" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderVersion : int64" Usage="System.Messaging.Message.SenderVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Version von Message Queuing ab, mit der die Meldung gesendet wurde.</summary>
        <value>Die Version von Message Queuing, mit der die Meldung gesendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.SenderVersion%2A> Eigenschaft ist wichtig für bestimmte Funktionen. Z. B. transaktionsverarbeitung wird nur von Message Queuing 2.0 und höher unterstützt und digitale Signaturen werden verwendet, um die Authentifizierung von Nachrichten von MSMQ 1.0 an.  
  
 Im sendenden Warteschlangen-Manager wird die <xref:System.Messaging.Message.SenderVersion%2A> Eigenschaft, wenn die Nachricht gesendet wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert von der Nachricht <xref:System.Messaging.Message.SenderVersion%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.SenderVersion" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.SentTime : DateTime" Usage="System.Messaging.Message.SentTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Datum und Uhrzeit auf dem sendenden Computer ab, zu der die Nachricht vom Quellwarteschlangen-Manager gesendet wurde.</summary>
        <value>Die <see cref="T:System.DateTime" /> stellt den Zeitpunkt dar, zu dem die Meldung gesendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.SentTime%2A> Eigenschaft angepasst an die lokale Zeit des Computers, auf dem diese Instanz von der <xref:System.Messaging.Message> Klasse erstellt wurde. Diese Zeitzone kann von der die Quelle und Ziel-Warteschlangen unterscheiden.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert von der Nachricht <xref:System.Messaging.Message.SentTime%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.SentTime" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceMachine : string" Usage="System.Messaging.Message.SourceMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Computer ab, von dem die Meldung ausging.</summary>
        <value>Der Name des Computers, von dem die Meldung gesendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Format der <xref:System.Messaging.Message.SourceMachine%2A> Eigenschaft umfasst nicht die umgekehrten Schrägstriche (\\\\). Z. B. `myServer` ist ein gültiger <xref:System.Messaging.Message.SourceMachine%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert von der Nachricht <xref:System.Messaging.Message.SourceMachine%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.SourceMachine" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Es konnte nicht auf die Computerinformationen oder den Verzeichnisdienst zugegriffen werden.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToBeReceived : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToBeReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeitbegrenzung für den Empfang der Meldung aus der Zielwarteschlange ab oder legt diese fest.</summary>
        <value>Die für eine gesendete Meldung vorgegebene Gesamtzeit bis zum Empfang aus der Zielwarteschlange. Der Standardwert ist <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschaft gibt an, die Gesamtzeit für eine gesendete Nachricht aus der Zielwarteschlange empfangen werden kann. Das Zeitlimit umfasst die Zeit an die Zielwarteschlange und die Zeit in der Warteschlange darauf warten, bevor die Nachricht empfangen wird.  
  
> [!CAUTION]
>  Wenn abhängige-Clientcomputern verwenden möchten, achten Sie darauf, dass die Uhr auf dem Clientcomputer mit der Uhr auf dem Server synchronisiert wird, die Message Queuing ausgeführt wird. Andernfalls kann zu unvorhersehbarem Verhalten führen, beim Senden einer Nachricht, deren <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschaft ist nicht <xref:System.Messaging.Message.InfiniteTimeout>.  
  
 Wenn das Zeitintervall, wird angegeben die <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschaft abläuft, bevor die Nachricht aus der Warteschlange entfernt wird, die Message Queuing, verwirft die Nachricht in eine von zwei Arten. Wenn die <xref:System.Messaging.Message.UseDeadLetterQueue%2A>-Eigenschaft auf `true` festgelegt ist, wird die Nachricht an die Dead Letter-Warteschlange gesendet. Wenn <xref:System.Messaging.Message.UseDeadLetterQueue%2A> ist `false`, die Nachricht wird ignoriert.  
  
 Sie können festlegen, dass der Nachricht <xref:System.Messaging.Message.AcknowledgeType%2A> Eigenschaft, um anzufordern, dass Message Queuing eine negative Bestätigung-Nachricht senden an die sendende Anwendung zurück, wenn die Nachricht vor Ablauf des Timers nicht abgerufen.  
  
 Wenn der Wert, wird angegeben die <xref:System.Messaging.Message.TimeToBeReceived%2A> -Eigenschaft ist kleiner als der Wert von der <xref:System.Messaging.Message.TimeToReachQueue%2A> Eigenschaft <xref:System.Messaging.Message.TimeToBeReceived%2A> hat Vorrang vor.  
  
 Wenn mehrere Nachrichten in einer einzelnen Transaktion gesendet werden, verwendet Message Queuing den <xref:System.Messaging.Message.TimeToBeReceived%2A> -Eigenschaft der ersten Nachricht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert für einer Nachricht <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.TimeToBeReceived" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">Der für <see cref="P:System.Messaging.Message.TimeToBeReceived" /> angegebene Wert ist ungültig.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToReachQueue : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToReachQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeitbegrenzung der Nachricht für das Erreichen der Warteschlange ab oder legt diese fest.</summary>
        <value>Die maximale Dauer zwischen dem Absenden der Meldung und dem Erreichen der Zielwarteschlange. Der Standardwert ist <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Zeitintervall, wird angegeben die <xref:System.Messaging.Message.TimeToReachQueue%2A> Eigenschaft abläuft, bevor die Nachricht ihr Ziel erreicht, Message Queuing, verwirft die Nachricht in eine von zwei Arten. Wenn die <xref:System.Messaging.Message.UseDeadLetterQueue%2A>-Eigenschaft auf `true` festgelegt ist, wird die Nachricht an die Dead Letter-Warteschlange gesendet. Wenn <xref:System.Messaging.Message.UseDeadLetterQueue%2A> ist `false`, die Nachricht wird ignoriert.  
  
 Sie können festlegen, dass seine Nachricht <xref:System.Messaging.Message.AcknowledgeType%2A> Eigenschaft, um anzufordern, dass Message Queuing Senden einer negativen Bestätigung-Nachricht an die sendende Anwendung zurück, wenn Sie die Nachricht nicht vor Ablauf des Timers.  
  
 Wenn die <xref:System.Messaging.Message.TimeToReachQueue%2A> Eigenschaft auf 0 Sekunden festgelegt ist, Message Queuing zum Senden der Nachricht an das Ziel einmal versucht, wenn die Nachricht die Warteschlange wartet. Wenn die Warteschlange lokal ist, erreicht die Nachricht immer es.  
  
 Wenn der Wert, wird angegeben die <xref:System.Messaging.Message.TimeToReachQueue%2A> -Eigenschaft ist größer als der Wert von der <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschaft <xref:System.Messaging.Message.TimeToBeReceived%2A> hat Vorrang vor.  
  
 Wenn mehrere Nachrichten in einer einzelnen Transaktion gesendet werden, verwendet Message Queuing den <xref:System.Messaging.Message.TimeToReachQueue%2A> -Eigenschaft der ersten Nachricht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert für einer Nachricht <xref:System.Messaging.Message.TimeToReachQueue%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.TimeToReachQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">Der für <see cref="P:System.Messaging.Message.TimeToReachQueue" /> angegebene Wert ist ungültig. Eventuell wurde ein negativer Wert angegeben.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionId : string" Usage="System.Messaging.Message.TransactionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die ID der Transaktion ab, in der die Meldung gesendet wurde.</summary>
        <value>Der Bezeichner der der Meldung zugeordneten Transaktion.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Empfangen von Anwendungen verwenden die <xref:System.Messaging.Message.TransactionId%2A> Eigenschaft, um sicherzustellen, dass eine Nachricht als Teil einer bestimmten Transaktion gesendet wurde. Die Transaktions-ID enthält den Bezeichner des sendenden Computers (erste 16 Bits) gefolgt von einem 4-Byte-Transaktionssequenznummer.  
  
 Diese Eigenschaft ist nur für Message Queuing-Version 2.0 und höher verfügbar.  
  
 Transaktions-IDs sind nicht unbedingt eindeutig sein, da transaktionssequenznummern nicht dauerhaft gespeichert werden, und sie dann wieder auf 2 startet <sup>20</sup>. Message Queuing garantiert nur an, dass aufeinander folgende Transaktionen verschiedene transaktionssequenznummern hat.  
  
 Können Sie die <xref:System.Messaging.Message.TransactionId%2A> Eigenschaft zusammen mit den <xref:System.Messaging.Message.IsFirstInTransaction%2A> und <xref:System.Messaging.Message.IsLastInTransaction%2A> Eigenschaften, die Transaktionsgrenzen.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert von der Nachricht <xref:System.Messaging.Message.TransactionId%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.TransactionId" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionStatusQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.TransactionStatusQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Transaktionsstatus-Warteschlange auf dem Quellcomputer ab.</summary>
        <value>Die Transaktionsstatus-Warteschlange auf dem Quellcomputer, die für das Senden von Bestätigungsmeldungen an die sendende Anwendung verwendet wird. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.TransactionStatusQueue%2A> Eigenschaft identifiziert, die transaktionale Warteschlange auf dem Quellcomputer, die Read-Empfangsbestätigungen von Connectoranwendungen empfängt. Message Queuing legt die Eigenschaft fest, und Connectoranwendungen verwenden Sie die Eigenschaft beim Abrufen von transaktionalen Übermittlung an fremde Warteschlangen Nachrichten.  
  
 Eine fremde sind Warteschlangen nicht von Microsoft Message Queuing. Message Queuing kommuniziert mit diesen Warteschlangen über einen Connector-Anwendung.  
  
 Die Connector-Anwendung kann die Transaktionsstatus-Warteschlange zum Senden von bestätigungsmeldungen an die sendende Anwendung verwenden. Die Transaktionsstatus-Warteschlange sollten diese Bestätigungen erhalten, selbst wenn die sendende Anwendung keine andere Bestätigungen anfordert.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert von der Nachricht <xref:System.Messaging.Message.TransactionStatusQueue%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder -  
Die <see cref="P:System.Messaging.Message.TransactionStatusQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseAuthentication : bool with get, set" Usage="System.Messaging.Message.UseAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Meldung vor dem Absenden authentifiziert wurde oder authentifiziert werden muss, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die sendende Anwendung die Authentifizierung der Meldung angefordert hat, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.UseAuthentication%2A> Eigenschaft gibt an, ob die Nachricht authentifiziert werden muss. Wenn die sendende Anwendung Authentifizierung anfordert, Message Queuing eine digitale Signatur erstellt und wird verwendet, die Nachricht signieren, wenn diese gesendet werden, und Authentifizieren bei Empfang der Nachricht.  
  
 Wenn <xref:System.Messaging.Message.UseAuthentication%2A> ist `false` und eine Nachricht an eine Warteschlange, die nur authentifizierte Meldungen akzeptiert, wird beim Erreichen der Warteschlange die Nachricht abgelehnt.  
  
 Sie können nicht feststellen, ob eine Meldung Fehler bei der Authentifizierung anhand der Eigenschaften. Message Queuing werden solche Nachrichten verworfen, bevor sie an die Warteschlange übermittelt werden. Allerdings können Sie anfordern, dass eine Bestätigungsnachricht gesendet werden, wenn ein Zustellungsfehler verhindert, dass eine Nachricht in der Warteschlange eingeht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.UseAuthentication" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDeadLetterQueue : bool with get, set" Usage="System.Messaging.Message.UseDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine Kopie der nicht zustellbaren Meldung an eine Dead Letter-Warteschlange gesendet werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn bei einem Fehler bei der Meldungsübermittlung eine Kopie der Meldung an die Warteschlange für unzustellbare Nachrichten gesendet werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.UseJournalQueue%2A> und <xref:System.Messaging.Message.UseDeadLetterQueue%2A> Eigenschaften angeben, wie der Message Queuing eine Nachricht nachverfolgt. Wenn <xref:System.Messaging.Message.UseDeadLetterQueue%2A> ist `true`, Unzustellbarkeit (eine nicht transaktionale Nachricht), wird die Nachricht an den nicht transaktionalen Dead Letter-Warteschlange auf dem Computer gesendet werden, die die Nachricht nicht zustellen konnte. Delivery-Fehler konnte von einem Message-Timer abgelaufen ist, z. B. verursacht werden.  
  
 Im Fall der Zustellfehler für eine Transaktionsnachricht sendet der Message Queuing die Nachricht an die Transaktionswarteschlange für unzustellbare Nachrichten, auf dem Quellcomputer in allen Fällen für negative und unsichere.  
  
 Wenn Sie in einer Warteschlange für unzustellbare Nachrichten speichern, sollten Sie durch Löschen die Warteschlange in regelmäßigen Abständen, um Nachrichten zu entfernen, die nicht mehr benötigt werden. Nachrichten in Warteschlangen für unzustellbare Anzahl für das Kontingent für den Computer, in dem sich die Warteschlange befindet. Das Computerkontingent, die vom Administrator festgelegt ist und bezieht sich auf der Größe des zum Speichern von Nachrichten auf dem gesamten Computer, nicht nur in einer einzelnen Warteschlange zugeordnet.  
  
 Sie erstellen keiner Journalwarteschlange oder Dead Letter-Warteschlange. Hierbei handelt es sich um Systemwarteschlangen, die von Message Queuing generiert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert für einer Nachricht <xref:System.Messaging.Message.UseDeadLetterQueue%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.UseDeadLetterQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseEncryption : bool with get, set" Usage="System.Messaging.Message.UseEncryption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Meldung als privat behandelt werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn Message Queuing die Meldung verschlüsseln soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Nachricht privat ist, wird der Textkörper verschlüsselt, bevor es gesendet und entschlüsselt, wenn sie empfangen wird. Um eine private Nachricht zu senden, muss die sendende Anwendung angeben, die Verschlüsselung verwendet werden und, optional den Verschlüsselungsalgorithmus.  
  
 Beim private Nachrichten zu senden, muss Ihre Anwendung nicht zum Durchführen der nachrichtenverschlüsselung. Message Queuing kann den Nachrichtentext für Sie verschlüsseln, wenn die Anwendung Nachrichten in einer Microsoft Windows 2000-Unternehmen, senden, ist der Zugriff auf den Verzeichnisdienst hat. Wenn Sie private Nachrichten zu empfangen, entschlüsselt empfangenden Warteschlangen-Manager immer den Nachrichtentext.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert für einer Nachricht <xref:System.Messaging.Message.UseEncryption%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.UseEncryption" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.Message.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine Kopie der Meldung in einem Journal auf dem sendenden Computer abgelegt werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn nach erfolgreicher Übermittlung vom sendenden Computer an den nächsten Server eine Kopie der Meldung in einem Journal auf dem sendenden Computer abgelegt werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.UseJournalQueue%2A> und <xref:System.Messaging.Message.UseDeadLetterQueue%2A> Eigenschaften angeben, wie der Message Queuing eine Nachricht nachverfolgt. Wenn <xref:System.Messaging.Message.UseJournalQueue%2A> ist `true`, und klicken Sie dann eine Kopie in das Computerjournal auf dem ursprünglichen Computer bei jedem Schritt gehalten wird, dass eine Nachricht übertragen wird.  
  
 Die gesendete Nachricht wird nur in die Journalwarteschlange kopiert, wenn die Zielwarteschlange auf einem Remotecomputer ist. Wenn das Ziel auf dem lokalen Computer ist, wird die Nachricht direkt an die Warteschlange gesendet. Es gibt keine Zwischenschritte Journal erforderlich ist.  
  
 Wenn Sie Nachrichten in eine Journalwarteschlange speichern, deaktivieren Sie die Warteschlange in regelmäßigen Abständen, um Nachrichten zu entfernen, die nicht mehr benötigt werden. Nachrichten, die im Buch.-Warteschlangen-Anzahl für das Kontingent für den Computer, in dem sich die Warteschlange befindet, gespeichert werden. (Das Kontingent des Computers wird vom Administrator festgelegt.)  
  
 Sie erstellen keiner Journalwarteschlange oder Dead Letter-Warteschlange. Hierbei handelt es sich um Systemwarteschlangen, die von Message Queuing generiert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert für einer Nachricht <xref:System.Messaging.Message.UseJournalQueue%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.UseJournalQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTracing : bool with get, set" Usage="System.Messaging.Message.UseTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine Meldung während der Weiterleitung an die Zielwarteschlange verfolgt wird, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn bei jeder Zwischenstation der Originalmeldung bis zum Erreichen der Zielwarteschlange ein Bericht generiert und an die Berichtswarteschlange des Systems gesendet werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.UseTracing%2A> Eigenschaft gibt an, ob die Route einer Nachricht nachverfolgt, wie die Weiterleitung an die Zielwarteschlange verschoben wird. Wenn `true`, jedes Mal, die die Nachricht einen Message Queuing-routing-Server durchläuft eine berichtsnachricht (von Message Queuing generiert) an eine Berichtswarteschlange gesendet. Die Berichtswarteschlange wird vom Quellwarteschlangen-Manager angegeben. Berichtswarteschlangen sind nicht auf Report-Meldungen, die von Message Queuing generierte beschränkt; Ihre Anwendung generierte Nachrichten können auch in Berichtswarteschlangen gesendet werden.  
  
 Verwenden der Ablaufverfolgung umfasst das Einrichten von Active Directory, und geben eine Berichtswarteschlange für die Message Queuing-Organisation. Der Administrator konfiguriert diese Einstellungen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert für einer Nachricht <xref:System.Messaging.Message.UseTracing%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.UseTracing" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>