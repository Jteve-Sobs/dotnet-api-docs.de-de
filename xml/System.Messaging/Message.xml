<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata><Meta Name="ms.openlocfilehash" Value="daa0e77edf7b25392c1fdafe9ec2d03ec85cbf7c" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70492526" /></Metadata><TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Message = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt den Zugriff auf die Eigenschaften bereit, die zur Definition einer Message Queuing-Meldung erforderlich sind.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.Messaging.Message> die-Klasse, um Nachrichten aus einer Warteschlange zu sehen oder zu empfangen oder um beim Senden einer Nachricht an eine Warteschlange eine genaue Kontrolle über die Nachrichten Eigenschaften zu haben.  
  
 <xref:System.Messaging.MessageQueue>verwendet die <xref:System.Messaging.Message> -Klasse, wenn Sie Nachrichten von Warteschlangen empfängt oder empfängt, <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType> da <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType> sowohl die-Methode als auch die <xref:System.Messaging.Message> -Methode eine neue Instanz der-Klasse erstellen und die Eigenschaften der-Instanz festlegen. Die <xref:System.Messaging.Message> schreibgeschützten Eigenschaften der-Klasse gelten für das Abrufen von Nachrichten aus einer Warteschlange, während die Lese-/Schreibeigenschaften für das Senden und Abrufen von Nachrichten gelten. Wenn <xref:System.Messaging.MessageQueue> ein Peer oder eine Nachricht von einer Warteschlange empfängt <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> , bestimmt die-Eigenschaft, welche der Nachrichten Eigenschaften abgerufen werden.  
  
 Mit <xref:System.Messaging.MessageQueue> der- <xref:System.Messaging.MessageQueue.Send%2A> Methode der-Klasse können Sie einen beliebigen Objekttyp für eine Nachricht angeben, die an diese Warteschlange gesendet wird. Sie können die- <xref:System.Messaging.MessageQueue> Eigenschaft der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> -Instanz verwenden, um Einstellungen für generische Meldungen anzugeben, die an die Warteschlange gesendet werden. Zu den Einstellungs Typen zählen Formatierer, Bezeichnung, Verschlüsselung und Authentifizierung. Sie können auch Werte für die entsprechenden <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member angeben, wenn Sie Ihre Messaging Anwendung so koordinieren, dass Sie auf Bestätigungs-und Berichts Nachrichten antwortet. Wenn Sie eine- Instanz verwenden, um eine Nachricht an die Warteschlange zu senden, haben Sie die Flexibilität, auf viele dieser Eigenschaften zuzugreifen und diese zu ändern, entweder für eine einzelne Nachricht oder für Nachrichten Nachrichten. <xref:System.Messaging.Message> <xref:System.Messaging.Message>Eigenschaften haben Vorrang <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>vor.  
  
 Nachrichten Daten werden in der <xref:System.Messaging.Message.Body%2A> -Eigenschaft gespeichert und in geringerem Umfang, der-Eigenschaft und der <xref:System.Messaging.Message.AppSpecific%2A> - <xref:System.Messaging.Message.Extension%2A> Eigenschaft. Wenn Nachrichten Daten verschlüsselt, serialisiert oder deserialisiert werden, wird nur der Inhalt <xref:System.Messaging.Message.Body%2A> der-Eigenschaft beeinflusst.  
  
 Der Inhalt <xref:System.Messaging.Message.Body%2A> der-Eigenschaft wird beim Senden der Nachricht mithilfe der <xref:System.Messaging.Message.Formatter%2A> angegebenen Eigenschaft serialisiert. Der serialisierte Inhalt wird in der <xref:System.Messaging.Message.BodyStream%2A> -Eigenschaft gefunden. Sie können die <xref:System.Messaging.Message.BodyStream%2A> -Eigenschaft auch direkt festlegen, um z. b. eine Datei als Dateninhalt einer Nachricht zu senden. Sie können die- <xref:System.Messaging.Message.Body%2A> Eigenschaft <xref:System.Messaging.Message.Formatter%2A> oder die-Eigenschaft zu einem beliebigen Zeitpunkt vor dem Senden der Nachricht ändern, und die Daten werden entsprechend <xref:System.Messaging.MessageQueue.Send%2A>serialisiert, wenn Sie aufzurufen.  
  
 Die Eigenschaften, die von <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType> der-Eigenschaft definiert werden, gelten nur für nach <xref:System.Messaging.Message>richten, die nicht vom Typ sind. Wenn Sie die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> -Eigenschaft für einen <xref:System.Messaging.MessageQueue>angeben, werden diese Standardeigenschaften von den <xref:System.Messaging.Message> identisch benannten Eigenschaften in einer-Instanz, die an diese Warteschlange gesendet werden, ignoriert.  
  
 Eine Liste der anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.Messaging.Message>finden Sie im <xref:System.Messaging.Message.%23ctor%2A> -Konstruktor.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Nachrichten <xref:System.Messaging.BinaryMessageFormatter>Text mit formatiert wird.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Nachrichten <xref:System.Messaging.XmlMessageFormatter>Text mit formatiert wird.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.Message" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.Message" />-Klasse mit einem leeren Meldungstext.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine neue Instanz <xref:System.Messaging.Message> der-Klasse zu erstellen, die einen leeren Text enthält.  
  
 Geben Sie vor <xref:System.Messaging.Message.Body%2A> dem Senden des <xref:System.Messaging.Message.BodyStream%2A> <xref:System.Messaging.Message> Objekts entweder die-Eigenschaft oder die-Eigenschaft an. Die <xref:System.Messaging.Message.Body%2A> -Eigenschaft kann ein beliebiges Objekt sein, das serialisiert werden kann, z. b. eine Text Zeichenfolge, ein Struktur Objekt, eine Klasseninstanz oder ein eingebettetes Objekt.  
  
 Wenn Sie den Inhalt der Nachricht nicht direkt in die <xref:System.Messaging.Message.BodyStream%2A> -Eigenschaft schreiben, legen Sie die <xref:System.Messaging.Message.Formatter%2A> -Eigenschaft vor dem Senden der Nachricht fest. Der Text wird mit dem <xref:System.Messaging.Message.Formatter%2A> Eigenschafts Wert serialisiert, wenn die <xref:System.Messaging.MessageQueue.Send%2A> -Methode für die <xref:System.Messaging.MessageQueue> -Instanz aufgerufen wird.  
  
 Der <xref:System.Messaging.XmlMessageFormatter> ist lose gekoppelt, sodass es nicht erforderlich ist, bei Verwendung dieses Formats denselben Objekttyp für den Absender und den Empfänger zu verwenden. <xref:System.Messaging.ActiveXMessageFormatter> Und <xref:System.Messaging.BinaryMessageFormatter>  serialisieren die Daten in binäre Darstellung. <xref:System.Messaging.ActiveXMessageFormatter> Wird beim Senden oder empfangen von COM-Komponenten verwendet.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftswerte für <xref:System.Messaging.Message>eine Instanz von angezeigt.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider Version 1,0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Ein Bytearray der Länge 0 (null).|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Ein Bytearray der Länge 0 (null).|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Ein Bytearray der Länge 0 (null).|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Ein Bytearray der Länge 0 (null).|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden zwei Nachrichten mit unterschiedlichen Prioritäten an die Warteschlange gesendet und anschließend abgerufen.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj -&gt; System.Messaging.Message" Usage="new System.Messaging.Message body" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">Das Objekt, das in den Meldungstext serialisiert werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.Message" />-Klasse, wobei das angegebene Objekt mithilfe des <see cref="T:System.Messaging.XmlMessageFormatter" /> in den Meldungstext serialisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine neue Instanz <xref:System.Messaging.Message> der-Klasse zu <xref:System.Messaging.Message.Body%2A> erstellen, die `body` die durch den-Parameter angegebene enthält. Der `body` -Parameter kann ein beliebiges Objekt sein, das serialisiert werden kann, z. b. eine Text Zeichenfolge, ein Struktur Objekt, eine Klasseninstanz oder ein eingebettetes Objekt. Der Text wird mit dem <xref:System.Messaging.XmlMessageFormatter> serialisiert, es sei denn, Sie ändern die <xref:System.Messaging.Message.Formatter%2A> -Eigenschaft, bevor der <xref:System.Messaging.Message> gesendet wird. Wenn Sie die- <xref:System.Messaging.Message.Body%2A> Eigenschaft <xref:System.Messaging.Message.Formatter%2A> oder die-Eigenschaft zu einem <xref:System.Messaging.MessageQueue.Send%2A>beliebigen Zeitpunkt vor dem Aufrufen von ändern, wird die Nachricht entsprechend dem neuen-Eigenschafts Wert serialisiert.  
  
 Der <xref:System.Messaging.XmlMessageFormatter> ist lose gekoppelt, sodass es nicht erforderlich ist, bei Verwendung dieses Formats denselben Objekttyp für den Absender und den Empfänger zu verwenden. <xref:System.Messaging.ActiveXMessageFormatter> Und <xref:System.Messaging.BinaryMessageFormatter>  serialisieren die Daten in binäre Darstellung. <xref:System.Messaging.ActiveXMessageFormatter> Wird beim Senden oder empfangen von COM-Komponenten verwendet.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftswerte für <xref:System.Messaging.Message>eine Instanz von angezeigt.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider Version 1,0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Der `body`-Parameter.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Ein Bytearray der Länge 0 (null).|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Ein Bytearray der Länge 0 (null).|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Ein Bytearray der Länge 0 (null).|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Ein Bytearray der Länge 0 (null).|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine neue Warteschlange erstellt, eine Nachricht gesendet, die eine Bestellung enthält, und dann wird Sie abgerufen.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj * System.Messaging.IMessageFormatter -&gt; System.Messaging.Message" Usage="new System.Messaging.Message (body, formatter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">Das Objekt, das in den Meldungstext serialisiert werden soll.</param>
        <param name="formatter">Der <see cref="T:System.Messaging.IMessageFormatter" /> gibt den Formatierer an, mit dem die Serialisierung in den Meldungstext erfolgen soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.Message" />-Klasse, wobei das angegebene Objekt mithilfe des angegebenen Formatierers in den Meldungstext serialisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine neue Instanz <xref:System.Messaging.Message> der-Klasse zu <xref:System.Messaging.Message.Body%2A> erstellen, die `body` die durch den-Parameter angegebene enthält und eine beliebige gültige Formatierung verwendet, um den Text zu serialisieren. Der `body` -Parameter ist ein beliebiges Objekt, das serialisiert werden kann, z. b. eine Text Zeichenfolge, ein Struktur Objekt, eine Klasseninstanz oder ein eingebettetes Objekt. Wenn Sie die- <xref:System.Messaging.Message.Body%2A> Eigenschaft <xref:System.Messaging.Message.Formatter%2A> oder die-Eigenschaft zu einem <xref:System.Messaging.MessageQueue.Send%2A>beliebigen Zeitpunkt vor dem Aufrufen von ändern, wird die Nachricht entsprechend dem neuen-Eigenschafts Wert serialisiert.  
  
 Der <xref:System.Messaging.XmlMessageFormatter> ist lose gekoppelt, sodass es nicht erforderlich ist, bei Verwendung dieses Formats denselben Objekttyp für den Absender und den Empfänger zu verwenden. <xref:System.Messaging.ActiveXMessageFormatter> Und <xref:System.Messaging.BinaryMessageFormatter>  serialisieren die Daten in binäre Darstellung. <xref:System.Messaging.ActiveXMessageFormatter> Wird beim Senden oder empfangen von COM-Komponenten verwendet.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftswerte für <xref:System.Messaging.Message>eine Instanz von angezeigt.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider Version 1,0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Der `body`-Parameter.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Ein Bytearray der Länge 0 (null).|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Ein Bytearray der Länge 0 (null).|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Ein Bytearray der Länge 0 (null).|  
|<xref:System.Messaging.Message.Formatter%2A>|Der `formatter`-Parameter.|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Ein Bytearray der Länge 0 (null).|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgeType : System.Messaging.AcknowledgeTypes with get, set" Usage="System.Messaging.Message.AcknowledgeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ der Bestätigungsmeldung ab, die an die sendende Anwendung zurückgegeben werden soll, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.AcknowledgeTypes" />-Werte, die sowohl die Typen der Bestätigungsmeldungen darstellen, die das System in die Verwaltungswarteschlange stellt, als auch die Bedingungen, unter denen Bestätigungsmeldungen an die sendende Anwendung zurückgegeben werden. Die Standardeinstellung ist <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.AcknowledgeType%2A> -Eigenschaft gibt den Typ der Bestätigungsnachrichten an, die von der sendenden Anwendung angefordert werden. Legen Sie <xref:System.Messaging.Message.AcknowledgeType%2A> die-Eigenschaft vor dem Senden der Nachricht fest, um Benachrichtigungen über bestimmte Vorkommen anzufordern, z. b. eine Nachricht, die die Ziel Warteschlange erreicht, eine Nachricht, die abgerufen wird, oder ein Timeout, das verhindert, dass eine Nachricht erreicht oder abgerufen wird. die Ziel Warteschlange.  
  
 Message Queuing gibt eine Benachrichtigung zurück, indem Bestätigungsnachrichten an <xref:System.Messaging.Message.AdministrationQueue%2A> die von der ursprünglichen Nachricht angegebene Eigenschaft gesendet werden. Die- <xref:System.Messaging.Message.Acknowledgment%2A> Eigenschaft einer Bestätigungsnachricht gibt den Typ der Bestätigung an, die Sie darstellt. Wenn z. b. eine Bestätigungsnachricht gesendet wurde, weil eine Nachricht das Ziel vor Ablauf des <xref:System.Messaging.Message.TimeToReachQueue%2A> Intervalls nicht erreicht hat, würde die <xref:System.Messaging.Message.Acknowledgment%2A> -Eigenschaft der Bestätigungsnachricht den Wert `ReachQueueTimeout`enthalten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Nachricht gesendet und empfangen, die eine Bestellung zu und aus einer Warteschlange enthält. Insbesondere wird eine positive Bestätigung angefordert, wenn die ursprüngliche Nachricht erreicht oder aus der Warteschlange abgerufen wird.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AcknowledgeType" />-Eigenschaft wird aufgrund eines für die Meldung gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberSignature Language="F#" Value="member this.Acknowledgment : System.Messaging.Acknowledgment" Usage="System.Messaging.Message.Acknowledgment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Klassifikation für die Bestätigung ab, die diese Meldung darstellt.</summary>
        <value>Einer der <see cref="T:System.Messaging.Acknowledgment" />-Enumerationswerte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Nachricht von einer Verwaltungs Warteschlange erhalten, <xref:System.Messaging.Message.Acknowledgment%2A> lesen Sie die-Eigenschaft, um den Status der ursprünglichen Nachricht zu überprüfen.  
  
 Wenn eine Nachricht an die Ziel Warteschlange gesendet wird, kann Message Queuing aufgefordert werden, eine Bestätigungsnachricht zu veröffentlichen. Eine solche Nachricht kann z. b. angeben, ob die Nachricht empfangen wurde und innerhalb der angegebenen Timeouts abgerufen wurde, oder Sie kann angeben, was bei einem Übermittlungs Fehler schief gelaufen ist. Die Ziel Warteschlange gibt Bestätigungsnachrichten zurück und sendet Sie an die Verwaltungs Warteschlange, die <xref:System.Messaging.Message.AdministrationQueue%2A> in der-Eigenschaft der ursprünglichen Meldung angegeben ist. Die <xref:System.Messaging.Message.Id%2A> -Eigenschaft einer Bestätigungsnachricht identifiziert die Bestätigungsnachricht, nicht die ursprüngliche Nachricht. Den Bezeichner der ursprünglichen Nachricht finden Sie in der- <xref:System.Messaging.Message> <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft der Bestätigungs Instanz.  
  
 Wenn diese <xref:System.Messaging.Message> Instanz eine Bestätigungsnachricht darstellt, gibt die <xref:System.Messaging.Message.Acknowledgment%2A> -Eigenschaft den Typ der Bestätigung an. Andernfalls enthält die <xref:System.Messaging.Message.Acknowledgment%2A> Eigenschaft den Wert. `Normal`  
  
 Verwenden Sie <xref:System.Messaging.Message.AcknowledgeType%2A> die-Eigenschaft der ursprünglichen Nachricht, um die Umstände anzugeben, unter denen Bestätigungen zurückgegeben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder - 
Die <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AdministrationQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.AdministrationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Warteschlange ab, die die von Message Queuing erzeugten Bestätigungsmeldungen empfängt, oder legt diese fest.</summary>
        <value>Die <see cref="T:System.Messaging.MessageQueue" />, die die Verwaltungswarteschlange für Bestätigungsmeldungen des Systems angibt. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die in der <xref:System.Messaging.Message.AdministrationQueue%2A> -Eigenschaft angegebene Warteschlange kann eine beliebige nicht transaktionale Warteschlange sein. In den an die Verwaltungswarteschlange gesendeten Bestätigungsnachrichten kann angezeigt werden, ob die ursprüngliche Nachricht ihre Zielwarteschlange erreicht hat und aus der Warteschlange entfernt wurde.  
  
 Wenn für <xref:System.Messaging.Message.AcknowledgeType%2A> die Eigenschaft ein anderer Wert als `None`festgelegt ist, muss die sendende Anwendung die Warteschlange angeben, die als Verwaltungs Warteschlange verwendet werden soll.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Nachricht gesendet und empfangen, die eine Bestellung zu und aus einer Warteschlange enthält. Insbesondere wird eine positive Bestätigung angefordert, wenn die ursprüngliche Nachricht erreicht oder aus der Warteschlange abgerufen wird.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AdministrationQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AppSpecific : int with get, set" Usage="System.Messaging.Message.AppSpecific" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft zusätzliche anwendungsspezifische Daten ab oder legt diese fest.</summary>
        <value>Anwendungsspezifische Daten. Der Standardwert ist 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.AppSpecific%2A> -Eigenschaft enthält anwendungsspezifische Informationen, mit denen Sie verschiedene Nachrichten Typen organisieren können. So können beispielsweise anwendungsspezifische Indizes verwendet werden. Es liegt in der Verantwortung der Anwendung, Eigenschafts Informationen zu interpretieren <xref:System.Messaging.Message.AppSpecific%2A> .  
  
 Wenn möglich, sollten Sie Nachrichten Daten anstelle der <xref:System.Messaging.Message.AppSpecific%2A> -Eigenschaft in den Text der Nachricht einschließen.  
  
 Verwenden Sie beim Arbeiten mit fremden Warteschlangen <xref:System.Messaging.Message.Extension%2A> die-Eigenschaft, um Nachrichten Eigenschaften anzugeben, die in Message Queuing nicht vorhanden sind. Wie bei der <xref:System.Messaging.Message.AppSpecific%2A> -Eigenschaft liegt es in der Verantwortung der Anwendung, den Inhalt <xref:System.Messaging.Message.Extension%2A> der-Eigenschaft zu verstehen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AppSpecific" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ArrivedTime : DateTime" Usage="System.Messaging.Message.ArrivedTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zeitpunkt ab, zu dem die Meldung von der Zielwarteschlange empfangen wurde.</summary>
        <value>Die <see cref="T:System.DateTime" /> stellt die Eingangszeit der Meldung in der Zielwarteschlange dar. Die Zeit wird von GMT in die lokale Zeit des Computers umgerechnet, auf dem sich die Zielwarteschlange befindet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschaft der Meldung gibt an, wie schnell die Nachricht von der Ziel Warteschlange empfangen werden muss. Der <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschafts Timer beginnt, wenn die Nachricht gesendet wird, und nicht, wenn die Nachricht in der Warteschlange eintrifft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.ArrivedTime%2A> Eigenschaft einer Nachricht angezeigt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.ArrivedTime" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AttachSenderId : bool with get, set" Usage="System.Messaging.Message.AttachSenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Sender-ID an die Meldung angehängt werden soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die <see cref="P:System.Messaging.Message.SenderId" /> an die Meldung angehängt werden soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.SenderId%2A> -Eigenschaft ist ein Bytearray, das den Bezeichner des sendenden Benutzers darstellt. Die Absender-ID wird Message Queuing festgelegt und vom empfangenden Warteschlangen-Manager verwendet, um zu überprüfen, ob der Absender über Zugriffsrechte für eine Warteschlange verfügt.  
  
 Das Fehlen der Absender-ID ist ein Hinweis von der sendenden Anwendung, dass Message Queuing den Absender der Nachricht weder überprüfen noch die Zugriffsrechte des Absenders für die empfangende Warteschlange überprüfen soll. Der <xref:System.Messaging.Message.SenderId%2A> ist nur vertrauenswürdig, wenn die Nachricht beim Erreichen der Ziel Warteschlange authentifiziert wurde. Die Nachricht wird zurückgewiesen, wenn Sie die Ziel Warteschlange erreicht, wenn die Warteschlange nur authentifizierte nach <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> richten akzeptiert `false`und entweder die <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A> -oder die-Eigenschaft ist.  
  
> [!CAUTION]
>  Wenn eine Nachricht abgelehnt wird, wird Sie entweder an die Warteschlange für unzustellbare nach <xref:System.Messaging.Message.UseDeadLetterQueue%2A> richten `true`gesendet (wenn ist), oder Sie wird ignoriert. Sie können Bestätigungen anfordern, wenn eine Nachricht nicht an eine Warteschlange gelangt. <xref:System.Messaging.Message.UseDeadLetterQueue%2A> Andernfalls ist `false` die Nachricht möglicherweise ohne Warnung verloren gegangen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.AttachSenderId%2A> Eigenschaft einer Nachricht abgerufen und festgelegt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AttachSenderId" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Authenticated : bool" Usage="System.Messaging.Message.Authenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Nachricht authentifiziert wurde.</summary>
        <value><see langword="true" />, wenn beim Erreichen der Warteschlange eine Authentifizierung für die Meldung angefordert wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.Authenticated%2A> -Eigenschaft wird nur von der Anwendung verwendet, während Sie mit der Nachricht interagiert und versucht, zu ermitteln, ob die Authentifizierung angefordert wurde. Wenn sich die Nachricht in der Warteschlange befindet, wurde die Nachricht authentifiziert. Wenn hingegen die <xref:System.Messaging.Message.Authenticated%2A> -Eigenschaft ist `true`, authentifiziert der empfangende Warteschlangen-Manager die Nachricht, als Sie diese Nachricht empfangen hat.  
  
 Sie können nicht ermitteln, ob die Authentifizierung einer Nachricht fehlgeschlagen ist, indem Sie Ihre Eigenschaften betrachten. Message Queuing verwirft Nachrichten, bei denen die Authentifizierung nicht erfolgreich war Sie können jedoch anfordern, dass eine Bestätigungsnachricht gesendet wird, wenn ein Übermittlungs Fehler verhindert, dass die Nachricht in der Warteschlange eintrifft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.Authenticated%2A> Eigenschaft einer Nachricht angezeigt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.Authenticated" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderName : string with get, set" Usage="System.Messaging.Message.AuthenticationProviderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Kryptografieanbieters ab, der zum Generieren der digitalen Signatur für die Meldung verwendet wird.</summary>
        <value>Der Name des Kryptografieanbieters, mit dem die digitale Signatur erzeugt wird. Die Standardeinstellung ist Microsoft Base Cryptographic Provider, Version 1.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Arbeiten mit fremden <xref:System.Messaging.Message.AuthenticationProviderName%2A> Warteschlangen verwenden Sie in der Regel. Message Queuing erfordert den Namen des Authentifizierungs Anbieters und den Authentifizierungstyp des Kryptografieanbieters (Authentifizierungs Anbieter) zum Überprüfen der digitalen Signaturen der an eine fremd Warteschlange gesendeten Nachrichten und der an die Nachricht übermittelten Nachrichten. Warteschlangen aus einer fremd Warteschlange.  
  
 Wenn Sie eine Nachricht senden, legen Sie <xref:System.Messaging.Message.AuthenticationProviderName%2A> immer <xref:System.Messaging.Message.ConnectorType%2A> die-Eigenschaft und die-Eigenschaft fest. Beim Senden der Nachricht ignoriert Message Queuing den Namen des Authentifizierungs Anbieters, wenn der Verbindungstyp nicht auch festgelegt ist.  
  
 Die <xref:System.Messaging.Message.AuthenticationProviderName%2A> -Eigenschaft kann `null`nicht sein, Sie kann jedoch eine leere Zeichenfolge ("") sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AuthenticationProviderName" />-Eigenschaft konnte nicht festgelegt werden.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.AuthenticationProviderName" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">Der <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> wurde auf <see langword="null" /> festgelegt.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderType : System.Messaging.CryptographicProviderType with get, set" Usage="System.Messaging.Message.AuthenticationProviderType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des Kryptografieanbieters ab, mit dem die digitale Signatur der Meldung generiert wird, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.CryptographicProviderType" />-Werte. Die Standardeinstellung ist <see langword="RSA_FULL" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalerweise verwenden Sie <xref:System.Messaging.Message.AuthenticationProviderType%2A> die-Eigenschaft bei der Arbeit mit fremden Warteschlangen, um anzugeben, welcher Kryptografiedienstanbieter mit einer Nachricht verknüpft ist. Message Queuing erfordert den Namen des Authentifizierungs Anbieters und den Authentifizierungstyp des Kryptografieanbieters (Authentifizierungs Anbieter) zum Überprüfen der digitalen Signaturen der an eine fremd Warteschlange gesendeten Nachrichten und der an die Nachricht übermittelten Nachrichten. Warteschlangen aus einer fremd Warteschlange.  
  
 Ist `RsaFull` nur für die Verwendung mit Messaging vorgesehen.  
  
 Wenn Sie eine Nachricht senden, legen Sie <xref:System.Messaging.Message.AuthenticationProviderType%2A> immer <xref:System.Messaging.Message.ConnectorType%2A> die-Eigenschaft und die-Eigenschaft fest. Beim Senden der Nachricht ignoriert Message Queuing den authentifizierunganbietertyp, wenn der Verbindungstyp nicht auch festgelegt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AuthenticationProviderType" />-Eigenschaft konnte nicht festgelegt werden.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.AuthenticationProviderType" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Body : obj with get, set" Usage="System.Messaging.Message.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Inhalt der Nachricht ab oder legt diesen fest.</summary>
        <value>Ein Objekt, das den Inhalt der Meldung enthält. Das Objekt kann eine Zeichenfolge, ein Datum, eine Währung, eine Zahl, ein Bytearray oder ein beliebiges verwaltetes Objekt sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Messaging.Message.Body%2A> Eigenschaft der Meldung enthält normalerweise die Daten, die der Nachricht zugeordnet sind. Obwohl Sie auch anwendungsspezifische Daten in den <xref:System.Messaging.Message.AppSpecific%2A> Eigenschaften und <xref:System.Messaging.Message.Extension%2A> senden können, sollten Sie nach Möglichkeit Nachrichten Daten in den <xref:System.Messaging.Message.Body%2A> der Nachricht einschließen. Nur der <xref:System.Messaging.Message.Body%2A> Eigenschafts Inhalt wird serialisiert oder verschlüsselt.  
  
 Die <xref:System.Messaging.Message.Body%2A> -Eigenschaft kann ein beliebiges-Objekt enthalten, dessen Größe 4 MB nicht überschreitet. Wenn Sie verwenden <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType> , um ein Objekt zu senden, das nicht <xref:System.Messaging.Message> vom Typ <xref:System.Messaging.MessageQueue>ist, wird dieses Objekt in der <xref:System.Messaging.Message.Body%2A> -Eigenschaft der- <xref:System.Messaging.Message> Instanz, die <xref:System.Messaging.MessageQueue.Peek%2A> von <xref:System.Messaging.MessageQueue.Receive%2A>oder zurückgegeben wird, gefunden.  
  
 Das Zeichen folgen Argument `MessageQueue.Send("hello.")` in ist ein Beispiel für ein solches generisches Objekt.  
  
 Die <xref:System.Messaging.Message.BodyType%2A> -Eigenschaft gibt den Typ der Informationen an, die im Nachrichtentext gespeichert sind. Message Queuing verwendet diese Informationen, um den Typ des <xref:System.Messaging.Message.Body%2A> Eigenschafts Inhalts zu identifizieren.  
  
 Geben Sie vor <xref:System.Messaging.Message.Body%2A> dem Senden des <xref:System.Messaging.Message.BodyStream%2A> <xref:System.Messaging.Message> Objekts entweder die-Eigenschaft oder die-Eigenschaft an. Die <xref:System.Messaging.Message.Body%2A> Eigenschaft kann ein beliebiges serialisierbares Objekt sein, z. b. eine Text Zeichenfolge, ein Struktur Objekt, eine Klasseninstanz oder ein eingebettetes Objekt  
  
 Wenn Sie den Inhalt der Nachricht nicht direkt in die <xref:System.Messaging.Message.BodyStream%2A> -Eigenschaft schreiben, legen Sie die <xref:System.Messaging.Message.Formatter%2A> -Eigenschaft vor dem Senden der Nachricht fest. Wenn die <xref:System.Messaging.MessageQueue.Send%2A> -Methode für die <xref:System.Messaging.MessageQueue> -Instanz aufgerufen wird, wird der Text mit dem Formatierer serialisiert, <xref:System.Messaging.Message.Formatter%2A> der in der-Eigenschaft enthalten ist. Wenn Sie die Nachricht senden, ohne einen Wert für die <xref:System.Messaging.Message.Formatter%2A> -Eigenschaft anzugeben, ist der Formatierer standardmäßig auf <xref:System.Messaging.XmlMessageFormatter>festgelegt.  
  
> [!NOTE]
>  <xref:System.Decimal.MaxValue> <xref:System.OverflowException> `Send` Wenn Sie <xref:System.Messaging.ActiveXMessageFormatter>  versuchen, den Text einer Nachricht auf festzulegen, wird eine ausgelöst, wenn die-Methode der- Klasse aufgerufen wird und verwendet wird. <xref:System.Messaging.MessageQueue>  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden zwei Nachrichten mit unterschiedlichen Prioritäten an die Warteschlange gesendet und anschließend abgerufen.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Formatter" />-Eigenschaft ist <see langword="null" />.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.Body" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BodyStream : System.IO.Stream with get, set" Usage="System.Messaging.Message.BodyStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Daten im Meldungstext ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.IO.Stream" />, der die serialisierten Daten aus dem <see cref="P:System.Messaging.Message.Body" /> der Meldung enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Nachrichtentext kann aus beliebigen Informationen bestehen, z. b. eine Zeichenfolge, ein Datum, eine Währung, eine Zahl, ein Bytearray oder ein beliebiges verwaltetes Objekt. Diese Informationen werden in eine <xref:System.IO.Stream> serialisiert, die an die Warteschlange übermittelt werden soll.  
  
 Geben Sie vor <xref:System.Messaging.Message.Body%2A> dem Senden des <xref:System.Messaging.Message.BodyStream%2A> <xref:System.Messaging.Message> Objekts entweder die-Eigenschaft oder die-Eigenschaft an. Wenn Sie die <xref:System.Messaging.Message.Body%2A> -Eigenschaft festlegen, wird der Inhalt in die <xref:System.Messaging.Message.BodyStream%2A> -Eigenschaft serialisiert. Sie können jedoch auch die <xref:System.Messaging.Message.BodyStream%2A> -Eigenschaft direkt schreiben. Dies ist beispielsweise hilfreich, wenn Sie eine Verbindung mit einer Datei öffnen und ihren Inhalt als Text der Nachricht streamen möchten.  
  
 Wenn Sie den Inhalt der Nachricht nicht direkt in die <xref:System.Messaging.Message.BodyStream%2A> -Eigenschaft schreiben, legen Sie die <xref:System.Messaging.Message.Formatter%2A> -Eigenschaft vor dem Senden der Nachricht fest. Wenn die <xref:System.Messaging.MessageQueue.Send%2A> -Methode für die <xref:System.Messaging.MessageQueue> -Instanz aufgerufen wird, wird der Text mit dem Formatierer serialisiert, <xref:System.Messaging.Message.Formatter%2A> der in der-Eigenschaft enthalten ist. Wenn Sie die Nachricht senden, ohne einen Wert für die <xref:System.Messaging.Message.Formatter%2A> -Eigenschaft anzugeben, ist der Formatierer standardmäßig auf <xref:System.Messaging.XmlMessageFormatter>festgelegt.  
  
 Wenn Sie für den <xref:System.Messaging.Message.UseEncryption%2A> Text der `true` Nachricht die-Eigenschaft auf festlegen, wird die Nachricht beim Senden verschlüsselt, nicht beim Festlegen der <xref:System.Messaging.Message.Body%2A> -Eigenschaft. Daher wird die <xref:System.Messaging.Message.BodyStream%2A> Eigenschaft nie verschlüsselt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Body" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BodyType : int with get, set" Usage="System.Messaging.Message.BodyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ der im Nachrichtenkörper enthaltenen Daten ab oder legt diesen fest.</summary>
        <value>Der tatsächliche Typ des Meldungstexts, z. B. Zeichenfolge, Datum, Währung oder Zahl.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing erkennt den Text Inhalt als Objekt oder als serialisierten Stream. Die <xref:System.Messaging.Message.BodyType%2A> -Eigenschaft gibt den Typ des Objekts innerhalb der <xref:System.Messaging.Message.Body%2A> -Eigenschaft der Nachricht an.  
  
 Das <xref:System.Messaging.XmlMessageFormatter> führt die Bindung zwischen systemeigenen Typen und dem Objekt in einem Nachrichtentext aus. Wenn Sie verwenden <xref:System.Messaging.XmlMessageFormatter>, legt das Formatierer die <xref:System.Messaging.Message.BodyType%2A> -Eigenschaft für Sie fest.  
  
 Andere Formatierer können auch Bindungsfunktionen bereitstellen, wie im folgenden C# Code gezeigt.  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.BodyType%2A> Eigenschaft einer Nachricht angezeigt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Body" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectorType : Guid with get, set" Usage="System.Messaging.Message.ConnectorType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der anzeigt, dass einige Meldungseigenschaften, die normalerweise von Message Queuing festgelegt werden, durch die sendende Anwendung festgelegt wurden, oder legt diesen fest.</summary>
        <value>Eine von der Anwendung definierte <see cref="T:System.Guid" />, die in Verbindung mit Connectoranwendungen oder der Meldungsverschlüsselung verwendet wird. Mithilfe der <see cref="T:System.Guid" /> kann eine empfangende Anwendung Meldungseigenschaften interpretieren, die normalerweise von Message Queuing festgelegt werden, in diesem Fall jedoch durch eine sendende Anwendung überschrieben wurden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing erfordert, <xref:System.Messaging.Message.ConnectorType%2A> dass die-Eigenschaft festgelegt wird, wenn eine Anwendung eine Nachrichten Eigenschaft festlegt, die normalerweise durch Message Queuing festgelegt wird. Eine Anwendung verwendet in den <xref:System.Messaging.Message.ConnectorType%2A> folgenden zwei Fällen normalerweise eine:  
  
-   Immer dann, wenn eine Connector-Anwendung eine Nachricht übergibt. Der <xref:System.Messaging.Message.ConnectorType%2A> teilt den sendenden und empfangenden Anwendungen mit, wie die Sicherheits-und Bestätigungs Eigenschaften der Nachricht interpretiert werden.  
  
-   Wenn die sendende Anwendung nicht Message Queuing, wird eine Nachricht verschlüsselt. Der <xref:System.Messaging.Message.ConnectorType%2A> weist Message Queuing an, den <xref:System.Messaging.Message.DestinationSymmetricKey%2A> Eigenschafts Wert zum Entschlüsseln der Nachricht zu verwenden.  
  
 Sie müssen die <xref:System.Messaging.Message.ConnectorType%2A> -Eigenschaft festlegen, wenn Sie eine der folgenden Eigenschaften festlegen (andernfalls werden diese Eigenschaften von der Warteschlange ignoriert, wenn die Nachricht gesendet wird):  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.ConnectorType" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CorrelationId : string with get, set" Usage="System.Messaging.Message.CorrelationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die in Bestätigungs-, Berichts- und Antwortnachrichten für den Verweis auf die ursprüngliche Nachricht verwendete Nachrichten-ID ab oder legt diese fest.</summary>
        <value>Die in der <see cref="P:System.Messaging.Message.Id" />-Eigenschaft der ursprünglichen Nachricht angegebene Meldungs-ID. Die Korrelations-ID wird in Message Queuing beim Erzeugen von Bestätigungs- oder Berichtsmeldungen sowie in Anwendungen beim Erzeugen von Antwortmeldungen verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Message Queuing eine Bestätigungs-oder Berichts Nachricht generiert, wird die Korrelations-ID-Eigenschaft verwendet, um den Nachrichten Bezeichner der ursprünglichen Nachricht anzugeben. Auf diese Weise bindet die Korrelations-ID die Berichts- oder Bestätigungsnachricht an die ursprüngliche Nachricht.  
  
 Die sendende Anwendung kann dann die Bestätigung oder den Bericht mit der ursprünglichen Nachricht vergleichen, indem <xref:System.Messaging.Message.CorrelationId%2A> die-Eigenschaft verwendet wird, um <xref:System.Messaging.Message.Id%2A> die-Eigenschaft der ursprünglichen Nachricht zu identifizieren.  
  
 Connector-Anwendungen müssen auch die <xref:System.Messaging.Message.CorrelationId%2A> -Eigenschaft der Bestätigungs-und Berichts Meldungen auf den Nachrichten Bezeichner der ursprünglichen Nachricht festlegen.  
  
 Wenn Ihre Anwendung eine Antwortnachricht an die sendende Anwendung sendet, können Sie die <xref:System.Messaging.Message.CorrelationId%2A> -Eigenschaft der Antwortnachricht auf die Nachrichten-ID der ursprünglichen Nachricht festlegen. Die sendende Anwendung kann dann die Antwortnachricht mit der gesendeten Nachricht vergleichen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Nachricht gesendet und empfangen, die eine Bestellung zu und aus einer Warteschlange enthält. Insbesondere wird eine positive Bestätigung angefordert, wenn die ursprüngliche Nachricht erreicht oder aus der Warteschlange abgerufen wird.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.CorrelationId" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.CorrelationId" /> ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DestinationQueue : System.Messaging.MessageQueue" Usage="System.Messaging.Message.DestinationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die für eine Meldung angegebene Zielwarteschlange ab.</summary>
        <value>Die <see cref="T:System.Messaging.MessageQueue" />, die die für die Meldung angegebene Zielwarteschlange angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.DestinationQueue%2A> -Eigenschaft wird am häufigsten verwendet, um das ursprüngliche Ziel einer Nachricht zu ermitteln, die in einem Journal oder einer Warteschlange für unzustellbare Nachrichten eingetroffen ist. Normalerweise müssen Sie diese Eigenschaft nicht überprüfen, da Sie in der Regel die Nachricht aus der Ziel Warteschlange abrufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.DestinationQueue%2A> Eigenschaft einer Nachricht angezeigt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.DestinationQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DestinationSymmetricKey : byte[] with get, set" Usage="System.Messaging.Message.DestinationSymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den symmetrischen Schlüssel für Meldungen ab, die in einer Anwendung oder für die Übermittlung an fremde Warteschlangen verschlüsselt werden.</summary>
        <value>Ein Bytearray, das den zur Verschlüsselung der Meldung verwendeten symmetrischen Zielschlüssel angibt. Der Standardwert ist ein Array der Länge 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei Szenarien erfordern die Verwendung der <xref:System.Messaging.Message.DestinationSymmetricKey%2A> -Eigenschaft. Der erste besteht darin, dass die Anwendung nicht Message Queuing, sondern eine Nachricht verschlüsselt. Die zweite ist, wenn Sie eine verschlüsselte Nachricht an ein anderes Warteschlangensystem als Message Queuing senden.  
  
 Bevor Sie diese Eigenschaft festlegen, müssen Sie den symmetrischen Schlüssel mit dem öffentlichen Schlüssel des empfangenden Warteschlangen-Managers verschlüsseln. Wenn Sie eine Anwendungs verschlüsselte Nachricht senden, verwendet der empfangende Warteschlangen-Manager den symmetrischen Schlüssel, um die Nachricht vor dem Senden an die Ziel Warteschlange zu entschlüsseln.  
  
 Wenn Sie eine Nachricht an eine fremde Warteschlange senden, wird die Nachricht zuerst von der entsprechenden Connector-Anwendung empfangen, die die verschlüsselte Nachricht mit dem angefügten symmetrischen Schlüssel an die empfangende Anwendung weiterleitet. Es ist dann die Aufgabe der empfangenden Anwendung, die Nachricht mit dem symmetrischen Schlüssel zu entschlüsseln.  
  
 Wenn Sie die <xref:System.Messaging.Message.DestinationSymmetricKey%2A> -Eigenschaft festlegen, müssen Sie auch die <xref:System.Messaging.Message.ConnectorType%2A> -Eigenschaft festlegen. Beim Senden der Nachricht ignoriert Message Queuing die <xref:System.Messaging.Message.DestinationSymmetricKey%2A> -Eigenschaft, wenn die <xref:System.Messaging.Message.ConnectorType%2A> -Eigenschaft nicht auch festgelegt ist.  
  
 Die <xref:System.Messaging.Message.DestinationSymmetricKey%2A> -Eigenschaft hat eine maximale Array Größe von 256.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.DestinationSymmetricKey" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DigitalSignature : byte[] with get, set" Usage="System.Messaging.Message.DigitalSignature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die digitale Signatur ab, mit der Message Queuing die Meldung authentifiziert, oder legt diese fest.</summary>
        <value>Ein Bytearray, das die zur Authentifizierung der Meldung verwendete digitale Signatur von Message Queuing 1.0 enthält. Der Standardwert ist ein Array der Länge 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing verwendet die digitale Signatur beim Authentifizieren von Nachrichten, die von Message Queuing Version 1,0 gesendet wurden. In den meisten Fällen generiert Message Queuing die <xref:System.Messaging.Message.DigitalSignature%2A> -Eigenschaft und legt diese fest, wenn die sendende Anwendung die Authentifizierung anfordert. Die empfangende Anwendung verwendet diese Eigenschaft, um die digitale Signatur abzurufen, die an die Nachricht angefügt ist.  
  
 Die <xref:System.Messaging.Message.DigitalSignature%2A> -Eigenschaft kann nur verwendet werden, wenn Message Queuing Version 2,0 ausgeführt wird. Die sendende Anwendung muss bei der Anforderung der Authentifizierung Message Queuing-Signaturen der Version 1,0 angeben. Wenn die sendende Anwendung eine Message Queuing Version 2,0-Signatur sendet, enthält diese Eigenschaft einen Puffer von vier Bytes, die jeweils 0 (null) enthalten.  
  
 Die <xref:System.Messaging.Message.DigitalSignature%2A> -Eigenschaft wird in Verbindung <xref:System.Messaging.Message.SenderCertificate%2A> mit der-Eigenschaft auch von Connector-Anwendungen verwendet, wenn eine Nachricht gesendet wird. In diesem Szenario generiert die Connector-Anwendung anstelle Message Queuing die digitale Signatur, die auf dem Zertifikat des Benutzers basiert, der die Nachricht sendet.  
  
 Die <xref:System.Messaging.Message.DigitalSignature%2A> -Eigenschaft hat eine maximale Array Größe von 256.  
  
 Wenn Sie die <xref:System.Messaging.Message.DigitalSignature%2A> -Eigenschaft festlegen, müssen Sie auch die <xref:System.Messaging.Message.ConnectorType%2A> -Eigenschaft festlegen. Wenn eine Nachricht gesendet wird, ignoriert Message Queuing die <xref:System.Messaging.Message.DigitalSignature%2A> -Eigenschaft, <xref:System.Messaging.Message.ConnectorType%2A> wenn die-Eigenschaft nicht auch festgelegt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.DigitalSignature" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.Message.DigitalSignature" />-Eigenschaft ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionAlgorithm : System.Messaging.EncryptionAlgorithm with get, set" Usage="System.Messaging.Message.EncryptionAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Verschlüsselungsalgorithmus ab, der zum Verschlüsseln des Meldungstextes einer privaten Meldung verwendet wird, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.EncryptionAlgorithm" />-Enumerationswerte. Die Standardeinstellung ist <see langword="RC2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Nachricht privat (verschlüsselt) ist, wird sie verschlüsselt, bevor Sie gesendet und nach dem Empfang entschlüsselt wird. Die <xref:System.Messaging.Message.EncryptionAlgorithm%2A> -Eigenschaft gibt den Algorithmus an, mit dem der Nachrichtentext einer privaten Nachricht verschlüsselt wird.  
  
 Eine Warteschlange kann erfordern, dass eingehende Nachrichten verschlüsselt werden. Wenn eine Anwendung eine nicht verschlüsselte (nicht private) Nachricht an eine Warteschlange sendet, die nur private Nachrichten akzeptiert, oder wenn Sie eine private Nachricht an eine Warteschlange sendet, die nur nicht private Nachrichten akzeptiert, lehnt die Warteschlange die Nachricht ab. Die sendende Anwendung kann anfordern, dass in einem solchen Fall eine negative Bestätigungsnachricht zurückgegeben wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.EncryptionAlgorithm" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Extension : byte[] with get, set" Usage="System.Messaging.Message.Extension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft weitere anwendungsspezifische, der Nachricht zugeordnete Informationen ab oder legt diese fest.</summary>
        <value>Ein Bytearray, das anwendungsspezifische, der Meldung zugeordnete Informationen bereitstellt. Der Standardwert ist ein Array der Länge 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.Extension%2A> -Eigenschaft bietet Anwendungs definierte Informationen, wie z. b. ein großes binäres Objekt, das der Nachricht zugeordnet ist. Es liegt in der Verantwortung der empfangenden Anwendung, den Inhalt der <xref:System.Messaging.Message.Extension%2A> -Eigenschaft zu interpretieren.  
  
 Wenn möglich, sollten Sie Nachrichten Daten in die <xref:System.Messaging.Message.Body%2A> -Eigenschaft der Nachricht statt in die <xref:System.Messaging.Message.Extension%2A> -Eigenschaft einschließen.  
  
 Verwenden Sie beim Arbeiten mit fremden Warteschlangen <xref:System.Messaging.Message.Extension%2A> die-Eigenschaft, um Nachrichten Eigenschaften anzugeben, die in Message Queuing nicht vorhanden sind.  
  
 Eine fremde Warteschlange ist in einem anderen Warteschlangensystem als Microsoft Message Queuing vorhanden. Message Queuing kommuniziert mit solchen Warteschlangen über eine Connector-Anwendung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Extension" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.Message.Extension" />-Eigenschaft ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.Message.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Formatierer ab, der zum Serialisieren und Deserialisieren eines Objekts in bzw. aus dem Nachrichtenkörper verwendet wird.</summary>
        <value>Der <see cref="T:System.Messaging.IMessageFormatter" />, der den Stream erstellt, der in den Meldungstext geschrieben oder aus diesem gelesen werden soll. Die Standardeinstellung ist <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.Messaging.Message.Formatter%2A> die-Eigenschaft, wenn Sie eine Nachricht lesen und schreiben. Wenn eine Nachricht an die Warteschlange gesendet wird, serialisiert der Formatierer <xref:System.Messaging.Message.Body%2A> die Eigenschaft in einen Stream, der an die Nachrichten Warteschlange gesendet werden kann. Beim Lesen aus einer Warteschlange deserialisiert der Formatierer die Nachrichten Daten in die <xref:System.Messaging.Message.Body%2A> -Eigenschaft.  
  
 Wenn Sie den Inhalt der Nachricht nicht direkt in die <xref:System.Messaging.Message.BodyStream%2A> -Eigenschaft schreiben, legen Sie die <xref:System.Messaging.Message.Formatter%2A> -Eigenschaft vor dem Senden der Nachricht fest. Wenn die <xref:System.Messaging.MessageQueue.Send%2A> -Methode für die <xref:System.Messaging.MessageQueue> -Instanz aufgerufen wird, wird der Text mit dem Formatierer serialisiert, <xref:System.Messaging.Message.Formatter%2A> der in der-Eigenschaft enthalten ist. Wenn Sie die Nachricht senden, ohne einen Wert für die <xref:System.Messaging.Message.Formatter%2A> -Eigenschaft anzugeben, ist der Formatierer standardmäßig auf <xref:System.Messaging.XmlMessageFormatter>festgelegt.  
  
 Der <xref:System.Messaging.XmlMessageFormatter> ist lose gekoppelt, sodass es nicht erforderlich ist, bei Verwendung dieses Formats denselben Objekttyp für den Absender und den Empfänger zu verwenden. <xref:System.Messaging.ActiveXMessageFormatter> Und <xref:System.Messaging.BinaryMessageFormatter>  serialisieren die Daten in binäre Darstellung. <xref:System.Messaging.ActiveXMessageFormatter> Wird beim Senden oder empfangen von COM-Komponenten verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Nachrichten <xref:System.Messaging.BinaryMessageFormatter>Text mit formatiert wird.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Nachrichten <xref:System.Messaging.XmlMessageFormatter>Text mit formatiert wird.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.Message.Formatter" />-Eigenschaft ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Messaging.HashAlgorithm with get, set" Usage="System.Messaging.Message.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zur Authentifizierung oder zur Erzeugung der digitalen Signatur einer Meldung von Message Queuing verwendeten Hashalgorithmus ab oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.HashAlgorithm" />-Enumerationswerte. Der Standardwert für Windows XP lautet <see langword="SHA" />. Andernfalls ist <see langword="MD5" /> der Standardwert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auf dem Quellcomputer verwendet Message Queuing den Hash Algorithmus, wenn eine digitale Signatur für eine Nachricht erstellt wird. Der Ziel Warteschlangen-Manager verwendet dann denselben Hash Algorithmus, um die Nachricht zu authentifizieren, wenn Sie empfangen wird.  

 Aufgrund von Konnektivitätsproblemen mit MD5 und SHA1 empfiehlt Microsoft SHA256. 
 
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.HashAlgorithm" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : string" Usage="System.Messaging.Message.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die ID der Nachricht ab.</summary>
        <value>Die eindeutige Meldungs-ID, die von Message Queuing generiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing generiert eine Nachrichten-ID, wenn die Nachricht gesendet wird. Der Bezeichner besteht aus 20 Bytes und umfasst zwei Elemente: den <xref:System.Guid> Computer des sendenden Computers und einen eindeutigen Bezeichner für die Nachricht auf dem Computer. Die Kombination beider Elemente liefert eine im Netzwerk eindeutige Nachrichten-ID.  
  
 Message Queuing generiert Nachrichten-IDs für alle Nachrichten, einschließlich Bestätigungs-und Berichts Nachrichten. Eine Bestätigungsnachricht wird in der Regel von Message Queuing als Reaktion auf den Eingang oder Misserfolg einer ursprünglichen gesendeten Nachricht gesendet. Den <xref:System.Messaging.Message.Id%2A> Eigenschafts Wert der ursprünglichen Nachricht finden Sie in der <xref:System.Messaging.Message.CorrelationId%2A> -Eigenschaft einer Bestätigungsnachricht.  
  
 Sie können auch die <xref:System.Messaging.Message.Id%2A> -Eigenschaft verwenden, wenn Sie eine Antwortnachricht an eine Antwort Warteschlange senden. Wenn Sie den Bezeichner der ursprünglichen Nachricht in eine Antwortnachricht einschließen möchten, <xref:System.Messaging.Message.CorrelationId%2A> legen Sie die-Eigenschaft der Antwort <xref:System.Messaging.Message.Id%2A> Nachricht auf die-Eigenschaft der ursprünglichen Nachricht fest. Die Anwendung, die die Antwortnachricht liest, kann dann den Korrelations Bezeichner der Antwortnachricht verwenden, um die ursprüngliche Nachricht zu identifizieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Nachricht gesendet und empfangen, die eine Bestellung zu und aus einer Warteschlange enthält. Insbesondere wird eine positive Bestätigung angefordert, wenn die ursprüngliche Nachricht erreicht oder aus der Warteschlange abgerufen wird.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.Id" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.Message.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass kein Timeout vorhanden ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A>und <xref:System.Messaging.Message.TimeToReachQueue%2A> erfordern einen-Wert, der ein Timeout angibt. Beim ersten ist das Timeout die maximale Zeit, die für das Empfangen einer Nachricht aus der Warteschlange zulässig ist. Bei letzterem ist das Timeout die Zeit, die eine Nachricht zum Erreichen der Warteschlange zulässt. In beiden Fällen können Sie das Timeout als eine Anzahl von Sekunden angeben oder verwenden <xref:System.Messaging.Message.InfiniteTimeout> , um anzugeben, dass kein Timeout vorhanden ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Messaging.Message.InfiniteTimeout> -Felds veranschaulicht.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFirstInTransaction : bool" Usage="System.Messaging.Message.IsFirstInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Meldung als erste Meldung in einer Transaktion gesendet wurde.</summary>
        <value><see langword="true" />, wenn die Meldung als erste Meldung in einer Transaktion gesendet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Empfangende Anwendungen verwenden <xref:System.Messaging.Message.IsFirstInTransaction%2A> die-Eigenschaft, um sicherzustellen, dass eine Nachricht die erste Nachricht war, die in einer einzelnen Transaktion an eine einzelne Warteschlange gesendet wurde.  
  
 Diese Eigenschaft ist nur mit Message Queuing Version 2,0 und höher verfügbar.  
  
 Zum Überprüfen der Transaktionsgrenzen können Sie die <xref:System.Messaging.Message.IsFirstInTransaction%2A> -Eigenschaft zusammen mit zwei anderen Eigenschaften <xref:System.Messaging.Message.IsLastInTransaction%2A> verwenden <xref:System.Messaging.Message.TransactionId%2A>: und. Verwenden Sie das erste, um zu überprüfen, ob eine Nachricht die letzte Nachricht war, die in der Transaktion gesendet wurde, und verwenden Sie letztere, um den Bezeichner der Transaktion abzurufen.  
  
 Wenn nur eine Nachricht in einer Transaktion gesendet wird, werden <xref:System.Messaging.Message.IsFirstInTransaction%2A> die <xref:System.Messaging.Message.IsLastInTransaction%2A> -Eigenschaft und die- `true`Eigenschaft auf festgelegt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.IsFirstInTransaction%2A> Eigenschaft einer Nachricht angezeigt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.IsFirstInTransaction" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLastInTransaction : bool" Usage="System.Messaging.Message.IsLastInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Meldung als letzte Meldung in einer Transaktion gesendet wurde.</summary>
        <value><see langword="true" />, wenn die Meldung als letzte Meldung in einer Transaktion gesendet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Empfangende Anwendungen verwenden <xref:System.Messaging.Message.IsLastInTransaction%2A> die-Eigenschaft, um sicherzustellen, dass eine Nachricht die letzte Nachricht war, die in einer einzelnen Transaktion an eine einzelne Warteschlange gesendet wurde.  
  
 Diese Eigenschaft ist nur mit Message Queuing Version 2,0 und höher verfügbar.  
  
 Zum Überprüfen der Transaktionsgrenzen können Sie die <xref:System.Messaging.Message.IsLastInTransaction%2A> -Eigenschaft zusammen mit zwei anderen Eigenschaften <xref:System.Messaging.Message.IsFirstInTransaction%2A> verwenden <xref:System.Messaging.Message.TransactionId%2A>: und. Verwenden Sie das erste, um zu überprüfen, ob eine Nachricht die erste Nachricht war, die in der Transaktion gesendet wurde, und verwenden Sie letztere, um den Bezeichner der Transaktion abzurufen.  
  
 Wenn nur eine Nachricht in einer Transaktion gesendet wird, werden <xref:System.Messaging.Message.IsFirstInTransaction%2A> die <xref:System.Messaging.Message.IsLastInTransaction%2A> -Eigenschaft und die- `true`Eigenschaft auf festgelegt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.IsLastInTransaction%2A> Eigenschaft einer Nachricht angezeigt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.IsLastInTransaction" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.Message.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine von der Anwendung definierte Unicode-Zeichenfolge ab, die die Nachricht beschreibt, oder legt diese fest.</summary>
        <value>Die Meldungsbezeichnung. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können eine Nachrichtenbezeichnung für mehrere Zwecke verwenden. Die Bezeichnung einer Nachricht kann beispielsweise angezeigt oder für die Verarbeitung einer von der Bezeichnung abhängigen Nachrichtenauswahl verwendet werden. Die Bezeichnung muss in den Nachrichten nicht eindeutig sein.  
  
 Bezeichnungen für Nachrichtenwarteschlangen und Nachrichten sind Werte, die von der Anwendung definiert werden und die Identifikation einer Warteschlange oder Nachricht über eine Textbeschreibung ermöglichen. Die Anwendung ist dafür verantwortlich, den Bezeichnungs Inhalt zu interpretieren, der keine intrinsische Bedeutung für die Message Queuing Anwendung hat.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.Label%2A> Eigenschaft einer Nachricht abgerufen und festgelegt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Label" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LookupId : int64" Usage="System.Messaging.Message.LookupId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eingeführt in MSMQ 3.0. Ruft den Suchbezeichner der Meldung ab.</summary>
        <value>Der von Message Queuing generierte Suchbezeichner der Meldung ist für die Warteschlange eindeutig, in der sich die Meldung befindet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.LookupId%2A> -Eigenschaft bietet schreibgeschützten Zugriff auf den Such Bezeichner einer Nachricht. Der in MSMQ 3,0 eingeführte Such Bezeichner ist ein 64-Bit-Bezeichner, der von Message Queuing generiert und jeder Nachricht zugewiesen wird, wenn die Nachricht in der Warteschlange abgelegt wird. Der Such Bezeichner ist nicht identisch mit dem Nachrichten Bezeichner, der beim Senden der Nachricht generiert wird.  
  
 Message Queuing generiert einen Such Bezeichner für alle Nachrichten, die in einer beliebigen Warteschlange platziert werden, einschließlich von der Anwendung generierter Ziel-, Verwaltungs-und Berichts Warteschlangen sowie vom System generiertes Journal, unzustellbare Nachrichten, Connector und ausgehende Warteschlangen. Das heißt, dies schließt sowohl Nachrichten ein, die durch das Senden von Anwendungen und Message Queuing gesendet werden. Der Such Bezeichner ist für die Warteschlange eindeutig und hat außerhalb der Warteschlange keine Bedeutung.  
  
 Wenn eine Nachricht an mehrere Ziel Warteschlangen gesendet wird oder wenn eine Kopie einer Nachricht in einem Computer Journal oder einem Warteschlangen Journal gespeichert wird, verfügt jede Kopie der Nachricht über einen eigenen Such Bezeichner, wenn Sie in der entsprechenden Warteschlange platziert wird.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> -Eigenschaft kann nur für Nachrichten gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
 Ein Such Bezeichner wird verwendet, um eine bestimmte Nachricht in der Warteschlange zu lesen. Sobald der Such Bezeichner einer Nachricht bekannt ist, kann die empfangende Anwendung die <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> -oder <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> -Funktion aufrufen, um direkt zu dieser Nachricht zu wechseln und Sie in der Warteschlange zu sehen oder abzurufen, anders als bei Cursorn, die am Anfang der Warteschlange beginnen müssen, und Navigieren Sie zum Ende der Warteschlange.  
  
 Das Abrufen der Such Bezeichner der Nachrichten in der Warteschlange liegt in der Verantwortung der Anwendung. Eine Möglichkeit zum Abrufen der Nachschlage Bezeichner besteht darin, einen Auslöser für die Ziel Warteschlange zu erstellen, die eine Komponente aufruft, die die Bezeichner der einzelnen Nachrichten in der Warteschlange zwischenspeichert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.LookupId" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageType : System.Messaging.MessageType" Usage="System.Messaging.Message.MessageType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Nachrichtentyp ab: <see langword="Normal" />, <see langword="Acknowledgment" /> oder <see langword="Report" />.</summary>
        <value>Einer der <see cref="P:System.Messaging.Message.MessageType" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing legt diese Eigenschaft normalerweise fest, wenn die Nachricht gesendet wird. Eine Message Queuing-Nachricht kann als einer der folgenden Typen definiert sein:  
  
-   `Normal`, bei dem es sich um eine typische Nachricht handelt, die von einer Anwendung an eine Warteschlange gesendet wird, oder um eine Antwortnachricht, die an die sendende Anwendung  
  
-   `Acknowledgement`, die Message Queuing generiert, wenn die sendende Anwendung eine Anforderung anfordert. Message Queuing kann positive oder negative Nachrichten erzeugen und hierdurch anzeigen, ob die ursprüngliche Nachricht empfangen oder gelesen wurde. Message Queuing sendet die entsprechende Bestätigungsnachricht an die von der sendenden Anwendung festgelegte Verwaltungswarteschlange zurück.  
  
-   `Report`, die Message Queuing generiert, wenn eine Berichts Warteschlange im Quell Warteschlangen-Manager definiert wird. Wenn die Verfolgung aktiviert ist, sendet Message Queuing eine Berichtsnachricht an die Message Queuing-Berichtswarteschlange, sobald die ursprüngliche Nachricht von einem Message Queuing-Server empfangen oder weitergeleitet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.MessageType%2A> Eigenschaft einer Nachricht angezeigt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.MessageType" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Messaging.MessagePriority with get, set" Usage="System.Messaging.Message.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Nachrichtenpriorität ab, die die Position der Nachricht in der Warteschlange bestimmt, oder legt diese fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.MessagePriority" />-Enumerationswerte, die die Prioritätsebenen für nicht transaktionale Meldungen darstellen. Die Standardeinstellung ist <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.Priority%2A> -Eigenschaft wirkt sich darauf aus, wie Message Queuing die Nachricht sowohl während der Route als auch nach Erreichen des Ziels behandelt. Nachrichten höherer Priorität werden beim Routing bevorzugt und gegen Anfang der Zielwarteschlange eingefügt. Nachrichten mit der gleichen Priorität werden entsprechend ihrer Ankunftszeit in der Warteschlange platziert.  
  
 Sie können nur für nicht transaktionale Nachrichten eine sinnvolle Priorität festlegen. In Message Queuing wird die Priorität für Transaktionsnachrichten automatisch auf `Lowest`festgelegt. Dies bewirkt, dass die Transaktionsnachrichten Priorität ignoriert wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden zwei Nachrichten mit unterschiedlichen Prioritäten an die Warteschlange gesendet und anschließend abgerufen.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Priority" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Recoverable : bool with get, set" Usage="System.Messaging.Message.Recoverable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Zustellung einer Meldung im Falle eines Computerfehlers oder Netzwerkproblems sichergestellt ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Übermittlung der Meldung durch Speichern auf der Festplatte während des Sendens sichergestellt wird, <see langword="false" />, wenn die Übermittlung nicht sichergestellt wird. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.Recoverable%2A> -Eigenschaft gibt an, ob die Übermittlung einer Nachricht gewährleistet ist, auch wenn ein Computer abstürzt, während die Nachricht an die Ziel Warteschlange weitergeleitet wird.  
  
 Wenn die Übermittlung einer Nachricht gewährleistet ist, wird die Nachricht lokal bei jedem Schritt auf der Route gespeichert, bis die Nachricht erfolgreich an den nächsten Computer weitergeleitet wird. Das Festlegen <xref:System.Messaging.Message.Recoverable%2A> der- `true` Eigenschaft auf kann den Durchsatz beeinträchtigen.  
  
 Wenn die Nachricht transaktional ist, behandelt Message Queuing die Nachricht automatisch als wiederherstellbar, unabhängig vom Wert der <xref:System.Messaging.Message.Recoverable%2A> -Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.Recoverable%2A> Eigenschaft einer Nachricht abgerufen und festgelegt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Recoverable" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.ResponseQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Warteschlange ab, die von einer Anwendung generierte Antwortnachrichten empfängt, oder legt diese fest.</summary>
        <value>Die <see cref="T:System.Messaging.MessageQueue" />, an die die von einer Anwendung generierten Antwortmeldungen zurückgesendet werden. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.ResponseQueue%2A> -Eigenschaft identifiziert die Warteschlange, die von der Anwendung generierte Antwort Nachrichten empfängt, die von der empfangenden Anwendung an die sendende Anwendung zurückgegeben werden. Die sendende Anwendung gibt die Antwortwarteschlangen beim Senden von Nachrichten an. Jede verfügbare Warteschlange kann als Antwortwarteschlange ausgewählt werden.  
  
 An die Antwortwarteschlange zurückgesendete Nachrichten sind anwendungsspezifisch. Die Anwendung muss sowohl den Inhalt der Nachrichten als auch die beim Empfang durchzuführenden Aktionen festlegen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.ResponseQueue%2A> Eigenschaft einer Nachricht abgerufen und festgelegt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.ResponseQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityContext : System.Messaging.SecurityContext with get, set" Usage="System.Messaging.Message.SecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Sicherheitskontext für eine Meldung ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Messaging.SecurityContext" />-Objekt, das den Sicherheitskontext für eine Meldung enthält, wenn die Eigenschaft zuvor festgelegt wurde, andernfalls NULL.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SenderCertificate : byte[] with get, set" Usage="System.Messaging.Message.SenderCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das zum Authentifizieren von Meldungen verwendete Sicherheitszertifikat ab oder legt dieses fest.</summary>
        <value>Ein Bytearray, das das Sicherheitszertifikat darstellt, anhand dessen Message Queuing den Sender einer Meldung überprüft. Der Standardwert ist ein Array der Länge 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die empfangende Anwendung verwendet <xref:System.Messaging.Message.SenderCertificate%2A> die-Eigenschaft, wenn die Nachricht ein externes Sicherheitszertifikat enthält.  
  
 Message Queuing können eine Nachricht entweder mit einem internen oder externen Sicherheitszertifikat authentifizieren. Message Queuing stellt interne Zertifikate bereit, die zum Überprüfen der Nachrichten Integrität verwendet werden. Eine Zertifizierungsstelle stellt ein externes Zertifikat bereit, auf das Sie über die <xref:System.Messaging.Message.SenderCertificate%2A> -Eigenschaft der Nachricht zugreifen können. Mit einem externen Zertifikat kann die empfangende Anwendung nicht nur den Message Queuing authentifizieren, sondern auch den Absender überprüfen. Ein internes Zertifikat hat keinen verwendbaren Wert für eine empfangende Anwendung.  
  
 Ein externes Zertifikat muss beim Verzeichnisdienst des Message Queuing Systems registriert werden. Ein externes Zertifikat enthält Informationen über die Zertifizierungsstelle, den Zertifikat Benutzer, die Gültigkeitsdauer des Zertifikats, den öffentlichen Schlüssel des Zertifikats Benutzers und die Signatur der Zertifizierungsstelle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.SenderCertificate" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderId : byte[]" Usage="System.Messaging.Message.SenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die ID des sendenden Benutzers ab.</summary>
        <value>Ein Bytearray, das den Benutzer identifiziert. Der empfangende Warteschlangenmanager überprüft bei der Authentifizierung einer Meldung den Sender und seine Zugriffsrechte für die Warteschlange anhand der ID.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Messaging.Message.AttachSenderId%2A> -Eigenschaft `false`ist, wird der in der <xref:System.Messaging.Message.SenderId%2A> -Eigenschaft angegebene Absender Bezeichner nicht an die Nachricht angefügt, wenn er gesendet wird. Dies gibt an, dass Message Queuing, dass der Absender nicht überprüft werden soll, wenn die Nachricht an die Ziel Warteschlange gesendet wird. Wenn die <xref:System.Messaging.Message.AttachSenderId%2A> -Eigenschaft `true`ist, <xref:System.Messaging.Message.SenderId%2A> ist der Eigenschafts Wert nur dann vertrauenswürdig, wenn die Nachricht authentifiziert wurde. Verwenden Sie <xref:System.Messaging.Message.Authenticated%2A> die-Eigenschaft in Verbindung <xref:System.Messaging.Message.SenderId%2A> mit der-Eigenschaft, um die Zugriffsrechte des Absenders zu überprüfen.  
  
 Eine Connector-Anwendung ist eine Anwendung, die einen Connector-Server verwendet, um die Kommunikation zwischen Message Queuing und anderen warteschlangensystemen bereitzustellen. Message Queuing erfordert, dass Connector-Anwendungen Absender Identifizierung bereitstellen. Sie müssen die <xref:System.Messaging.Message.ConnectorType%2A> -Eigenschaft festlegen, wenn Sie eine Nachricht über eine Connector-Anwendung senden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.SenderId" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderVersion : int64" Usage="System.Messaging.Message.SenderVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Version von Message Queuing ab, mit der die Meldung gesendet wurde.</summary>
        <value>Die Version von Message Queuing, mit der die Meldung gesendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.SenderVersion%2A> -Eigenschaft ist für bestimmte Features wichtig. Beispielsweise wird die Transaktionsverarbeitung nur von Message Queuing 2,0 und höher unterstützt, und digitale Signaturen werden verwendet, um die von MSMQ 1,0 gesendeten Nachrichten zu authentifizieren.  
  
 Der sendende Warteschlangen- <xref:System.Messaging.Message.SenderVersion%2A> Manager legt die-Eigenschaft fest, wenn die Nachricht gesendet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.SenderVersion%2A> Eigenschaft einer Nachricht angezeigt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.SenderVersion" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.SentTime : DateTime" Usage="System.Messaging.Message.SentTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Datum und Uhrzeit auf dem sendenden Computer ab, zu der die Nachricht vom Quellwarteschlangen-Manager gesendet wurde.</summary>
        <value>Die <see cref="T:System.DateTime" /> stellt den Zeitpunkt dar, zu dem die Meldung gesendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.SentTime%2A> -Eigenschaft wird an die lokale Zeit des Computers angepasst, auf dem diese Instanz <xref:System.Messaging.Message> der-Klasse erstellt wurde. Diese Zeitzone kann sich von den Quell-und Ziel Warteschlangen unterscheiden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.SentTime%2A> Eigenschaft einer Nachricht angezeigt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.SentTime" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceMachine : string" Usage="System.Messaging.Message.SourceMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Computer ab, von dem die Meldung ausging.</summary>
        <value>Der Name des Computers, von dem die Meldung gesendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Format <xref:System.Messaging.Message.SourceMachine%2A> der-Eigenschaft enthält keine vorangehenden beiden Schrägstriche (\\\\). Beispielsweise `myServer` ist ein gültiger <xref:System.Messaging.Message.SourceMachine%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.SourceMachine%2A> Eigenschaft einer Nachricht angezeigt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.SourceMachine" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Es konnte nicht auf die Computerinformationen oder den Verzeichnisdienst zugegriffen werden.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToBeReceived : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToBeReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeitbegrenzung für den Empfang der Meldung aus der Zielwarteschlange ab oder legt diese fest.</summary>
        <value>Die für eine gesendete Meldung vorgegebene Gesamtzeit bis zum Empfang aus der Zielwarteschlange. Die Standardeinstellung ist <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.TimeToBeReceived%2A> -Eigenschaft gibt die Gesamtzeit an, die eine gesendete Nachricht von der Ziel Warteschlange empfangen werden soll. Das Zeitlimit umfasst die Zeit, die für das Erreichen der Ziel Warteschlange aufgewendet wurde, und die Zeit, die in der Warteschlange verbracht wurde, bevor die Nachricht empfangen  
  
> [!CAUTION]
>  Wenn Sie abhängige Client Computer verwenden, müssen Sie sicherstellen, dass die Uhr auf dem Client Computer mit der Uhr auf dem Server synchronisiert wird, auf dem Message Queuing ausgeführt wird. Andernfalls kann es zu unvorhersehbarem Verhalten kommen, wenn eine <xref:System.Messaging.Message.TimeToBeReceived%2A> Nachricht gesendet wird <xref:System.Messaging.Message.InfiniteTimeout>, deren-Eigenschaft nicht ist.  
  
 Wenn das von der <xref:System.Messaging.Message.TimeToBeReceived%2A> -Eigenschaft angegebene Intervall abläuft, bevor die Nachricht aus der Warteschlange entfernt wird, wird die Nachricht von Message Queuing auf eine von zwei Arten verworfen. Wenn die <xref:System.Messaging.Message.UseDeadLetterQueue%2A>-Eigenschaft auf `true` festgelegt ist, wird die Nachricht an die Dead Letter-Warteschlange gesendet. Wenn  <xref:System.Messaging.Message.UseDeadLetterQueue%2A> den Wert hat, wird die Meldung ignoriert. `false`  
  
 Sie können die- <xref:System.Messaging.Message.AcknowledgeType%2A> Eigenschaft der Nachricht so festlegen, dass Message Queuing eine negative Bestätigungsnachricht zurück an die sendende Anwendung sendet, wenn die Nachricht nicht vor Ablauf des Timers abgerufen wird.  
  
 Wenn der von der <xref:System.Messaging.Message.TimeToBeReceived%2A> -Eigenschaft angegebene Wert kleiner als der von der <xref:System.Messaging.Message.TimeToReachQueue%2A> -Eigenschaft angegebene Wert <xref:System.Messaging.Message.TimeToBeReceived%2A> ist, hat Vorrang.  
  
 Wenn mehrere Nachrichten in einer einzelnen Transaktion gesendet werden, verwendet Message Queuing <xref:System.Messaging.Message.TimeToBeReceived%2A> die-Eigenschaft der ersten Nachricht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschaft einer Nachricht abgerufen und festgelegt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.TimeToBeReceived" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">Der für <see cref="P:System.Messaging.Message.TimeToBeReceived" /> angegebene Wert ist ungültig.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToReachQueue : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToReachQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeitbegrenzung der Nachricht für das Erreichen der Warteschlange ab oder legt diese fest.</summary>
        <value>Die maximale Dauer zwischen dem Absenden der Meldung und dem Erreichen der Zielwarteschlange. Die Standardeinstellung ist <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das von der <xref:System.Messaging.Message.TimeToReachQueue%2A> -Eigenschaft angegebene Intervall abläuft, bevor die Nachricht das Ziel erreicht, verwirft Message Queuing die Nachricht auf zwei Arten. Wenn die <xref:System.Messaging.Message.UseDeadLetterQueue%2A>-Eigenschaft auf `true` festgelegt ist, wird die Nachricht an die Dead Letter-Warteschlange gesendet. Wenn  <xref:System.Messaging.Message.UseDeadLetterQueue%2A> den Wert hat, wird die Meldung ignoriert. `false`  
  
 Sie können die-Eigenschaft der <xref:System.Messaging.Message.AcknowledgeType%2A> Nachricht so festlegen, dass Message Queuing eine negative Bestätigungsnachricht an die sendende Anwendung zurücksenden, wenn die Nachricht vor Ablauf des Timers nicht eingeht.  
  
 Wenn die <xref:System.Messaging.Message.TimeToReachQueue%2A> -Eigenschaft auf 0 Sekunden festgelegt ist, versucht Message Queuing einmal, die Nachricht an das Ziel zu senden, wenn die Warteschlange auf die Nachricht wartet. Wenn die Warteschlange lokal ist, erreicht die Nachricht Sie immer.  
  
 Wenn der von der <xref:System.Messaging.Message.TimeToReachQueue%2A> -Eigenschaft angegebene Wert größer ist als der von der <xref:System.Messaging.Message.TimeToBeReceived%2A> -Eigenschaft angegebene <xref:System.Messaging.Message.TimeToBeReceived%2A> Wert, hat Vorrang.  
  
 Wenn mehrere Nachrichten in einer einzelnen Transaktion gesendet werden, verwendet Message Queuing <xref:System.Messaging.Message.TimeToReachQueue%2A> die-Eigenschaft der ersten Nachricht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.TimeToReachQueue%2A> Eigenschaft einer Nachricht abgerufen und festgelegt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.TimeToReachQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">Der für <see cref="P:System.Messaging.Message.TimeToReachQueue" /> angegebene Wert ist ungültig. Eventuell wurde ein negativer Wert angegeben.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionId : string" Usage="System.Messaging.Message.TransactionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die ID der Transaktion ab, in der die Meldung gesendet wurde.</summary>
        <value>Der Bezeichner der der Meldung zugeordneten Transaktion.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Empfangende Anwendungen verwenden <xref:System.Messaging.Message.TransactionId%2A> die-Eigenschaft, um zu überprüfen, ob eine Nachricht als Teil einer bestimmten Transaktion gesendet wurde. Der Transaktions Bezeichner enthält den Bezeichner des sendenden Computers (erste 16 Bits), gefolgt von einer 4-Byte-Transaktions Sequenznummer.  
  
 Diese Eigenschaft ist nur für Message Queuing Version 2,0 und höher verfügbar.  
  
 Es ist nicht garantiert, dass Transaktions Bezeichner eindeutig sind, da Transaktions Sequenznummern nicht persistent sind und bei 2 <sup>20</sup>erneut gestartet werden. Message Queuing wird nur sichergestellt, dass nachfolgende Transaktionen verschiedene Transaktions Sequenznummern aufweisen.  
  
 Sie können die <xref:System.Messaging.Message.TransactionId%2A> -Eigenschaft zusammen mit den <xref:System.Messaging.Message.IsFirstInTransaction%2A> - <xref:System.Messaging.Message.IsLastInTransaction%2A> und-Eigenschaften verwenden, um Transaktionsgrenzen zu überprüfen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.TransactionId%2A> Eigenschaft einer Nachricht angezeigt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.TransactionId" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionStatusQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.TransactionStatusQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Transaktionsstatus-Warteschlange auf dem Quellcomputer ab.</summary>
        <value>Die Transaktionsstatus-Warteschlange auf dem Quellcomputer, die für das Senden von Bestätigungsmeldungen an die sendende Anwendung verwendet wird. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.TransactionStatusQueue%2A> -Eigenschaft identifiziert die Transaktions Warteschlange auf dem Quellcomputer, von der Empfangsbestätigungen von Connector-Anwendungen empfangen werden. Message Queuing legt die-Eigenschaft fest, und die-Connector-Anwendungen verwenden die-Eigenschaft, wenn Transaktionsnachrichten abgerufen werden, die an fremde Warteschlangen gesendet werden.  
  
 Eine fremde Warteschlange ist in einem anderen Warteschlangensystem als Microsoft Message Queuing vorhanden. Message Queuing kommuniziert mit solchen Warteschlangen über eine Connector-Anwendung.  
  
 Die Connector-Anwendung kann die Transaktionsstatus-Warteschlange verwenden, um Bestätigungsnachrichten an die sendende Anwendung zurückzusenden. Die Transaktionsstatus-Warteschlange sollte diese Bestätigungen auch dann erhalten, wenn die sendende Anwendung keine anderen Bestätigungen anfordert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.TransactionStatusQueue%2A> Eigenschaft einer Nachricht angezeigt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
- oder - 
Die <see cref="P:System.Messaging.Message.TransactionStatusQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseAuthentication : bool with get, set" Usage="System.Messaging.Message.UseAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Meldung vor dem Absenden authentifiziert wurde oder authentifiziert werden muss, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die sendende Anwendung die Authentifizierung der Meldung angefordert hat, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.UseAuthentication%2A> -Eigenschaft gibt an, ob die Nachricht authentifiziert werden muss. Wenn die sendende Anwendung die Authentifizierung anfordert, erstellt Message Queuing eine digitale Signatur und verwendet diese zum Signieren der Nachricht, wenn Sie gesendet wird, und authentifiziert die Nachricht, wenn Sie empfangen wird.  
  
 Wenn <xref:System.Messaging.Message.UseAuthentication%2A> ist `false`  und eine Nachricht an eine Warteschlange gesendet wird, die nur authentifizierte Nachrichten akzeptiert, wird die Nachricht zurückgewiesen, wenn Sie die Warteschlange erreicht.  
  
 Sie können nicht ermitteln, ob die Authentifizierung einer Nachricht fehlgeschlagen ist, indem Sie Ihre Eigenschaften betrachten. Message Queuing verwirft solche Nachrichten, bevor Sie an die Warteschlange übermittelt werden. Sie können jedoch anfordern, dass eine Bestätigungsnachricht gesendet wird, wenn ein Übermittlungs Fehler verhindert, dass eine Nachricht in der Warteschlange eintrifft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.UseAuthentication" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDeadLetterQueue : bool with get, set" Usage="System.Messaging.Message.UseDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine Kopie der nicht zustellbaren Meldung an eine Dead Letter-Warteschlange gesendet werden soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn bei einem Fehler bei der Meldungsübermittlung eine Kopie der Meldung an die Warteschlange für unzustellbare Nachrichten gesendet werden soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.UseJournalQueue%2A> Eigenschaften <xref:System.Messaging.Message.UseDeadLetterQueue%2A> und geben an, wie Message Queuing eine Nachricht nachverfolgt. Wenn <xref:System.Messaging.Message.UseDeadLetterQueue%2A> ist `true` , wird der Übermittlungs Fehler (einer nicht transaktionalen Nachricht) bewirkt, dass die Nachricht an die nicht transaktionale Warteschlange für unzustellbare Nachrichten auf dem Computer gesendet wird, der die Nachricht nicht übermitteln konnte. Ein Übermittlungs Fehler kann z. b. dadurch verursacht werden, dass ein Nachrichten-Timer abläuft.  
  
 Im Fall eines Übermittlungs Fehlers für eine transaktionale Nachricht sendet Message Queuing die Nachricht in allen negativen und unsicheren Fällen an die transaktionale Warteschlange für unzustellbare Nachrichten auf dem Quellcomputer.  
  
 Wenn Sie Nachrichten in einer Warteschlange für unzustellbare Nachrichten speichern, sollten Sie die Warteschlange regelmäßig löschen, um nicht mehr benötigte Nachrichten zu entfernen. Nachrichten, die in Warteschlangen für unzustellbare Nachrichten gespeichert werden, werden auf das Kontingent für den Computer festgestellt Das Computer Kontingent wird vom Administrator festgelegt und bezieht sich auf die Größe, die zum Speichern von Nachrichten auf dem gesamten Computer, nicht nur in einer einzigen Warteschlange zugeordnet ist.  
  
 Sie erstellen weder ein Journal noch eine Warteschlange für unzustellbare Nachrichten. Dabei handelt es sich um System Warteschlangen, die Message Queuing generiert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.UseDeadLetterQueue%2A> Eigenschaft einer Nachricht abgerufen und festgelegt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.UseDeadLetterQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseEncryption : bool with get, set" Usage="System.Messaging.Message.UseEncryption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Meldung als privat behandelt werden soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn Message Queuing die Meldung verschlüsseln soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Nachricht privat ist, wird Ihr Text verschlüsselt, bevor Sie gesendet und entschlüsselt wird, wenn Sie empfangen wird. Zum Senden einer privaten Nachricht muss die sendende Anwendung angeben, dass die Verschlüsselung und optional der Verschlüsselungsalgorithmus verwendet werden soll.  
  
 Wenn Sie private Nachrichten senden, muss Ihre Anwendung die Nachrichten Verschlüsselung nicht durchführen. Message Queuing können den Nachrichtentext für Sie verschlüsseln, wenn Ihre Anwendung Nachrichten innerhalb von Microsoft Windows 2000 Enterprise sendet, die Zugriff auf den Verzeichnisdienst haben. Wenn private Nachrichten empfangen werden, entschlüsselt der empfangende Warteschlangen-Manager immer den Nachrichtentext.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.UseEncryption%2A> Eigenschaft einer Nachricht abgerufen und festgelegt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.UseEncryption" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.Message.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine Kopie der Meldung in einem Journal auf dem sendenden Computer abgelegt werden soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn nach erfolgreicher Übermittlung vom sendenden Computer an den nächsten Server eine Kopie der Meldung in einem Journal auf dem sendenden Computer abgelegt werden soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.UseJournalQueue%2A> Eigenschaften <xref:System.Messaging.Message.UseDeadLetterQueue%2A> und geben an, wie Message Queuing eine Nachricht nachverfolgt. Wenn <xref:System.Messaging.Message.UseJournalQueue%2A> ist `true` , wird bei jedem Schritt, in dem eine Nachricht übertragen wird, im Computer Journal auf dem Ursprungs Computer eine Kopie aufbewahrt.  
  
 Die gesendete Nachricht wird nur in die Journal Warteschlange kopiert, wenn sich die Ziel Warteschlange auf einem Remote Computer befindet. Wenn sich das Ziel auf dem lokalen Computer befindet, wird die Nachricht direkt an die Warteschlange gesendet. Es sind keine Zwischenschritte erforderlich, um Journale zu erzwingen.  
  
 Wenn Sie Nachrichten in einer Journal Warteschlange speichern, löschen Sie die Warteschlange regelmäßig, um nicht mehr benötigte Nachrichten zu entfernen. In Journal Warteschlangen gespeicherte Nachrichten werden für das Kontingent des Computers gezählt, auf dem sich die Warteschlange befindet. (Das Computer Kontingent wird vom Administrator festgelegt.)  
  
 Sie erstellen weder ein Journal noch eine Warteschlange für unzustellbare Nachrichten. Dabei handelt es sich um System Warteschlangen, die Message Queuing generiert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.UseJournalQueue%2A> Eigenschaft einer Nachricht abgerufen und festgelegt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.UseJournalQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTracing : bool with get, set" Usage="System.Messaging.Message.UseTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine Meldung während der Weiterleitung an die Zielwarteschlange verfolgt wird, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn bei jeder Zwischenstation der Originalmeldung bis zum Erreichen der Zielwarteschlange ein Bericht generiert und an die Berichtswarteschlange des Systems gesendet werden soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.UseTracing%2A> -Eigenschaft gibt an, ob die Route einer Nachricht nachverfolgt werden soll, wenn Sie in die Ziel Warteschlange verschoben wird. Wenn `true`der Wert ist, wird eine Berichts Meldung (generiert von Message Queuing) jedes Mal an eine Berichts Warteschlange gesendet, wenn die Nachricht einen Message Queuing Routing Server durchläuft. Die Berichts Warteschlange wird vom Quell Warteschlangen-Manager angegeben. Berichts Warteschlangen sind nicht auf Berichts Meldungen beschränkt, die von Message Queuing generiert werden. die von der Anwendung generierten Meldungen können auch an Berichts Warteschlangen gesendet werden.  
  
 Die Verwendung der Ablauf Verfolgung umfasst das Einrichten Active Directory und das Angeben einer Berichts Warteschlange für die Message Queuing Enterprise. Diese Einstellungen werden vom Administrator konfiguriert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der- <xref:System.Messaging.Message.UseTracing%2A> Eigenschaft einer Nachricht abgerufen und festgelegt.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.UseTracing" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>
