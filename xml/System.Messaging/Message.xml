<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="452b72d229254f13a5d2827bfeca0ec97c6f6675" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30461094" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt den Zugriff auf die Eigenschaften bereit, die zur Definition einer Message Queuing-Meldung erforderlich sind.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Messaging.Message> Klasse zum Einsehen oder Empfangen von Nachrichten aus einer Warteschlange, oder um die genaue Steuerung von Nachrichteneigenschaften beim Senden einer Nachricht an eine Warteschlange zu haben.  
  
 <xref:System.Messaging.MessageQueue> verwendet die <xref:System.Messaging.Message> beim eingesehen oder Nachrichten aus der empfängt Klasse, da sowohl die <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType> und <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType> Methoden erstellen eine neue Instanz der die <xref:System.Messaging.Message> Klasse, und legen Sie die Eigenschaften der Instanz. Die <xref:System.Messaging.Message> Klasse schreibgeschützte Eigenschaften gelten für das Abrufen von Nachrichten aus einer Warteschlange, während die Lese-/Schreibeigenschaften zum Senden und Empfangen von Nachrichten gelten. Wenn <xref:System.Messaging.MessageQueue> einsieht oder aus einer Warteschlange eine Nachricht empfängt die <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> Eigenschaft bestimmt, welche Eigenschaften für die Nachricht abgerufen werden.  
  
 Die <xref:System.Messaging.MessageQueue> Klasse <xref:System.Messaging.MessageQueue.Send%2A> Methode ermöglicht Ihnen die Angabe für einen beliebigen Objekttyp für eine Nachricht an die Warteschlange gesendet wird. Sie können die <xref:System.Messaging.MessageQueue> Instanz <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft, um Einstellungen für generische an die Warteschlange gesendeten Nachrichten anzugeben. Die Einstellungen zählen Formatierer, Bezeichnung, Verschlüsselung und Authentifizierung. Sie können auch angeben, die Werte für die entsprechende <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member, wenn Sie Ihre messaging-Anwendung so reagieren Sie auf die Bestätigungs- und Berichtsnachrichten Nachrichten koordinieren. Mithilfe einer <xref:System.Messaging.Message> Instanz zum Senden einer Nachricht an die Warteschlange bietet Ihnen die Flexibilität zum Zugreifen auf und viele dieser Eigenschaften ändern – entweder für eine einzelne Nachricht oder auf Basis von Nachricht. <xref:System.Messaging.Message> Eigenschaften haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.  
  
 Nachrichtendaten befindet sich in der <xref:System.Messaging.Message.Body%2A> Eigenschaft und in geringerem Maße, die <xref:System.Messaging.Message.AppSpecific%2A> und <xref:System.Messaging.Message.Extension%2A> Eigenschaften. Wenn Nachrichtendaten verschlüsselt, serialisiert oder deserialisiert wird, nur der Inhalt des der <xref:System.Messaging.Message.Body%2A> -Eigenschaft beeinflusst werden.  
  
 Den Inhalt der <xref:System.Messaging.Message.Body%2A> Eigenschaft werden serialisiert, wenn die Nachricht gesendet wird, mithilfe der <xref:System.Messaging.Message.Formatter%2A> Eigenschaft, die Sie angeben. Der serialisierte Inhalt befinden sich in der <xref:System.Messaging.Message.BodyStream%2A> Eigenschaft. Sie können auch Festlegen der <xref:System.Messaging.Message.BodyStream%2A> Eigenschaft direkt, z. B. eine Datei als der Dateninhalt einer Nachricht zu senden. Sie können ändern, die <xref:System.Messaging.Message.Body%2A> oder <xref:System.Messaging.Message.Formatter%2A> Eigenschaften zu einem beliebigen Zeitpunkt vor dem Senden der Nachricht, und die Daten werden entsprechend serialisiert werden, wenn Sie aufrufen <xref:System.Messaging.MessageQueue.Send%2A>.  
  
 Eigenschaften, definiert durch die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType> Eigenschaft gelten nur für Nachrichten, die nicht vom Typ <xref:System.Messaging.Message>. Bei Angabe der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> -Eigenschaft für eine <xref:System.Messaging.MessageQueue>, der gleichnamigen Eigenschaften eine <xref:System.Messaging.Message> Instanz gesendet, an die Warteschlange diese Standardeigenschaften ignoriert werden soll.  
  
 Eine Liste der anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.Message>, finden Sie unter der <xref:System.Messaging.Message.%23ctor%2A> Konstruktor.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Formatieren Nachrichtentexts mit <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Das folgende Codebeispiel veranschaulicht das Formatieren Nachrichtentexts mit <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.Message" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.Message" />-Klasse mit einem leeren Meldungstext.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, erstellen Sie eine neue Instanz der dem <xref:System.Messaging.Message> Klasse, die keinen Text verfügt.  
  
 Geben Sie entweder die <xref:System.Messaging.Message.Body%2A> Eigenschaft oder die <xref:System.Messaging.Message.BodyStream%2A> Eigenschaft vor dem Senden der <xref:System.Messaging.Message> Objekt. Die <xref:System.Messaging.Message.Body%2A> Eigenschaft kann jedes Objekt, das serialisiert werden kann, z. B. eine Zeichenfolge, ein Strukturobjekt, eine Klasseninstanz oder ein eingebettetes Objekt sein.  
  
 Es sei denn, Sie direkt an den Inhalt der Nachricht Schreiben der <xref:System.Messaging.Message.BodyStream%2A> Eigenschaftensatz, der <xref:System.Messaging.Message.Formatter%2A> Eigenschaft vor dem Senden der Nachricht. Der Nachrichtentext serialisiert wird, mit der <xref:System.Messaging.Message.Formatter%2A> Eigenschaftswert zum Zeitpunkt der <xref:System.Messaging.MessageQueue.Send%2A> Methode aufgerufen wird die <xref:System.Messaging.MessageQueue> Instanz.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> lose verknüpft, daher ist es nicht notwendig, dass das gleiche Objekt, das auf dem Absender und Empfänger geben Sie bei Verwendung dieses Format ist. Die <xref:System.Messaging.ActiveXMessageFormatter> und <xref:System.Messaging.BinaryMessageFormatter> Serialisieren der Daten in eine binäre Darstellung. Die <xref:System.Messaging.ActiveXMessageFormatter> wird beim Senden oder Empfangen von COM-Komponenten verwendet.  
  
 In der folgenden Tabelle zeigt die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.Message>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider Version 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Ein Bytearray mit der Länge null|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Ein Bytearray mit der Länge null|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Ein Bytearray mit der Länge null|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Ein Bytearray mit der Länge null|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird zwei Nachrichten unterschiedliche Prioritäten an die Warteschlange sendet, und sie werden später abgerufen.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">Das Objekt, das in den Meldungstext serialisiert werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.Message" />-Klasse, wobei das angegebene Objekt mithilfe des <see cref="T:System.Messaging.XmlMessageFormatter" /> in den Meldungstext serialisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, erstellen Sie eine neue Instanz der dem <xref:System.Messaging.Message> Klasse enthält die <xref:System.Messaging.Message.Body%2A> gemäß der `body` Parameter. Die `body` Parameter kann jedes Objekt, das serialisiert werden kann, z. B. eine Zeichenfolge, ein Strukturobjekt, eine Klasseninstanz oder ein eingebettetes Objekt sein. Text serialisiert wird, mithilfe der <xref:System.Messaging.XmlMessageFormatter> es sei denn, Sie ändern die <xref:System.Messaging.Message.Formatter%2A> Eigenschaft, bevor die <xref:System.Messaging.Message> gesendet wird. Wenn Sie ändern die <xref:System.Messaging.Message.Body%2A> oder <xref:System.Messaging.Message.Formatter%2A> Eigenschaft zu einem beliebigen Zeitpunkt vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%2A>, die Nachricht wird gemäß der neue Eigenschaftswert serialisiert werden.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> lose verknüpft, daher ist es nicht notwendig, dass das gleiche Objekt, das auf dem Absender und Empfänger geben Sie bei Verwendung dieses Format ist. Die <xref:System.Messaging.ActiveXMessageFormatter> und <xref:System.Messaging.BinaryMessageFormatter> Serialisieren der Daten in eine binäre Darstellung. Die <xref:System.Messaging.ActiveXMessageFormatter> wird beim Senden oder Empfangen von COM-Komponenten verwendet.  
  
 In der folgenden Tabelle zeigt die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.Message>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider Version 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Der `body`-Parameter.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Ein Bytearray mit der Länge null|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Ein Bytearray mit der Länge null|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Ein Bytearray mit der Länge null|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Ein Bytearray mit der Länge null|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine neue Warteschlange, sendet eine Nachricht, die eine Bestellung, enthält, und klicken Sie dann abgerufen.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">Das Objekt, das in den Meldungstext serialisiert werden soll.</param>
        <param name="formatter">Der <see cref="T:System.Messaging.IMessageFormatter" /> gibt den Formatierer an, mit dem die Serialisierung in den Meldungstext erfolgen soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.Message" />-Klasse, wobei das angegebene Objekt mithilfe des angegebenen Formatierers in den Meldungstext serialisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Erstellen einer neuen Instanz von der <xref:System.Messaging.Message> Klasse enthält die <xref:System.Messaging.Message.Body%2A> gemäß der `body` und einen zulässigen Formatierer verwendet, um den Text zu serialisieren. Die `body` Parameter ist jedes Objekt, das serialisiert werden kann, z. B. eine Zeichenfolge, ein Strukturobjekt, eine Klasseninstanz oder ein eingebettetes Objekt. Wenn Sie ändern die <xref:System.Messaging.Message.Body%2A> oder <xref:System.Messaging.Message.Formatter%2A> Eigenschaft zu einem beliebigen Zeitpunkt vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%2A>, die Nachricht wird gemäß der neue Eigenschaftswert serialisiert werden.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> lose verknüpft, daher ist es nicht notwendig, dass das gleiche Objekt, das auf dem Absender und Empfänger geben Sie bei Verwendung dieses Format ist. Die <xref:System.Messaging.ActiveXMessageFormatter> und <xref:System.Messaging.BinaryMessageFormatter> Serialisieren der Daten in eine binäre Darstellung. Die <xref:System.Messaging.ActiveXMessageFormatter> wird beim Senden oder Empfangen von COM-Komponenten verwendet.  
  
 In der folgenden Tabelle zeigt die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.Message>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider Version 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Der `body`-Parameter.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Ein Bytearray mit der Länge null|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Ein Bytearray mit der Länge null|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Ein Bytearray mit der Länge null|  
|<xref:System.Messaging.Message.Formatter%2A>|Der `formatter`-Parameter.|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Ein Bytearray mit der Länge null|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ der Bestätigungsmeldung ab, die an die sendende Anwendung zurückgegeben werden soll, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.AcknowledgeTypes" />-Werte, die sowohl die Typen der Bestätigungsmeldungen darstellen, die das System in die Verwaltungswarteschlange stellt, als auch die Bedingungen, unter denen Bestätigungsmeldungen an die sendende Anwendung zurückgegeben werden. Der Standardwert ist <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.AcknowledgeType%2A> Eigenschaft gibt den Typ der Bestätigungsnachricht an, die von der sendenden Anwendung angefordert. Legen Sie die <xref:System.Messaging.Message.AcknowledgeType%2A> Eigenschaft vor dem Senden der Nachricht, um Benachrichtigungen zu bestimmten Vorkommen anzufordern – z. B. eine Nachricht die Zielwarteschlange, eine Nachricht abgerufen wird oder ein Timeout, die verhindern, dass einer Nachricht erreicht wurde oder vom abgerufen wird die Zielwarteschlange.  
  
 Message Queuing zurück Benachrichtigung durch Senden von Bestätigungsnachrichten an die <xref:System.Messaging.Message.AdministrationQueue%2A> durch die ursprüngliche Nachricht angegebene Eigenschaft. Einer Bestätigungsnachricht <xref:System.Messaging.Message.Acknowledgment%2A> Eigenschaft gibt den Typ der Bestätigung, die es darstellt. Angenommen, eine Bestätigungsnachricht gesendet wurde, da eine Nachricht vor dem Ziel nicht erreicht hatten die <xref:System.Messaging.Message.TimeToReachQueue%2A> Intervall abgelaufen ist, die <xref:System.Messaging.Message.Acknowledgment%2A> -Eigenschaft der Bestätigungsnachricht-Zeilenwert enthält den Wert `ReachQueueTimeout`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht, die eine Bestellung in und aus einer Warteschlange enthält. Eine positive Bestätigung wird ausdrücklich angefordert, wenn die ursprüngliche Nachricht erreicht wurde oder wird aus der Warteschlange abgerufen.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AcknowledgeType" />-Eigenschaft wird aufgrund eines für die Meldung gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Klassifikation für die Bestätigung ab, die diese Meldung darstellt.</summary>
        <value>Einer der <see cref="T:System.Messaging.Acknowledgment" />-Enumerationswerte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Nachricht von einer Verwaltungswarteschlange erhalten, lesen Sie die <xref:System.Messaging.Message.Acknowledgment%2A> Eigenschaft, um den Status der ursprünglichen Nachricht zu überprüfen.  
  
 Wenn eine Nachricht an die Zielwarteschlange gesendet wird, kann Message Queuing angefordert werden, um eine Bestätigungsnachricht. Eine solche Nachricht kann, z. B. angeben, ob die Nachricht angekommen ist und innerhalb der angegebenen Timeouts abgerufen wurde, oder es darauf hinweisen kann, im Fall von Zustellungsfehler Einzelheiten. Die Zielwarteschlange gibt Bestätigung Nachrichten und sendet diese an die Verwaltungswarteschlange, die in der ursprünglichen Nachricht angegebene <xref:System.Messaging.Message.AdministrationQueue%2A> Eigenschaft. Die <xref:System.Messaging.Message.Id%2A> Eigenschaft eine Bestätigungsnachricht identifiziert die Bestätigungsnachricht, nicht die ursprüngliche Nachricht. Den Bezeichner der ursprünglichen Nachricht finden Sie in der Bestätigung <xref:System.Messaging.Message> Instanz <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft.  
  
 Wenn diese <xref:System.Messaging.Message> Instanz steht eine Bestätigungsnachricht, die <xref:System.Messaging.Message.Acknowledgment%2A> Eigenschaft gibt den Typ der Bestätigung. Andernfalls die <xref:System.Messaging.Message.Acknowledgment%2A> -Eigenschaft enthält den Wert `Normal`.  
  
 Verwenden der <xref:System.Messaging.Message.AcknowledgeType%2A> -Eigenschaft der ursprünglichen Nachricht an die Umstände, unter denen Bestätigungen zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Warteschlange ab, die die von Message Queuing erzeugten Bestätigungsmeldungen empfängt, oder legt diese fest.</summary>
        <value>Die <see cref="T:System.Messaging.MessageQueue" />, die die Verwaltungswarteschlange für Bestätigungsmeldungen des Systems angibt. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Warteschlange die <xref:System.Messaging.Message.AdministrationQueue%2A> Eigenschaft kann eine nicht transaktionale Warteschlange gesendet werden. In den an die Verwaltungswarteschlange gesendeten Bestätigungsnachrichten kann angezeigt werden, ob die ursprüngliche Nachricht ihre Zielwarteschlange erreicht hat und aus der Warteschlange entfernt wurde.  
  
 Wenn die <xref:System.Messaging.Message.AcknowledgeType%2A> Eigenschaft verfügt über einen beliebigen Wert außer `None`, die sendende Anwendung muss die Warteschlange angeben, die als die Verwaltungswarteschlange verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht, die eine Bestellung in und aus einer Warteschlange enthält. Eine positive Bestätigung wird ausdrücklich angefordert, wenn die ursprüngliche Nachricht erreicht wurde oder wird aus der Warteschlange abgerufen.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AdministrationQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft zusätzliche anwendungsspezifische Daten ab oder legt diese fest.</summary>
        <value>Anwendungsspezifische Daten. Der Standardwert ist 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.AppSpecific%2A> Eigenschaft enthält anwendungsspezifische Informationen, die Sie verwenden können, um verschiedene Typen von Nachrichten zu organisieren. So können beispielsweise anwendungsspezifische Indizes verwendet werden. Es ist Aufgabe der Anwendung interpretiert <xref:System.Messaging.Message.AppSpecific%2A> Eigenschaftsinformationen.  
  
 Nach Möglichkeit sollten Sie die Nachrichtendaten einschließen, im Text der Nachricht statt über das <xref:System.Messaging.Message.AppSpecific%2A> Eigenschaft.  
  
 Verwenden Sie bei der Arbeit mit fremden Warteschlangen die <xref:System.Messaging.Message.Extension%2A> Eigenschaft angeben, Message Queuing-Nachrichteneigenschaften, die nicht vorhanden sind. Wie bei der <xref:System.Messaging.Message.AppSpecific%2A> -Eigenschaft, es liegt in der Verantwortung der Anwendung zu verstehen, den Inhalt der <xref:System.Messaging.Message.Extension%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AppSpecific" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zeitpunkt ab, zu dem die Meldung von der Zielwarteschlange empfangen wurde.</summary>
        <value>Die <see cref="T:System.DateTime" /> stellt die Eingangszeit der Meldung in der Zielwarteschlange dar. Die Zeit wird von GMT in die lokale Zeit des Computers umgerechnet, auf dem sich die Zielwarteschlange befindet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Nachricht <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschaft gibt an, wie schnell die Nachricht aus der Zielwarteschlange empfangen werden muss. Die <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschaft beginnen, wenn die Nachricht gesendet wird, nicht verwendet werden, wenn die Nachricht in der Warteschlange eintrifft.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachricht <xref:System.Messaging.Message.ArrivedTime%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.ArrivedTime" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Sender-ID an die Meldung angehängt werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die <see cref="P:System.Messaging.Message.SenderId" /> an die Meldung angehängt werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.SenderId%2A> Eigenschaft ist ein Array von Bytes, die den Bezeichner des sendenden Benutzers darstellt. Die Absender-ID wird vom Message Queuing festgelegt und wird von den empfangenden Warteschlangen-Manager um zu überprüfen, ob der Absender über die Zugriffsrechte für eine Warteschlange wurde verwendet.  
  
 Das Fehlen des Absenders ID eine Angabe über das von der sendenden Anwendung liegt darin, dass nicht den Absender der Nachricht zu überprüfen oder des Zugriffs auf den Absender überprüfen sollte Message Queuing-Rechte für die Zielwarteschlange. Die <xref:System.Messaging.Message.SenderId%2A> vertrauenswürdig nur, wenn die Nachricht authentifiziert wurde, wenn sie die Zielwarteschlange erreicht ist. Die Nachricht wird abgelehnt, wenn sie die Zielwarteschlange erreicht, wenn die Warteschlange nur authentifizierte Nachrichten und entweder akzeptiert die <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A> oder <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> Eigenschaft ist `false`.  
  
> [!CAUTION]
>  Wenn eine Nachricht abgelehnt wird, wird entweder an die Dead Letter-Warteschlange gesendet (Wenn <xref:System.Messaging.Message.UseDeadLetterQueue%2A> ist `true`), oder sie wird ignoriert. Wenn eine Nachricht ein Fehler auftritt, um eine Warteschlange zu erreichen, können Sie Bestätigungen anfordern. Andernfalls gilt bei <xref:System.Messaging.Message.UseDeadLetterQueue%2A> ist `false` möglich, dass die Nachricht ohne Warnung verloren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachricht <xref:System.Messaging.Message.AttachSenderId%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AttachSenderId" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Nachricht authentifiziert wurde.</summary>
        <value>
          <see langword="true" />, wenn beim Erreichen der Warteschlange eine Authentifizierung für die Meldung angefordert wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.Authenticated%2A> Eigenschaft wird nur von der Anwendung verwendet, während die Interaktion mit der Nachricht, und versuchen, um festzustellen, ob eine Authentifizierung angefordert wurde. Wenn die Nachricht in der Warteschlange befindet, wurde die Nachricht authentifiziert. Umgekehrt, wenn die <xref:System.Messaging.Message.Authenticated%2A> Eigenschaft `true`, empfangenden Warteschlangen-Manager die Nachricht authentifiziert, wenn sie diese Nachricht empfangen.  
  
 Sie können nicht feststellen, ob eine Nachricht Fehler bei der Authentifizierung durch einen Blick auf ihre Eigenschaften. Message Queuing verwirft Nachrichten, die Authentifizierung fehl, bevor sie an die Warteschlange übermittelt werden. Allerdings können Sie anfordern, dass eine Bestätigungsnachricht gesendet werden, wenn ein Zustellungsfehler verhindert, dass die Nachricht in die Warteschlange eingeht.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachricht <xref:System.Messaging.Message.Authenticated%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.Authenticated" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Kryptografieanbieters ab, der zum Generieren der digitalen Signatur für die Meldung verwendet wird.</summary>
        <value>Der Name des Kryptografieanbieters, mit dem die digitale Signatur erzeugt wird. Die Standardeinstellung ist Microsoft Base Cryptographic Provider, Version 1.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel die <xref:System.Messaging.Message.AuthenticationProviderName%2A> bei der Arbeit mit fremden Warteschlangen. Message Queuing erfordert die Authentifizierung Anbietername und die Authentifizierungsanbietertyp des Kryptografieanbieters (Authentifizierungsanbieter) zum Überprüfen der digitalen Signaturen der an eine fremde Warteschlange gesendeten Nachrichten und Nachrichten an die Nachricht übergeben Queuing aus einer fremden Warteschlange.  
  
 Legen Sie beim Senden einer Nachricht immer die <xref:System.Messaging.Message.AuthenticationProviderName%2A> und <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaften zusammen. Wenn die Nachricht gesendet wird, ignoriert Message Queuing-der Name des Authentifizierungsanbieters, wenn der Connectortyp nicht festgelegt wurde.  
  
 Die <xref:System.Messaging.Message.AuthenticationProviderName%2A> Eigenschaft darf nicht sein `null`, aber es kann eine leere Zeichenfolge ("").  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AuthenticationProviderName" />-Eigenschaft konnte nicht festgelegt werden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.AuthenticationProviderName" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">Der <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> wurde auf <see langword="null" /> festgelegt.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des Kryptografieanbieters ab, mit dem die digitale Signatur der Meldung generiert wird, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.CryptographicProviderType" />-Werte. Der Standardwert ist <see langword="RSA_FULL" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel die <xref:System.Messaging.Message.AuthenticationProviderType%2A> Eigenschaft bei der Arbeit mit fremden Warteschlangen an, welcher Kryptografiedienstanbieters Nachricht zugeordnet ist. Message Queuing erfordert die Authentifizierung Anbietername und die Authentifizierungsanbietertyp des Kryptografieanbieters (Authentifizierungsanbieter) zum Überprüfen der digitalen Signaturen der an eine fremde Warteschlange gesendeten Nachrichten und Nachrichten an die Nachricht übergeben Queuing aus einer fremden Warteschlange.  
  
 Nur `RsaFull` mit messaging verwendet werden soll.  
  
 Legen Sie beim Senden einer Nachricht immer die <xref:System.Messaging.Message.AuthenticationProviderType%2A> und <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaften zusammen. Wenn die Nachricht gesendet wird, ignoriert Message Queuing den Authentifizierungstyp für Anbieter, wenn der Connectortyp nicht festgelegt wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.AuthenticationProviderType" />-Eigenschaft konnte nicht festgelegt werden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.AuthenticationProviderType" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Inhalt der Nachricht ab oder legt diesen fest.</summary>
        <value>Ein Objekt, das den Inhalt der Meldung enthält. Das Objekt kann eine Zeichenfolge, ein Datum, eine Währung, eine Zahl, ein Bytearray oder ein beliebiges verwaltetes Objekt sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Nachricht <xref:System.Messaging.Message.Body%2A> Eigenschaft enthält in der Regel die Daten, die der Nachricht zugeordnet. Obwohl anwendungsspezifische Daten werden, in gesendet können der <xref:System.Messaging.Message.AppSpecific%2A> und <xref:System.Messaging.Message.Extension%2A> Eigenschaften, sollten Sie Nachrichtendaten in gehören die <xref:System.Messaging.Message.Body%2A> der Nachricht nach Möglichkeit. Nur die <xref:System.Messaging.Message.Body%2A> Inhalt-Eigenschaft serialisiert oder verschlüsselt sind.  
  
 Die <xref:System.Messaging.Message.Body%2A> Eigenschaft kann ein Objekt, dessen Größe 4 MB maximal, enthalten. Bei Verwendung von <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType> jedes Objekt zu senden, die nicht vom Typ ist <xref:System.Messaging.Message> auf die <xref:System.Messaging.MessageQueue>, dieses Objekt befinden sich der <xref:System.Messaging.Message.Body%2A> Eigenschaft von der <xref:System.Messaging.Message> zurückgegebene Instanz <xref:System.Messaging.MessageQueue.Peek%2A> oder <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 Das Zeichenfolgenargument in `MessageQueue.Send("hello.")` ist ein Beispiel für solches generisches Objekt.  
  
 Die <xref:System.Messaging.Message.BodyType%2A> Eigenschaft gibt den Typ der Informationen, die im Nachrichtentext gespeichert ist. Message Queuing verwendet diese Informationen der Identifizierung der <xref:System.Messaging.Message.Body%2A> Inhalt-Eigenschaft.  
  
 Geben Sie entweder die <xref:System.Messaging.Message.Body%2A> Eigenschaft oder die <xref:System.Messaging.Message.BodyStream%2A> Eigenschaft vor dem Senden der <xref:System.Messaging.Message> Objekt. Die <xref:System.Messaging.Message.Body%2A> Eigenschaft kann sein, alle serialisierbaren Objekts, z. B. eine Textzeichenfolge, Strukturobjekt, Klasseninstanz oder eingebettetes Objekt.  
  
 Es sei denn, Sie direkt an den Inhalt der Nachricht Schreiben der <xref:System.Messaging.Message.BodyStream%2A> Eigenschaftensatz, der <xref:System.Messaging.Message.Formatter%2A> Eigenschaft vor dem Senden der Nachricht. Wenn die <xref:System.Messaging.MessageQueue.Send%2A> Methode aufgerufen wird die <xref:System.Messaging.MessageQueue> Instanz den Text mithilfe der in enthaltenen Formatierers serialisiert wird die <xref:System.Messaging.Message.Formatter%2A> Eigenschaft. Wenn die Nachricht zu senden, ohne Angabe eines Werts für die <xref:System.Messaging.Message.Formatter%2A> -Eigenschaft, wird der Standardformatierer <xref:System.Messaging.XmlMessageFormatter>.  
  
> [!NOTE]
>  Beim Festlegen der Text einer Nachricht in <xref:System.Decimal.MaxValue> führt dazu, dass eine <xref:System.OverflowException> beim der `Send` Methode der <xref:System.Messaging.MessageQueue> -Klasse aufgerufen wird und die <xref:System.Messaging.ActiveXMessageFormatter> verwendet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird zwei Nachrichten unterschiedliche Prioritäten an die Warteschlange sendet, und sie werden später abgerufen.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Formatter" />-Eigenschaft ist <see langword="null" />.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.Body" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Daten im Meldungstext ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.IO.Stream" />, der die serialisierten Daten aus dem <see cref="P:System.Messaging.Message.Body" /> der Meldung enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Text einer Nachricht kann einen beliebigen Typ von Informationen bestehen – z. B. eine Zeichenfolge, ein Datum, Währung, eine Zahl, ein Array von Bytes oder ein verwaltetes Objekt. Diese Informationen serialisiert eine <xref:System.IO.Stream> an die Warteschlange übergeben werden.  
  
 Geben Sie entweder die <xref:System.Messaging.Message.Body%2A> Eigenschaft oder die <xref:System.Messaging.Message.BodyStream%2A> Eigenschaft vor dem Senden der <xref:System.Messaging.Message> Objekt. Wenn Sie festlegen, die <xref:System.Messaging.Message.Body%2A> -Eigenschaft, die Inhalte werden serialisiert, in der <xref:System.Messaging.Message.BodyStream%2A> Eigenschaft. Sie können jedoch auswählen, zum Schreiben der <xref:System.Messaging.Message.BodyStream%2A> -Eigenschaft direkt. Dies empfiehlt sich beispielsweise, wenn Sie eine Verbindung mit einer Datei zu öffnen und seinen Inhalt als Text der Nachricht zu streamen möchten.  
  
 Es sei denn, Sie direkt an den Inhalt der Nachricht Schreiben der <xref:System.Messaging.Message.BodyStream%2A> Eigenschaftensatz, der <xref:System.Messaging.Message.Formatter%2A> Eigenschaft vor dem Senden der Nachricht. Wenn die <xref:System.Messaging.MessageQueue.Send%2A> Methode aufgerufen wird die <xref:System.Messaging.MessageQueue> Instanz den Text mithilfe der in enthaltenen Formatierers serialisiert wird die <xref:System.Messaging.Message.Formatter%2A> Eigenschaft. Wenn die Nachricht zu senden, ohne Angabe eines Werts für die <xref:System.Messaging.Message.Formatter%2A> -Eigenschaft, wird der Standardformatierer <xref:System.Messaging.XmlMessageFormatter>.  
  
 Wenn Sie festlegen, die <xref:System.Messaging.Message.UseEncryption%2A> Eigenschaft `true` für den Text dieser Meldung, die Nachricht verschlüsselt wird, wenn sie gesendet wird, nicht verwendet werden, wenn Sie festlegen, die <xref:System.Messaging.Message.Body%2A> Eigenschaft. Aus diesem Grund die <xref:System.Messaging.Message.BodyStream%2A> Eigenschaft niemals verschlüsselt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Body" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ der im Nachrichtenkörper enthaltenen Daten ab oder legt diesen fest.</summary>
        <value>Der tatsächliche Typ des Meldungstexts, z. B. Zeichenfolge, Datum, Währung oder Zahl.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing erkennt der Textinhalt als Objekt oder als serialisierten Stream. Die <xref:System.Messaging.Message.BodyType%2A> Eigenschaft gibt den Typ des Objekts innerhalb der <xref:System.Messaging.Message.Body%2A> -Eigenschaft der Nachricht.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> führt eine Bindung zwischen systemeigenen Typen und das Objekt in einem Nachrichtentext. Bei Verwendung der <xref:System.Messaging.XmlMessageFormatter>, das Formatierungsprogramm legt die <xref:System.Messaging.Message.BodyType%2A> -Eigenschaft für Sie.  
  
 Andere Formatierungsprogramme bieten Bindungsfunktionalität auch, wie im folgenden C#-Code dargestellt.  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachricht <xref:System.Messaging.Message.BodyType%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Body" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der anzeigt, dass einige Meldungseigenschaften, die normalerweise von Message Queuing festgelegt werden, durch die sendende Anwendung festgelegt wurden, oder legt diesen fest.</summary>
        <value>Eine von der Anwendung definierte <see cref="T:System.Guid" />, die in Verbindung mit Connectoranwendungen oder der Meldungsverschlüsselung verwendet wird. Mithilfe der <see cref="T:System.Guid" /> kann eine empfangende Anwendung Meldungseigenschaften interpretieren, die normalerweise von Message Queuing festgelegt werden, in diesem Fall jedoch durch eine sendende Anwendung überschrieben wurden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing erfordert die <xref:System.Messaging.Message.ConnectorType%2A> -Eigenschaft festgelegt werden, wenn eine Anwendung eine Nachrichteneigenschaft festlegt, die von Message Queuing in der Regel festgelegt ist. Eine Anwendung in der Regel verwendet eine <xref:System.Messaging.Message.ConnectorType%2A> in den folgenden zwei Fällen:  
  
-   Bei jedem übergibt eine Connectoranwendung eine Meldung an. Die <xref:System.Messaging.Message.ConnectorType%2A> teilt den sendenden und empfangenden Anwendungen wie die Sicherheit und die Bestätigung der Nachricht zu interpretieren.  
  
-   Bei jedem verschlüsselt die sendende Anwendung, anstelle von Message Queuing eine Nachricht. Die <xref:System.Messaging.Message.ConnectorType%2A> teilt Message Queuing verwendet den <xref:System.Messaging.Message.DestinationSymmetricKey%2A> Eigenschaftswert zum Entschlüsseln der Nachricht.  
  
 Sie müssen festlegen, die <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaft, wenn Sie die folgenden Eigenschaften festlegen (andernfalls werden diese Eigenschaften beim Senden der Nachricht von die Warteschlange ignoriert):  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.ConnectorType" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die in Bestätigungs-, Berichts- und Antwortnachrichten für den Verweis auf die ursprüngliche Nachricht verwendete Nachrichten-ID ab oder legt diese fest.</summary>
        <value>Die in der <see cref="P:System.Messaging.Message.Id" />-Eigenschaft der ursprünglichen Nachricht angegebene Meldungs-ID. Die Korrelations-ID wird in Message Queuing beim Erzeugen von Bestätigungs- oder Berichtsmeldungen sowie in Anwendungen beim Erzeugen von Antwortmeldungen verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Message Queuing eine Bestätigungs- oder berichtsnachricht generiert, verwendet er die Korrelations-ID-Eigenschaft, um die Nachrichten-ID der ursprünglichen Nachricht anzugeben. Auf diese Weise bindet die Korrelations-ID die Berichts- oder Bestätigungsnachricht an die ursprüngliche Nachricht.  
  
 Die sendende Anwendung kann dann die Bestätigung oder den Bericht mit der ursprünglichen Nachricht mit entsprechen den <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft, um der ursprünglichen Nachricht identifizieren <xref:System.Messaging.Message.Id%2A> Eigenschaft.  
  
 Connectoranwendungen müssen Festlegen der <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft der Bestätigungs- und Berichtsnachrichten Nachrichten, die die Nachrichten-ID der ursprünglichen Nachricht.  
  
 Wenn Ihre Anwendung eine Antwortnachricht an die sendende Anwendung sendet, können Sie festlegen der <xref:System.Messaging.Message.CorrelationId%2A> -Eigenschaft der Antwortnachricht an die Nachrichten-ID der ursprünglichen Nachricht. Die sendende Anwendung kann dann die Antwortnachricht an die Nachricht überein, die gesendet wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht, die eine Bestellung in und aus einer Warteschlange enthält. Eine positive Bestätigung wird ausdrücklich angefordert, wenn die ursprüngliche Nachricht erreicht wurde oder wird aus der Warteschlange abgerufen.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.CorrelationId" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.CorrelationId" /> ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die für eine Meldung angegebene Zielwarteschlange ab.</summary>
        <value>Die <see cref="T:System.Messaging.MessageQueue" />, die die für die Meldung angegebene Zielwarteschlange angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.DestinationQueue%2A> Eigenschaft wird am häufigsten verwendet, um das ursprüngliche Ziel eine Nachricht zu ermitteln, die in einer Journalwarteschlange oder Dead Letter-Warteschlange empfangen. In der Regel müssen nicht Sie diese Eigenschaft zu überprüfen, da Sie in der Regel die Nachricht aus der Zielwarteschlange abgerufen werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachricht <xref:System.Messaging.Message.DestinationQueue%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.DestinationQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den symmetrischen Schlüssel für Meldungen ab, die in einer Anwendung oder für die Übermittlung an fremde Warteschlangen verschlüsselt werden.</summary>
        <value>Ein Bytearray, das den zur Verschlüsselung der Meldung verwendeten symmetrischen Zielschlüssel angibt. Der Standardwert ist ein Array der Länge 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei Szenarien müssen Sie verwenden die <xref:System.Messaging.Message.DestinationSymmetricKey%2A> Eigenschaft. Das erste ist, wenn Ihre Anwendung, anstatt Message Queuing eine Nachricht verschlüsselt. Das zweite ist beim Senden einer verschlüsselten Nachricht an eine queuing-System als Message Queuing.  
  
 Bevor Sie diese Eigenschaft festlegen, müssen Sie den symmetrischen Schlüssel mit dem öffentlichen Schlüssel des empfangenden Warteschlangen-Manager verschlüsseln. Wenn Sie eine Anwendung verschlüsselte Nachricht senden, verwendet der empfangende Warteschlangenmanager den symmetrischen Schlüssel zum Entschlüsseln der Nachricht vor dem Senden an die Zielwarteschlange an.  
  
 Wenn Sie eine Nachricht an eine fremde Warteschlange senden, wird von der entsprechenden Connector-Anwendung, die verschlüsselte Nachricht mit dem angefügten symmetrischen Schlüssel an die empfangende Anwendung weitergeleitet, zuerst die Nachricht empfangen. Es ist dann die Zuständigkeit für die empfangende Anwendung zum Entschlüsseln der Nachricht mit dem symmetrischen Schlüssel.  
  
 Beim Festlegen der <xref:System.Messaging.Message.DestinationSymmetricKey%2A> -Eigenschaft, müssen Sie auch Festlegen der <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaft. Wenn die Nachricht gesendet wird, Message Queuing ignoriert den <xref:System.Messaging.Message.DestinationSymmetricKey%2A> Eigenschaft Wenn die <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaft nicht festgelegt.  
  
 Die <xref:System.Messaging.Message.DestinationSymmetricKey%2A> Eigenschaft hat eine maximale Größe des Arrays 256.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.DestinationSymmetricKey" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die digitale Signatur ab, mit der Message Queuing die Meldung authentifiziert, oder legt diese fest.</summary>
        <value>Ein Bytearray, das die zur Authentifizierung der Meldung verwendete digitale Signatur von Message Queuing 1.0 enthält. Der Standardwert ist ein Array der Länge 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing verwendet die digitale Signatur beim Authentifizieren von Nachrichten, die von Message Queuing, Version 1.0 gesendet wurden. In den meisten Fällen generiert Message Queuing und legt die <xref:System.Messaging.Message.DigitalSignature%2A> Eigenschaft, wenn die sendende Anwendung eine Authentifizierung anfordert. Die empfangende Anwendung verwendet diese Eigenschaft, um die digitale Signatur der Nachricht abzurufen.  
  
 Sie können nur die <xref:System.Messaging.Message.DigitalSignature%2A> Eigenschaft, wenn Message Queuing, Version 2.0 ausgeführt. Wenn Authentifizierung anfordert, muss die sendende Anwendung Signaturen für Message Queuing-Version 1.0 angeben. Wenn eine Signatur für Message Queuing-Version 2.0 von die sendende Anwendung gesendet wird, enthält diese Eigenschaft einen Puffer von vier Bytes, die mit dem Wert 0.  
  
 Die <xref:System.Messaging.Message.DigitalSignature%2A> Eigenschaft zusammen mit der <xref:System.Messaging.Message.SenderCertificate%2A> -Eigenschaft, wird auch vom Connectoranwendungen verwendet, wenn eine Nachricht gesendet wird. In diesem Szenario wird die Connector-Anwendung – anstatt Message Queuing – generiert die digitale Signatur, die sie auf das Zertifikat des Benutzers senden der Nachricht beruht.  
  
 Die <xref:System.Messaging.Message.DigitalSignature%2A> Eigenschaft hat eine maximale Größe des Arrays 256.  
  
 Beim Festlegen der <xref:System.Messaging.Message.DigitalSignature%2A> -Eigenschaft, müssen Sie auch Festlegen der <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaft. Wenn eine Nachricht gesendet wird, Message Queuing ignoriert den <xref:System.Messaging.Message.DigitalSignature%2A> Eigenschaft Wenn die <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaft nicht festgelegt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.DigitalSignature" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.Message.DigitalSignature" />-Eigenschaft ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Verschlüsselungsalgorithmus ab, der zum Verschlüsseln des Meldungstextes einer privaten Meldung verwendet wird, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.EncryptionAlgorithm" />-Enumerationswerte. Der Standardwert ist <see langword="RC2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Nachricht privat ist (verschlüsselt), wird sie verschlüsselt, bevor er gesendet und beim Empfang entschlüsselt. Die <xref:System.Messaging.Message.EncryptionAlgorithm%2A> Eigenschaft gibt an, der zum Verschlüsseln des Nachrichtentextes einer privaten Nachricht verwendeten Algorithmus.  
  
 Eine Warteschlange kann erfordern, eingehende Nachrichten werden verschlüsselt. Wenn eine Anwendung sendet eine unverschlüsselte (privaten)-Nachricht an eine Warteschlange, die nur private Nachrichten akzeptiert werden oder eine private Nachricht an eine Warteschlange gesendet wird, nur Nachrichten, die nicht privaten akzeptiert, lehnt die Nachricht von die Warteschlange ab. Die sendende Anwendung kann anfordern, dass eine negative Bestätigungsnachricht in einem solchen Fall zurückgegeben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.EncryptionAlgorithm" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft weitere anwendungsspezifische, der Nachricht zugeordnete Informationen ab oder legt diese fest.</summary>
        <value>Ein Bytearray, das anwendungsspezifische, der Meldung zugeordnete Informationen bereitstellt. Der Standardwert ist ein Array der Länge 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.Extension%2A> Eigenschaft enthält anwendungsspezifische Informationen, z. B. ein großes binäres Objekt, das mit der Nachricht assoziiert ist. Es liegt in der Verantwortung der empfangenden Anwendung Interpretieren des Inhalts von den <xref:System.Messaging.Message.Extension%2A> Eigenschaft.  
  
 Wenn möglich, sollten Sie Nachrichtendaten in umfassen die <xref:System.Messaging.Message.Body%2A> -Eigenschaft der Nachricht statt über das <xref:System.Messaging.Message.Extension%2A> Eigenschaft.  
  
 Verwenden Sie bei der Arbeit mit fremden Warteschlangen die <xref:System.Messaging.Message.Extension%2A> Eigenschaft angeben, Message Queuing-Nachrichteneigenschaften, die nicht vorhanden sind.  
  
 In einem Queuing-System als Microsoft Message Queuing ist eine fremde Warteschlange vorhanden. Message Queuing kommuniziert mit solchen Warteschlangen über einen Connector-Anwendung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Extension" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.Message.Extension" />-Eigenschaft ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Formatierer ab, der zum Serialisieren und Deserialisieren eines Objekts in bzw. aus dem Nachrichtenkörper verwendet wird.</summary>
        <value>Der <see cref="T:System.Messaging.IMessageFormatter" />, der den Stream erstellt, der in den Meldungstext geschrieben oder aus diesem gelesen werden soll. Der Standardwert ist <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Messaging.Message.Formatter%2A> Eigenschaft beim Lesen und Schreiben einer Nachricht. Wenn eine Nachricht an die Warteschlange gesendet wird, serialisiert der Formatierer die <xref:System.Messaging.Message.Body%2A> Eigenschaft in einen Stream, der an die Nachrichtenwarteschlange gesendet werden kann. Beim Lesen aus einer Warteschlange deserialisiert der Formatierer die Nachrichtendaten in das <xref:System.Messaging.Message.Body%2A> Eigenschaft.  
  
 Es sei denn, Sie direkt an den Inhalt der Nachricht Schreiben der <xref:System.Messaging.Message.BodyStream%2A> Eigenschaftensatz, der <xref:System.Messaging.Message.Formatter%2A> Eigenschaft vor dem Senden der Nachricht. Wenn die <xref:System.Messaging.MessageQueue.Send%2A> Methode aufgerufen wird die <xref:System.Messaging.MessageQueue> Instanz den Text mithilfe der in enthaltenen Formatierers serialisiert wird die <xref:System.Messaging.Message.Formatter%2A> Eigenschaft. Wenn die Nachricht zu senden, ohne Angabe eines Werts für die <xref:System.Messaging.Message.Formatter%2A> -Eigenschaft, wird der Standardformatierer <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> lose verknüpft, daher ist es nicht notwendig, dass das gleiche Objekt, das auf dem Absender und Empfänger geben Sie bei Verwendung dieses Format ist. Die <xref:System.Messaging.ActiveXMessageFormatter> und <xref:System.Messaging.BinaryMessageFormatter> Serialisieren der Daten in eine binäre Darstellung. Die <xref:System.Messaging.ActiveXMessageFormatter> wird beim Senden oder Empfangen von COM-Komponenten verwendet.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Formatieren Nachrichtentexts mit <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Das folgende Codebeispiel veranschaulicht das Formatieren Nachrichtentexts mit <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.Message.Formatter" />-Eigenschaft ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zur Authentifizierung oder zur Erzeugung der digitalen Signatur einer Meldung von Message Queuing verwendeten Hashalgorithmus ab oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.HashAlgorithm" />-Enumerationswerte. Der Standardwert für Windows XP lautet <see langword="SHA" />. Andernfalls ist <see langword="MD5" /> der Standardwert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auf dem Quellcomputer verwendet Message Queuing den Hashalgorithmus für die Erstellung eine digitale Signatur für eine Nachricht. Das Ziel Warteschlangen-Manager verwendet dann denselben Hashalgorithmus auf um die Nachricht zu authentifizieren, wenn sie empfangen wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.HashAlgorithm" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die ID der Nachricht ab.</summary>
        <value>Die eindeutige Meldungs-ID, die von Message Queuing generiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing generiert eine Nachrichten-ID an, wenn die Nachricht gesendet wird. Der Bezeichner besteht aus 20 Bytes und enthält zwei Elemente: die Maschine <xref:System.Guid> des sendenden Computers und einen eindeutigen Bezeichner für die Nachricht auf dem Computer. Die Kombination beider Elemente liefert eine im Netzwerk eindeutige Nachrichten-ID.  
  
 Message Queuing generiert für alle Nachrichten, einschließlich Bestätigungs- und Berichtsnachrichten Nachrichten. Eine Bestätigungsnachricht wird von Message Queuing in der Regel als Reaktion auf den Eingang oder das Fehlschlagen einer ursprünglichen, gesendeten Nachricht gesendet. Finden Sie die <xref:System.Messaging.Message.Id%2A> Eigenschaftswert, der die ursprüngliche Nachricht in die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft eine Bestätigungsnachricht.  
  
 Sie können auch die <xref:System.Messaging.Message.Id%2A> Eigenschaft beim Senden einer Antwortnachricht an eine Antwortwarteschlange. Um die ID der ursprünglichen Nachricht in einer Antwortnachricht einzubeziehen, legen die <xref:System.Messaging.Message.CorrelationId%2A> -Eigenschaft der Antwortnachricht an die <xref:System.Messaging.Message.Id%2A> -Eigenschaft der ursprünglichen Nachricht. Die Anwendung liest die Antwortnachricht kann dann die Korrelations-ID der Antwortnachricht verwenden, um die ursprüngliche Nachricht zu identifizieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht, die eine Bestellung in und aus einer Warteschlange enthält. Eine positive Bestätigung wird ausdrücklich angefordert, wenn die ursprüngliche Nachricht erreicht wurde oder wird aus der Warteschlange abgerufen.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.Id" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass kein Timeout vorhanden ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> und <xref:System.Messaging.Message.TimeToReachQueue%2A> erfordern einen Wert, der einen Timeout angibt. Für die erste der Timeout ist die maximale Zeitspanne für eine Nachricht aus der Warteschlange empfangen werden. Für die letztgenannte Aufgabe ist das Timeout die zulässige Zeit für eine Nachricht zum Erreichen der Warteschlange. In beiden Fällen können Sie das Timeout als eine Anzahl von Sekunden angeben oder <xref:System.Messaging.Message.InfiniteTimeout> , um anzugeben, dass kein Timeout vorhanden ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Messaging.Message.InfiniteTimeout> Feld.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Meldung als erste Meldung in einer Transaktion gesendet wurde.</summary>
        <value>
          <see langword="true" />, wenn die Meldung als erste Meldung in einer Transaktion gesendet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Empfangen von Anwendungen verwenden die <xref:System.Messaging.Message.IsFirstInTransaction%2A> Eigenschaft, um sicherzustellen, dass eine Nachricht die zuerst gesendete Nachricht in einer einzelnen Transaktion für eine einzelne Warteschlange war.  
  
 Diese Eigenschaft ist nur mit Message Queuing-Version 2.0 und höher.  
  
 Um die Transaktionsgrenzen zu überprüfen, können Sie die <xref:System.Messaging.Message.IsFirstInTransaction%2A> Eigenschaft unterstützt zusammen mit zwei weitere Eigenschaften: <xref:System.Messaging.Message.IsLastInTransaction%2A> und <xref:System.Messaging.Message.TransactionId%2A>. Verwenden Sie die erste um zu überprüfen, ob eine Nachricht die zuletzt gesendete Nachricht in die Transaktion wurde, und verwenden Sie letztere, um den Bezeichner der Transaktion abzurufen.  
  
 Wenn nur eine Nachricht in einer Transaktion gesendet wird die <xref:System.Messaging.Message.IsFirstInTransaction%2A> und <xref:System.Messaging.Message.IsLastInTransaction%2A> Eigenschaften festgelegt `true`.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachricht <xref:System.Messaging.Message.IsFirstInTransaction%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.IsFirstInTransaction" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Meldung als letzte Meldung in einer Transaktion gesendet wurde.</summary>
        <value>
          <see langword="true" />, wenn die Meldung als letzte Meldung in einer Transaktion gesendet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Empfangen von Anwendungen verwenden die <xref:System.Messaging.Message.IsLastInTransaction%2A> Eigenschaft, um sicherzustellen, dass eine Nachricht die zuletzt gesendete Nachricht in einer einzelnen Transaktion für eine einzelne Warteschlange war.  
  
 Diese Eigenschaft ist nur mit Message Queuing-Version 2.0 und höher.  
  
 Um die Transaktionsgrenzen zu überprüfen, können Sie die <xref:System.Messaging.Message.IsLastInTransaction%2A> Eigenschaft unterstützt zusammen mit zwei weitere Eigenschaften: <xref:System.Messaging.Message.IsFirstInTransaction%2A> und <xref:System.Messaging.Message.TransactionId%2A>. Verwenden Sie die erste um zu überprüfen, ob eine Nachricht die zuerst gesendete Nachricht in die Transaktion wurde, und verwenden Sie letztere, um den Bezeichner der Transaktion abzurufen.  
  
 Wenn nur eine Nachricht in einer Transaktion gesendet wird die <xref:System.Messaging.Message.IsFirstInTransaction%2A> und <xref:System.Messaging.Message.IsLastInTransaction%2A> Eigenschaften festgelegt `true`.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachricht <xref:System.Messaging.Message.IsLastInTransaction%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.IsLastInTransaction" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine von der Anwendung definierte Unicode-Zeichenfolge ab, die die Nachricht beschreibt, oder legt diese fest.</summary>
        <value>Die Meldungsbezeichnung. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können eine Nachrichtenbezeichnung für mehrere Zwecke verwenden. Die Bezeichnung einer Nachricht kann beispielsweise angezeigt oder für die Verarbeitung einer von der Bezeichnung abhängigen Nachrichtenauswahl verwendet werden. Die Bezeichnung muss nicht über Nachrichten hinweg eindeutig sein.  
  
 Bezeichnungen für Nachrichtenwarteschlangen und Nachrichten sind Werte, die von der Anwendung definiert werden und die Identifikation einer Warteschlange oder Nachricht über eine Textbeschreibung ermöglichen. Es ist die Verantwortung der Anwendung, die den Inhalt der Beschriftung interpretieren, die für die Message Queuing-Anwendung keine systeminterne Bedeutung haben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachricht <xref:System.Messaging.Message.Label%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Label" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eingeführt in MSMQ 3.0. Ruft den Suchbezeichner der Meldung ab.</summary>
        <value>Der von Message Queuing generierte Suchbezeichner der Meldung ist für die Warteschlange eindeutig, in der sich die Meldung befindet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft ermöglicht den schreibgeschützten Zugriff auf eine Nachricht Nachschlage-ID ab. Nachschlage-ID, eingeführt in MSMQ 3.0 ist ein 64-Bit-Bezeichner, der vom Message Queuing generiert und auf die einzelnen Nachrichten zugewiesen werden, wenn die Nachricht in der Warteschlange platziert wird. Die Nachschlage-ID ist nicht identisch mit der Nachrichten-ID, die generiert wird, wenn die Nachricht gesendet wird.  
  
 Message Queuing generiert eine Nachschlage-ID für alle Nachrichten, die in einer beliebigen Warteschlange, einschließlich anwendungserstellte Ziel, Verwaltung und Berichtswarteschlangen sowie vom System generierte Journal unzustellbare, Connectors und die ausgehenden Warteschlangen platziert werden. Das heißt, schließt dies beiden Nachrichten, die von sendenden Anwendungen und von Message Queuing gesendet. Die Nachschlage-ID ist für die Warteschlange eindeutig und hat keine Bedeutung außerhalb der Warteschlangenobjekts.  
  
 Wenn eine Nachricht an verschiedene Zielwarteschlangen gesendet wird oder wenn eine Kopie einer Nachricht in einem Computerjournal oder Journalwarteschlange gespeichert ist, wird jede Kopie der Nachricht einen eigenen Nachschlage-ID haben, wenn er in der entsprechenden Warteschlange platziert wird.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft kann nur für Nachrichten, die aus einer Warteschlange abgerufen gelesen werden.  
  
 Nachschlage-ID wird verwendet, um eine bestimmte Nachricht in der Warteschlange gelesen. Nachdem der Nachschlage-ID der Nachricht bekannt ist, kann die empfangende Anwendung Aufrufen der <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> oder <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> Funktion, um direkt auf diese Nachricht und einsehen oder Abrufen aus der Warteschlange, im Gegensatz zu Cursor, die am Anfang der Warteschlange beginnen muss und Navigieren Sie gegen Ende der Warteschlange,  
  
 Abrufen von die Suche-IDs der Nachrichten in der Warteschlange liegt in der Verantwortung der Anwendung. Eine Möglichkeit für die Suche Bezeichner ermitteln, ist einen Trigger für die Zielwarteschlange erstellt, die eine Komponente aufruft, die die einzelnen Nachrichten-IDs werden zwischengespeichert, wie sie in der Warteschlange gespeichert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.LookupId" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Nachrichtentyp ab: <see langword="Normal" />, <see langword="Acknowledgment" /> oder <see langword="Report" />.</summary>
        <value>Einer der <see cref="P:System.Messaging.Message.MessageType" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing wird diese Eigenschaft in der Regel, wenn er die Nachricht sendet. Eine Message Queuing-Nachricht kann als einer der folgenden Typen definiert sein:  
  
-   `Normal`, die ist entweder eine typische Nachricht, die von einer Anwendung an eine Warteschlange gesendet oder eine Antwortnachricht an die sendende Anwendung zurückgegeben.  
  
-   `Acknowledgement`, die Message Queuing generiert, wenn die sendende Anwendung anfordert. Message Queuing kann positive oder negative Nachrichten erzeugen und hierdurch anzeigen, ob die ursprüngliche Nachricht empfangen oder gelesen wurde. Message Queuing sendet die entsprechende Bestätigungsnachricht an die von der sendenden Anwendung festgelegte Verwaltungswarteschlange zurück.  
  
-   `Report`, die Message Queuing generiert, wenn der Quelle des Warteschlangen-Manager eine Berichtswarteschlange definiert ist. Wenn die Verfolgung aktiviert ist, sendet Message Queuing eine Berichtsnachricht an die Message Queuing-Berichtswarteschlange, sobald die ursprüngliche Nachricht von einem Message Queuing-Server empfangen oder weitergeleitet wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachricht <xref:System.Messaging.Message.MessageType%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.MessageType" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Nachrichtenpriorität ab, die die Position der Nachricht in der Warteschlange bestimmt, oder legt diese fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.MessagePriority" />-Enumerationswerte, die die Prioritätsebenen für nicht transaktionale Meldungen darstellen. Der Standardwert ist <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.Priority%2A> Eigenschaft wirkt sich auf wie Message Queuing die Nachricht verarbeitet, während des Routings und es sich um das Ziel erreicht. Nachrichten höherer Priorität werden beim Routing bevorzugt und gegen Anfang der Zielwarteschlange eingefügt. Nachrichten mit der gleichen Priorität werden entsprechend ihrer Ankunftszeit in der Warteschlange platziert.  
  
 Sie können eine sinnvolle Priorität nur für nicht transaktionale Nachrichten festlegen. Message Queuing legt automatisch die Priorität für die transaktionale Nachrichten `Lowest`, wodurch Transaktionsnachricht Priorität, ignoriert werden sollen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird zwei Nachrichten unterschiedliche Prioritäten an die Warteschlange sendet, und sie werden später abgerufen.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Priority" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Zustellung einer Meldung im Falle eines Computerfehlers oder Netzwerkproblems sichergestellt ist, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die Übermittlung der Meldung durch Speichern auf der Festplatte während des Sendens sichergestellt wird, <see langword="false" />, wenn die Übermittlung nicht sichergestellt wird. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.Recoverable%2A> Eigenschaft gibt an, ob die Übermittlung einer Nachricht garantiert wird – selbst wenn ein Computer stürzt ab, während die Nachricht an die Zielwarteschlange gestellt wird.  
  
 Wenn Übermittlung einer Nachricht garantiert ist, wird die Nachricht lokal bei jedem Schritt entlang der Route gespeichert, bis die Nachricht erfolgreich an den nächsten Computer weitergeleitet wird. Festlegen der <xref:System.Messaging.Message.Recoverable%2A> Eigenschaft `true` kann der Durchsatz beeinträchtigt.  
  
 Falls die Nachricht transaktionsgebunden ist, die Nachricht automatisch als wiederherstellbar, unabhängig vom Wert der behandelt Message Queuing den <xref:System.Messaging.Message.Recoverable%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachricht <xref:System.Messaging.Message.Recoverable%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.Recoverable" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Warteschlange ab, die von einer Anwendung generierte Antwortnachrichten empfängt, oder legt diese fest.</summary>
        <value>Die <see cref="T:System.Messaging.MessageQueue" />, an die die von einer Anwendung generierten Antwortmeldungen zurückgesendet werden. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.ResponseQueue%2A> Eigenschaft kennzeichnet die Warteschlange, die Anwendung generierte Antwortnachrichten empfängt, die der empfangenden Anwendung an die sendende Anwendung zurückgesendet. Die sendende Anwendung gibt die Antwortwarteschlangen beim Senden von Nachrichten an. Jede verfügbare Warteschlange kann als Antwortwarteschlange ausgewählt werden.  
  
 An die Antwortwarteschlange zurückgesendete Nachrichten sind anwendungsspezifisch. Die Anwendung muss sowohl den Inhalt der Nachrichten als auch die beim Empfang durchzuführenden Aktionen festlegen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachricht <xref:System.Messaging.Message.ResponseQueue%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.ResponseQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Sicherheitskontext für eine Meldung ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Messaging.SecurityContext" />-Objekt, das den Sicherheitskontext für eine Meldung enthält, wenn die Eigenschaft zuvor festgelegt wurde, andernfalls NULL.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das zum Authentifizieren von Meldungen verwendete Sicherheitszertifikat ab oder legt dieses fest.</summary>
        <value>Ein Bytearray, das das Sicherheitszertifikat darstellt, anhand dessen Message Queuing den Sender einer Meldung überprüft. Der Standardwert ist ein Array der Länge 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die empfangende Anwendung verwendet die <xref:System.Messaging.Message.SenderCertificate%2A> Eigenschaft, wenn die Meldung ein externes Sicherheitszertifikat enthält.  
  
 Message Queuing kann einer Meldung über ein internes oder externes Sicherheitszertifikat authentifizieren. Message Queuing bietet interne Zertifikate, die verwendet werden, um die Nachrichtenintegrität sicherzustellen. Eine Zertifizierungsstelle stellt ein externes Zertifikat, die Sie über zugreifen können die <xref:System.Messaging.Message.SenderCertificate%2A> -Eigenschaft der Nachricht. Zusätzlich zu ermöglichen, Message Queuing zum Authentifizieren der Nachrichteninhalts, ermöglicht ein externes Zertifikat die empfangende Anwendung, um den Absender zu überprüfen. Ein internes Zertifikat wurde kein verwendbaren Wert an eine empfangende Anwendung.  
  
 Ein externes Zertifikat muss mit dem Verzeichnisdienst von den Message Queuing-System registriert sein. Ein externes Zertifikat enthält Informationen über die Zertifizierungsstelle, die dem Zertifikatsbenutzer, die Gültigkeitsdauer des Zertifikats, den öffentlichen Schlüssel aus dem Zertifikatsbenutzer und Signatur der Zertifizierungsstelle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.SenderCertificate" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die ID des sendenden Benutzers ab.</summary>
        <value>Ein Bytearray, das den Benutzer identifiziert. Der empfangende Warteschlangenmanager überprüft bei der Authentifizierung einer Meldung den Sender und seine Zugriffsrechte für die Warteschlange anhand der ID.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Messaging.Message.AttachSenderId%2A> Eigenschaft ist `false`, den absenderbezeichner, angegeben der <xref:System.Messaging.Message.SenderId%2A> Eigenschaft ist nicht an die Nachricht angefügt, wenn es gesendet wird. Dies zeigt Message Queuing, dass der Absender nicht überprüft werden soll, wenn er die Nachricht an die Zielwarteschlange sendet. Wenn die <xref:System.Messaging.Message.AttachSenderId%2A> Eigenschaft `true`, die <xref:System.Messaging.Message.SenderId%2A> Eigenschaftswert ist trustworthy nur, wenn die Nachricht authentifiziert wurde. Verwenden der <xref:System.Messaging.Message.Authenticated%2A> Eigenschaft in Verbindung mit der <xref:System.Messaging.Message.SenderId%2A> Eigenschaft, um die Zugriffsrechte des Absenders zu überprüfen.  
  
 Connector-Anwendung ist eine Anwendung, die Connector-Server verwendet wird, um die Kommunikation zwischen Message Queuing und anderen warteschlangensysteme bereitstellen. Message Queuing erfordert Connectoranwendungen für die Identifizierung des Absenders. Sie müssen festlegen, die <xref:System.Messaging.Message.ConnectorType%2A> Eigenschaft beim Senden einer Nachricht über einen Connector-Anwendung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.SenderId" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Version von Message Queuing ab, mit der die Meldung gesendet wurde.</summary>
        <value>Die Version von Message Queuing, mit der die Meldung gesendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.SenderVersion%2A> Eigenschaft ist für bestimmte Features von Bedeutung. Z. B. transaktionsverarbeitung wird nur von Message Queuing 2.0 und höher unterstützt und digitale Signaturen werden verwendet, um Nachrichten von MSMQ 1.0 zu authentifizieren.  
  
 Der sendende Warteschlangen-Manager legt die <xref:System.Messaging.Message.SenderVersion%2A> Eigenschaft, wenn die Nachricht gesendet wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachricht <xref:System.Messaging.Message.SenderVersion%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.SenderVersion" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Datum und Uhrzeit auf dem sendenden Computer ab, zu der die Nachricht vom Quellwarteschlangen-Manager gesendet wurde.</summary>
        <value>Die <see cref="T:System.DateTime" /> stellt den Zeitpunkt dar, zu dem die Meldung gesendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.SentTime%2A> Eigenschaft angepasst wird, in der lokalen Zeit des Computers, auf dem diese Instanz die <xref:System.Messaging.Message> Klasse erstellt wurde. Diese Zeitzone kann sich von der Quell- und die Zielwarteschlangen sein.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachricht <xref:System.Messaging.Message.SentTime%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.SentTime" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Computer ab, von dem die Meldung ausging.</summary>
        <value>Der Name des Computers, von dem die Meldung gesendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Format der <xref:System.Messaging.Message.SourceMachine%2A> Eigenschaft enthält keine umgekehrten Schrägstriche (\\\\). Beispielsweise `myServer` ist ein gültiger <xref:System.Messaging.Message.SourceMachine%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachricht <xref:System.Messaging.Message.SourceMachine%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.SourceMachine" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Es konnte nicht auf die Computerinformationen oder den Verzeichnisdienst zugegriffen werden.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeitbegrenzung für den Empfang der Meldung aus der Zielwarteschlange ab oder legt diese fest.</summary>
        <value>Die für eine gesendete Meldung vorgegebene Gesamtzeit bis zum Empfang aus der Zielwarteschlange. Der Standardwert ist <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschaft gibt die Gesamtzeit für eine gesendete Nachricht aus der Zielwarteschlange empfangen werden soll. Das Zeitlimit umfasst die Zeit an, der für das Aufrufen von der Zielwarteschlange und die Zeit in der Warteschlange darauf warten, bevor die Nachricht empfangen wird.  
  
> [!CAUTION]
>  Bei der abhängigen Clientcomputer verwenden, achten Sie darauf, dass die Uhr auf dem Clientcomputer mit der Uhr auf dem Server synchronisiert wird, auf denen Message Queuing ausgeführt wird. Andernfalls zu einem unvorhersehbaren Verhalten unter Umständen beim Senden einer Nachricht, deren <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschaft ist nicht <xref:System.Messaging.Message.InfiniteTimeout>.  
  
 Wenn das Intervall, wird angegeben die <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschaft abläuft, bevor die Nachricht aus der Warteschlange entfernt wird, Message Queuing verwirft die Nachricht in einer von zwei Methoden. Wenn die <xref:System.Messaging.Message.UseDeadLetterQueue%2A>-Eigenschaft auf `true` festgelegt ist, wird die Nachricht an die Dead Letter-Warteschlange gesendet. Wenn <xref:System.Messaging.Message.UseDeadLetterQueue%2A> ist `false`, die Nachricht wird ignoriert.  
  
 Sie können festlegen, dass der Nachricht <xref:System.Messaging.Message.AcknowledgeType%2A> Eigenschaft, um anzufordern, dass eine negative Bestätigungsnachricht Message Queuing gesendet werden an die sendende Anwendung sichern, wenn die Nachricht vor Ablauf des Zeitgebers nicht abgerufen werden.  
  
 Wenn der Wert der <xref:System.Messaging.Message.TimeToBeReceived%2A> -Eigenschaft ist kleiner als der Wert von der <xref:System.Messaging.Message.TimeToReachQueue%2A> Eigenschaft <xref:System.Messaging.Message.TimeToBeReceived%2A> hat Vorrang vor.  
  
 Wenn mehrere Nachrichten in einer einzelnen Transaktion gesendet werden, verwendet Message Queuing den <xref:System.Messaging.Message.TimeToBeReceived%2A> -Eigenschaft der ersten Nachricht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachricht <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.TimeToBeReceived" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">Der für <see cref="P:System.Messaging.Message.TimeToBeReceived" /> angegebene Wert ist ungültig.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeitbegrenzung der Nachricht für das Erreichen der Warteschlange ab oder legt diese fest.</summary>
        <value>Die maximale Dauer zwischen dem Absenden der Meldung und dem Erreichen der Zielwarteschlange. Der Standardwert ist <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Intervall, wird angegeben die <xref:System.Messaging.Message.TimeToReachQueue%2A> Eigenschaft abläuft, bevor die Nachricht das Ziel erreicht hat, Message Queuing verwirft die Nachricht in einer von zwei Methoden. Wenn die <xref:System.Messaging.Message.UseDeadLetterQueue%2A>-Eigenschaft auf `true` festgelegt ist, wird die Nachricht an die Dead Letter-Warteschlange gesendet. Wenn <xref:System.Messaging.Message.UseDeadLetterQueue%2A> ist `false`, die Nachricht wird ignoriert.  
  
 Sie können festlegen, He-Nachricht <xref:System.Messaging.Message.AcknowledgeType%2A> Eigenschaft, um anzufordern, dass Message Queuing eine negative Bestätigung-Nachricht zu senden an die sendende Anwendung sichern, wenn Sie die Nachricht nicht vor Ablauf des Zeitgebers.  
  
 Wenn der <xref:System.Messaging.Message.TimeToReachQueue%2A> Eigenschaft auf 0 Sekunden festgelegt ist, Message Queuing zum Senden der Nachricht an ihr Ziel einmal versucht, wenn die Nachricht die Warteschlange wartet. Wenn die Warteschlange lokal ist, erreicht die Nachricht immer es.  
  
 Wenn der Wert der <xref:System.Messaging.Message.TimeToReachQueue%2A> -Eigenschaft ist größer als der Wert von der <xref:System.Messaging.Message.TimeToBeReceived%2A> Eigenschaft <xref:System.Messaging.Message.TimeToBeReceived%2A> hat Vorrang vor.  
  
 Wenn mehrere Nachrichten in einer einzelnen Transaktion gesendet werden, verwendet Message Queuing den <xref:System.Messaging.Message.TimeToReachQueue%2A> -Eigenschaft der ersten Nachricht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachricht <xref:System.Messaging.Message.TimeToReachQueue%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.TimeToReachQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <exception cref="T:System.ArgumentException">Der für <see cref="P:System.Messaging.Message.TimeToReachQueue" /> angegebene Wert ist ungültig. Eventuell wurde ein negativer Wert angegeben.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die ID der Transaktion ab, in der die Meldung gesendet wurde.</summary>
        <value>Der Bezeichner der der Meldung zugeordneten Transaktion.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Empfangen von Anwendungen verwenden die <xref:System.Messaging.Message.TransactionId%2A> Eigenschaft, um sicherzustellen, dass eine Nachricht als Teil einer bestimmten Transaktion gesendet wurde. Die Transaktions-ID enthält den Bezeichner des sendenden Computers (erste 16 Bits) gefolgt von einem 4-Byte-Transaktionssequenznummer.  
  
 Diese Eigenschaft ist nur für Message Queuing-Version 2.0 und höher verfügbar.  
  
 Transaktions-IDs sind nicht unbedingt eindeutig, da transaktionssequenznummern nicht dauerhaft gespeichert werden, und sie dann wieder auf 2 startet <sup>20</sup>. Message Queuing garantiert nur, dass nachfolgende Transaktionen unterschiedliche transaktionssequenznummern vorhanden sind.  
  
 Können Sie die <xref:System.Messaging.Message.TransactionId%2A> Eigenschaft zusammen mit der <xref:System.Messaging.Message.IsFirstInTransaction%2A> und <xref:System.Messaging.Message.IsLastInTransaction%2A> Eigenschaften Transaktionsgrenzen zu überprüfen.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachricht <xref:System.Messaging.Message.TransactionId%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.TransactionId" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Transaktionsstatus-Warteschlange auf dem Quellcomputer ab.</summary>
        <value>Die Transaktionsstatus-Warteschlange auf dem Quellcomputer, die für das Senden von Bestätigungsmeldungen an die sendende Anwendung verwendet wird. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.TransactionStatusQueue%2A> Eigenschaft identifiziert, die transaktionale Warteschlange auf dem Quellcomputer, die lesen-Empfangsbestätigungen vom Connectoranwendungen empfängt. Message Queuing legt die Eigenschaft fest, und Connectoranwendungen verwenden die Eigenschaft aus, wenn Fremdschlüssel Warteschlangen gesendete Transaktionsnachrichten abrufen.  
  
 In einem Queuing-System als Microsoft Message Queuing ist eine fremde Warteschlange vorhanden. Message Queuing kommuniziert mit solchen Warteschlangen über einen Connector-Anwendung.  
  
 Die Connector-Anwendung kann die Transaktionsstatus-Warteschlange zum Senden von Bestätigungsnachrichten an die sendende Anwendung verwenden. Die Transaktionsstatus-Warteschlange sollten diese Bestätigungen erhalten, selbst wenn die sendende Anwendung keine andere Bestätigungen anfordert.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachricht <xref:System.Messaging.Message.TransactionStatusQueue%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Meldung wurde nicht gesendet. Diese Eigenschaft kann nur bei Meldungen gelesen werden, die aus einer Warteschlange abgerufen wurden.  
  
 - oder -   
  
 Die <see cref="P:System.Messaging.Message.TransactionStatusQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Meldung vor dem Absenden authentifiziert wurde oder authentifiziert werden muss, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die sendende Anwendung die Authentifizierung der Meldung angefordert hat, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.UseAuthentication%2A> Eigenschaft gibt an, ob die Nachricht authentifiziert werden muss. Wenn die sendende Anwendung, Authentifizierung anfordert, Message Queuing eine digitale Signatur erstellt und verwendet, um die Nachricht signieren, wenn es gesendet wird und die Nachricht zu authentifizieren, wenn sie empfangen werden.  
  
 Wenn <xref:System.Messaging.Message.UseAuthentication%2A> ist `false` und eine Nachricht an eine Warteschlange, die nur authentifizierte Nachrichten akzeptiert werden, die Nachricht wird beim Erreichen der Warteschlange abgelehnt.  
  
 Sie können nicht feststellen, ob eine Nachricht Fehler bei der Authentifizierung durch einen Blick auf ihre Eigenschaften. Message Queuing werden solche Nachrichten verworfen, bevor sie an die Warteschlange übermittelt werden. Allerdings können Sie anfordern, dass eine Bestätigungsnachricht gesendet werden, wenn ein Zustellungsfehler verhindert, dass eine Nachricht in die Warteschlange eingeht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.UseAuthentication" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine Kopie der nicht zustellbaren Meldung an eine Dead Letter-Warteschlange gesendet werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn bei einem Fehler bei der Meldungsübermittlung eine Kopie der Meldung an die Warteschlange für unzustellbare Nachrichten gesendet werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.UseJournalQueue%2A> und <xref:System.Messaging.Message.UseDeadLetterQueue%2A> Eigenschaften angeben, wie Message Queuing eine Nachricht protokolliert. Wenn <xref:System.Messaging.Message.UseDeadLetterQueue%2A> ist `true`, Unzustellbarkeit (eine nicht transaktionale Nachricht), wird die Nachricht an die nicht transaktionale Dead Letter-Warteschlange auf dem Computer gesendet werden, die die Nachricht nicht zustellen konnte. Zustellungsfehler kann durch eine Nachricht Zeitgeber abläuft, z. B. verursacht werden.  
  
 Im Fall der Zustellfehler für eine transaktionale Nachricht sendet Message Queuing die Nachricht an die transaktionale Dead Letter-Warteschlange auf dem Quellcomputer in allen Fällen von negativen und unsichere.  
  
 Wenn Sie in einer Warteschlange für unzustellbare Nachrichten speichern, sollten Sie deaktivieren die Warteschlange in regelmäßigen Abständen, um Nachrichten zu entfernen, die nicht mehr benötigt werden. Nachrichten in Warteschlangen für unzustellbare Anzahl für das Kontingent für den Computer, auf dem sich die Warteschlange befindet. Das Computerkontingent wird vom Administrator festgelegten und bezieht sich auf die Größe, die zum Speichern von Nachrichten auf dem gesamten Computer, nicht nur in einer einzelnen Warteschlange zugeordnet.  
  
 Sie keiner Journalwarteschlange oder Dead Letter-Warteschlange erstellen. Hierbei handelt es sich um Systemwarteschlangen, die Message Queuing generiert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachricht <xref:System.Messaging.Message.UseDeadLetterQueue%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.UseDeadLetterQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Meldung als privat behandelt werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn Message Queuing die Meldung verschlüsseln soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Nachricht privat ist, ist Text verschlüsselt, bevor er gesendet und entschlüsselt, wenn sie empfangen werden. Um einer privaten Nachricht senden zu können, muss die sendende Anwendung angeben, die Verschlüsselung verwendet werden und optional den Verschlüsselungsalgorithmus.  
  
 Beim private Nachrichten senden zu können, muss Ihre Anwendung nicht führen Sie die Verschlüsselung von Nachrichten. Message Queuing können Sie den Nachrichtentext verschlüsseln, wenn Ihre Anwendung Nachrichten in einer Microsoft Windows 2000-Unternehmen, sendet die Zugriff auf den Verzeichnisdienst verfügt. Wenn Sie private Nachrichten zu empfangen, entschlüsselt der empfangende Warteschlangenmanager immer den Nachrichtentext.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachricht <xref:System.Messaging.Message.UseEncryption%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.UseEncryption" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine Kopie der Meldung in einem Journal auf dem sendenden Computer abgelegt werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn nach erfolgreicher Übermittlung vom sendenden Computer an den nächsten Server eine Kopie der Meldung in einem Journal auf dem sendenden Computer abgelegt werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.UseJournalQueue%2A> und <xref:System.Messaging.Message.UseDeadLetterQueue%2A> Eigenschaften angeben, wie Message Queuing eine Nachricht protokolliert. Wenn <xref:System.Messaging.Message.UseJournalQueue%2A> ist `true`, und klicken Sie dann eine Kopie in das Computerjournal auf dem ursprünglichen Computer bei jedem Schritt gehalten wird, dass eine Nachricht gesendet wird.  
  
 Die gesendete Nachricht wird nur in die Journalwarteschlange kopiert, wenn die Zielwarteschlange auf einem Remotecomputer ist. Wenn das Ziel auf dem lokalen Computer ist, wird die Nachricht direkt an die Warteschlange gesendet; Es gibt keine Zwischenschritte Journal erforderlich ist.  
  
 Beim Speichern von Nachrichten in eine Journalwarteschlange deaktivieren Sie die Warteschlange in regelmäßigen Abständen, um Nachrichten zu entfernen, die nicht mehr benötigt werden. Nachrichten in Journal Warteschlangen Anzahl für das Kontingent für den Computer, auf dem sich die Warteschlange befindet. (Das Computerkontingent wird vom Administrator festgelegt.)  
  
 Sie keiner Journalwarteschlange oder Dead Letter-Warteschlange erstellen. Hierbei handelt es sich um Systemwarteschlangen, die Message Queuing generiert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachricht <xref:System.Messaging.Message.UseJournalQueue%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.UseJournalQueue" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine Meldung während der Weiterleitung an die Zielwarteschlange verfolgt wird, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn bei jeder Zwischenstation der Originalmeldung bis zum Erreichen der Zielwarteschlange ein Bericht generiert und an die Berichtswarteschlange des Systems gesendet werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.Message.UseTracing%2A> Eigenschaft gibt an, ob die Route einer Nachricht verfolgen, wie die Weiterleitung an die Zielwarteschlange verschoben. Wenn `true`, jedes Mal, die die Nachricht eine Message Queuing-routing-Server durchläuft eine berichtsnachricht (von Message Queuing generiert) an eine Berichtswarteschlange gesendet. Die Berichtswarteschlange wird vom Quellwarteschlangen-Manager angegeben. Berichtswarteschlangen sind nicht für Berichtnachrichten, die von Message Queuing generierte beschränkt. Ihre Anwendung generierte Nachrichten können auch auf Berichtswarteschlangen gesendet werden.  
  
 Verwenden der Ablaufverfolgung umfasst die Active Directory einrichten und eine Berichtswarteschlange für die Message Queuing-Organisation angeben. Der Administrator konfiguriert diese Einstellungen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachricht <xref:System.Messaging.Message.UseTracing%2A> Eigenschaft.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.UseTracing" />-Eigenschaft wird aufgrund eines für die Meldungswarteschlange gesetzten Filters ignoriert.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>