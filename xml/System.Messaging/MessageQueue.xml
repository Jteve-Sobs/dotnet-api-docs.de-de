<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f362dd97709b65574ff7b9474682818d0cb2c4b1" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32038293" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht den Zugriff auf eine Warteschlange auf einem Message Queuing-Server.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Message Queuing-Technologie ermöglicht Anwendungen, die zu unterschiedlichen Zeiten ausgeführt werden, kommunizieren über heterogene Netzwerke und Systeme, die möglicherweise vorübergehend offline. Anwendungen senden, empfangen und Einsehen von Nachrichten aus Warteschlangen (Lesen ohne zu entfernen). Message Queuing ist eine optionale Komponente des [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] und Windows NT, und müssen separat installiert werden.  
  
 Die <xref:System.Messaging.MessageQueue> Klasse ist ein Wrapper für Message Queuing. Es gibt mehrere Versionen der Message Queuing und die Nutzung der <xref:System.Messaging.MessageQueue> Klasse geringfügig anderes Verhalten führen kann, verwenden Sie je nach Betriebssystem. Informationen über bestimmte Funktionen jeder Version von Message Queuing finden Sie unter dem Thema "Neuheiten Message Queuing" im Plattform-SDK in MSDN.  
  
 Die <xref:System.Messaging.MessageQueue> Klasse stellt einen Verweis auf eine Message Queuing-Warteschlange. Sie können einen Pfad im Angeben der <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor zur Verbindung mit einer vorhandenen Ressource ist, oder Sie können eine neue Warteschlange erstellen, auf dem Server. Bevor Sie aufrufen können <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, oder <xref:System.Messaging.MessageQueue.Receive%2A>, müssen Sie die neue Instanz der Zuordnen der <xref:System.Messaging.MessageQueue> -Klasse mit einer vorhandenen Warteschlange. An diesem Punkt können Sie ändern die Eigenschaften der Warteschlange wie z. B. <xref:System.Messaging.MessageQueue.Category%2A> und <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue> unterstützt zwei Arten von Nachrichtenabruf: synchrone und asynchrone. Die synchronen Methoden <xref:System.Messaging.MessageQueue.Peek%2A> und <xref:System.Messaging.MessageQueue.Receive%2A>, dazu führen, dass Prozessthreads warten ein angegebenen Zeitintervalls für eine neue Nachricht in der Warteschlange eintreffen. Die asynchronen Methoden <xref:System.Messaging.MessageQueue.BeginPeek%2A> und <xref:System.Messaging.MessageQueue.BeginReceive%2A>, ermöglichen die Hauptassembly der Anwendungsaufgaben in einem separaten Thread fortgesetzt, bis eine Nachricht in der Warteschlange eingeht. Diese Methoden funktionieren mithilfe von Rückrufobjekten und Zustandsobjekte zur Übermittlung von Informationen zwischen Threads.  
  
 Eine neue Instanz der beim Erstellen der <xref:System.Messaging.MessageQueue> -Klasse, erstellen Sie keine neue Message Queuing-Warteschlange. Stattdessen können Sie die <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, und <xref:System.Messaging.MessageQueue.Purge%2A> Methoden zum Verwalten von Warteschlangen auf dem Server.  
  
 Im Gegensatz zu <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> und <xref:System.Messaging.MessageQueue.Delete%28System.String%29> sind `static` Member, damit Sie sie aufrufen können, ohne dass erstellt eine neue Instanz der dem <xref:System.Messaging.MessageQueue> Klasse.  
  
 Sie können festlegen, die <xref:System.Messaging.MessageQueue> des Objekts <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft mit einem der drei Namen: der angezeigte Name der <xref:System.Messaging.MessageQueue.FormatName%2A>, oder die <xref:System.Messaging.MessageQueue.Label%2A>. Der Anzeigename, der von der Warteschlange definiert ist <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaften ist <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> für eine öffentliche Warteschlange und <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> für eine private Warteschlange. Die <xref:System.Messaging.MessageQueue.FormatName%2A> Eigenschaft ermöglicht den Offlinezugriff auf Warteschlangen. Schließlich können Sie der Warteschlange <xref:System.Messaging.MessageQueue.Label%2A> -Eigenschaft zum Festlegen der Warteschlange <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Eine Liste der anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.MessageQueue>, finden Sie unter der <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt neuer <xref:System.Messaging.MessageQueue> -Objekte mit verschiedenen Pfad benennen Syntax von Typen. In jedem Fall sendet er eine Nachricht an die Warteschlange, deren Pfad im Konstruktor definiert ist.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 Im folgenden Codebeispiel wird eine Nachricht an eine Warteschlange sendet und empfängt eine Nachricht aus einer Warteschlange mit einer anwendungsspezifischen Klasse mit dem Namen `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Nur die <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> Methode ist threadsicher.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse. Nach dem Initialisieren der neuen Instanz durch den Standardkonstruktor muss die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft festgelegt werden, bevor die Instanz verwendet werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, erstellen Sie eine neue Instanz der dem <xref:System.Messaging.MessageQueue> -Klasse, die nicht sofort an eine Warteschlange auf dem Message Queuing-Server verbunden ist. Vor der Verwendung dieser Instanz an, Sie müssen auch Verbinden mit einer vorhandenen Message Queuing-Warteschlange durch Festlegen der <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft. Sie können alternativ Festlegen der <xref:System.Messaging.MessageQueue> einen Verweis auf die <xref:System.Messaging.MessageQueue.Create%28System.String%29> Rückgabewert der Methode, wodurch eine neue Message Queuing-Warteschlange.  
  
 Die <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor instanziiert eine neue Instanz der dem <xref:System.Messaging.MessageQueue> -Klasse werden keine neue Message Queuing-Warteschlange erstellt.  
  
 In der folgenden Tabelle zeigt die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.MessageQueue>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Die von den Standardkonstruktor des festgelegten Werte der <xref:System.Messaging.DefaultPropertiesToSend> Klasse.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Die von den Standardkonstruktor des festgelegten Werte der <xref:System.Messaging.MessagePropertyFilter> Klasse. Die Filterwerte werden festgelegt, um `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein neues <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse, die auf die Message Queuing-Warteschlange am angegebenen Pfad verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn die neue einbinden möchten <xref:System.Messaging.MessageQueue> Instanz mit einer bestimmten Message Queuing-Warteschlange für das kennen Sie den Pfad, den Formatnamen oder die Bezeichnung. Wenn Sie exklusiven Zugriff auf die erste Anwendung gewähren möchten, die auf die Warteschlange verweist, müssen Sie festlegen der <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Eigenschaft `true` oder verwenden Sie den Konstruktor, der einen Lesezugriff Einschränkungsparameter übergibt.  
  
 Die <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor instanziiert eine neue Instanz der dem <xref:System.Messaging.MessageQueue> -Klasse werden keine neue Message Queuing-Warteschlange erstellt. Verwenden Sie zum Erstellen einer neuen Warteschlange in Message Queuing <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Die Syntax der `path` Parameter hängt vom Typ der Warteschlange für diese Verweise, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
|Computer-Journalwarteschlange|`MachineName`\\`Journal$`|  
|Computer, Warteschlange für unzustellbare|`MachineName`\\`Deadletter$`|  
|Computer Transaktionswarteschlange für unzustellbare|`MachineName`\\`XactDeadletter$`|  
  
 Alternativ können Sie die <xref:System.Messaging.MessageQueue.FormatName%2A> oder <xref:System.Messaging.MessageQueue.Label%2A> den Warteschlangenpfad zu beschreiben, wie in der folgenden Tabelle gezeigt.  
  
|Referenz|Syntax|Beispiel|  
|---------------|------------|-------------|  
|Formatname|`FormatName:` [ *Formatnamen* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Bezeichnung|`Label:` [ *label* ]|`Label:` TheLabel|  
  
 Um offline zu arbeiten, müssen Sie die formatnamenssyntax nicht der pfadnamensyntax des Konstruktors verwenden. Andernfalls wird eine Ausnahme ausgelöst, da der primäre Domänencontroller nicht verfügbar ist, zum Auflösen des Pfads in den Formatnamen ist.  
  
 In der folgenden Tabelle zeigt die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.MessageQueue>. Diese Werte basieren auf den Eigenschaften des Message Queuing-Warteschlange mit dem Pfad, der gemäß der `path` Parameter.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Die von den Standardkonstruktor des festgelegten Werte der <xref:System.Messaging.DefaultPropertiesToSend> Klasse.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, wenn Datenschutzebene für die Message Queuing-Warteschlange "Body"; andernfalls `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Der Wert des Name-Eigenschaft für die Message Queuing-Warteschlange Computer.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Die von den Standardkonstruktor des festgelegten Werte der <xref:System.Messaging.MessagePropertyFilter> Klasse.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, wenn nicht vom Konstruktor festgelegt.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, wenn nicht vom Konstruktor festgelegt.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, wenn das Message Queuing-Objekt Journal-Einstellung aktiviert ist; andernfalls `false`.|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt neuer <xref:System.Messaging.MessageQueue> -Objekte mit verschiedenen Pfad benennen Syntax von Typen. In jedem Fall sendet er eine Nachricht an die Warteschlange, deren Pfad im Konstruktor definiert ist.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft ist ungültig. Möglicherweise wurde sie nicht festgelegt.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser kann für den lokalen Computer "." lauten.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" />, wenn der ersten Anwendung, die auf die Warteschlange zugreift, exklusiver Zugriff gewährt werden soll, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse mit der angegebenen Lesezugriffsbeschränkung, die auf die Message Queuing-Warteschlange unter dem angegebenen Pfad verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn die neue einbinden möchten <xref:System.Messaging.MessageQueue> mit einer bestimmten Message Queuing-Warteschlange für das kennen Sie den Pfad, den Formatnamen oder die Bezeichnung. Wenn Sie exklusiven Zugriff auf die erste Anwendung gewähren möchten, die auf die Warteschlange verweist, legen Sie die `sharedModeDenyReceive` Parameter `true`. Legen Sie andernfalls `sharedModeDenyReceive` auf `false` oder verwenden Sie den Konstruktor aus, die nur eine `path` Parameter.  
  
 Festlegen von `sharedModeDenyReceive` auf `true` wirkt sich auf alle Objekte, die die Message Queuing-Warteschlange, einschließlich von anderen Anwendungen zugreifen. Die Auswirkungen des Parameters sind nicht auf diese Anwendung beschränkt.  
  
 Die <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor erstellt eine neue Instanz der dem <xref:System.Messaging.MessageQueue> -Klasse werden keine neue Message Queuing-Warteschlange erstellt. Verwenden Sie zum Erstellen einer neuen Warteschlange in Message Queuing <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Die Syntax der `path` Parameter hängt vom Typ der Warteschlange.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
|Computer-Journalwarteschlange|`MachineName`\\`Journal$`|  
|Computer, Warteschlange für unzustellbare|`MachineName`\\`Deadletter$`|  
|Computer Transaktionswarteschlange für unzustellbare|`MachineName`\\`XactDeadletter$`|  
  
 Alternativ können Sie den Warteschlangenpfad beschreiben die Formatnamen oder die Bezeichnung einer Message Queuing-Warteschlange.  
  
|Referenz|Syntax|Beispiel|  
|---------------|------------|-------------|  
|Formatname|`FormatName:` [ *Formatnamen* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Bezeichnung|`Label:` [ *label* ]|`Label:` TheLabel|  
  
 Um offline zu arbeiten, müssen Sie die formatnamenssyntax, anstatt die Anzeigenamen-Syntax verwenden. Andernfalls wird eine Ausnahme ausgelöst, da der primäre Domänencontroller (Active Directory auf dem befindet) nicht zum Auflösen des Pfads in den Formatnamen verfügbar ist.  
  
 Wenn eine <xref:System.Messaging.MessageQueue> eine Warteschlange öffnet und die `sharedModeDenyReceive` Parameter festgelegt wird, um `true`, stellen alle <xref:System.Messaging.MessageQueue> , anschließend versucht, aus der Warteschlange gelesen generiert eine <xref:System.Messaging.MessageQueueException> wegen der freigabeverletzung. Ein <xref:System.Messaging.MessageQueueException> wird auch ausgelöst, wenn eine <xref:System.Messaging.MessageQueue> versucht, die auf die Warteschlange im exklusiven Modus während eine andere <xref:System.Messaging.MessageQueue> bereits nicht exklusiven Zugriff auf die Warteschlange verfügt.  
  
 In der folgenden Tabelle zeigt die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.MessageQueue>. Diese Werte basieren auf den Eigenschaften des Message Queuing-Warteschlange mit dem Pfad, der gemäß der `path` Parameter.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Die von den Standardkonstruktor des festgelegten Werte der <xref:System.Messaging.DefaultPropertiesToSend> Klasse.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, wenn Datenschutzebene für die Message Queuing-Warteschlange "Body"; andernfalls `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Der Wert des Name-Eigenschaft für die Message Queuing-Warteschlange Computer.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Die von den Standardkonstruktor des festgelegten Werte der <xref:System.Messaging.MessagePropertyFilter> Klasse.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, wenn nicht vom Konstruktor festgelegt.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, wenn nicht vom Konstruktor festgelegt.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|Der Wert des `sharedModeDenyReceive`-Parameters.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, wenn das Message Queuing-Objekt Journal-Einstellung aktiviert ist; andernfalls `false`.|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein neues <xref:System.Messaging.MessageQueue> mit exklusivem Zugriff legt den Pfad und sendet eine Nachricht an die Warteschlange.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft ist ungültig. Möglicherweise wurde sie nicht festgelegt.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser kann für den lokalen Computer "." lauten.</param>
        <param name="accessMode">Einer der <see cref="T:System.Messaging.QueueAccessMode" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser kann für den lokalen Computer "." lauten.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" />, wenn der ersten Anwendung, die auf die Warteschlange zugreift, exklusiver Zugriff gewährt werden soll, andernfalls <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" />, wenn ein Verbindungscache erstellt und verwendet wird, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel erstellt ein neues <xref:System.Messaging.MessageQueue> mit exklusivem Lesezugriff und Zwischenspeichern von Verbindungen aktiviert.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser kann für den lokalen Computer "." lauten.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" />, wenn der ersten Anwendung, die auf die Warteschlange zugreift, exklusiver Zugriff gewährt werden soll, andernfalls <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" />, wenn ein Verbindungscache erstellt und verwendet wird, andernfalls <see langword="false" />.</param>
        <param name="accessMode">Einer der <see cref="T:System.Messaging.QueueAccessMode" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den Zugriffsmodus für die Warteschlange angibt.</summary>
        <value>Einer der <see cref="T:System.Messaging.QueueAccessMode" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardmodus für den Zugriff für eine Warteschlange ist `QueueAccessMode.SendAndReceive`, es sei denn, Sie nichts anderes angeben, wenn der Konstruktor aufgerufen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Warteschlange nur authentifizierte Meldungen akzeptiert, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die Warteschlange nur authentifizierte Meldungen akzeptiert, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Nachrichtenauthentifizierung bietet eine Möglichkeit, um die Nachrichtenintegrität sicherzustellen und zu überprüfen, ob Absender der Nachricht. Um eine Authentifizierung anzufordern, legt die sendende Anwendung der meldungsauthentifizierungsebene fest.  
  
 Bei Festlegung <xref:System.Messaging.MessageQueue.Authenticate%2A> auf `true`, sind Sie restriktive Zugriff auf die Warteschlange auf dem Server, nicht nur auf diese <xref:System.Messaging.MessageQueue> Instanz. Alle Clients, die für die gleichen Message Queuing-Warteschlange arbeiten sind betroffen.  
  
 Eine Warteschlange, die nur authentifizierte Nachrichten akzeptiert werden, weist eine nicht authentifizierte Nachricht zurück. Benachrichtigung Nachricht Ablehnung anfordern eine sendende Anwendung festgelegt werden kann die <xref:System.Messaging.Message.AcknowledgeType%2A> -Eigenschaft der Nachricht. Da keine andere Angabe Ablehnung der Nachricht vorhanden ist, kann die sendende Anwendung die Nachricht verlieren, es sei denn, Sie fordern, dass sie an die Dead Letter-Warteschlange gesendet werden.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.Authenticate%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Basispriorität an, die von Message Queuing beim Weiterleiten von Meldungen einer öffentlichen Warteschlange über das Netzwerk verwendet wird, oder legt diese fest.</summary>
        <value>Die einzige Basispriorität für alle an die (öffentliche) Warteschlange gesendeten Meldungen. Der Standardwert ist null (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Nachrichtenwarteschlange Basispriorität festlegt, wie eine Meldung an, die Warteschlange behandelt wird, während der Übertragung über das Netzwerk. Sie können festlegen, die <xref:System.Messaging.MessageQueue.BasePriority%2A> Eigenschaft, um eine höhere oder niedrigere Priorität auf alle Nachrichten an die angegebene Warteschlange weichen gesendet, um andere Warteschlangen zu gewähren. Durch Festlegen dieser Eigenschaft ändert die Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind.  
  
 Einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.BasePriority%2A> bezieht sich nicht auf die <xref:System.Messaging.Message.Priority%2A> Eigenschaft einer Nachricht, die die Reihenfolge angibt, in dem eine eingehende Nachricht in der Warteschlange platziert wird.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> gilt nur für Öffentliche Warteschlangen, deren Pfade mit dem Formatnamen angegeben werden. Die Basispriorität einer privaten Warteschlange ist immer 0 (null).  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.BasePriority%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Basispriorität wurde auf einen ungültigen Wert festgelegt.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <summary>Initiiert einen asynchronen Lesevorgang, indem Message Queuing angewiesen wird, mit dem Einsehen einer Meldung zu beginnen und nach Abschluss des Vorgangs den Ereignishandler zu benachrichtigen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiiert einen asynchronen Lesevorgang ohne Timeout. Die Operation wird erst abgeschlossen, wenn eine Meldung in der Warteschlange verfügbar ist.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginPeek%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis aus, wenn eine Nachricht in der Warteschlange verfügbar wird.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Mit <xref:System.Messaging.MessageQueue.BeginPeek%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und Ihre Ereignisdelegaten zuordnen. <xref:System.Messaging.MessageQueue.BeginPeek%2A> initiiert einen asynchronen Lesevorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, durch das Auslösen von der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> oder durch Abrufen des Ergebnisses über die <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> ist asynchron, Sie können ihn aufrufen zum Einsehen der Warteschlange, ohne dass blockiert den aktuellen Thread der Ausführung. Verwenden Sie zum synchronen Einsehen der Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginPeek%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, wird das Abschlussereignis ausgelöst, aber eine Ausnahme wird ausgelöst, wenn der Aufruf von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Ereignishandler namens `MyPeekCompleted`, fügt es der <xref:System.Messaging.MessageQueue.PeekCompleted> eventhandlerdelegaten und ruft <xref:System.Messaging.MessageQueue.BeginPeek%2A> um einen asynchronen Lesevorgang in der Warteschlange zu initiieren, die unter dem Pfad befindet ". \myQueue". Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst, die im Beispiel sieht die Nachricht und schreibt Text auf dem Bildschirm. Das Beispiel ruft dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aus, um eine neue asynchrone Lesevorgang zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <summary>Initiiert einen asynchronen Lesevorgang mit einem festgelegten Timeout. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginPeek%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis aus, wenn eine Nachricht verfügbar, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Mit <xref:System.Messaging.MessageQueue.BeginPeek%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und Ihre Ereignisdelegaten zuordnen. <xref:System.Messaging.MessageQueue.BeginPeek%2A> initiiert einen asynchronen Lesevorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, durch das Auslösen von der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> oder durch Abrufen des Ergebnisses über die <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> ist asynchron, Sie können ihn aufrufen zum Einsehen der Warteschlange, ohne dass blockiert den aktuellen Thread der Ausführung. Verwenden Sie zum synchronen Einsehen der Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginPeek%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Diese Überladung gibt einen Timeoutwert an. Wenn das Intervall, wird angegeben die `timeout` Parameter abgelaufen ist, löst diese Komponente die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis. Da keine Meldung vorhanden ist, einen nachfolgenden Aufruf von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wird eine Ausnahme ausgelöst.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, wird das Abschlussereignis ausgelöst, aber eine Ausnahme wird ausgelöst, wenn der Aufruf von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Lesevorgang, mit dem Warteschlangenpfad ". \myQueue". Erstellt einen Ereignishandler `MyPeekCompleted`, und fügt es der <xref:System.Messaging.MessageQueue.PeekCompleted> eventhandlerdelegaten. <xref:System.Messaging.MessageQueue.BeginPeek%2A> wird mit einem Timeout von einer Minute aufgerufen, um den asynchronen Lesevorgang initiieren. Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst, oder das Timeout abläuft, die Nachricht abgerufen wird, wenn eine solche vorhanden ist und Text auf dem Bildschirm ausgegeben wird. Klicken Sie dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aufgerufen, um einen neuen asynchronen Lesevorgang mit demselben Timeout zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="stateObject">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <summary>Initiiert einen asynchronen Lesevorgang mit einem angegebenen Timeout und einem angegebenen Zustandsobjekt, das während der Lebensdauer des Vorgangs Informationen für den Vorgang bereitstellt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginPeek%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis aus, wenn eine Nachricht verfügbar, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Verwenden Sie diese Überladung, um den Vorgang Informationen zuzuordnen, die in der gesamten Lebensdauer des Vorgangs beibehalten werden sollen. Der Ereignishandler kann auf diese Informationen zugreifen, durch einen Blick auf die <xref:System.IAsyncResult.AsyncState%2A> Eigenschaft von der <xref:System.IAsyncResult> , die dem Vorgang zugeordnet ist.  
  
 Mit <xref:System.Messaging.MessageQueue.BeginPeek%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und Ihre Ereignisdelegaten zuordnen. <xref:System.Messaging.MessageQueue.BeginPeek%2A> initiiert einen asynchronen Lesevorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, durch das Auslösen von der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> oder durch Abrufen des Ergebnisses über die <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> ist asynchron, Sie können ihn aufrufen zum Einsehen der Warteschlange, ohne dass blockiert den aktuellen Thread der Ausführung. Verwenden Sie zum synchronen Einsehen der Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Gibt eine <xref:System.IAsyncResult> , die den asynchronen Vorgang, der die Methode gestartet identifiziert. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Diese Überladung gibt einen Timeout und ein Zustandsobjekt. Wenn das Intervall, wird angegeben die `timeout` Parameter abgelaufen ist, löst diese Komponente die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis. Da keine Meldung vorhanden ist, einen nachfolgenden Aufruf von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wird eine Ausnahme ausgelöst.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Angenommen, Sie rufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über eine separate Statusobjekt, das Sie definieren identifizieren. Zur Veranschaulichung dieses Szenarios finden Sie im Beispielabschnitt.  
  
 Das Zustandsobjekt können auch um Informationen über die Verarbeitung der Prozessthreads zu übergeben. Wenn ein Thread gestartet wurde, aber der Rückruf auf einem anderen Thread in einem asynchronen Szenario ist, wird das Zustandsobjekt gemarshallt und wieder zusammen mit Informationen aus dem Ereignis übergeben.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, wird das Abschlussereignis ausgelöst, aber eine Ausnahme wird ausgelöst, wenn der Aufruf von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Lesevorgang, mit dem Warteschlangenpfad ". \myQueue". Erstellt einen Ereignishandler `MyPeekCompleted`, und fügt es der <xref:System.Messaging.MessageQueue.PeekCompleted> eventhandlerdelegaten. <xref:System.Messaging.MessageQueue.BeginPeek%2A> wird mit einem Timeout von einer Minute aufgerufen. Jeder Aufruf von <xref:System.Messaging.MessageQueue.BeginPeek%2A> verfügt über eine eindeutige ganze Zahl zugeordnet, die diesem bestimmten Vorgang identifiziert. Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst, oder das Timeout abgelaufen ist, sofern vorhanden, wird die Nachricht abgerufen und Text und der spezifische ganzzahlige Bezeichner, die auf dem Bildschirm ausgegeben werden. Klicken Sie dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aufgerufen, um einen neuen asynchronen Lesevorgang mit demselben Timeout und die zugehörigen ganze Zahl von zuvor abgeschlossenen Vorgangs zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="stateObject">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />, der die Benachrichtigung über den Abschluss des asynchronen Vorgangs erhält.</param>
        <summary>Initiiert einen asynchronen Lesevorgang mit einem angegebenen Timeout und einem angegebenen Zustandsobjekt, das während der Lebensdauer des Vorgangs Informationen für den Vorgang bereitstellt. Dieser Überladung wird in einem Rückruf die Identität des Ereignishandlers für den Vorgang mitgeteilt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Überladung verwenden, wird der Rückruf, der im Rückrufparameter angegebene direkt aufgerufen, wenn eine Nachricht verfügbar, oder wenn das angegebene Zeitintervall abgelaufen ist in der Warteschlange wird; die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird nicht ausgelöst. Andere Überladungen der <xref:System.Messaging.MessageQueue.BeginPeek%2A> abhängig ist, diese Komponente zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> ist asynchron, Sie können ihn aufrufen zum Einsehen der Warteschlange, ohne dass blockiert den aktuellen Thread der Ausführung. Verwenden Sie zum synchronen Einsehen der Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Gibt eine <xref:System.IAsyncResult> , die den asynchronen Vorgang, der die Methode gestartet identifiziert. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Angenommen, Sie rufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über eine separate Statusobjekt, das Sie definieren identifizieren.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Lesevorgang. Anschließend ruft der Code Beispiel sendet eine Nachricht in eine lokale Warteschlange, <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, und übergeben Sie: ein Timeoutwert von zehn Sekunden, eine eindeutige ganze Zahl, die der jeweiligen Nachricht; und eine neue Instanz der identifiziert <xref:System.AsyncCallback> , identifiziert den Ereignishandler `MyPeekCompleted`. Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> -Ereignis ausgelöst wird, wird der Ereignishandler sieht die Nachricht und schreibt den Nachrichtentext und die Integer-Nachrichten-ID auf dem Bildschirm.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <param name="action">Einer der <see cref="T:System.Messaging.PeekAction" />-Werte. Gibt an, ob die aktuelle oder die folgende Meldung in der Warteschlange eingesehen wird.</param>
        <param name="state">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />, der die Benachrichtigung über den Abschluss des asynchronen Vorgangs erhält.</param>
        <summary>Initiiert einen asynchronen Lesevorgang, der über einen angegebenen Timeout verfügt und für den ein Cursor, eine Suchaktion und ein Zustandsobjekt festgelegt sind. Das Zustandsobjekt stellt für die Lebensdauer des Vorgangs zugeordnete Informationen bereit. Dieser Überladung wird in einem Rückruf die Identität des Ereignishandlers für den Vorgang mitgeteilt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Überladung verwenden, wird der Rückruf, der in den Rückrufparameter angegebene direkt aufgerufen, wenn eine Nachricht verfügbar, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist. Die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird nicht ausgelöst. Andere Überladungen der <xref:System.Messaging.MessageQueue.BeginPeek%2A> abhängig ist, diese Komponente zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> ist asynchron, Sie können ihn aufrufen zum Einsehen der Warteschlange, ohne dass blockiert den aktuellen Thread der Ausführung. Verwenden Sie zum synchronen Einsehen der Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Gibt eine <xref:System.IAsyncResult> , die den asynchronen Vorgang gestartet, indem die Methode identifiziert. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Angenommen, Sie rufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über eine separate Statusobjekt, das Sie definieren identifizieren.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für den <paramref name="action" />-Parameter wurde ein anderer Wert als <see langword="PeekAction.Current" /> oder <see langword="PeekAction.Next" /> angegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <summary>Initiiert eine asynchrone Receive-Methode, indem Message Queuing angewiesen wird, mit dem Empfangen einer Meldung zu beginnen und nach Abschluss des Vorgangs den Ereignishandler zu benachrichtigen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiiert eine asynchrone Receive-Methode ohne Timeout. Die Operation wird erst abgeschlossen, wenn eine Meldung in der Warteschlange verfügbar ist.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginReceive%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis aus, wenn eine Nachricht aus der Warteschlange entfernt wurde.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Mit <xref:System.Messaging.MessageQueue.BeginReceive%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet, und verknüpfen Sie sie mit der Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert einen asynchronen Empfangsvorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, durch das Auslösen von der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> ist asynchron, Sie können aufrufen, um eine Nachricht aus der Warteschlange zu empfangen, ohne dass blockiert den aktuellen Thread der Ausführung. Um eine Nachricht synchron zu erhalten, verwenden die <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, wird das Abschlussereignis ausgelöst, aber eine Ausnahme wird ausgelöst, wenn der Aufruf von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Verwenden Sie nicht den asynchronen Aufruf <xref:System.Messaging.MessageQueue.BeginReceive%2A> mit Transaktionen. Wenn Sie einen asynchronen Transaktionsvorgang durchführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, und setzen Sie die Transaktion und die (synchron) <xref:System.Messaging.MessageQueue.Receive%2A> Methode innerhalb der Ereignishandler, die Sie erstellen, für den Lesevorgang. Ihr Ereignishandler kann Funktionen enthalten, wie im folgenden C#-Code dargestellt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird verkettet asynchrone Anforderungen ist. Es wird davon ausgegangen, dass eine Warteschlange auf dem lokalen Computer mit dem Namen "MyQueue". Die `Main` Funktion beginnt den asynchronen Vorgang, der vom übernommen wird die `MyReceiveCompleted` Routine. `MyReceiveCompleted` die aktuelle Nachricht verarbeitet und beginnt einen neuen asynchronen Empfangsvorgang.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 Im folgenden Codebeispiel wird die Warteschlange gestellt asynchroner Anforderungen. Der Aufruf von <xref:System.Messaging.MessageQueue.BeginReceive%2A> verwendet die <xref:System.IAsyncResult.AsyncWaitHandle%2A> im Rückgabewert. Die `Main` Routine wartet, bis alle asynchronen Vorgänge abgeschlossen werden, vor dem Beenden.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <summary>Initiiert eine asynchrone Receive-Methode mit einem festgelegten Timeout. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginReceive%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis aus, wenn eine Nachricht verfügbar, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Mit <xref:System.Messaging.MessageQueue.BeginReceive%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet, und verknüpfen Sie sie mit der Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert einen asynchronen Empfangsvorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, durch das Auslösen von der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> oder abrufen, das Ergebnis wird mithilfe der <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> ist asynchron, Sie können aufrufen, um eine Nachricht aus der Warteschlange zu empfangen, ohne dass blockiert den aktuellen Thread der Ausführung. Um eine Nachricht synchron zu erhalten, verwenden die <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, wird das Abschlussereignis ausgelöst, aber eine Ausnahme wird ausgelöst, wenn der Aufruf von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Diese Überladung gibt einen Timeoutwert an. Wenn das Intervall, wird angegeben die `timeout` Parameter abgelaufen ist, löst diese Komponente die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis. Da keine Meldung vorhanden ist, einen nachfolgenden Aufruf von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> wird eine Ausnahme ausgelöst.  
  
 Verwenden Sie nicht den asynchronen Aufruf <xref:System.Messaging.MessageQueue.BeginReceive%2A> mit Transaktionen. Wenn Sie einen asynchronen Transaktionsvorgang durchführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, und setzen Sie die Transaktion und die (synchron) <xref:System.Messaging.MessageQueue.Receive%2A> Methode innerhalb der Ereignishandler, die Sie erstellen, für den Lesevorgang. Ihr Ereignishandler kann Funktionen enthalten, wie im folgenden C#-Code dargestellt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Empfangsvorgang. Das Codebeispiel erstellt einen Ereignishandler `MyReceiveCompleted`, und fügt es der <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventhandlerdelegaten. Anschließend ruft der Code Beispiel sendet eine Nachricht in eine lokale Warteschlange, <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, und übergeben Sie einen Timeoutwert von zehn Sekunden. Wenn ein <xref:System.Messaging.MessageQueue.ReceiveCompleted> -Ereignis ausgelöst wird, wird der Ereignishandler empfängt die Nachricht und schreibt den Nachrichtentext auf dem Bildschirm.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise wurde ein negativer Wert angegeben.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="stateObject">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <summary>Initiiert eine asynchrone Receive-Methode mit einem angegebenen Timeout und einem angegebenen Zustandsobjekt, das während der Lebensdauer des Vorgangs Informationen für den Vorgang bereitstellt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginReceive%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis aus, wenn eine Nachricht verfügbar, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Verwenden Sie diese Überladung, um den Vorgang Informationen zuzuordnen, die in der gesamten Lebensdauer des Vorgangs beibehalten werden sollen. Der Ereignishandler kann diese Informationen erkennen, durch einen Blick auf die <xref:System.IAsyncResult.AsyncState%2A> Eigenschaft von der <xref:System.IAsyncResult> , die dem Vorgang zugeordnet ist.  
  
 Mit <xref:System.Messaging.MessageQueue.BeginReceive%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet, und verknüpfen Sie sie mit der Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert einen asynchronen Empfangsvorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, durch das Auslösen von der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> oder abrufen, das Ergebnis wird mithilfe der <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> ist asynchron, Sie können aufrufen, um eine Nachricht aus der Warteschlange zu empfangen, ohne dass blockiert den aktuellen Thread der Ausführung. Um eine Nachricht synchron zu erhalten, verwenden die <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Diese Überladung gibt einen Timeout und ein Zustandsobjekt. Wenn das Intervall, wird angegeben die `timeout` Parameter abgelaufen ist, löst diese Komponente die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis. Da keine Meldung vorhanden ist, einen nachfolgenden Aufruf von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> wird eine Ausnahme ausgelöst.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Angenommen, Sie rufen <xref:System.Messaging.MessageQueue.BeginReceive%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über eine separate Statusobjekt, das Sie definieren identifizieren.  
  
 Das Zustandsobjekt können auch um Informationen über die Verarbeitung der Prozessthreads zu übergeben. Wenn ein Thread gestartet wurde, aber der Rückruf auf einem anderen Thread in einem asynchronen Szenario ist, wird das Zustandsobjekt gemarshallt und wieder zusammen mit Informationen aus dem Ereignis übergeben.  
  
 Verwenden Sie nicht den asynchronen Aufruf <xref:System.Messaging.MessageQueue.BeginReceive%2A> mit Transaktionen. Wenn Sie einen asynchronen Transaktionsvorgang durchführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, und setzen Sie die Transaktion und die (synchron) <xref:System.Messaging.MessageQueue.Receive%2A> Methode innerhalb der Ereignishandler, die Sie erstellen, für den Lesevorgang. Ihr Ereignishandler kann Funktionen enthalten, wie im folgenden C#-Code dargestellt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Empfangsvorgang. Das Codebeispiel erstellt einen Ereignishandler `MyReceiveCompleted`, und fügt es der <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventhandlerdelegaten. Anschließend ruft der Code Beispiel sendet eine Nachricht in eine lokale Warteschlange, <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, und übergeben Sie einen Timeoutwert von zehn Sekunden und eine eindeutige ganze Zahl, die die jeweiligen Nachricht identifiziert. Wenn ein <xref:System.Messaging.MessageQueue.ReceiveCompleted> -Ereignis ausgelöst wird, wird der Ereignishandler empfängt die Nachricht und schreibt den Nachrichtentext und die Integer-Nachrichten-ID auf dem Bildschirm.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="stateObject">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />, der die Benachrichtigung über den Abschluss des asynchronen Vorgangs erhält.</param>
        <summary>Initiiert eine asynchrone Receive-Methode mit einem angegebenen Timeout und einem angegebenen Zustandsobjekt, das während der Lebensdauer des Vorgangs Informationen für den Vorgang bereitstellt. Dieser Überladung wird in einem Rückruf die Identität des Ereignishandlers für den Vorgang mitgeteilt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Überladung verwenden, wird der Rückruf, der im Rückrufparameter angegebene direkt aufgerufen, wenn eine Nachricht verfügbar, oder wenn das angegebene Zeitintervall abgelaufen ist in der Warteschlange wird; die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis wird nicht ausgelöst. Andere Überladungen der <xref:System.Messaging.MessageQueue.BeginReceive%2A> abhängig ist, diese Komponente zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Mit <xref:System.Messaging.MessageQueue.BeginReceive%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet, und verknüpfen Sie sie mit der Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert einen asynchronen Empfangsvorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, durch das Auslösen von der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> oder abrufen, das Ergebnis wird mithilfe der <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> ist asynchron, Sie können aufrufen, um eine Nachricht aus der Warteschlange zu empfangen, ohne dass blockiert den aktuellen Thread der Ausführung. Um eine Nachricht synchron zu erhalten, verwenden die <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Angenommen, Sie rufen <xref:System.Messaging.MessageQueue.BeginReceive%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über eine separate Statusobjekt, das Sie definieren identifizieren.  
  
 Das Zustandsobjekt können auch um Informationen über die Verarbeitung der Prozessthreads zu übergeben. Wenn ein Thread gestartet wurde, aber der Rückruf auf einem anderen Thread in einem asynchronen Szenario ist, wird das Zustandsobjekt gemarshallt und wieder zusammen mit Informationen aus dem Ereignis übergeben.  
  
 Verwenden Sie nicht den asynchronen Aufruf <xref:System.Messaging.MessageQueue.BeginReceive%2A> mit Transaktionen. Wenn Sie einen asynchronen Transaktionsvorgang durchführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, und setzen Sie die Transaktion und die (synchron) <xref:System.Messaging.MessageQueue.Receive%2A> Methode innerhalb der Ereignishandler, die Sie erstellen, für den Lesevorgang. Ihr Ereignishandler kann Funktionen enthalten, wie im folgenden C#-Code dargestellt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Empfangsvorgang. Anschließend ruft der Code Beispiel sendet eine Nachricht in eine lokale Warteschlange, <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, und übergeben Sie: ein Timeoutwert von zehn Sekunden, eine eindeutige ganze Zahl, die der jeweiligen Nachricht; und eine neue Instanz der identifiziert <xref:System.AsyncCallback> , identifiziert den Ereignishandler `MyReceiveCompleted`. Wenn ein <xref:System.Messaging.MessageQueue.ReceiveCompleted> -Ereignis ausgelöst wird, wird der Ereignishandler empfängt die Nachricht und schreibt den Nachrichtentext und die Integer-Nachrichten-ID auf dem Bildschirm.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <param name="state">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />, der die Benachrichtigung über den Abschluss des asynchronen Vorgangs erhält.</param>
        <summary>Initiiert einen asynchronen Receive-Vorgang, der über einen angegebenen Timeout verfügt und für den ein Cursor und ein Zustandsobjekt festgelegt sind. Das Zustandsobjekt stellt für die Lebensdauer des Vorgangs zugeordnete Informationen bereit. Dieser Überladung wird in einem Rückruf die Identität des Ereignishandlers für den Vorgang mitgeteilt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Überladung verwenden, wird der Rückruf, der im Rückrufparameter angegebene direkt aufgerufen, wenn eine Nachricht verfügbar, oder wenn das angegebene Zeitintervall abgelaufen ist in der Warteschlange wird; die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis wird nicht ausgelöst. Andere Überladungen der <xref:System.Messaging.MessageQueue.BeginReceive%2A> abhängig ist, diese Komponente zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Mit <xref:System.Messaging.MessageQueue.BeginReceive%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet, und verknüpfen Sie sie mit der Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert einen asynchronen Empfangsvorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, durch das Auslösen von der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> oder abrufen, das Ergebnis wird mithilfe der <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> ist asynchron, Sie können aufrufen, um eine Nachricht aus der Warteschlange zu empfangen, ohne dass blockiert den aktuellen Thread der Ausführung. Um eine Nachricht synchron zu erhalten, verwenden die <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Sobald ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen von beibehalten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der Lebensdauer des Vorgangs, obwohl Sie in der Regel keine erst verwendet <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Es gibt jedoch, wenn Sie mehrere asynchrone Vorgänge starten, Sie können platziert ihre <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang zum Abschließen. In diesem Fall verwenden die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft von der <xref:System.IAsyncResult> abgeschlossenen Vorgang identifiziert.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Angenommen, Sie rufen <xref:System.Messaging.MessageQueue.BeginReceive%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über eine separate Statusobjekt, das Sie definieren identifizieren.  
  
 Das Zustandsobjekt können auch um Informationen über die Verarbeitung der Prozessthreads zu übergeben. Wenn ein Thread gestartet wurde, aber der Rückruf auf einem anderen Thread in einem asynchronen Szenario ist, wird das Zustandsobjekt gemarshallt und wieder zusammen mit Informationen aus dem Ereignis übergeben.  
  
 Verwenden Sie nicht den asynchronen Aufruf <xref:System.Messaging.MessageQueue.BeginReceive%2A> mit Transaktionen. Wenn Sie einen asynchronen Transaktionsvorgang durchführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, und setzen Sie die Transaktion und die (synchron) <xref:System.Messaging.MessageQueue.Receive%2A> Methode innerhalb der Ereignishandler, die Sie erstellen, für den Lesevorgang. Ihr Ereignishandler kann Funktionen enthalten, wie im folgenden C#-Code dargestellt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Messaging.MessageQueue" /> gelesen werden kann.</summary>
        <value>
          <see langword="true" />, wenn die <see cref="T:System.Messaging.MessageQueue" /> vorhanden und ein Lesezugriff durch die Anwendung möglich ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> Gibt an, ob die Anwendung kann zum Einsehen oder Empfangen von Nachrichten aus der Warteschlange. Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `true`, <xref:System.Messaging.MessageQueue> können empfangen und Einsehen von Nachrichten aus der Warteschlange. Andernfalls ist es nicht möglich.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false` Wenn eine Warteschlange bereits mit exklusivem Lesezugriff geöffnet ist (oder geöffnet, und dies nicht exklusiven Zugriff ist <xref:System.Messaging.MessageQueue> exklusiven Zugriff anfordert), oder die Anwendung nicht über ausreichende Berechtigungen für den Zugriff darauf besitzt. Wenn die Anwendung versucht, das Lesen aus einer Warteschlange beim <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, Zugriff verweigert.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.CanRead%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob in die <see cref="T:System.Messaging.MessageQueue" /> geschrieben werden kann.</summary>
        <value>
          <see langword="true" />, wenn die <see cref="T:System.Messaging.MessageQueue" /> vorhanden und ein Schreibzugriff durch die Anwendung möglich ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> Gibt an, ob die Anwendung Nachrichten an die Warteschlange senden kann. Wenn <xref:System.Messaging.MessageQueue.CanWrite%2A> ist `true`, <xref:System.Messaging.MessageQueue> können Nachrichten an die Warteschlange senden. Andernfalls ist es nicht möglich.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> ist `false` , wenn eine Warteschlange bereits mit exklusivem Schreibzugriff geöffnet wurde (oder geöffnet, und dies nicht exklusiven Zugriff ist <xref:System.Messaging.MessageQueue> exklusiven Zugriff anfordert), oder die Anwendung nicht über ausreichende Berechtigungen für den Zugriff darauf besitzt. Wenn die Anwendung versucht, die an eine Warteschlange schreiben beim <xref:System.Messaging.MessageQueue.CanWrite%2A> ist `false`, der Zugriff wurde verweigert.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.CanWrite%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Kategorie der Warteschlange ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Guid" />, die die Kategorie der Warteschlange (Message Queuing-Typenbezeichner) darstellt und mit der eine Anwendung ihre Warteschlangen kategorisieren kann. Der Standardwert ist <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kategorie der Warteschlange kann eine Anwendung ihre Warteschlangen kategorisieren. Beispielsweise können Sie alle Abrechnung Warteschlangen in einer Kategorie und alle Reihenfolge Warteschlangen in einem anderen platzieren.  
  
 Die <xref:System.Messaging.MessageQueue.Category%2A> Eigenschaft ermöglicht den Zugriff auf die Message Queuing-Typ-ID-Eigenschaft (die Lese-/Schreibzugriff aufweist), über die **Warteschlangeneigenschaften** Dialogfeld in der Computerverwaltungskonsole. Sie können eine neue Kategorie definieren. Sie können zwar <xref:System.Guid.NewGuid%2A> Kategorie erstellen, die auf allen eindeutig ist <xref:System.Guid> Werte, die Aktion ist nicht erforderlich. Der Kategoriewert muss nur aus anderen Kategorien, die nicht von allen anderen unterscheiden <xref:System.Guid> Werte. Sie können z. B. zuweisen {00000000-0000-0000-0000-000000000001} als die <xref:System.Messaging.MessageQueue.Category%2A> für einen Satz von Warteschlangen und {00000000-0000-0000-0000-000000000002} als die <xref:System.Messaging.MessageQueue.Category%2A> für eine andere Gruppe.  
  
 Es ist nicht notwendig, legen Sie die <xref:System.Messaging.MessageQueue.Category%2A>. Der Wert kann `null` sein.  
  
 Durch Festlegen dieser Eigenschaft ändert die Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.Category%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Kategorie der Warteschlange wurde auf einen ungültigen Wert festgelegt.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht den Verbindungscache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufruf <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, die im Cache gespeicherten Formatnamen entfernt, und Handles geöffnet und im Cache gespeichert, geschlossen.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A> aufgerufen.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der <see cref="T:System.Messaging.MessageQueue" /> reservierten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> Gibt alle zugeordneten Ressourcen frei eine <xref:System.Messaging.MessageQueue>, einschließlich der freigegebene Ressourcen bei Bedarf. Das System automatisch wieder zugewiesen diese Ressourcen stehen noch zur Verfügung, z. B. beim Aufrufen der <xref:System.Messaging.MessageQueue.Send%28System.Object%29> Methode, wie im folgenden C#-Code.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 Beim Aufruf <xref:System.Messaging.MessageQueue.Close%2A>, dass alle <xref:System.Messaging.MessageQueue> Eigenschaften, die Message Queuing-Warteschlange direkt zugreifen, werden gelöscht. Die <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, und <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> alle unverändert beibehalten wurden.  
  
 <xref:System.Messaging.MessageQueue.Close%2A> nicht immer die schreibgeschützte frei und Schreibhandles an eine Warteschlange, da sie gemeinsam genutzt werden können. Sie können die folgenden Schritte aus, um sicherzustellen, dass wie <xref:System.Messaging.MessageQueue.Close%2A> der Lese- und Schreibhandles an eine Warteschlange freigegeben:  
  
-   Erstellen der <xref:System.Messaging.MessageQueue> mit exklusivem Zugriff. Rufen Sie hierzu die <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> oder <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor, und legen die `sharedModeDenyReceive` Parameter `true`.  
  
-   Erstellen der <xref:System.Messaging.MessageQueue> mit Zwischenspeichern Verbindungen deaktiviert. Rufen Sie hierzu die <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor, und legen die `enableConnectionCache` Parameter `false`.  
  
-   Deaktivieren Sie das Zwischenspeichern Verbindungen. Legen Sie hierzu die <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> Eigenschaft `false`.  
  
 Rufen Sie <xref:System.Messaging.MessageQueue.Close%2A> für eine Warteschlange, bevor Sie die Warteschlange auf dem Message Queuing-Server löschen. Andernfalls konnte an die Warteschlange gesendete Nachrichten Ausnahmen auslösen oder in die Dead Letter-Warteschlange angezeigt.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Message Queuing-Warteschlange geschlossen.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Warteschlange unter dem angegebenen Pfad auf einem Message Queuing-Server.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der zu erstellenden Warteschlange.</param>
        <summary>Erstellt eine nicht transaktionale Message Queuing-Warteschlange unter dem angegebenen Pfad.</summary>
        <returns>Eine <see cref="T:System.Messaging.MessageQueue" />, die die neue Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine nicht transaktionale Message Queuing-Warteschlange zu erstellen.  
  
 So erstellen eine neue Instanz der dem <xref:System.Messaging.MessageQueue> Klasse in der Anwendung und binden es an eine vorhandene Warteschlange, verwenden Sie die <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor. Rufen Sie zum Erstellen einer neuen Warteschlange in Message Queuing <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Die Syntax für die `path` Parameter hängt vom Typ der Warteschlange für diese Verweise, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
  
 Verwenden "." für den lokalen Computer. Weitere Informationen zur Syntax finden Sie unter der <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die öffentliche und private Warteschlangen erstellt. Sie sendet eine Nachricht an ausgewählte Warteschlangen.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist <see langword="null" /> oder eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Unter dem angegebenen Pfad ist bereits eine Warteschlange vorhanden.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der zu erstellenden Warteschlange.</param>
        <param name="transactional">
          <see langword="true" />, um eine transaktionale Warteschlange zu erstellen, oder <see langword="false" />, wenn eine nicht transaktionale Warteschlange erstellt werden soll.</param>
        <summary>Erstellt eine transaktionale oder eine nicht transaktionale Message Queuing-Warteschlange unter dem angegebenen Pfad.</summary>
        <returns>Eine <see cref="T:System.Messaging.MessageQueue" />, die die neue Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Überladung verwenden, um eine Transaktionswarteschlange in Message Queuing zu erstellen. Sie können eine nicht transaktionale Warteschlange erstellen, durch Festlegen der `transactional` Parameter `false` oder durch die andere Überladung von Aufrufen <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 So erstellen eine neue Instanz der dem <xref:System.Messaging.MessageQueue> Klasse in der Anwendung und binden es an eine vorhandene Warteschlange, verwenden Sie die <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor. Rufen Sie zum Erstellen einer neuen Warteschlange in Message Queuing <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Die Syntax für die `path` Parameter hängt vom Typ der Warteschlange für diese Verweise, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
  
 Verwenden "." für den lokalen Computer. Weitere Informationen zur Syntax finden Sie unter der <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird öffentliche und private transaktionale Warteschlangen erstellt. Sie sendet eine Nachricht an ausgewählte Warteschlangen.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist <see langword="null" /> oder eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Unter dem angegebenen Pfad ist bereits eine Warteschlange vorhanden.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Messaging.Cursor" /> für die aktuelle Meldungswarteschlange.</summary>
        <returns>Ein neuer <see cref="T:System.Messaging.Cursor" /> für die aktuelle Meldungswarteschlange. Mithilfe des Cursors kann beim Lesen der Warteschlangenmeldungen eine bestimmte Position in der Warteschlange beibehalten werden.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Zeit und Datum der Erstellung der Warteschlange in Message Queuing ab.</summary>
        <value>Eine <see cref="T:System.DateTime" />, die Erstellungsdatum und -uhrzeit der Warteschlange darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> bezieht sich auf die Warteschlange auf dem Message Queuing-Server nicht die <xref:System.Messaging.MessageQueue> Instanz.  
  
 Wenn die Warteschlange vorhanden ist, stellt diese Eigenschaft den Zeitpunkt der Erstellung die Warteschlange angepasst an die lokale Zeit des Servers, auf dem die Warteschlange vorhanden ist, den dar.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.CreateTime%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Eigenschaftswerte für Meldungen ab, die beim Senden einer Meldung an die Warteschlange standardmäßig verwendet werden.</summary>
        <value>Ein <see cref="T:System.Messaging.DefaultPropertiesToSend" /> mit den Standardeigenschaftswerten für Meldungen in Message Queuing, die verwendet werden, wenn die Anwendung andere Objekte als <see cref="T:System.Messaging.Message" />-Instanzen an die Warteschlange sendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Objekt, das nicht vom Typ senden <xref:System.Messaging.Message> an die Warteschlange die <xref:System.Messaging.MessageQueue> fügt das Objekt in eine Message Queuing-Nachricht. Zu diesem Zeitpunkt wird die <xref:System.Messaging.MessageQueue> gilt für die Nachricht die Eigenschaftswerte, die Sie, in angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft. Umgekehrt, wenn Sie senden eine <xref:System.Messaging.Message> an die Warteschlange diese Eigenschaften sind bereits für die Instanz angegebenen selbst, also <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> wird ignoriert, die <xref:System.Messaging.Message>.  
  
 Obwohl Sie die Eigenschaften durch Festlegen der <xref:System.Messaging.MessageQueue> -Objekt, das <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> bezieht sich auf die Eigenschaften der Nachrichten, die an die Warteschlange nicht die Warteschlange selbst gesendet werden.  
  
 In der folgenden Tabelle werden die Standardwerte für die Eigenschaften angezeigt.  
  
|Eigenschaft|Standardwert|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|Null (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|Ein Bytearray mit der Länge null|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|Leere Zeichenfolge ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet die Priorität einer Nachricht, um Standardeigenschaften zum Senden der Meldung zu bestimmen.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Standardeigenschaften konnten für diese Warteschlange nicht festgelegt werden. Möglicherweise ist eine der Eigenschaften ungültig.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der zu löschenden Warteschlange.</param>
        <summary>Löschte eine Warteschlange auf einem Message Queuing-Server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Syntax für die `path` Parameter hängt vom Typ der Warteschlange.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
  
 Weitere Informationen zur Syntax finden Sie unter der <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.  
  
 Alternativ können Sie die <xref:System.Messaging.MessageQueue.FormatName%2A> oder <xref:System.Messaging.MessageQueue.Label%2A> den Warteschlangenpfad zu beschreiben.  
  
|Referenz|Syntax|  
|---------------|------------|  
|Formatname|FormatName: [ *Formatnamen* ]|  
|Bezeichnung|Label:[ *label* ]|  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Message Queuing-Warteschlange löscht, falls vorhanden.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist <see langword="null" /> oder eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Syntax für den <paramref name="path" />-Parameter ist ungültig.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob diese <see cref="T:System.Messaging.MessageQueue" /> über exklusive Zugriffsrechte für das Empfangen von Meldungen aus der Message Queuing-Warteschlange verfügt, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn diese <see cref="T:System.Messaging.MessageQueue" /> über exklusive Zugriffsrechte für das Empfangen von Meldungen aus der Warteschlange verfügt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Gibt an, die im freigegebenen Modus, der auf die verwiesen wird von dieser Warteschlange <xref:System.Messaging.MessageQueue>. Legen Sie <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> auf `true` um anzugeben, dass nur diese <xref:System.Messaging.MessageQueue> zum Einsehen oder Empfangen von Nachrichten aus der Warteschlange mit dem angegebenen Zugriff haben sollten <xref:System.Messaging.MessageQueue.Path%2A>. Wenn ein anderer <xref:System.Messaging.MessageQueue> oder eine andere Anwendung die gleichen Warteschlangenressource dieser Instanz zugeordnet ist oder Anwendung zum Einsehen oder Empfangen von Nachrichten nicht möglich, kann es jedoch immer noch senden sie.  
  
 Wenn <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> ist `false`, die Warteschlange für mehrere Anwendungen zum Senden, einsehen oder Empfangen von Nachrichten verfügbar ist.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von der <see cref="T:System.Messaging.MessageQueue" />-Klasse verwendeten Ressourcen (mit Ausnahme des Speichers) frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> auf, wenn Sie <xref:System.Messaging.MessageQueue> nicht mehr benötigen. Die <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>-Methode bewirkt, dass <xref:System.Messaging.MessageQueue> nicht mehr verwendet werden kann. Nach dem Aufruf <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, müssen Sie alle Verweise auf Freigeben der <xref:System.Messaging.MessageQueue> , damit der belegte Arbeitsspeicher von der Garbagecollection wieder zugänglich gemacht werden kann.  
  
 Rufen Sie <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> , bevor Sie den letzten Verweis auf Freigeben der <xref:System.Messaging.MessageQueue>. Andernfalls, die Ressourcen der <xref:System.Messaging.MessageQueue> ist mit bleiben reserviert, bis die Garbage Collection-Aufrufe der <xref:System.Messaging.MessageQueue> Destruktor des Objekts.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Anwendung einen Verbindungscache verwaltet, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn ein Verbindungscache erstellt und verwendet wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Verbindungscache ist eine Liste von Verweisen auf Strukturen, die enthalten lesen oder Schreiben von Handles in Warteschlangen. Wenn <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> ist `true`, <xref:System.Messaging.MessageQueue> Grunde Handles aus dem Cache verwendet, bei jedem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, oder <xref:System.Messaging.MessageQueue.Receive%2A>, anstatt neue Handles zu öffnen. Dies kann die Leistung verbessern. Verwenden einen Verbindungscache auch isoliert die <xref:System.Messaging.MessageQueue> um eventuelle Änderungen in der Topologie des Netzwerks.  
  
 Wenn Sie eine neue Verbindung mit einer Warteschlange erstellen, wenn es sich bei der Verbindungscache voll ist, wird die <xref:System.Messaging.MessageQueue> überschreibt die zuletzt am wenigsten Struktur mit der neuen Verbindung. Sie können den Cache löschen, entweder durch Aufrufen von <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, z. B. wenn die Formatnamen, der Sie arbeiten mit Warteschlangen geändert haben, damit das vorherige lesen und Schreiben von Handles sind nicht mehr gültig.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Warteschlange lediglich nicht private (nicht verschlüsselte) Meldungen akzeptiert, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.EncryptionRequired" />-Werte. Der Standardwert ist <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie, dass die Verschlüsselung erforderlich, damit die Nachrichten an eine Warteschlange gesendet wird angeben, werden nur die Nachrichtentexte verschlüsselt. Die anderen Elemente (z. B. die <xref:System.Messaging.Message.Label%2A> und <xref:System.Messaging.Message.SenderId%2A> Eigenschaften) kann nicht verschlüsselt werden.  
  
 Durch Festlegen dieser Eigenschaft ändert die Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind.  
  
 Verschlüsseln einer Nachricht wird die Nachricht in der privaten. Sie können angeben, gilt der Warteschlange werden `None`, `Body`, oder `Optional` durch Festlegen der <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> Eigenschaft entsprechend. Die <xref:System.Messaging.Message.UseEncryption%2A> Einstellung der Nachricht muss mit der Encryption-Anforderung der Warteschlange entsprechen. Wenn die Nachricht nicht verschlüsselt, aber die Warteschlange gibt `Body`, oder wenn die Nachricht verschlüsselt ist, aber die Warteschlange gibt `None`, die Nachricht wird von der Warteschlange abgelehnt. Wenn die sendende Anwendung eine negative Bestätigungsnachricht in diesem Ereignis anfordert, gibt das Message Queuing Ablehnung die Nachricht an die sendende Anwendung an. Wenn die <xref:System.Messaging.Message.UseDeadLetterQueue%2A> Eigenschaft `true`, eine Nachricht, die Verschlüsselung ein Fehler auftritt, wird an die Dead Letter-Warteschlange gesendet. Andernfalls ist die Nachricht verloren gehen.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das den abzuschließenden asynchronen Lesevorgang bestimmt und über das das Endergebnis abgerufen werden kann.</param>
        <summary>Schließt den angegebenen asynchronen Lesevorgang ab.</summary>
        <returns>Die dem abgeschlossenen asynchronen Vorgang zugeordnete <see cref="T:System.Messaging.Message" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> schließt den Vorgang nach der Initiierung der <xref:System.Messaging.MessageQueue.BeginPeek%2A> aufrufen. Zu diesem Zweck <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> sieht die Nachricht.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> festlegbaren ein Timeout, wodurch die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis ausgelöst wird, wenn das Timeout auftritt, bevor eine in der Warteschlange Meldung. Wenn ein Timeout auftritt, ohne dass eine Meldung in der Warteschlange, ein nachfolgender Aufruf von eingehenden <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> löst eine Ausnahme aus.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wird verwendet, um die Nachricht zu lesen, die aufgrund der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis ausgelöst wurde.  
  
 Wenn Sie zum Einsehen von Nachrichten asynchron zu fortfahren möchten, können Sie erneut aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> nach dem Aufruf <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Ereignishandler namens `MyPeekCompleted`, fügt es der <xref:System.Messaging.MessageQueue.PeekCompleted> eventhandlerdelegaten und ruft <xref:System.Messaging.MessageQueue.BeginPeek%2A> um einen asynchronen Lesevorgang in der Warteschlange zu initiieren, die unter dem Pfad befindet ". \myQueue". Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst, die im Beispiel sieht die Nachricht und schreibt Text auf dem Bildschirm. Das Beispiel ruft dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aus, um eine neue asynchrone Lesevorgang zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="asyncResult" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="asyncResult" />-Parameters ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das die abzuschließende asynchrone Receive-Methode bestimmt und über das das Ergebnis abgerufen werden kann.</param>
        <summary>Schließt die angegebene asynchrone Receive-Methode ab.</summary>
        <returns>Die dem abgeschlossenen asynchronen Vorgang zugeordnete <see cref="T:System.Messaging.Message" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis wird ausgelöst, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> schließt den Vorgang nach der Initiierung der <xref:System.Messaging.MessageQueue.BeginReceive%2A> aufrufen. Zu diesem Zweck <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> empfängt die Nachricht.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> festlegbaren ein Timeout, wodurch die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis ausgelöst wird, wenn das Timeout auftritt, bevor eine in der Warteschlange Meldung. Wenn ein Timeout auftritt, ohne dass eine Meldung in der Warteschlange, ein nachfolgender Aufruf von eingehenden <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> löst eine Ausnahme aus.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> Dient zum Lesen (Entfernen Sie aus der Warteschlange) der Nachrichteninhalts, die aufgrund der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis ausgelöst wurde.  
  
 Wenn Sie weiterhin Nachrichten asynchron empfangen möchten, können Sie erneut aufrufen <xref:System.Messaging.MessageQueue.BeginReceive%2A> nach dem Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird verkettet asynchrone Anforderungen ist. Es wird davon ausgegangen, dass eine Warteschlange auf dem lokalen Computer mit dem Namen "MyQueue". Die `Main` Funktion beginnt den asynchronen Vorgang, der vom übernommen wird die `MyReceiveCompleted` Routine. `MyReceiveCompleted` die aktuelle Nachricht verarbeitet und beginnt einen neuen asynchronen Empfangsvorgang.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="asyncResult" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="asyncResult" />-Parameters ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der gesuchten Warteschlange.</param>
        <summary>Bestimmt, ob unter dem angegeben Pfad eine Message Queuing-Warteschlange vorhanden ist.</summary>
        <returns>
          <see langword="true" />, wenn unter dem angegebenen Pfad eine Warteschlange vorhanden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Methode bestimmt, ob eine Message Queuing-Warteschlange in einem angegebenen Pfad vorhanden ist. Keine Methode ist vorhanden, um zu bestimmen, ob eine Warteschlange mit einem angegebenen Formatnamen vorhanden ist. Weitere Informationen zu den formatnamenssyntax und andere Syntaxformen, finden Sie unter der <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> ist ein teurer Vorgang. Verwenden sie nur, wenn es in der Anwendung erforderlich ist.  
  
> [!NOTE]
>  Die <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Methode unterstützt nicht die <xref:System.Messaging.MessageQueue.FormatName%2A> Präfix.  
  
 Die Syntax für die `path` Parameter hängt vom Typ der Warteschlange, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> kann nicht aufgerufen werden, um das Vorhandensein einer privaten Remotewarteschlange zu überprüfen.  
  
 Weitere Informationen zur Syntax finden Sie unter der <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.  
  
 Alternativ können Sie die <xref:System.Messaging.MessageQueue.Label%2A> den Warteschlangenpfad zu beschreiben.  
  
|Referenz|Syntax|  
|---------------|------------|  
|Bezeichnung|Label:[ `label` ]|  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob eine Message Queuing-Warteschlange vorhanden ist, und klicken Sie dann gelöscht.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="path" />-Syntax ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.  
  
 - oder -   
  
 Die <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" />-Methode wird für eine private Remotewarteschlange aufgerufen.</exception>
        <exception cref="T:System.InvalidOperationException">In der Anwendung wurde eine Syntax für Formatnamen verwendet, um das Vorhandensein der Warteschlange zu überprüfen.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den eindeutigen Namen der Warteschlange ab, den Message Queuing beim Erstellen der Warteschlange erzeugt hat.</summary>
        <value>Der im Netzwerk eindeutige Name der Warteschlange.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.FormatName%2A> Eigenschaft enthält den Formatnamen der Warteschlange. Message Queuing verwendet den Formatnamen zum Identifizieren der Warteschlange zu öffnen und wie Sie darauf zugreifen. Im Gegensatz zu einer Warteschlange Merkmale ist der Formatnamen keine Message Queuing-Warteschlange Anwendungseigenschaft, sodass Sie über den Message Queuing-Verwaltungstool auf zugreifen zu können. Der Formatnamen ist einfach ein eindeutiger Name für die Warteschlange, die Message Queuing generiert, beim Erstellen der Warteschlange oder die Anwendung später erneut generiert wird.  
  
 Wenn Sie einen Pfad mithilfe der pfadnamensyntax angeben (z. B. `myComputer\myQueue`) statt der formatnamenssyntax beim Lesen oder in die Warteschlange schreiben, die dem primären Domänencontroller (das Active Directory verwendet) übersetzt die <xref:System.Messaging.MessageQueue.Path%2A> in der zugeordneten <xref:System.Messaging.MessageQueue.FormatName%2A> vor dem Zugriff auf die Warteschlange. Wenn Ihre Anwendung im Offlinemodus ist, müssen Sie die formatnamenssyntax verwenden; Andernfalls wird der primäre Domänencontroller zum Durchführen der Übersetzung Pfad nicht verfügbar.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.FormatName%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> ist nicht festgelegt.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Formatierungsprogramm ab, oder legt das Formatierungsprogramm fest, das zum Serialisieren und Deserialisieren eines Objekts in bzw. aus dem Körper einer Meldung verwendet wird, die aus einer Warteschlange gelesen oder in eine Warteschlange geschrieben wird.</summary>
        <value>Der <see cref="T:System.Messaging.IMessageFormatter" />, der den Stream erstellt, der in den Meldungstext geschrieben oder aus diesem gelesen werden soll. Der Standardwert ist <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft enthält eine Instanz eines Objekts Formatierer, der Nachrichten transformiert werden, wenn die Anwendung liest oder schreibt in die Warteschlange.  
  
 Wenn die Anwendung eine Nachricht an die Warteschlange sendet, wird das Formatierungsprogramm serialisiert das Objekt in einen Stream und fügt es in den Nachrichtentext. Beim Lesen aus einer Warteschlange deserialisiert der Formatierer die Nachrichtendaten in das <xref:System.Messaging.Message.Body%2A> Eigenschaft von einem <xref:System.Messaging.Message>.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> lose verknüpft, daher ist es nicht notwendig, dass das gleiche Objekt, das auf dem Absender und Empfänger geben Sie bei Verwendung dieses Format ist. Die <xref:System.Messaging.ActiveXMessageFormatter> und <xref:System.Messaging.BinaryMessageFormatter> Serialisieren der Daten in eine binäre Darstellung. Die <xref:System.Messaging.ActiveXMessageFormatter> wird beim Senden oder Empfangen von COM-Komponenten verwendet.  
  
 <xref:System.Messaging.BinaryMessageFormatter> und <xref:System.Messaging.ActiveXMessageFormatter> ermöglichen einen höheren Durchsatz als die <xref:System.Messaging.XmlMessageFormatter>. Die <xref:System.Messaging.ActiveXMessageFormatter> ermöglicht die Interoperabilität mit Visual Basic 6.0-Message Queuing-Anwendungen.  
  
 Wenn die Anwendung Nachrichten an die Warteschlange sendet die <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> gilt nur für diese Nachrichten, die die Standard-Nachrichteneigenschaften verwenden <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. Wenn Sie senden eine <xref:System.Messaging.Message> in die Warteschlange, Message Queuing verwendet der Formatierer, der definiert, der <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> Eigenschaft, um stattdessen den Text zu serialisieren.  
  
 Die <xref:System.Messaging.MessageQueue> Klasse verwendet immer eine <xref:System.Messaging.Message> empfangen und Einsehen einer Nachricht aus der Warteschlange. Die Nachricht deserialisiert wird, mithilfe der <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Formatieren Nachrichtentexts mit <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Das folgende Codebeispiel veranschaulicht das Formatieren Nachrichtentexts mit <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle Meldungen in der Warteschlange zurück.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Messaging.Message" />, das alle Meldungen aus der Warteschlange darstellt. Die Reihenfolge entspricht der Reihenfolge in der Message Queuing-Warteschlange.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Gibt einen statischen Snapshot der Nachrichten in der Warteschlange, die keine dynamischen Links zu diesen Nachrichten zurück. Das Array können Sie aus diesem Grund Ändern der Nachrichten in der Warteschlange. Wenn Sie in Echtzeit, dynamische Interaktion mit der Warteschlange (z. B. die Fähigkeit, Nachrichten zu löschen) möchten, rufen Sie die <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> Methode, die eine dynamische Liste der Nachrichten in der Warteschlange zurückgibt.  
  
 Da <xref:System.Messaging.MessageQueue.GetAllMessages%2A> gibt eine Kopie der Nachrichten in der Warteschlange zum Zeitpunkt die Methode aufgerufen wurde, wird das Array reflektiert keinen neuen Nachrichten, die in der Warteschlange ankommen oder Nachrichten, die aus der Warteschlange entfernt werden.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Ruft nur die Eigenschaften, die nicht herausgefiltert, durch die <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Listet die Meldungen in einer Warteschlange auf. <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> ist veraltet. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> sollte stattdessen verwendet werden.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />, der eine dynamische Verbindung mit den Meldungen in der Warteschlange bereitstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Name des Computers, der die Warteschlange enthält, ohne die zwei führenden umgekehrten Schrägstriche (\\\\).</param>
        <summary>Ruft den Computerbezeichner ab, auf dem sich die Warteschlange befindet, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist.</summary>
        <returns>Eine <see cref="T:System.Guid" />, die einen eindeutigen Bezeichner für den Computer darstellt, auf dem sich die Warteschlange befindet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Können Sie einen Computer Bezeichner für zwei Zwecke, u. a.: das Computerjournal lesen und Festlegen von Sicherheitszertifikaten. Allerdings können Sie nicht aufrufen <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> für einen Remotecomputer, wenn Sie offline arbeiten, da die Anwendung den Zugriff auf den Verzeichnisdienst auf dem Domänencontroller verfügen muss.  
  
 Der Computer-ID (oder das Computer-ID) ist eine <xref:System.Guid> , die Message Queuing erstellt, wenn ein Computer für das Unternehmen hinzugefügt wird. Message Queuing kombiniert den Bezeichner für den Computer mit der `Machine` und `Journal` Schlüsselwörter für das Computerjournal Formatnamen, erstellen Sie mit der Syntax `Machine=<computeridentifier>;Journal`. Das Computerjournal, auch bekannt als der Journalwarteschlange ist eine Systemwarteschlange, die speichert Kopien der Anwendung generierte Instanznachrichten an, wenn die <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> Eigenschaft ist `true`.  
  
 Diese Syntax für die Erfassung ist nur gültig, wenn den Formatnamen der Warteschlange zu erstellen. Ist der pfadnamensyntax `MachineName` \\ `Journal$`.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> aufgerufen.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Der Computerbezeichner konnte nicht abgerufen werden. Möglicherweise ist der Verzeichnisdienst nicht verfügbar (z. B. während der Ausführung im Offlinebetrieb).  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein Enumerationsobjekt für alle Meldungen in der Warteschlange. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> ist veraltet. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> sollte stattdessen verwendet werden.</summary>
        <returns>Ein <see cref="T:System.Messaging.MessageEnumerator" /> mit den in der Warteschlange enthaltenen Meldungen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> erstellt eine dynamische Liste aller Nachrichten in einer Warteschlange. Sie können aus der Warteschlange entfernt die Nachricht an der aktuellen Position des Enumerators durch den Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> für die <xref:System.Messaging.MessageEnumerator> , <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> zurückgibt.  
  
 Da der Cursor die dynamische Liste von Nachrichten in der Warteschlange zugeordnet ist, gibt die Enumeration jede Änderung, die Sie an die Nachrichten in der Warteschlange wieder, ist die Meldung außerhalb der aktuellen Cursorposition bis. Der Enumerator kann z. B. automatisch ein niedrigerer Priorität-Nachricht, die außerhalb der aktuellen Cursorposition eingefügt, jedoch keine höhere Priorität-Nachricht, die vor dieser Position eingefügt zugreifen. Allerdings Sie können Zurücksetzen die Enumeration und so den Cursor wieder an den Anfang der Liste durch Aufrufen von <xref:System.Messaging.MessageEnumerator.Reset%2A> für die <xref:System.Messaging.MessageEnumerator>.  
  
 Die Reihenfolge der Nachrichten in der Enumeration widerspiegelt deren Reihenfolge in der Warteschlange, damit Nachrichten höherer Priorität vor diejenigen niedrigerer Priorität angezeigt werden.  
  
 Wenn Sie eine statische Momentaufnahme der Nachrichten in der Warteschlange statt einer dynamischen Verbindung, die sie verwenden möchten, rufen Sie <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Diese Methode gibt ein Array von <xref:System.Messaging.Message> Objekte, die die Nachrichten zu dem Zeitpunkt darstellen, die Methode wurde aufgerufen.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine dynamische Liste von Nachrichten in einer Warteschlange ruft und zählt alle Meldungen mit der <xref:System.Messaging.Message.Priority%2A> -Eigenschaftensatz auf <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein Enumerationsobjekt für alle Meldungen in der Warteschlange.</summary>
        <returns>Ein <see cref="T:System.Messaging.MessageEnumerator" /> mit den in der Warteschlange enthaltenen Meldungen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> erstellt eine dynamische Liste aller Nachrichten in einer Warteschlange. Sie können aus der Warteschlange entfernt die Nachricht an der aktuellen Position des Enumerators durch den Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> für die <xref:System.Messaging.MessageEnumerator> , <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> zurückgibt.  
  
 Da der Cursor die dynamische Liste von Nachrichten in der Warteschlange zugeordnet ist, gibt die Enumeration jede Änderung, die Sie an die Nachrichten in der Warteschlange wieder, ist die Meldung außerhalb der aktuellen Cursorposition bis. Der Enumerator kann z. B. automatisch ein niedrigerer Priorität-Nachricht, die außerhalb der aktuellen Cursorposition eingefügt, jedoch keine höhere Priorität-Nachricht, die vor dieser Position eingefügt zugreifen. Allerdings Sie können Zurücksetzen die Enumeration und so den Cursor wieder an den Anfang der Liste durch Aufrufen von <xref:System.Messaging.MessageEnumerator.Reset%2A> für die <xref:System.Messaging.MessageEnumerator>.  
  
 Die Reihenfolge der Nachrichten in der Enumeration widerspiegelt deren Reihenfolge in der Warteschlange, damit Nachrichten höherer Priorität vor diejenigen niedrigerer Priorität angezeigt werden.  
  
 Wenn Sie eine statische Momentaufnahme der Nachrichten in der Warteschlange statt einer dynamischen Verbindung, die sie verwenden möchten, rufen Sie <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Diese Methode gibt ein Array von <xref:System.Messaging.Message> Objekte, die die Nachrichten zu dem Zeitpunkt darstellen, die Methode wurde aufgerufen.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Enumerationsobjekt für eine dynamische Liste der öffentlichen Warteschlangen im Netzwerk.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt eine Vorwärts-Cursorsemantik zum Durchlaufen aller öffentlichen Warteschlangen im Netzwerk bereit.</summary>
        <returns>Ein <see cref="T:System.Messaging.MessageQueueEnumerator" />, der eine dynamische Liste aller öffentlichen Meldungswarteschlangen im Netzwerk bereitstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung der <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> gibt eine Enumeration aller öffentlichen Warteschlangen, die sich im Netzwerk befinden.  
  
 Da der Cursor eine dynamische Liste zugeordnet ist, gibt die Enumeration jede Änderung, die Sie vornehmen, um eine Liste der Warteschlangen für Warteschlangen, die außerhalb der aktuellen Cursorposition hinzugefügt oder gelöscht. Hinzufügen oder Löschen von Warteschlangen vor der aktuellen Cursorposition werden nicht berücksichtigt. Der Enumerator kann z. B. eine Warteschlange, die hinter der Cursorposition angefügt, aber keiner vor dieser Position eingefügt automatisch zugreifen. Allerdings Sie können Zurücksetzen die Enumeration und so den Cursor wieder an den Anfang der Liste durch Aufrufen von <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> für die <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Es gibt keine festgelegte Reihenfolge von Warteschlangen in einem Netzwerk. Ein Enumerator sortiert, z. B. nach Computer, Bezeichnung, öffentlichen oder privaten Status oder andere Kriterien zugänglich nicht.  
  
 Wenn Sie eine statische Momentaufnahme der Warteschlangen auf dem Netzwerk statt einer dynamischen Verbindung mit möchten, rufen <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> oder <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Jede dieser beiden Methoden gibt ein Array von <xref:System.Messaging.MessageQueue> Objekte, die die Warteschlangen zum Zeitpunkt darstellen, die Methode wurde aufgerufen.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Meldungswarteschlangen im Netzwerk durchlaufen und untersucht den Pfad für jede Warteschlange. Schließlich wird die Anzahl von öffentlichen Warteschlangen im Netzwerk angezeigt.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Ein <see cref="T:System.Messaging.MessageQueueCriteria" />, das die Kriterien zum Filtern der verfügbaren Meldungswarteschlangen enthält.</param>
        <summary>Stellt eine Vorwärts-Cursorsemantik zum Durchlaufen aller öffentlichen Warteschlangen im Netzwerk bereit, die die angegebenen Kriterien erfüllen.</summary>
        <returns>Ein <see cref="T:System.Messaging.MessageQueueEnumerator" />, der eine dynamische Liste der öffentlichen Meldungswarteschlangen im Netzwerk bereitstellt, die die im <paramref name="criteria" />-Parameter angegebenen Bedingungen erfüllen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung der <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> gibt eine Liste aller öffentlichen Warteschlangen im Netzwerk, die in den Anwendungskriterien definierte Kriterien erfüllen. Sie können angeben, dass die Kriterien eingeschlossen werden, z. B. erstellungs- oder Änderungsdatum Zeit, die Computernamen, Menge, Kategorie oder eine beliebige Kombination dieser Warteschlange.  
  
 Da der Cursor eine dynamische Liste zugeordnet ist, gibt die Enumeration jede Änderung, die an eine Warteschlange zu stellen, die außerhalb der aktuellen Cursorposition auftritt, wieder. Änderungen an Warteschlangen vor der aktuellen Cursorposition werden nicht berücksichtigt. Der Enumerator kann z. B. eine Warteschlange, die hinter der Cursorposition angefügt, aber keiner vor dieser Position eingefügt automatisch zugreifen. Allerdings Sie können Zurücksetzen die Enumeration und so den Cursor wieder an den Anfang der Liste durch Aufrufen von <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> für die <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Es gibt keine festgelegte Reihenfolge von Warteschlangen in einem Netzwerk. Ein Enumerator sortiert, z. B. nach Computer, Bezeichnung, öffentlichen oder privaten Status oder andere Kriterien zugänglich nicht.  
  
 Wenn Sie eine statische Momentaufnahme der Warteschlangen auf das Netzwerk statt einer dynamischen Verbindung möchten, geben Sie Kriterien für <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> , oder rufen Sie <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Jede dieser beiden Methoden gibt ein Array von <xref:System.Messaging.MessageQueue> Objekte, die die Warteschlangen zum Zeitpunkt darstellen, die Methode wurde aufgerufen. Aufrufen von <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, oder <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> bietet die gleichen Ergebnisse wie das Aufrufen <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> mit den Filterkriterien der <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, und <xref:System.Messaging.MessageQueue.MachineName%2A>zugeordnet.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel durchläuft Nachrichtenwarteschlangen und zeigt den Pfad für jede Warteschlange, die in den letzten Tag erstellt wurde und vorhanden ist, auf dem Computer "MyComputer".  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Computer, dessen private Warteschlangen abgerufen werden sollen.</param>
        <summary>Ruft alle privaten Warteschlangen auf dem angegebenen Computer ab.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die abgerufenen privaten Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> Ruft eine statische Momentaufnahme der Warteschlangen auf einem angegebenen Computer ab.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft Warteschlangenlisten zu senden.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="machineName" />-Parameter ist <see langword="null" /> oder enthält eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk ab.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die abgerufenen öffentlichen Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn eine vollständige Liste aller öffentlichen Warteschlangen im Netzwerk verwendet werden soll. Wenn Sie z. B. die Liste nach bestimmten Kriterien einschränken möchten <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, oder die Uhrzeit der letzten Änderung mit einer anderen Überladung dieser Methode. (Alternativ können Sie <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, oder <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie für die Interaktion mit einer dynamischen Liste der Warteschlangen <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft Warteschlangenlisten zu senden.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Ein <see cref="T:System.Messaging.MessageQueueCriteria" />, das die Kriterien zum Filtern der Warteschlangen enthält.</param>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk ab, die die angegebenen Kriterien erfüllen.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die abgerufenen öffentlichen Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie alle öffentlichen Warteschlangen im Netzwerk nach Bezeichnung, Kategorie oder Computername filtern möchten die <xref:System.Messaging.MessageQueue> Klasse enthält bestimmte Methoden, die diese Funktionen bereitstellen (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, und <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>bzw.). Verwenden Sie diese Überladung, um eine Liste aller öffentlichen Warteschlangen im Netzwerk abzurufen, die mehr als eine der folgenden Kriterien erfüllen (beispielsweise, wenn Sie eine Bezeichnung und eine Kategorie angeben möchten). Sie können auch filtern, indem meldungskriterien außer <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, und <xref:System.Messaging.MessageQueue.MachineName%2A>. Beispielsweise verwenden Sie diese Überladung, um nach der Uhrzeit der letzten Änderung einer Warteschlange zu filtern. Erstellen Sie einfach eine neue Instanz der dem <xref:System.Messaging.MessageQueueCriteria> Klasse, legen Sie die entsprechenden Eigenschaften in der Instanz, und übergeben Sie die Instanz als der `criteria` Parameter.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie für die Interaktion mit einer dynamischen Liste der Warteschlangen <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft Warteschlangenlisten zu senden.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">Eine <see cref="T:System.Guid" /> zum Gruppieren der Gruppe von abzurufenden Warteschlangen.</param>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk ab, die der angegebenen Kategorie angehören.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die abgerufenen öffentlichen Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um öffentlichen Warteschlangen nach Kategorie filtern. Die <xref:System.Messaging.MessageQueue.Category%2A> Eigenschaft ermöglicht den Zugriff auf die Message Queuing-Typ ID-Eigenschaft (also Lese-/Schreibzugriff) einer bestimmten Warteschlange. Sie können zwar <xref:System.Guid.NewGuid%2A> Kategorie erstellen, die auf allen eindeutig ist <xref:System.Guid> Werte, es ist nicht erforderlich. Der Kategoriewert muss nur aus anderen Kategorien, die nicht von allen anderen unterscheiden <xref:System.Guid> Werte. Sie können z. B. zuweisen {00000000-0000-0000-0000-000000000001} als die <xref:System.Messaging.MessageQueue.Category%2A> für einen Satz von Warteschlangen und {00000000-0000-0000-0000-000000000002} als die <xref:System.Messaging.MessageQueue.Category%2A> für eine andere Gruppe.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie für die Interaktion mit einer dynamischen Liste der Warteschlangen <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Sie können die Kategorie angeben, als Teil der <xref:System.Messaging.MessageQueueCriteria> Sie an die Methode übergeben.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft Warteschlangenlisten zu senden.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">Eine Bezeichnung zum Gruppieren der Gruppe von abzurufenden Warteschlangen.</param>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk ab, die die angegebene Bezeichnung aufweisen.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die abgerufenen öffentlichen Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um die öffentliche Warteschlangen Bezeichnung zu filtern.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie für die Interaktion mit einer dynamischen Liste der Warteschlangen <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Geben Sie die Bezeichnung als Teil der <xref:System.Messaging.MessageQueueCriteria> Sie an die Methode übergeben.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft Warteschlangenlisten zu senden.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="label" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Name des Computers mit der Gruppe der abzurufenden öffentlichen Warteschlangen.</param>
        <summary>Ruft alle öffentlichen Warteschlangen auf dem angegebenen Computer ab.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die öffentlichen Warteschlangen auf dem Computer verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um öffentlichen Warteschlangen nach Computer filtern.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie für die Interaktion mit einer dynamischen Liste der Warteschlangen <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Sie können den Computernamen angeben, als Teil der <xref:System.Messaging.MessageQueueCriteria> Sie an die Methode übergeben.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokale Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft Warteschlangenlisten zu senden.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="machineName" />-Parameters ist falsch.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Sicherheitskontext ab, den MSMQ zum Zeitpunkt des Aufrufs dem aktuellen Benutzer zuordnet (Threadidentität).</summary>
        <returns>Ein <see cref="T:System.Messaging.SecurityContext" />-Objekt mit dem Sicherheitskontext.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den eindeutigen Message Queuing-Bezeichner für die Warteschlange ab.</summary>
        <value>Eine <see cref="P:System.Messaging.MessageQueue.Id" />, die die von der Message Queuing-Anwendung generierte Meldungs-ID darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing-legt die <xref:System.Messaging.MessageQueue.Id%2A> Eigenschaft bei der Erstellung der Warteschlangenobjekts. Diese Eigenschaft ist nur für Öffentliche Warteschlangen verfügbar.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.Id%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt fest, dass für eine Warteschlange keine Größenbeschränkung besteht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Element wird häufig verwendet, der zum Einstellen <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> oder <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Messaging.MessageQueue.InfiniteQueueSize> Member.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass für Methoden, die Meldungen einsehen oder empfangen, kein Timeout festgelegt ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> unterstützt zwei Arten von Nachrichtenabruf: synchrone und asynchrone. Die synchronen Methoden <xref:System.Messaging.MessageQueue.Peek%2A> und <xref:System.Messaging.MessageQueue.Receive%2A>, dazu führen, dass Prozessthreads warten ein angegebenen Zeitintervalls für eine neue Nachricht in der Warteschlange eintreffen. Wenn das angegebene Zeitintervall ist <xref:System.Messaging.MessageQueue.InfiniteTimeout>, Prozessthreads bleibt blockiert, bis eine neue Nachricht verfügbar ist. Andererseits, <xref:System.Messaging.MessageQueue.BeginPeek%2A> und <xref:System.Messaging.MessageQueue.BeginReceive%2A> (die asynchronen Methoden), ermöglichen die Hauptassembly der Anwendungsaufgaben in einem separaten Thread fortgesetzt, bis eine Nachricht in der Warteschlange eingeht.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Messaging.MessageQueue.InfiniteTimeout> Member.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Beschreibung der Warteschlange ab oder legt diese fest.</summary>
        <value>Die Bezeichnung der Meldungswarteschlange. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die maximale Länge für die Bezeichnung einer Warteschlange beträgt 124 Zeichen.  
  
 Die <xref:System.Messaging.MessageQueue.Label%2A> Eigenschaft muss nicht für alle Warteschlangen eindeutig sein. Jedoch, wenn mehrere Warteschlangen desselben Anzeigestatus <xref:System.Messaging.MessageQueue.Label%2A>, können Sie keine der <xref:System.Messaging.MessageQueue.Send%28System.Object%29> Methode, um eine Nachricht an alle übertragen. Bei Verwendung der Syntax der Volumebezeichnung für die <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft beim Senden der Nachricht, eine Ausnahme wird ausgelöst, wenn die <xref:System.Messaging.MessageQueue.Label%2A> ist nicht eindeutig.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.Label%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Bezeichnung wurde auf einen ungültigen Wert festgelegt.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zeitpunkt ab, zu dem die Eigenschaften einer Warteschlange zuletzt geändert wurden.</summary>
        <value>Eine <see cref="T:System.DateTime" />, die den Zeitpunkt der letzten Änderung der Warteschlangeneigenschaften angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeitpunkt der letzten Änderung enthält, wenn die Warteschlange erstellt wurde und ein beliebiger <xref:System.Messaging.MessageQueue> -Eigenschaft, die die Message Queuing-Warteschlange, wie z. B. ändert <xref:System.Messaging.MessageQueue.BasePriority%2A>. Der Wert, der die <xref:System.Messaging.MessageQueue.LastModifyTime%2A> Eigenschaft darstellt, die Systemzeit des lokalen Computers.  
  
 Rufen Sie <xref:System.Messaging.MessageQueue.Refresh%2A> vor dem Abrufen der <xref:System.Messaging.MessageQueue.LastModifyTime%2A> Eigenschaft; andernfalls, der Zeitpunkt der Änderung zugeordnet <xref:System.Messaging.MessageQueue> möglicherweise nicht auf dem neuesten Stand.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.LastModifyTime%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Computers ab, auf dem sich die Message Queuing-Warteschlange befindet, oder legt diesen fest.</summary>
        <value>Der Name des Computers, auf dem sich die Warteschlange befindet. Die Standardeinstellung von Message Queuing ist "." für den lokalen Computer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.MachineName%2A> ist ein Bestandteil der Syntax für den angezeigten Namen der Warteschlange <xref:System.Messaging.MessageQueue.Path%2A>. Die folgende Tabelle zeigt die Syntax, die Sie für eine Warteschlange eines bestimmten Typs verwenden soll, wenn der Pfad der Warteschlange über den Anzeigenamen angegeben werden sollen.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
|Computer-Journalwarteschlange|`MachineName`\\`Journal$`|  
|Computer, Warteschlange für unzustellbare|`MachineName`\\`Deadletter$`|  
|Computer Transaktionswarteschlange für unzustellbare|`MachineName`\\`XactDeadletter$`|  
  
 Verwenden "." für den lokalen Computer bei der Angabe der <xref:System.Messaging.MessageQueue.MachineName%2A>. Nur der Computernamen ist für diese Eigenschaft wird erkannt, z. B. `Server0`. Die <xref:System.Messaging.MessageQueue.MachineName%2A> -Eigenschaft das Format der IP-Adresse nicht unterstützt.  
  
 Wenn Sie definieren die <xref:System.Messaging.MessageQueue.Path%2A> im Sinne von der <xref:System.Messaging.MessageQueue.MachineName%2A>, die Anwendung löst eine Ausnahme aus, wenn Sie offline arbeiten, da der Domänencontroller für die Übersetzung des Pfads erforderlich ist. Deshalb müssen Sie verwenden die <xref:System.Messaging.MessageQueue.FormatName%2A> für die <xref:System.Messaging.MessageQueue.Path%2A> Syntax, wenn Sie offline arbeiten.  
  
 Die <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, und <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaften beziehen. Ändern der <xref:System.Messaging.MessageQueue.MachineName%2A> bewirkt, dass die <xref:System.Messaging.MessageQueue.Path%2A> zu ändernden Eigenschaft. Er wird erstellt, aus dem neuen <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A>. Ändern der <xref:System.Messaging.MessageQueue.Path%2A> (z. B. mit der formatnamenssyntax) setzt die <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaften zum Verweisen auf die neue Warteschlange. Wenn die <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaft leer ist, ist die <xref:System.Messaging.MessageQueue.Path%2A> festgelegt ist, in die Journalwarteschlange des Computers, die Sie angeben.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.MachineName%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Computername ist ungültig. Möglicherweise wurde eine falsche Syntax verwendet.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe der Journalwarteschlange ab oder legt diese fest.</summary>
        <value>Die maximale Größe der Journalwarteschlange in Kilobyte. In der Standardeinstellung von Message Queuing ist keine Begrenzung festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> bietet Zugriff auf die Speicherobergrenze für Message Queuing-Journal. Es ist nur relevant, wenn <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> ist `true`. Durch Festlegen dieser Eigenschaft ändert die Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind  
  
 Wenn Sie Nachrichten in einer Journalwarteschlange oder Dead Letter-Warteschlange gespeichert werden, sollten Sie in regelmäßigen Abständen deaktivieren die Warteschlange, um Nachrichten zu entfernen, die nicht mehr benötigt werden. Nachrichten in eine solche Warteschlange angerechnet Kontingent für die für den Computer, auf dem sich die Warteschlange befindet. (Der Administrator wird das Computerkontingent.)  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die maximale Größe der Journalwarteschlange wurde auf einen ungültigen Wert festgelegt.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe der Warteschlange ab oder legt diese fest.</summary>
        <value>Die maximale Größe der Warteschlange in KB. In der Standardeinstellung von Message Queuing ist keine Begrenzung festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> ermöglicht den Zugriff auf die Message Queuing-Nachricht Speicherlimit überschritten, die getrennt von dem Computer das Kontingent für der Administrator definiert sind. Weitere Informationen zu den Nachrichtenkontingent, finden Sie unter <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 Durch Festlegen dieser Eigenschaft ändert die Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind  
  
 Wenn versucht wird, überschreitet die maximale Warteschlangengröße oder das Kontingent für die Computer, möglicherweise Nachrichten verloren gehen. Wenn das Warteschlangenkontingent erreicht wird, benachrichtigt Message Queuing die Verwaltungswarteschlange, die von der sendenden Anwendung aus, um anzugeben, dass die Warteschlange voll ist, wird durch eine negative Bestätigungsnachricht zurückgeben. Message Queuing wird fortgesetzt, negative Bestätigungen zu senden, bis die Gesamtgröße der Nachrichten in der Warteschlange unter dem Limit liegt.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die maximale Größe für die Warteschlange enthält einen negativen Wert.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Eigenschaftenfilter für das Empfangen oder Einsehen von Meldungen ab oder legt diesen fest.</summary>
        <value>Der <see cref="T:System.Messaging.MessagePropertyFilter" />, der von der Warteschlange zum Filtern der Eigenschaften verwendet wird, die mit einer Meldung empfangen oder eingesehen werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Filter ist ein Satz von booleschen Werten, die die Nachrichteneigenschaften einschränken, die die <xref:System.Messaging.MessageQueue> empfängt oder einsieht. Wenn die <xref:System.Messaging.MessageQueue> empfängt oder sieht eine Nachricht aus der Serverwarteschlange abgerufen, nur die Eigenschaften für die die <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> Wert ist `true`.  
  
 Im folgenden werden die anfänglichen Eigenschaftenwerte für die <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> Eigenschaft. Diese Einstellungen sind identisch mit einem Aufruf <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> auf eine <xref:System.Messaging.MessagePropertyFilter>.  
  
|Eigenschaft|Standardwert|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 Byte|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 Byte|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 Byte|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> beschränken Sie die Eigenschaften der Nachricht empfangen.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Filter ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eingeführt in MSMQ 3.0. Ruft die der Warteschlange zugeordnete Multicastadresse ab oder oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.String" /> mit einer gültigen Multicastadresse (im nachfolgend angegebenen Format) oder <see langword="null" />. Letzteres gibt an, dass die Warteschlange keiner Multicastadresse zugeordnet ist.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.MulticastAddress%2A> Eigenschaft wird verwendet, um eine nicht transaktionale Warteschlange mit einer Multicastadresse zuordnen, die beim Senden von Nachrichten verwendet werden kann. Eine transaktionale Warteschlange nicht mit einer Multicastadresse zugeordnet werden. Wenn die sendende Anwendung Nachrichten an eine Multicastadresse sendet, sendet Message Queuing eine Kopie der Nachricht zu jedem dieser Adresse zugeordnete Warteschlange.  
  
 Multicast-IP-Adressen muss im Bereich Klasse D von 224.0.0.0 bis 239.255.255.255 an, die die ersten vier höherwertigen Bits 1110 gleich Einstellung entspricht. Nur bestimmte Bereiche von Adressen in diesem Bereich sind jedoch nicht reserviert und für das Senden von Multicastnachrichten verfügbar. Die aktuelle Liste der reservierten Multicastadressen, finden Sie unter der [Internet Assigned Number Authority (IANA) Internet Multicastadressen](http://go.microsoft.com/fwlink/?linkid=3859) Webseite. Es gibt keine Einschränkungen auf die Portnummer an.  
  
 Wenn mehrere Quellcomputern multicast-Nachrichten senden, und Sie eine bestimmte Warteschlange zum Empfangen von Nachrichten aus nur einem Quellcomputer möchten, muss jede Quellcomputer Nachrichten an eine andere Kombination aus IP-Adresse und Port senden.  
  
 Um eine Warteschlange zu einer Multicastadresse trennen möchten, legen Sie die <xref:System.Messaging.MessageQueue.MulticastAddress%2A> Eigenschaft, um eine Zeichenfolge der Länge 0 (null). Legen Sie sie nicht auf `null`, wie dies führt eine <xref:System.ArgumentNullException>.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad der Warteschlange ab oder legt diesen fest. Nach dem Festlegen des <see cref="P:System.Messaging.MessageQueue.Path" /> zeigt die <see cref="T:System.Messaging.MessageQueue" /> auf eine neue Warteschlange.</summary>
        <value>Die Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist. Die Standardeinstellung hängt vom verwendeten <see cref="M:System.Messaging.MessageQueue.#ctor" />-Konstruktor ab. Sie ist entweder <see langword="null" />, oder sie wird durch den <paramref name="path" />-Parameter des Konstruktors angegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Syntax für die <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft hängt vom Typ der Warteschlange es zeigt an, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
|Computer-Journalwarteschlange|`MachineName`\\`Journal$`|  
|Computer, Warteschlange für unzustellbare|`MachineName`\\`Deadletter$`|  
|Computer Transaktionswarteschlange für unzustellbare|`MachineName`\\`XactDeadletter$`|  
  
 Verwenden "." auf den lokalen Computer darzustellen.  
  
 Die <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, und <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaften beziehen. Ändern der <xref:System.Messaging.MessageQueue.MachineName%2A> bewirkt, dass die <xref:System.Messaging.MessageQueue.Path%2A> zu ändernden Eigenschaft. Er wird erstellt, aus dem neuen <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A>. Ändern der <xref:System.Messaging.MessageQueue.Path%2A> (z. B. mit der formatnamenssyntax) setzt die <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaften zum Verweisen auf die neue Warteschlange.  
  
 Alternativ können Sie die <xref:System.Messaging.MessageQueue.FormatName%2A> oder <xref:System.Messaging.MessageQueue.Label%2A> den Warteschlangenpfad zu beschreiben, wie in der folgenden Tabelle gezeigt.  
  
|Referenz|Syntax|Beispiel|  
|---------------|------------|-------------|  
|Formatname|`FormatName:` [ *Formatnamen* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Bezeichnung|`Label:` [ *label* ]|`Label:` TheLabel|  
  
 Bei Verwendung der Syntax der Volumebezeichnung für die <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft beim Senden der Nachricht, eine Ausnahme wird ausgelöst, wenn die <xref:System.Messaging.MessageQueue.Label%2A> ist nicht eindeutig.  
  
 Um offline zu arbeiten, müssen Sie die Syntax der Anzeigename, anstatt die formatnamenssyntax in der ersten Tabelle verwenden. Andernfalls wird eine Ausnahme ausgelöst, da der primäre Domänencontroller (Active Directory auf dem befindet) nicht zum Auflösen des Pfads in den Formatnamen verfügbar ist.  
  
 Festlegen eines neuen Pfads schließt die Nachrichtenwarteschlange und alle Handles frei.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
> [!NOTE]
>  Im Arbeitsgruppenmodus können Sie nur die private Warteschlangen verwenden. Geben Sie den Pfad mit der Syntax für die private Warteschlange `MachineName` \\ `Private$` \\ `QueueName`.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt neuer <xref:System.Messaging.MessageQueue> -Objekte mit verschiedenen Pfad benennen Syntax von Typen. In jedem Fall sendet er eine Nachricht an die Warteschlange, deren Pfad im Konstruktor definiert ist.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist ungültig. Möglicherweise wurde eine falsche Syntax verwendet.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <summary>Gibt eine Kopie der ersten Meldung in der Warteschlange zurück, ohne die Meldung aus der Warteschlange zu entfernen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird beendet, ohne die erste Meldung in der Warteschlange zu entfernen (einzusehen), auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Die <see cref="M:System.Messaging.MessageQueue.Peek" />-Methode ist synchron. Sie blockiert daher den aktuellen Thread bis zum Eingang einer Meldung.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, die die erste Meldung in der Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung aus, um eine Warteschlange einsehen oder warten, bis eine Nachricht in die Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode liest, jedoch nicht entfernt, die erste Nachricht aus der Warteschlange. Aus diesem Grund wiederholte Aufrufe von <xref:System.Messaging.MessageQueue.Peek%2A> dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode, andererseits, liest und die erste Nachricht aus der Warteschlange entfernt. Wiederholte Aufrufe von <xref:System.Messaging.MessageQueue.Receive%2A>, daher verschiedene Nachrichten zurückzugeben.  
  
 Message Queuing ordnet die Nachrichten in der Warteschlange nach Priorität und der Ankunft. Eine neuere Nachricht wird vor einer älteren platziert werden, nur, wenn sie eine höhere Priorität hat.  
  
 Verwenden Sie <xref:System.Messaging.MessageQueue.Peek%2A>¸ wenn eine Blockade des aktuellen Threads bis zum Eingehen einer Nachricht in die Warteschlange akzeptabel ist. Da diese Überladung ein Timeouts nicht angegeben ist, kann die Anwendung unbegrenzt warten. Wenn die Anwendungsverarbeitung ohne Wartezeiten fortgesetzt werden soll, verwenden Sie die asynchrone <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode. Alternativ können Sie angeben, einen Timeout für eine Nachricht in der Warteschlange eintrifft, mit der Überladung der <xref:System.Messaging.MessageQueue.Peek%2A> , einen Timeout angibt.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Die folgenden Beispiele verwenden die <xref:System.Messaging.MessageQueue.Peek%2A> Methode in einer Warteschlange.  
  
 Im ersten Beispiel wartet die Anwendung eine Nachricht in der Warteschlange verfügbar wird. Beachten Sie, dass im erste Beispiel nicht geht die Nachricht zugreifen. Es wird lediglich angehalten, verarbeitet werden, bevor eine Nachricht eingeht. Wenn eine Nachricht in die Warteschlange bereits vorhanden ist, wird sofort zurückgegeben.  
  
 Im zweiten Beispiel, eine Nachricht mit einem anwendungsdefinierten `Order` Klasse ist an die Warteschlange gesendet und anschließend aus der Warteschlange eingesehen.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die maximale Zeitspanne angibt, für die auf den Eingang einer Meldung gewartet werden soll.</param>
        <summary>Wird beendet, ohne die erste Meldung in der Warteschlange zu entfernen (einzusehen), auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Die <see cref="M:System.Messaging.MessageQueue.Peek" />-Methode ist synchron. Sie blockiert daher den aktuellen Thread, bis eine Meldung verfügbar wird oder der Timeout eintritt.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, die die erste Meldung in der Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, können Sie eine Warteschlange einsehen und warten Sie einen angegebenen Zeitraum, bis eine Nachricht in die Warteschlange vorhanden ist. Die Methode gibt sofort zurück, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode liest, jedoch nicht entfernt, die erste Nachricht aus der Warteschlange. Aus diesem Grund wiederholte Aufrufe von <xref:System.Messaging.MessageQueue.Peek%2A> dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode, andererseits, liest und die erste Nachricht aus der Warteschlange entfernt. Wiederholte Aufrufe von <xref:System.Messaging.MessageQueue.Receive%2A>, daher verschiedene Nachrichten zurückzugeben.  
  
 Message Queuing ordnet die Nachrichten in der Warteschlange nach Priorität und der Ankunft. Eine neuere Nachricht wird vor einer älteren platziert werden, nur, wenn sie eine höhere Priorität hat.  
  
 Verwenden Sie <xref:System.Messaging.MessageQueue.Peek%2A>¸ wenn eine Blockade des aktuellen Threads bis zum Eingehen einer Nachricht in die Warteschlange akzeptabel ist. Der Thread bis zum angegebenen Zeitraum Zeit oder auf unbestimmte Zeit blockiert werden, wenn Sie angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Wenn die Anwendungsverarbeitung ohne Wartezeiten fortgesetzt werden soll, verwenden Sie die asynchrone <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Messaging.MessageQueue.Peek%2A> Methode mit einem Timeoutwert von 0 (null), um zu überprüfen, ob die Warteschlange leer ist.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die maximale Zeitspanne angibt, für die auf den Eingang einer Meldung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <param name="action">Einer der <see cref="T:System.Messaging.PeekAction" />-Werte. Gibt an, ob die aktuelle oder die folgende Meldung in der Warteschlange eingesehen wird.</param>
        <summary>Wird beendet, ohne die aktuelle oder die nächste Meldung mithilfe des angegebenen Cursors zu entfernen (einzusehen). Die <see cref="M:System.Messaging.MessageQueue.Peek" />-Methode ist synchron. Sie blockiert daher den aktuellen Thread, bis eine Meldung verfügbar wird oder der Timeout eintritt.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die eine Meldung in der Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, können Sie eine Warteschlange einsehen und warten Sie einen angegebenen Zeitraum, bis eine Nachricht in die Warteschlange vorhanden ist. Die Methode gibt sofort zurück, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode liest, jedoch nicht entfernt, eine Nachricht aus der Warteschlange. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode, andererseits, liest und eine Nachricht aus der Warteschlange entfernt.  
  
 Verwenden Sie <xref:System.Messaging.MessageQueue.Peek%2A>¸ wenn eine Blockade des aktuellen Threads bis zum Eingehen einer Nachricht in die Warteschlange akzeptabel ist. Der Thread blockiert, bis zu den angegebenen Zeitraum Zeit oder unbegrenzt haben Sie <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Wenn die Anwendungsverarbeitung ohne Wartezeiten fortgesetzt werden soll, verwenden Sie die asynchrone <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für den <paramref name="action" />-Parameter wurde ein anderer Wert als <see langword="PeekAction.Current" /> oder <see langword="PeekAction.Next" /> angegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig. Möglicherweise ist <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sieht eine Meldung mit der angegebenen Korrelations-ID ein.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der einzusehenden Meldung.</param>
        <summary>Sieht die Meldung mit der angegebenen Korrelations-ID ein und löst sofort eine Ausnahme aus, wenn in der Warteschlange derzeit keine Meldung mit der angegebenen Korrelations-ID vorhanden ist.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Warteschlange, die auf die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Wenn keine Nachricht gefunden wird, entspricht die `correlationID` Parameter, es wird eine Ausnahme ausgelöst.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht an die Warteschlange zugeordnete Antwort, Berichts- oder Bestätigungsnachricht Nachrichten zu binden.  
  
 Zwei andere Methoden ermöglichen es Ihnen zum Einsehen von Nachrichten in einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode dient zum Abrufen einer Nachricht durch Angabe des eindeutigen Bezeichners.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht, die eine Bestellung in und aus einer Warteschlange enthält. Eine positive Bestätigung wird ausdrücklich angefordert, wenn die ursprüngliche Nachricht erreicht wurde oder wird aus der Warteschlange abgerufen.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="correlationId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der einzusehenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <summary>Sieht eine Meldung mit der angegebenen Korrelations-ID ein und wartet, bis eine Meldung mit der angegebenen Korrelations-ID in der Warteschlange verfügbar ist oder bis der Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Warteschlange, die auf die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Wenn keine Nachricht gefunden wird, entspricht die `correlationID` Parameter und keine neue Nachricht geht in der Warteschlange innerhalb des Zeitraums gemäß der `timeout` Parameter, es wird eine Ausnahme ausgelöst.  
  
 Die `timeout` Parameter gibt die Gesamtausführungszeit für diese Methode keine. Stattdessen gibt es die Zeit zum Warten, bis einer neuen Nachricht in der Warteschlange eintreffen. Jedes Mal eine neue Nachricht eingeht, wird diese Methode überprüft die <xref:System.Messaging.Message.CorrelationId%2A> der neuen Nachricht zu überprüfen, ob es entspricht dem `correlationId` Parameter. Wenn dies nicht der Fall, diese Methode startet den Timeoutzeitraum über und wartet auf eine andere neue Nachricht auf das eingehen. Daher neue Nachrichten weiterhin innerhalb des Timeoutzeitraums eintreffen, ist es möglich, dass diese Methode zur Ausführung unbegrenzt lange, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht der `correlationId` Parameter.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht an die Warteschlange zugeordnete Antwort, Berichts- oder Bestätigungsnachricht Nachrichten zu binden.  
  
 Zwei andere Methoden ermöglichen es Ihnen zum Einsehen von Nachrichten in einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode dient zum Abrufen einer Nachricht durch Angabe des eindeutigen Bezeichners.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine Meldung mit der angegebenen <paramref name="correlationId" /> ist nicht in der Warteschlange vorhanden und nicht vor Ablauf des Timeouts eingegangen.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung eingegangen.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Kopie der Meldung mit der angegebenen Meldungs-ID zurück, ohne die Meldung aus der Warteschlange zu entfernen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der einzusehenden Meldung.</param>
        <summary>Sieht die Meldung ein, deren Meldungs-ID mit dem <paramref name="id" />-Parameter übereinstimmt.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft mit dem <paramref name="id" />-Parameter übereinstimmt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> zu lesen, ohne dass aus der Warteschlange entfernt, eine Nachricht, die über eine bekannte Nachrichten-ID verfügt. Der Bezeichner einer Nachricht ist für die Message Queuing-Organisation eindeutig, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter. Diese Überladung löst eine Ausnahme aus, wenn die Warteschlange zurzeit nicht die Nachricht enthält.  
  
 Zwei weitere Methoden ermöglichen es Ihnen zum Einsehen von Nachrichten in einer Warteschlange: <xref:System.Messaging.MessageQueue.Peek%2A> und <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Nachricht in der Warteschlange zurück. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> gibt eine Bestätigung, den Bericht oder die Anwendung generierte Antwortnachricht, die als Ergebnis eine Meldung an die Warteschlange gesendeten erstellt wurde.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine Meldung mit der angegebenen <paramref name="id" /> vorhanden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der einzusehenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <summary>Sieht die Meldung ein, deren Meldungs-ID mit dem <paramref name="id" />-Parameter übereinstimmt. Wartet, bis die Meldung in der Warteschlange eingeht oder ein Timeout auftritt.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft mit dem <paramref name="id" />-Parameter übereinstimmt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> zu lesen, ohne dass aus der Warteschlange entfernt, eine Nachricht, die über eine bekannte Nachrichten-ID verfügt. Der Bezeichner einer Nachricht ist für die Message Queuing-Organisation eindeutig, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter. Diese Überladung löst eine Ausnahme aus, wenn die Warteschlange derzeit keine Nachricht enthält und eine neue Nachricht kommen nicht, bevor das Timeout auftritt.  
  
 Die `timeout` Parameter gibt die Gesamtausführungszeit für diese Methode keine. Stattdessen gibt es die Zeit zum Warten, bis einer neuen Nachricht in der Warteschlange eintreffen. Jedes Mal eine neue Nachricht eingeht, wird diese Methode überprüft die <xref:System.Messaging.Message.Id%2A> der neuen Nachricht zu überprüfen, ob es entspricht dem `id` Parameter. Wenn dies nicht der Fall, diese Methode startet den Timeoutzeitraum über und wartet auf eine andere neue Nachricht auf das eingehen. Daher neue Nachrichten weiterhin innerhalb des Timeoutzeitraums eintreffen, ist es möglich, dass diese Methode zur Ausführung unbegrenzt lange, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.Id%2A> entspricht der `id` Parameter.  
  
 Zwei weitere Methoden ermöglichen es Ihnen zum Einsehen von Nachrichten in einer Warteschlange: <xref:System.Messaging.MessageQueue.Peek%2A> und <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Nachricht in der Warteschlange zurück. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> gibt eine Bestätigung, den Bericht oder die Anwendung generierte Antwortnachricht, die als Ergebnis eine Meldung an die Warteschlange gesendeten erstellt wurde.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine Meldung mit der angegebenen <paramref name="id" /> ist nicht in der Warteschlange vorhanden und nicht vor Ablauf der im <paramref name="timeout" />-Parameter angegebenen Zeitspanne eingegangen.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Eingeführt in MSMQ 3.0. Sieht eine bestimmte Meldung in der Warteschlange ein. Die Meldung kann anhand eines Suchbezeichners oder anhand der Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der einzusehenden Meldung.</param>
        <summary>Eingeführt in MSMQ 3.0. Sieht die Meldung ein, die dem angegebenen Suchbezeichner in einer nicht transaktionalen Warteschlange entspricht.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.LookupId" />-Eigenschaft dem übergebenen <paramref name="lookupId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bestimmten Suchbezeichner zu lesen, ohne es zu entfernen aus der Warteschlange an. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft einer Nachricht ist eindeutig in der Warteschlange befindet, in dem die Nachricht ein, damit kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `lookupId` Parameter.  
  
 Verwenden Sie zum Lesen einer Nachricht mit der angegebenen Nachschlage-ID und aus der Warteschlange zu entfernen, die <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> Methode.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="lookupId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">Einer der <see cref="T:System.Messaging.MessageLookupAction" />-Werte, der angibt, wie die Meldung in der Warteschlange gelesen wird. Geben Sie eine der folgenden Optionen an:  
  
 <see langword="MessageLookupAction.Current" />: Sieht die durch <c>lookupId</c> angegebene Meldung ein.  
  
 <see langword="MessageLookupAction.Next" />: Sieht die Meldung ein, die auf die durch <c>lookupId</c> angegebene Meldung folgt.  
  
 <see langword="MessageLookupAction.Previous" />: Sieht die Meldung ein, die der die durch <c>lookupId</c> angegebene Meldung vorausgeht.  
  
 <see langword="MessageLookupAction.First" />: Sieht die erste Meldung in der Warteschlange ein. Der <c>lookupId</c>-Parameter muss auf 0 (null) festgelegt werden.  
  
 <see langword="MessageLookupAction.Last" />: Sieht die letzte Meldung in der Warteschlange ein. Der <c>lookupId</c>-Parameter muss auf 0 (null) festgelegt werden.</param>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der einzusehenden Meldung, andernfalls 0 (null). 0 wird beim Zugreifen auf die erste oder letzte Meldung in die Warteschlange verwendet.</param>
        <summary>Eingeführt in MSMQ 3.0. Sieht eine bestimmte Meldung in der Warteschlange ein. Die Meldung kann anhand eines Suchbezeichners oder anhand der Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
        <returns>Die durch den übergebenen <paramref name="action" />-Parameter und <paramref name="lookupId" />-Parameter angegebene <see cref="T:System.Messaging.Message" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bestimmten Suchbezeichner zu lesen, ohne es zu entfernen aus der Warteschlange an. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft einer Nachricht ist eindeutig in der Warteschlange befindet, in dem die Nachricht ein, damit kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `lookupId` Parameter.  
  
 Verwenden Sie zum Lesen einer Nachricht mit einem angegebenen Bezeichner und aus der Warteschlange zu entfernen, die <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> Methode.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="lookupId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="action" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageLookupAction" />-Member.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine Meldung gelesen wird, ohne sie aus der Warteschlange zu entfernen. Dies ist ein Ergebnis eines asynchronen <see cref="M:System.Messaging.MessageQueue.BeginPeek" />-Vorgangs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> wird verwendet, bei der asynchronen Verarbeitung zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis aus, wenn eine Nachricht in der Warteschlange verfügbar ist.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> Dient zum Abschließen des Vorgangs, der durch einen Aufruf initiiert <xref:System.Messaging.MessageQueue.BeginPeek%2A> und die Nachricht bei der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst.  
  
 Beim Erstellen eines <xref:System.Messaging.PeekCompletedEventHandler>-Delegaten bestimmen Sie die Methode für die Ereignisbehandlung. Um dem Ereignishandler das Ereignis zuzuordnen, fügen Sie dem Ereignis eine Instanz des Delegaten hinzu. Der Ereignishandler wird bei jedem Eintreten des Ereignisses aufgerufen, sofern der Delegat nicht entfernt wird. Weitere Informationen zu Ereignishandlerdelegaten, finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Ereignishandler namens `MyPeekCompleted`, fügt es der <xref:System.Messaging.MessageQueue.PeekCompleted> eventhandlerdelegaten und ruft <xref:System.Messaging.MessageQueue.BeginPeek%2A> um einen asynchronen Lesevorgang in der Warteschlange zu initiieren, die unter dem Pfad befindet ". \myQueue". Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst, die im Beispiel sieht die Nachricht und schreibt Text auf dem Bildschirm. Das Beispiel ruft dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aus, um eine neue asynchronen Lesevorgang initiieren  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle in der Warteschlange enthaltenen Meldungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löschen der Warteschlangenobjekts bewirkt, dass Message Queuing zum fest, wodurch die wirkt sich auf die <xref:System.Messaging.MessageQueue.LastModifyTime%2A> Eigenschaft. Nachrichten, die aus der Warteschlange gelöscht werden, gehen verloren; Sie werden nicht an die Dead Letter-Warteschlange oder Journalwarteschlange gesendet.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den angezeigten Namen für die Warteschlange ab oder legt diesen fest.</summary>
        <value>Der Name zur Bezeichnung der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Der Wert darf nicht <see langword="null" /> sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie kombinieren können die <xref:System.Messaging.MessageQueue.QueueName%2A> mit der <xref:System.Messaging.MessageQueue.MachineName%2A> So erstellen einen aussagekräftigen <xref:System.Messaging.MessageQueue.Path%2A> Namen für die Warteschlange. Die Syntax für den Anzeigenamen des der <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft hängt vom Typ der Warteschlange, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Verwenden "." auf den lokalen Computer darzustellen.  
  
 Ändern der <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaft wirkt sich auf die <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft. Wenn Sie festlegen, die <xref:System.Messaging.MessageQueue.QueueName%2A> festlegen, ohne die <xref:System.Messaging.MessageQueue.MachineName%2A> -Eigenschaft, die <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.\\ `QueueName`. Andernfalls die <xref:System.Messaging.MessageQueue.Path%2A> wird `MachineName` \\ `QueueName`.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name der Warteschlange ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das systemeigene Handle zum Empfangen von Meldungen aus der Meldungswarteschlange ab.</summary>
        <value>Ein Handle für das systemeigene Warteschlangenobjekt, das zum Einsehen und Empfangen von Meldungen aus der Warteschlange verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.ReadHandle%2A> bietet eine systemeigene Windows-Handle für das Message Queue-Objekt, das für den Empfang und Empfangen von Nachrichten aus der Warteschlange verwendet wird. Wenn Sie den Pfad der Warteschlange zu ändern, wird durch einen neuen Wert das Handle geschlossen und erneut geöffnet.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <summary>Empfängt die erste Meldung aus der Warteschlange und entfernt sie aus der Warteschlange.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Empfängt die erste verfügbare Meldung aus der Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser Aufruf ist synchron und blockiert den aktuellen Ausführungsthread, bis eine Meldung verfügbar ist.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht aus einer Warteschlange empfangen, oder warten Sie, bis die Nachrichten in der Warteschlange vorhanden sind.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchrone Lesen einer Nachricht und somit aus der Warteschlange entfernt. Nachfolgende Aufrufe <xref:System.Messaging.MessageQueue.Receive%2A> gibt zurück, die Nachrichten, die in der Warteschlange oder neuer, Nachrichten mit höhere Priorität folgen.  
  
 Um die erste Nachricht in einer Warteschlange ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn eine für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Da dieser Überladung von der <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt ein unbegrenztes Timeout an, die Anwendung möglicherweise unbegrenzt warten. Wenn die anwendungsverarbeitung ohne Wartezeiten für die Nachricht fortgesetzt werden soll, erwägen Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Nachricht aus einer Warteschlange empfängt und gibt Informationen über diese Meldung auf dem Bildschirm.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die erste verfügbare Meldung aus der transaktionalen Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser Aufruf ist synchron und blockiert den aktuellen Ausführungsthread, bis eine Meldung verfügbar ist.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht von einer Transaktionswarteschlange mit den internen bereits verwendeten Transaktionskontext durch definiert die `transaction` -Parameters an, oder warten Sie, bis die Nachrichten in der Warteschlange vorhanden sind.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchrone Lesen einer Nachricht und somit aus der Warteschlange entfernt. Nachfolgende Aufrufe <xref:System.Messaging.MessageQueue.Receive%2A> zurück in die Warteschlange die Nachrichten, die folgen.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um die erste Nachricht in einer Warteschlange ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts ein Rollback durch einen Aufruf von <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn eine für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Da dieser Überladung von der <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt ein unbegrenztes Timeout an, die Anwendung möglicherweise unbegrenzt warten. Wenn die anwendungsverarbeitung ohne Wartezeiten für die Nachricht fortgesetzt werden soll, erwägen Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einer transaktionalen Warteschlange auf dem lokalen Computer her, und sendet eine Nachricht an die Warteschlange. Anschließend wird die Nachricht mit einer Bestellung empfangen. Wenn sie eine nicht transaktionale Warteschlange auftritt, löst sie Ausnahme ausgegeben und ein Rollback der Transaktion.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.  
  
 - oder -   
  
 Die Warteschlange ist nicht transaktional.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die erste verfügbare Meldung aus der Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser Aufruf ist synchron und blockiert den aktuellen Ausführungsthread, bis eine Meldung verfügbar ist.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht aus einer Warteschlange mit einem bereits verwendeten Transaktionskontext durch definiert die `transactionType` -Parameters an, oder warten Sie, bis die Nachrichten in der Warteschlange vorhanden sind.  
  
 Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchrone Lesen einer Nachricht und somit aus der Warteschlange entfernt. Nachfolgende Aufrufe <xref:System.Messaging.MessageQueue.Receive%2A> zurück in die Warteschlange die Nachrichten, die folgen.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht von einer Transaktionswarteschlange zu empfangen, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um die erste Nachricht in einer Warteschlange ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts ein Rollback durch einen Aufruf von <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn eine für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Da dieser Überladung von der <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt ein unbegrenztes Timeout an, die Anwendung möglicherweise unbegrenzt warten. Wenn die anwendungsverarbeitung ohne Wartezeiten für die Nachricht fortgesetzt werden soll, erwägen Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <summary>Empfängt die erste verfügbare Meldung aus der Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist, und wartet, bis eine Meldung in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Überladung können Sie eine Meldung empfangen und nach einer angegebenen Zeitspanne beenden, sofern sich keine Meldungen in der Warteschlange befinden.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchronen Lesen einer Nachricht aus der Warteschlange entfernt. Nachfolgende Aufrufe <xref:System.Messaging.MessageQueue.Receive%2A> gibt zurück, die Nachrichten, die in der Warteschlange oder neuer, Nachrichten mit höhere Priorität folgen.  
  
 Um die erste Nachricht in einer Warteschlange ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn eine für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Der Thread für den angegebenen Zeitraum Zeit oder auf unbestimmte Zeit blockiert werden, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter. Wenn die anwendungsverarbeitung ohne Wartezeiten für eine Nachricht fortgesetzt werden soll, erwägen Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Nachricht aus einer Warteschlange empfängt und gibt Informationen über diese Meldung auf dem Bildschirm. Im Beispiel hält die Ausführung bis zu fünf Sekunden warten, in der Warteschlange eingehen einer Nachricht.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <summary>Empfängt unter Verwendung des aktuellen Cursors die aktuelle Meldung in der Warteschlange. Wenn keine Meldung verfügbar ist, wartet diese Methode, bis eine Meldung verfügbar ist oder der Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.  
  
 Mit dieser Überladung können Sie eine Meldung empfangen und nach einer angegebenen Zeitspanne beenden, sofern sich keine Meldungen in der Warteschlange befinden.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die erste verfügbare Meldung aus der transaktionalen Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist, und wartet, bis eine Meldung in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht von einer Transaktionswarteschlange mit den internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter und Rückgabetypen innerhalb einer festgelegten Zeitspanne Wenn in der Warteschlange keine Nachrichten vorhanden sind.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchrone Lesen einer Nachricht und somit aus der Warteschlange entfernt. Nachfolgende Aufrufe <xref:System.Messaging.MessageQueue.Receive%2A> zurück in die Warteschlange die Nachrichten, die folgen.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um die erste Nachricht in einer Warteschlange ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts ein Rollback durch einen Aufruf von <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn eine für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Der Thread für den angegebenen Zeitraum Zeit oder auf unbestimmte Zeit blockiert werden, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter. Wenn die anwendungsverarbeitung ohne Wartezeiten für eine Nachricht fortgesetzt werden soll, erwägen Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieser Methode veranschaulicht.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
 - oder -   
  
 Die Warteschlange ist nicht transaktional.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die erste verfügbare Meldung aus der Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser Aufruf ist synchron und wartet, bis entweder eine Meldung in der Warteschlange verfügbar ist oder der Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht aus einer Warteschlange mit einem bereits verwendeten Transaktionskontext durch definiert die `transactionType` Parameter und der Rückgabewert in einer angegebenen Zeitspanne, wenn keine Nachrichten in der Warteschlange vorhanden sind.  
  
 Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchrone Lesen einer Nachricht und somit aus der Warteschlange entfernt. Nachfolgende Aufrufe <xref:System.Messaging.MessageQueue.Receive%2A> zurück in die Warteschlange die Nachrichten, die folgen.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht von einer Transaktionswarteschlange zu empfangen, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um die erste Nachricht in einer Warteschlange ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts ein Rollback durch einen Aufruf von <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn eine für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Der Thread für den angegebenen Zeitraum Zeit oder auf unbestimmte Zeit blockiert werden, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter. Wenn die anwendungsverarbeitung ohne Wartezeiten für eine Nachricht fortgesetzt werden soll, erwägen Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieser Methode veranschaulicht.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt unter Verwendung des aktuellen Cursors die aktuelle Meldung in der Warteschlange. Wenn keine Meldung verfügbar ist, wartet diese Methode, bis eine Meldung verfügbar ist oder der Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf eine Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht von einer Transaktionswarteschlange mit den internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter und Rückgabetypen innerhalb einer festgelegten Zeitspanne Wenn in der Warteschlange keine Nachrichten vorhanden sind.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchrone Lesen einer Nachricht und somit aus der Warteschlange entfernt. Nachfolgende Aufrufe <xref:System.Messaging.MessageQueue.Receive%2A> die Nachrichten, die Folgen in der Warteschlange zurück.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Verwenden Sie zum Lesen einer Nachricht in einer Warteschlange ohne entfernt diese aus der Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernen, die Nachrichten in die Warteschlange verfügt, gibt es keine durch einen Aufruf von Rollback <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn eine für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Der Thread ist für den angegebenen Zeitraum Zeit oder auf unbestimmte Zeit blockiert, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter. Wenn die anwendungsverarbeitung ohne Wartezeiten für eine Nachricht fortgesetzt werden soll, erwägen Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.  
  
 - oder -   
  
 Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig. Möglicherweise ist <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
 - oder -   
  
 Die Warteschlange ist nicht transaktional.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt unter Verwendung des aktuellen Cursors die aktuelle Meldung in der Warteschlange. Wenn keine Meldung verfügbar ist, wartet diese Methode, bis eine Meldung verfügbar ist oder der Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf eine Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht aus einer Warteschlange mit einem bereits verwendeten Transaktionskontext durch definiert die `transactionType` Parameter und der Rückgabewert in einer angegebenen Zeitspanne, wenn keine Nachrichten in der Warteschlange vorhanden sind.  
  
 Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchrone Lesen einer Nachricht und somit aus der Warteschlange entfernt. Nachfolgende Aufrufe <xref:System.Messaging.MessageQueue.Receive%2A> die Nachrichten, die Folgen in der Warteschlange zurück.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht von einer Transaktionswarteschlange zu empfangen, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Verwenden Sie zum Lesen einer Nachricht in einer Warteschlange ohne entfernt diese aus der Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernen, die Nachrichten in die Warteschlange verfügt, gibt es keine durch einen Aufruf von Rollback <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn eine für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Der Thread ist für den angegebenen Zeitraum Zeit oder auf unbestimmte Zeit blockiert, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter. Wenn die anwendungsverarbeitung ohne Wartezeiten für eine Nachricht fortgesetzt werden soll, erwägen Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig. Möglicherweise ist <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Empfängt eine Meldung mit der angegebenen Korrelations-ID.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID (aus einer nicht transaktionalen Warteschlange) und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen Korrelations-ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der nicht transaktionalen Warteschlange verweist die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Wenn keine Nachricht gefunden wird, entspricht die `correlationID` Parameter, es wird eine Ausnahme ausgelöst. Andernfalls wird die Nachricht aus der Warteschlange entfernt und an die Anwendung zurückgegeben.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht an die Warteschlange zugeordnete Antwort, Berichts- oder Bestätigungsnachricht Nachrichten zu binden.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode ruft eine Meldung ab, durch den eindeutigen Bezeichner angeben.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID gelesen, ohne ihn aus der Warteschlange zu entfernen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht, die eine Bestellung in und aus einer Warteschlange enthält. Eine positive Bestätigung wird ausdrücklich angefordert, wenn die ursprüngliche Nachricht erreicht wurde oder wird aus der Warteschlange abgerufen.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="correlationId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID (aus einer transaktionalen Warteschlange) und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen Korrelations-ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in die Transaktionswarteschlange, verweist der <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Wenn keine Nachricht gefunden wird, entspricht die `correlationID` Parameter, es wird eine Ausnahme ausgelöst. Andernfalls die Nachricht aus der Warteschlange entfernt und zurückgegeben, die in der Anwendung mit der internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht an die Warteschlange zugeordnete Antwort, Berichts- oder Bestätigungsnachricht Nachrichten zu binden.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode dient zum Abrufen einer Nachricht durch Angabe des eindeutigen Bezeichners.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID gelesen, ohne ihn aus der Warteschlange zu entfernen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.  
  
 - oder -   
  
 Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="correlationId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Warteschlange ist nicht transaktional.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen Korrelations-ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Warteschlange, die auf die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Wenn keine Nachricht gefunden wird, entspricht die `correlationID` Parameter, es wird eine Ausnahme ausgelöst. Andernfalls die Nachricht aus der Warteschlange entfernt und zurückgegeben, die in der Anwendung mit einem bereits verwendeten Transaktionskontext durch definiert die `transactionType` Parameter.  
  
 Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht von einer Transaktionswarteschlange zu empfangen, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht an die Warteschlange zugeordnete Antwort, Berichts- oder Bestätigungsnachricht Nachrichten zu binden.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode dient zum Abrufen einer Nachricht durch Angabe des eindeutigen Bezeichners.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID gelesen, ohne ihn aus der Warteschlange zu entfernen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="correlationId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID (aus einer nicht transaktionalen Warteschlange) und wartet, bis eine Meldung mit der angegebenen Korrelations-ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der nicht transaktionalen Warteschlange verweist die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Diese Methode kehrt sofort zurück, wenn die Nachricht mit der Korrelations-ID, wird angegeben die `correlationId` Parameter ist in der Warteschlange. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eingeht, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` Parameter gibt die Gesamtausführungszeit für diese Methode keine. Stattdessen gibt es die Zeit zum Warten, bis einer neuen Nachricht in der Warteschlange eintreffen. Jedes Mal eine neue Nachricht eingeht, wird diese Methode überprüft die <xref:System.Messaging.Message.CorrelationId%2A> der neuen Nachricht zu überprüfen, ob es entspricht dem `correlationId` Parameter. Wenn dies nicht der Fall, diese Methode startet den Timeoutzeitraum über und wartet auf eine andere neue Nachricht auf das eingehen. Daher neue Nachrichten weiterhin innerhalb des Timeoutzeitraums eintreffen, ist es möglich, dass diese Methode zur Ausführung unbegrenzt lange, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht der `correlationId` Parameter.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht an die Warteschlange zugeordnete Antwort, Berichts- oder Bestätigungsnachricht Nachrichten zu binden.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode dient zum Abrufen einer Nachricht durch Angabe des eindeutigen Bezeichners.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID gelesen, ohne ihn aus der Warteschlange zu entfernen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Meldung mit der angegebenen <paramref name="correlationId" /> ist nicht in der Warteschlange vorhanden und nicht vor Ablauf des Timeouts eingegangen.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID (aus einer transaktionalen Warteschlange) und wartet, bis eine Meldung mit der angegebenen Korrelations-ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in die Transaktionswarteschlange, verweist der <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Diese Methode kehrt sofort zurück, wenn die Nachricht mit der Korrelations-ID, wird angegeben die `correlationId` Parameter ist in der Warteschlange, die mit der internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eingeht, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` Parameter gibt die Gesamtausführungszeit für diese Methode keine. Stattdessen gibt es die Zeit zum Warten, bis einer neuen Nachricht in der Warteschlange eintreffen. Jedes Mal eine neue Nachricht eingeht, wird diese Methode überprüft die <xref:System.Messaging.Message.CorrelationId%2A> der neuen Nachricht zu überprüfen, ob es entspricht dem `correlationId` Parameter. Wenn dies nicht der Fall, diese Methode startet den Timeoutzeitraum über und wartet auf eine andere neue Nachricht auf das eingehen. Daher neue Nachrichten weiterhin innerhalb des Timeoutzeitraums eintreffen, ist es möglich, dass diese Methode zur Ausführung unbegrenzt lange, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht der `correlationId` Parameter.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht an die Warteschlange zugeordnete Antwort, Berichts- oder Bestätigungsnachricht Nachrichten zu binden.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode dient zum Abrufen einer Nachricht durch Angabe des eindeutigen Bezeichners.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID gelesen, ohne ihn aus der Warteschlange zu entfernen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.  
  
 - oder -   
  
 Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Meldung mit der angegebenen <paramref name="correlationId" /> ist nicht in der Warteschlange vorhanden und nicht vor Ablauf des Timeouts eingegangen.  
  
 - oder -   
  
 Die Warteschlange ist nicht transaktional.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID und wartet, bis eine Meldung mit der angegebenen Korrelations-ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Warteschlange, die auf die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Diese Methode kehrt sofort zurück, wenn die Nachricht mit der Korrelations-ID, wird angegeben die `correlationId` Parameter ist in der Warteschlange, einen bereits verwendeten Transaktionskontext definiert, indem Sie mit der `transactionType` Parameter. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eingeht, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` Parameter gibt die Gesamtausführungszeit für diese Methode keine. Stattdessen gibt es die Zeit zum Warten, bis einer neuen Nachricht in der Warteschlange eintreffen. Jedes Mal eine neue Nachricht eingeht, wird diese Methode überprüft die <xref:System.Messaging.Message.CorrelationId%2A> der neuen Nachricht zu überprüfen, ob es entspricht dem `correlationId` Parameter. Wenn dies nicht der Fall, diese Methode startet den Timeoutzeitraum über und wartet auf eine andere neue Nachricht auf das eingehen. Daher neue Nachrichten weiterhin innerhalb des Timeoutzeitraums eintreffen, ist es möglich, dass diese Methode zur Ausführung unbegrenzt lange, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht der `correlationId` Parameter. Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht von einer Transaktionswarteschlange zu empfangen, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht an die Warteschlange zugeordnete Antwort, Berichts- oder Bestätigungsnachricht Nachrichten zu binden.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode dient zum Abrufen einer Nachricht durch Angabe des eindeutigen Bezeichners.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID gelesen, ohne ihn aus der Warteschlange zu entfernen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="correlationId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Meldung mit der angegebenen <paramref name="correlationId" /> ist nicht in der Warteschlange vorhanden und nicht vor Ablauf des Timeouts eingegangen.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Empfängt die Meldung mit der angegebenen ID und entfernt sie aus der Warteschlange.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID aus einer nicht transaktionalen Warteschlange und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einem Bezeichner und aus der Warteschlange zu entfernen. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist für die Message Queuing-Organisation eindeutig, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung oder den Bericht anwendungserstellte Antwortnachricht, die als Ergebnis eine Meldung an die Warteschlange gesendeten erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="id" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID (aus einer transaktionalen Warteschlange) und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einem Bezeichner und entfernen es aus der Warteschlange, die mit der internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist für die Message Queuing-Organisation eindeutig, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung oder den Bericht anwendungserstellte Antwortnachricht, die als Ergebnis eine Meldung an die Warteschlange gesendeten erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.  
  
 - oder -   
  
 Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="id" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Warteschlange ist nicht transaktional.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einem Bezeichner und aus der Warteschlange zu entfernen. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist. Andernfalls die Nachricht aus der Warteschlange entfernt und zurückgegeben, die in der Anwendung mit einem bereits verwendeten Transaktionskontext durch definiert die `transactionType` Parameter.  
  
 Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist für die Message Queuing-Organisation eindeutig, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter. Wenn die Nachricht mit dem angegebenen Bezeichner in einer Warteschlange als dem zugeordneten <xref:System.Messaging.MessageQueue> Instanz, die Nachricht wird nicht gefunden werden.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht von einer Transaktionswarteschlange zu empfangen, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung oder den Bericht anwendungserstellte Antwortnachricht, die als Ergebnis eine Meldung an die Warteschlange gesendeten erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="id" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID (aus einer nicht transaktionalen Warteschlange) und wartet, bis eine Meldung mit der angegebenen ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einem Bezeichner und aus der Warteschlange zu entfernen. Diese Methode kehrt sofort zurück, wenn die Nachricht mit dem Bezeichner, wird angegeben die `id` Parameter ist in der Warteschlange. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eingeht, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` Parameter gibt die Gesamtausführungszeit für diese Methode keine. Stattdessen gibt es die Zeit zum Warten, bis einer neuen Nachricht in der Warteschlange eintreffen. Jedes Mal eine neue Nachricht eingeht, wird diese Methode überprüft die <xref:System.Messaging.Message.Id%2A> der neuen Nachricht zu überprüfen, ob es entspricht dem `id` Parameter. Wenn dies nicht der Fall, diese Methode startet den Timeoutzeitraum über und wartet auf eine andere neue Nachricht auf das eingehen. Daher neue Nachrichten weiterhin innerhalb des Timeoutzeitraums eintreffen, ist es möglich, dass diese Methode zur Ausführung unbegrenzt lange, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.Id%2A> entspricht der `id` Parameter.  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist für die Message Queuing-Organisation eindeutig, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter.  
  
 Verwenden Sie diese Überladung der <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Wenn eine für den aktuellen Thread blockiert wird, als neue Nachrichten fortfahren, auf das Eintreffen in der Warteschlange innerhalb des Timeoutzeitraums gemäß akzeptabel ist die `timeout` Parameter. Der Thread blockiert werden für mindestens im angegebenen Zeitraum Zeit oder auf unbestimmte Zeit, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter, oder wenn neue Nachrichten fortfahren, auf das Eintreffen in der Warteschlange innerhalb des Timeoutzeitraums gemäß der `timeout` Parameter.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung oder den Bericht anwendungserstellte Antwortnachricht, die als Ergebnis eine Meldung an die Warteschlange gesendeten erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung mit der angegebenen <paramref name="id" /> in die Warteschlange eingegangen.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID (aus einer transaktionalen Warteschlange) und wartet, bis eine Meldung mit der angegebenen ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einem Bezeichner und entfernen es aus der Warteschlange, die mit der internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter. Diese Methode kehrt sofort zurück, wenn die Nachricht mit dem Bezeichner, wird angegeben die `id` Parameter ist in der Warteschlange. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eingeht, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` Parameter gibt die Gesamtausführungszeit für diese Methode keine. Stattdessen gibt es die Zeit zum Warten, bis einer neuen Nachricht in der Warteschlange eintreffen. Jedes Mal eine neue Nachricht eingeht, wird diese Methode überprüft die <xref:System.Messaging.Message.Id%2A> der neuen Nachricht zu überprüfen, ob es entspricht dem `id` Parameter. Wenn dies nicht der Fall, diese Methode startet den Timeoutzeitraum über und wartet auf eine andere neue Nachricht auf das eingehen. Daher neue Nachrichten weiterhin innerhalb des Timeoutzeitraums eintreffen, ist es möglich, dass diese Methode zur Ausführung unbegrenzt lange, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.Id%2A> entspricht der `id` Parameter.  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist für die Message Queuing-Organisation eindeutig, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter.  
  
 Verwenden Sie diese Überladung der <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Wenn eine für den aktuellen Thread blockiert wird, als neue Nachrichten fortfahren, auf das Eintreffen in der Warteschlange innerhalb des Timeoutzeitraums gemäß akzeptabel ist die `timeout` Parameter. Der Thread blockiert werden für mindestens im angegebenen Zeitraum Zeit oder unbegrenzt, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter, oder wenn neue Nachrichten fortfahren, auf das Eintreffen in der Warteschlange innerhalb des Zeitlimits gemäß der `timeout` Parameter.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung oder den Bericht anwendungserstellte Antwortnachricht, die als Ergebnis eine Meldung an die Warteschlange gesendeten erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.  
  
 - oder -   
  
 Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung mit der angegebenen <paramref name="id" /> in die Warteschlange eingegangen.  
  
 - oder -   
  
 Die Warteschlange ist nicht transaktional.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID und wartet, bis eine Meldung mit der angegebenen ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einem Bezeichner und aus der Warteschlange zu entfernen. Diese Methode kehrt sofort zurück, wenn die Nachricht mit dem Bezeichner, wird angegeben die `id` Parameter ist in der Warteschlange, einen bereits verwendeten Transaktionskontext definiert, indem Sie mit der `transactionType` Parameter. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eingeht, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` Parameter gibt die Gesamtausführungszeit für diese Methode keine. Stattdessen gibt es die Zeit zum Warten, bis einer neuen Nachricht in der Warteschlange eintreffen. Jedes Mal eine neue Nachricht eingeht, wird diese Methode überprüft die <xref:System.Messaging.Message.Id%2A> der neuen Nachricht zu überprüfen, ob es entspricht dem `id` Parameter. Wenn dies nicht der Fall, diese Methode startet den Timeoutzeitraum über und wartet auf eine andere neue Nachricht auf das eingehen. Daher neue Nachrichten weiterhin innerhalb des Timeoutzeitraums eintreffen, ist es möglich, dass diese Methode zur Ausführung unbegrenzt lange, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.Id%2A> entspricht der `id` Parameter.  
  
 Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist für die Message Queuing-Organisation eindeutig, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter. Wenn die Nachricht mit dem angegebenen Bezeichner in einer Warteschlange als dem zugeordneten <xref:System.Messaging.MessageQueue> Instanz, die Nachricht wird nicht gefunden werden.  
  
 Verwenden Sie diese Überladung der <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Wenn eine für den aktuellen Thread blockiert wird, als neue Nachrichten fortfahren, auf das Eintreffen in der Warteschlange innerhalb des Timeoutzeitraums gemäß akzeptabel ist die `timeout` Parameter. Der Thread blockiert werden für mindestens im angegebenen Zeitraum Zeit oder auf unbestimmte Zeit, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter, oder wenn neue Nachrichten fortfahren, auf das Eintreffen in der Warteschlange innerhalb des Timeoutzeitraums gemäß der `timeout` Parameter.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht von einer Transaktionswarteschlange zu empfangen, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Zwei andere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung oder den Bericht anwendungserstellte Antwortnachricht, die als Ergebnis eine Meldung an die Warteschlange gesendeten erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, damit nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, eine Nachricht mit höhere Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nicht entfernen, werden alle Nachrichten in der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung mit der angegebenen <paramref name="id" /> in die Warteschlange eingegangen.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Eingeführt in MSMQ 3.0. Empfängt eine bestimmte Meldung aus der Warteschlange. Die Meldung kann anhand eines Suchbezeichners oder anhand der Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der zu empfangenden Meldung.</param>
        <summary>Eingeführt in MSMQ 3.0. Empfängt die Meldung, die dem angegebenen Suchbezeichner in einer nicht transaktionalen Warteschlange entspricht.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.LookupId" />-Eigenschaft dem übergebenen <paramref name="lookupId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bestimmten Suchbezeichner lesen und aus der Warteschlange zu entfernen. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft einer Nachricht ist eindeutig in der Warteschlange befindet, in dem die Nachricht ein, damit kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `lookupId` Parameter.  
  
 Um eine Nachricht mit der angegebenen Nachschlage-ID gelesen, ohne ihn aus der Warteschlange zu entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> Methode.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="lookupId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">Einer der <see cref="T:System.Messaging.MessageLookupAction" />-Werte, der angibt, wie die Meldung in der Warteschlange gelesen wird. Geben Sie eine der folgenden Optionen an:  
  
 <see langword="MessageLookupAction.Current" />: Empfängt die durch <c>lookupId</c> angegebene Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.Next" />: Empfängt die Meldung nach der durch <c>lookupId</c> angegebenen Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.Previous" />: Empfängt die Meldung vor der durch <c>lookupId</c> angegebenen Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.First" />: Empfängt die erste Meldung aus der Warteschlange und entfernt sie aus dieser. Der <c>lookupId</c>-Parameter muss auf 0 (null) festgelegt werden.  
  
 <see langword="MessageLookupAction.Last" />: Empfängt die letzte Meldung aus der Warteschlange und entfernt sie aus dieser. Der <c>lookupId</c>-Parameter muss auf 0 (null) festgelegt werden.</param>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der zu empfangenden Meldung, andernfalls 0 (null). 0 wird beim Zugreifen auf die erste oder letzte Meldung in die Warteschlange verwendet.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Eingeführt in MSMQ 3.0. Empfängt eine bestimmte Meldung aus einer transaktionalen Warteschlange. Die Meldung kann anhand eines Suchbezeichners oder anhand der Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
        <returns>Die durch den übergebenen <paramref name="lookupId" />-Parameter und <paramref name="action" />-Parameter angegebene <see cref="T:System.Messaging.Message" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einem bestimmten Suchbezeichner und entfernen es aus der Warteschlange, einen bereits verwendeten Transaktionskontext definiert, indem Sie mit der `transaction` Parameter. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft einer Nachricht ist eindeutig in der Warteschlange befindet, in dem die Nachricht ein, damit kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `lookupId` Parameter.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> Methode. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Da <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> nicht entfernen, werden alle Nachrichten aus der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="lookupId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.  
  
 - oder -   
  
 Die Warteschlange ist nicht transaktional.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="action" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageLookupAction" />-Member.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">Einer der <see cref="T:System.Messaging.MessageLookupAction" />-Werte, der angibt, wie die Meldung in der Warteschlange gelesen wird. Geben Sie eine der folgenden Optionen an:  
  
 <see langword="MessageLookupAction.Current" />: Empfängt die durch <c>lookupId</c> angegebene Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.Next" />: Empfängt die Meldung nach der durch <c>lookupId</c> angegebenen Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.Previous" />: Empfängt die Meldung vor der durch <c>lookupId</c> angegebenen Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.First" />: Empfängt die erste Meldung aus der Warteschlange und entfernt sie aus dieser. Der <c>lookupId</c>-Parameter muss auf 0 (null) festgelegt werden.  
  
 <see langword="MessageLookupAction.Last" />: Empfängt die letzte Meldung aus der Warteschlange und entfernt sie aus dieser. Der <c>lookupId</c>-Parameter muss auf 0 (null) festgelegt werden.</param>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der zu empfangenden Meldung, andernfalls 0 (null). 0 wird beim Zugreifen auf die erste oder letzte Meldung in die Warteschlange verwendet.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Eingeführt in MSMQ 3.0. Empfängt unter Verwendung des angegebenen Transaktionskontexts eine bestimmte Meldung aus der Warteschlange. Die Meldung kann anhand eines Suchbezeichners oder anhand der Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
        <returns>Die durch den übergebenen <paramref name="action" />-Parameter und <paramref name="lookupId" />-Parameter angegebene <see cref="T:System.Messaging.Message" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einem bestimmten Suchbezeichner und entfernen es aus der Warteschlange, einen bereits verwendeten Transaktionskontext definiert, indem Sie mit der `transactionType` Parameter. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft einer Nachricht ist eindeutig in der Warteschlange befindet, in dem die Nachricht ein, damit kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `lookupId` Parameter.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner ohne entfernt diese aus der Warteschlange zu lesen, verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> Methode. Es ist kein Transaktionskontext zugewiesen ist, mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Da <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> nicht entfernen, werden alle Nachrichten aus der Warteschlange, gäbe es nichts Rollback, wenn die Transaktion abgebrochen wurden.  
  
 Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion empfangen werden sollen. Sie können angeben, `None` Wenn eine Nachricht von einer Transaktionswarteschlange außerhalb eines Transaktionskontexts zu empfangen werden sollen.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht von einer Transaktionswarteschlange zu empfangen, würde die empfangene Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="lookupId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="action" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageLookupAction" />-Member.  
  
 - oder -   
  
 Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine Meldung aus der Warteschlange entfernt wurde. Dieses Ereignis wird von dem asynchronen <see cref="M:System.Messaging.MessageQueue.BeginReceive" />-Vorgang ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> wird verwendet, bei der asynchronen Verarbeitung zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis aus, wenn eine Nachricht in der Warteschlange verfügbar ist.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> Dient zum Abschließen des Vorgangs, der durch einen Aufruf initiiert <xref:System.Messaging.MessageQueue.BeginReceive%2A> und die Nachricht bei der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis wird ausgelöst.  
  
 Beim Erstellen eines <xref:System.Messaging.ReceiveCompletedEventHandler>-Delegaten bestimmen Sie die Methode für die Ereignisbehandlung. Um dem Ereignishandler das Ereignis zuzuordnen, fügen Sie dem Ereignis eine Instanz des Delegaten hinzu. Der Ereignishandler wird bei jedem Eintreten des Ereignisses aufgerufen, sofern der Delegat nicht entfernt wird. Weitere Informationen zu Ereignishandlerdelegaten, finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Ereignishandler namens `MyReceiveCompleted`, fügt es der <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventhandlerdelegaten und ruft <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert einen asynchronen Empfangsvorgang in der Warteschlange, die im Pfad ist ". \myQueue". Wenn ein <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis wird ausgelöst, die im Beispiel empfängt die Nachricht und schreibt Text auf dem Bildschirm. Das Beispiel ruft dann <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut aus, um ein neues initiieren asynchronen Empfangsvorgang.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktualisiert die von der <see cref="T:System.Messaging.MessageQueue" /> dargestellten Eigenschaften, sodass sie den aktuellen Zustand der Ressource wiedergeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> synchronisiert die Eigenschaften einer <xref:System.Messaging.MessageQueue> mit ihrer zugeordneten Message Queuing-Server-Ressource. Wenn eine Eigenschaft, z. B. <xref:System.Messaging.MessageQueue.Label%2A> oder <xref:System.Messaging.MessageQueue.Category%2A>, auf dem Server geändert wurde, seit dem Zeitpunkt der <xref:System.Messaging.MessageQueue> erstellt wurde, <xref:System.Messaging.MessageQueue.Refresh%2A> Updates der <xref:System.Messaging.MessageQueue> mit den neuen Informationen.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die Berechtigungsliste auf die Standardwerte des Betriebssystems zurück. Entfernt sämtliche Berechtigungen für Warteschlangen, die an die Standardliste angefügt wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufruf <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, Sie die Berechtigungsliste auf ihre Standardwerte zurück. Im Allgemeinen dies Ersteller der Warteschlange alle Berechtigungen und gibt der Gruppe "Jeder" die folgenden Rechte:  
  
-   Rufen Sie die Eigenschaften der Warteschlange an.  
  
-   Rufen Sie die Berechtigungen der Warteschlange.  
  
-   Schreiben Sie in die Warteschlange.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet ein Objekt an eine Warteschlange.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <summary>Sendet ein Objekt an die nicht transaktionale Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter an die Warteschlange, verweist der <xref:System.Messaging.MessageQueue>. Das Objekt, das Sie an die Warteschlange senden, kann ein <xref:System.Messaging.Message> oder ein verwaltetes Objekt. Wenn Sie ein Objekt, außer senden einem <xref:System.Messaging.Message>, das Objekt serialisiert und in den Text der Nachricht eingefügt wird.  
  
 Wenn Sie diese Überladung zum Senden einer Nachricht an eine transaktionale Warteschlange verwenden, wird die Nachricht an die Dead Letter-Warteschlange gesendet werden. Wenn Sie möchten die Nachricht als Teil einer Transaktion, die andere Meldungen enthält, verwenden Sie eine Überladung mit einem <xref:System.Messaging.MessageQueueTransaction> oder <xref:System.Messaging.MessageQueueTransactionType> als Parameter.  
  
 Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt für alle Objekte außer einem <xref:System.Messaging.Message>. Wenn Sie beispielsweise eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member auf der, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ ist <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange sendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einer Nachrichtenwarteschlange her und sendet eine Nachricht an die Warteschlange.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 Im folgenden Codebeispiel sendet eine anwendungsdefinierte `Order` Klasse an eine Warteschlange, und klicken Sie dann eine Nachricht aus der Warteschlange empfängt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Sendet ein Objekt an die transaktionale Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter an die transaktionale Warteschlange die <xref:System.Messaging.MessageQueue>, mit einer internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter. Das Objekt, das Sie an die Warteschlange senden, kann ein <xref:System.Messaging.Message> oder ein verwaltetes Objekt. Wenn Sie ein Objekt, außer senden einem <xref:System.Messaging.Message>, das Objekt serialisiert und in den Text der Nachricht eingefügt wird.  
  
 Wenn Sie diese Überladung zum Senden einer Nachricht an eine nicht transaktionale Warteschlange verwenden, kann die Nachricht an die Dead Letter-Warteschlange gesendet werden, ohne eine Ausnahme auszulösen.  
  
 Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt für alle Objekte außer einem <xref:System.Messaging.Message>. Wenn Sie beispielsweise eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member auf der, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ ist <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange sendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 <xref:System.Messaging.MessageQueueTransaction> Apartmentthreading fähig ist, wenn der Apartmentzustand `STA`, die Transaktion in mehreren Threads nicht verwendet werden können. Visual Basic legt den Zustand des Hauptthreads auf `STA`, sodass Sie anwenden, müssen die <xref:System.MTAThreadAttribute> in die `Main` Unterroutine. Andernfalls wird durch das Senden einer Transaktionsmeldung mithilfe eines anderen Threads eine <xref:System.Messaging.MessageQueueException>-Ausnahme ausgelöst. Sie wenden die <xref:System.MTAThreadAttribute> mit dem folgenden Fragment.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Zeichenfolge an eine transaktionale Warteschlange gesendet, und klicken Sie dann eine Nachricht aus der Warteschlange empfängt.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
 - oder -   
  
 Die Message Queuing-Anwendung hat eine falsche Verwendung der Transaktion gemeldet.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Sendet ein Objekt an die Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter an die Warteschlange verweist die <xref:System.Messaging.MessageQueue>, verwenden einen bereits verwendeten Transaktionskontext durch definiert die `transactionType` Parameter. Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, der zum Senden der Nachricht verwendet werden sollen. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion gesendet werden soll. Sie können angeben, `None` , wenn eine transaktionale Nachricht an einen nicht transaktionalen Thread gesendet werden soll.  
  
 Das Objekt, das Sie an die Warteschlange senden, kann ein <xref:System.Messaging.Message> oder ein verwaltetes Objekt. Wenn Sie ein Objekt, außer senden einem <xref:System.Messaging.Message>, das Objekt serialisiert und in den Text der Nachricht eingefügt wird.  
  
 Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt für alle Objekte außer einem <xref:System.Messaging.Message>. Wenn Sie beispielsweise eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member auf der, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ ist <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange sendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <param name="label">Die Meldungsbezeichnung.</param>
        <summary>Sendet ein Objekt an die nicht transaktionale Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist, und gibt eine Bezeichnung für die Meldung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter an die Warteschlange, verweist der <xref:System.Messaging.MessageQueue>. Mit dieser Überladung können Sie die Bezeichnung Zeichenfolge angeben, die die Meldung identifiziert. Das Objekt, das Sie an die Warteschlange senden, kann ein <xref:System.Messaging.Message>, eine Struktur, ein Datenobjekt oder ein verwaltetes Objekt. Wenn Sie ein Objekt, außer senden einem <xref:System.Messaging.Message>, das Objekt serialisiert und in den Text der Nachricht eingefügt wird.  
  
 Die nachrichtenbezeichnung unterscheidet sich von der Bezeichnung der Warteschlange, aber beide sind abhängig von der Anwendung und haben keine Bedeutung für Message Queuing erben.  
  
 Wenn Sie diese Überladung zum Senden einer Nachricht an eine transaktionale Warteschlange verwenden, wird die Nachricht an die Dead Letter-Warteschlange gesendet werden. Wenn Sie möchten die Nachricht als Teil einer Transaktion, die andere Meldungen enthält, verwenden Sie eine Überladung mit einem <xref:System.Messaging.MessageQueueTransaction> oder <xref:System.Messaging.MessageQueueTransactionType> als Parameter.  
  
 Die <xref:System.Messaging.MessageQueue.Path%2A> für diese Eigenschaft <xref:System.Messaging.MessageQueue> Instanz muss angegeben werden, bevor die Nachricht zu senden. Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt für alle Objekte außer einem <xref:System.Messaging.Message>. Wenn Sie beispielsweise eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member auf der, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ ist <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange sendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="label" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <param name="label">Die Meldungsbezeichnung.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Sendet ein Objekt an die transaktionale Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist, und gibt eine Bezeichnung für die Meldung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter an die transaktionale Warteschlange die <xref:System.Messaging.MessageQueue>, mit einer internen bereits verwendeten Transaktionskontext durch definiert die `transaction` Parameter. Mit dieser Überladung können Sie die Bezeichnung Zeichenfolge angeben, die die Meldung identifiziert. Das Objekt, das Sie an die Warteschlange senden, kann ein <xref:System.Messaging.Message>, eine Struktur, ein Datenobjekt oder ein verwaltetes Objekt. Wenn Sie ein Objekt, außer senden einem <xref:System.Messaging.Message>, das Objekt serialisiert und in den Text der Nachricht eingefügt wird.  
  
 Die nachrichtenbezeichnung unterscheidet sich von der Bezeichnung der Warteschlange, aber beide sind abhängig von der Anwendung und haben keine Bedeutung für Message Queuing erben.  
  
 Wenn Sie diese Überladung zum Senden einer Nachricht an eine nicht transaktionale Warteschlange verwenden, kann die Nachricht an die Dead Letter-Warteschlange gesendet werden, ohne eine Ausnahme auszulösen.  
  
 Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt für alle Objekte außer einem <xref:System.Messaging.Message>. Wenn Sie beispielsweise eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member auf der, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ ist <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange sendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft  
  
 <xref:System.Messaging.MessageQueueTransaction> Apartmentthreading fähig ist, wenn der Apartmentzustand `STA`, die Transaktion in mehreren Threads nicht verwendet werden können. Visual Basic legt den Zustand des Hauptthreads auf `STA`, sodass Sie anwenden, müssen die <xref:System.MTAThreadAttribute> in die `Main` Unterroutine. Andernfalls wird durch das Senden einer Transaktionsmeldung mithilfe eines anderen Threads eine <xref:System.Messaging.MessageQueueException>-Ausnahme ausgelöst. Sie wenden die <xref:System.MTAThreadAttribute> mit dem folgenden Fragment.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="label" />-Parameter ist <see langword="null" />.  
  
 - oder -   
  
 Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
 - oder -   
  
 Die Message Queuing-Anwendung hat eine falsche Verwendung der Transaktion gemeldet.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <param name="label">Die Meldungsbezeichnung.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Sendet ein Objekt an die Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist, und gibt eine Bezeichnung für die Meldung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter an die Warteschlange verweist die <xref:System.Messaging.MessageQueue>, verwenden einen bereits verwendeten Transaktionskontext durch definiert die `transactionType` Parameter. Geben Sie `Automatic` für die `transactionType` Parameter an, wenn es bereits ein externer Transaktionskontext ist angefügt wird, an den Thread, der zum Senden der Nachricht verwendet werden sollen. Geben Sie `Single` , wenn die Nachricht als eine interne Transaktion gesendet werden soll. Sie können angeben, `None` , wenn eine transaktionale Nachricht an einen nicht transaktionalen Thread gesendet werden soll.  
  
 Das Objekt, das Sie an die Warteschlange senden, kann ein <xref:System.Messaging.Message> oder ein verwaltetes Objekt. Wenn Sie ein Objekt, außer senden einem <xref:System.Messaging.Message>, das Objekt serialisiert und in den Text der Nachricht eingefügt wird. Mit dieser Überladung können Sie die Bezeichnung Zeichenfolge angeben, die die Meldung identifiziert.  
  
 Die nachrichtenbezeichnung unterscheidet sich von der Bezeichnung der Warteschlange, aber beide sind abhängig von der Anwendung und haben keine Bedeutung für Message Queuing erben.  
  
 Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt für alle Objekte außer einem <xref:System.Messaging.Message>. Wenn Sie beispielsweise eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member auf der, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ ist <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange sendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="label" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">Die Message Queuing-Anwendung hat eine falsche Verwendung der Transaktion gemeldet.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
 - oder -   
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt dem aktuellen Satz Berechtigungen hinzu. Hiermit wird festgelegt, wer Zugriff auf Eigenschaften und Meldungen in der Warteschlange erhält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">Eine <see cref="T:System.Messaging.AccessControlList" /> mit einem oder mehreren Zugriffsteuerungseinträgen, die die Vertrauensnehmer und die zu gewährenden Berechtigungen angeben.</param>
        <summary>Weist der Warteschlange anhand einer Zugriffssteuerungsliste Zugriffsrechte zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zu erteilen, verweigern oder widerrufen Rechte, indem Sie eine Auflistung von Zugriffssteuerungseinträgen Vertrauensnehmer und Berechtigungen angeben. Dies ist z. B. verwendet zum Gewähren von Berechtigungen für mehrere Benutzer gleichzeitig.  
  
 Der Vertrauensnehmer, die Sie angeben, bei der Erstellung der `ace` Parameter kann ein einzelner Benutzer, eine Benutzergruppe oder ein Computer sein. Wenn die Vertrauensnehmer einer Person ist, verwenden Sie das Format `DOMAIN` \\ `user`. Sie können angeben, "." für den Vertrauensnehmer auf den lokalen Computer anzugeben.  
  
 Die Berechtigungen, die Sie durch Zuweisen <xref:System.Messaging.MessageQueue.SetPermissions%2A> Rechte für die vorhandene Liste hinzufügen. Wird standardmäßig der Ersteller des eine öffentliche oder private Warteschlange verfügt über Vollzugriff und der Domänengruppe "Jeder" über die Berechtigung zum Abrufen von Eigenschaften für eine Warteschlange, Berechtigungen und Schreiben in die Warteschlange hat. Beim Aufruf <xref:System.Messaging.MessageQueue.SetPermissions%2A>, die Informationen über Benutzer und Berechtigungen wird am Ende der vorhandenen Liste angefügt.  
  
 Das System untersucht jede <xref:System.Messaging.AccessControlEntry> nacheinander bis eines der folgenden Ereignisse eintritt:  
  
-   Ein Zugriff verweigert <xref:System.Messaging.AccessControlEntry> keines der angeforderten Zugriffsrechte auf einen der im Zugriffstoken des Threads aufgelisteten Vertrauensnehmer explizit verweigert.  
  
-   Eine oder mehrere-Zugriff <xref:System.Messaging.AccessControlEntry> Element explizit im Zugriffstoken des Threads aufgelisteten Vertrauensnehmer der angeforderten Zugriffsrechte gewähren.  
  
-   Alle <xref:System.Messaging.AccessControlEntry> Elemente überprüft wurden, und es ist noch mindestens ein angefordertes Zugriffsrecht, die nicht explizit hat in diesem Fall wird der Zugriff implizit verweigert zugelassen wurde,.  
  
 Bei der Erstellung der `dacl` Parameter, Sie fügen <xref:System.Messaging.AccessControlEntry> -Instanzen Ihrer <xref:System.Messaging.AccessControlList> Auflistung. Beim Erstellen jedes Zugriffssteuerungseintrag können Sie generische oder "standard" Zugriffsrechte angeben. Die Rechte für eine Warteschlange können eine beliebige Kombination der folgenden sein:  
  
-   Löschen  
  
-   Sicherheit lesen  
  
-   Schreiben Sie die Sicherheit  
  
-   Synchronisieren  
  
-   Besitzer ändern  
  
-   Lesen  
  
-   Write  
  
-   Ausführen  
  
-   Erforderlich  
  
-   Alle  
  
-   Keiner  
  
 Diese Rechte sind ein Satz von Bitflags, die Sie mit dem bitweisen OR-Operator kombinieren können.  
  
-   Vollzugriff  
  
-   Nachricht löschen  
  
-   Fehlermeldung  
  
-   Peek-Nachricht  
  
-   Meldung für die Erfassung  
  
-   Abrufen von Eigenschaften für eine Warteschlange  
  
-   Festlegen von Eigenschaften  
  
-   Abrufen von Berechtigungen  
  
-   Festlegen von Berechtigungen  
  
-   Besitz übernehmen  
  
-   Schreiben der Nachricht  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">Ein <see cref="T:System.Messaging.MessageQueueAccessControlEntry" />, der einen Benutzer, einen Zugriffstyp und einen Berechtigungstyp angibt.</param>
        <summary>Weist der Warteschlange anhand eines Zugriffssteuerungseintrags Zugriffsrechte zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung erteilen, verweigern oder widerrufen Rechte, indem Sie mit einem Zugriffssteuerungseintrag Vertrauensnehmer und Rechte angeben.  
  
 Der Vertrauensnehmer, die Sie angeben, bei der Erstellung der `ace` Parameter kann ein einzelner Benutzer, eine Benutzergruppe oder ein Computer sein. Wenn die Vertrauensnehmer einer Person ist, verwenden Sie das Format `DOMAIN` \\ `user`. Sie können angeben, "." für den Vertrauensnehmer auf den lokalen Computer anzugeben.  
  
 Die Berechtigungen, die Sie durch Zuweisen <xref:System.Messaging.MessageQueue.SetPermissions%2A> Rechte für die vorhandene Liste hinzufügen. Wird standardmäßig der Ersteller des eine öffentliche oder private Warteschlange verfügt über Vollzugriff und der Domänengruppe "Jeder" über die Berechtigung zum Abrufen von Eigenschaften für eine Warteschlange, Berechtigungen und Schreiben in die Warteschlange hat. Beim Aufruf <xref:System.Messaging.MessageQueue.SetPermissions%2A>, die Informationen über Benutzer und Berechtigungen wird am Ende der vorhandenen Liste angefügt.  
  
 Das System untersucht jede <xref:System.Messaging.AccessControlEntry> nacheinander bis eines der folgenden Ereignisse eintritt:  
  
-   Ein Zugriff verweigert <xref:System.Messaging.AccessControlEntry> keines der angeforderten Zugriffsrechte auf einen der im Zugriffstoken des Threads aufgelisteten Vertrauensnehmer explizit verweigert.  
  
-   Eine oder mehrere-Zugriff <xref:System.Messaging.AccessControlEntry> Element explizit im Zugriffstoken des Threads aufgelisteten Vertrauensnehmer der angeforderten Zugriffsrechte gewähren.  
  
-   Alle <xref:System.Messaging.AccessControlEntry> Elemente überprüft wurden, und es ist noch mindestens ein angefordertes Zugriffsrecht, die nicht explizit hat in diesem Fall wird der Zugriff implizit verweigert zugelassen wurde,.  
  
 Die Rechte für eine Warteschlange, die Sie, in angeben der `rights` Parameter beim Erstellen Ihrer <xref:System.Messaging.MessageQueueAccessControlEntry>, eine beliebige Kombination der folgenden Werte ist möglich:  
  
-   Vollzugriff  
  
-   Nachricht löschen  
  
-   Fehlermeldung  
  
-   Peek-Nachricht  
  
-   Meldung für die Erfassung  
  
-   Abrufen von Eigenschaften für eine Warteschlange  
  
-   Festlegen von Eigenschaften  
  
-   Abrufen von Berechtigungen  
  
-   Festlegen von Berechtigungen  
  
-   Besitz übernehmen  
  
-   Schreiben der Nachricht  
  
 Die `rights` Parameter, die Sie, in der Konstruktor für angeben die `ace` Parameter ist ein Flag, der die <xref:System.Messaging.MessageQueueAccessRights> Enumeration. Er stellt einen Satz von Bitflags, die Sie kombinieren können mit dem bitweisen Operator oder bei der Erstellung der `rights` Parameter.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">Der einzelne Benutzer, die Gruppe oder der Computer, der zusätzliche Rechte für die Warteschlange erhält.</param>
        <param name="rights">Ein <see cref="T:System.Messaging.MessageQueueAccessRights" />, das die verschiedenen Rechte für die Warteschlange darstellt, die Message Queuing dem übergebenen <c>user</c> zuweist.</param>
        <summary>Gewährt einem Computer, einer Gruppe oder einem Benutzer die angegebenen Zugriffsrechte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung angegebene Berechtigungen für einen einzelnen Benutzer zu gewähren. Der Benutzer kann es sich um eine beliebige gültige Vertrauensnehmer, die einzelne Benutzer, Gruppen von Benutzern oder einen Computer umfasst. Wenn der Benutzer eine Person ist, verwenden Sie das Format `DOMAIN` \\ `user` für die `user` Parameter. Sie können angeben, "." für die `user` Parameter, um den lokalen Computer anzugeben.  
  
 Die Berechtigungen, die Sie durch Zuweisen <xref:System.Messaging.MessageQueue.SetPermissions%2A> Rechte für die vorhandene Liste hinzufügen. Wird standardmäßig der Ersteller des eine öffentliche oder private Warteschlange verfügt über Vollzugriff und der Domänengruppe "Jeder" über die Berechtigung zum Abrufen von Eigenschaften für eine Warteschlange, Berechtigungen und Schreiben in die Warteschlange hat. Beim Aufruf <xref:System.Messaging.MessageQueue.SetPermissions%2A>, die Informationen über Benutzer und Berechtigungen wird am Ende der vorhandenen Liste angefügt.  
  
 Das System untersucht jede <xref:System.Messaging.AccessControlEntry> nacheinander bis eines der folgenden Ereignisse eintritt:  
  
-   Ein Zugriff verweigert <xref:System.Messaging.AccessControlEntry> keines der angeforderten Zugriffsrechte auf einen der im Zugriffstoken des Threads aufgelisteten Vertrauensnehmer explizit verweigert.  
  
-   Eine oder mehrere-Zugriff <xref:System.Messaging.AccessControlEntry> Element explizit im Zugriffstoken des Threads aufgelisteten Vertrauensnehmer der angeforderten Zugriffsrechte gewähren.  
  
-   Alle <xref:System.Messaging.AccessControlEntry> Elemente überprüft wurden, und es ist noch mindestens ein angefordertes Zugriffsrecht, die nicht explizit hat in diesem Fall wird der Zugriff implizit verweigert zugelassen wurde,.  
  
 Die Rechte für eine Warteschlange, angegeben der `rights` -Parameter kann eine beliebige Kombination der folgenden sein:  
  
-   Vollzugriff  
  
-   Nachricht löschen  
  
-   Fehlermeldung  
  
-   Peek-Nachricht  
  
-   Meldung für die Erfassung  
  
-   Abrufen von Eigenschaften für eine Warteschlange  
  
-   Festlegen von Eigenschaften  
  
-   Abrufen von Berechtigungen  
  
-   Festlegen von Berechtigungen  
  
-   Besitz übernehmen  
  
-   Schreiben der Nachricht  
  
 Die <xref:System.Messaging.MessageQueueAccessRights> -Enumeration stellt einen Satz von Bitflags, die Sie kombinieren können mit dem bitweisen Operator oder zum Erstellen der `rights` Parameter.  
  
 Mit dieser Überladung können Sie nur die Berechtigungen gewähren; Sie können nicht widerrufen oder verweigern. Sie müssen eine andere Überladung verwenden, um explizit alle gewähren <xref:System.Messaging.AccessControlEntryType> außer `Allow`.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="user" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">Der einzelne Benutzer, die Gruppe oder der Computer, der zusätzliche Rechte für die Warteschlange erhält.</param>
        <param name="rights">Ein <see cref="T:System.Messaging.MessageQueueAccessRights" />, das die verschiedenen Rechte für die Warteschlange darstellt, die Message Queuing dem übergebenen <c>user</c> zuweist.</param>
        <param name="entryType">Ein <see cref="T:System.Messaging.AccessControlEntryType" />, der angibt, ob die im <c>rights</c>-Parameter angegebenen Berechtigungen gewährt, verweigert oder widerrufen werden sollen.</param>
        <summary>Gewährt einem Computer, einer Gruppe oder einem einzelnen Benutzer die angegebenen Zugriffsrechte mit dem angegebenen Zugriffssteuerungstyp (Zulassen, Verweigern, Widerrufen oder Festlegen).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung erteilen, verweigern oder widerrufen angegebenen Rechte für einen einzelnen Benutzer. Der Benutzer kann es sich um eine beliebige gültige Vertrauensnehmer, die einzelne Benutzer, Gruppen von Benutzern oder einen Computer umfasst. Wenn der Benutzer eine Person ist, verwenden Sie das Format `DOMAIN` \\ `user` für die `user` Parameter. Sie können angeben, "." für die `user` Parameter, um den lokalen Computer anzugeben.  
  
 Die Berechtigungen, die Sie durch Zuweisen <xref:System.Messaging.MessageQueue.SetPermissions%2A> Rechte für die vorhandene Liste hinzufügen. Wird standardmäßig der Ersteller des eine öffentliche oder private Warteschlange verfügt über Vollzugriff und der Domänengruppe "Jeder" über die Berechtigung zum Abrufen von Eigenschaften für eine Warteschlange, Berechtigungen und Schreiben in die Warteschlange hat. Beim Aufruf <xref:System.Messaging.MessageQueue.SetPermissions%2A>, die Informationen über Benutzer und Berechtigungen wird am Ende der vorhandenen Liste angefügt.  
  
 Das System untersucht jede <xref:System.Messaging.AccessControlEntry> nacheinander bis eines der folgenden Ereignisse eintritt:  
  
-   Ein Zugriff verweigert <xref:System.Messaging.AccessControlEntry> keines der angeforderten Zugriffsrechte auf einen der im Zugriffstoken des Threads aufgelisteten Vertrauensnehmer explizit verweigert.  
  
-   Eine oder mehrere-Zugriff <xref:System.Messaging.AccessControlEntry> Element explizit im Zugriffstoken des Threads aufgelisteten Vertrauensnehmer der angeforderten Zugriffsrechte gewähren.  
  
-   Alle <xref:System.Messaging.AccessControlEntry> Elemente überprüft wurden, und es ist noch mindestens ein angefordertes Zugriffsrecht, die nicht explizit hat in diesem Fall wird der Zugriff implizit verweigert zugelassen wurde,.  
  
 Die Rechte für eine Warteschlange, angegeben der `rights` -Parameter kann eine beliebige Kombination der folgenden sein:  
  
-   Vollzugriff  
  
-   Nachricht löschen  
  
-   Fehlermeldung  
  
-   Peek-Nachricht  
  
-   Meldung für die Erfassung  
  
-   Abrufen von Eigenschaften für eine Warteschlange  
  
-   Festlegen von Eigenschaften  
  
-   Abrufen von Berechtigungen  
  
-   Festlegen von Berechtigungen  
  
-   Besitz übernehmen  
  
-   Schreiben der Nachricht  
  
 Die <xref:System.Messaging.MessageQueueAccessRights> -Enumeration stellt einen Satz von Bitflags, die Sie kombinieren können mit dem bitweisen Operator oder zum Erstellen der `rights` Parameter.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das den durch ein <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />-Ereignis oder ein <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />-Ereignis ausgelösten Ereignishandleraufruf marshallt, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, das das Objekt darstellt, das den durch ein <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />-Ereignis oder ein <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />-Ereignis ausgelösten Ereignishandleraufruf marshallt. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Messaging.MessageQueue.ReceiveCompleted> oder <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis tritt auf, aus einer <xref:System.Messaging.MessageQueue.BeginReceive%2A> oder <xref:System.Messaging.MessageQueue.BeginPeek%2A> -Anforderung für einen bestimmten Thread. In der Regel die <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> wird festgelegt, wenn die zugehörige Komponente in einem Steuerelement oder einem Formular befindet, da diese Komponenten an einen bestimmten Thread gebunden sind.  
  
 Das Synchronisieren von Objekt marshallt in der Regel den Aufruf einer Methode in einem einzelnen Thread.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Warteschlange nur Transaktionen akzeptiert.</summary>
        <value>
          <see langword="true" />, wenn die Warteschlange nur Meldungen akzeptiert, die als Teil einer Transaktion gesendet wurden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transaktionales messaging verweist auf die Kopplung mehrere zusammengehöriger Nachrichten in einer einzelnen Transaktion. Senden von Nachrichten als Teil einer Transaktion wird sichergestellt, dass die Nachrichten in der Reihenfolge zugestellt werden nur einmal übermittelt und aus ihrer Zielwarteschlange erfolgreich abgerufen.  
  
 Wenn eine Warteschlange transaktional ist, akzeptiert er nur Nachrichten, die im Rahmen einer Transaktion gesendet werden. Jedoch eine nicht transaktionale Meldung gesendet oder empfangen aus einer lokalen Transaktionswarteschlange ohne explizit transaktional sein kann <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, und <xref:System.Messaging.MessageQueueTransaction.Abort%2A> Syntax. Wenn eine nicht transaktionale Meldung an eine transaktionale Warteschlange gesendet wird, erstellt diese Komponente eine Transaktion Einzelnachrichten, außer bei Verweisen auf eine Warteschlange auf einem Remotecomputer befindet, die mit einem direkten Formatnamen. In diesem Fall, wenn Sie einen bereits verwendeten Transaktionskontext beim Senden einer Nachricht nicht angeben, wird eine nicht für Sie erstellt und die Nachricht wird an die Dead Letter-Warteschlange gesendet werden.  
  
 Wenn Sie eine nicht transaktionale Meldung an eine transaktionale Warteschlange senden, werden Sie kein Rollback der Nachricht im Falle einer Ausnahme sein.  
  
 <xref:System.Messaging.MessageQueueTransaction> Apartmentthreading fähig ist, wenn der Apartmentzustand `STA`, die Transaktion in mehreren Threads nicht verwendet werden können. Visual Basic legt den Zustand des Hauptthreads auf `STA`, sodass Sie anwenden, müssen die <xref:System.MTAThreadAttribute> in die `Main` Unterroutine. Andernfalls wird durch das Senden einer Transaktionsmeldung mithilfe eines anderen Threads eine <xref:System.Messaging.MessageQueueException>-Ausnahme ausgelöst. Sie wenden die <xref:System.MTAThreadAttribute> mit dem folgenden Fragment.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.Transactional%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob abgerufene Meldungen in die Journalwarteschlange kopiert werden, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn aus der Warteschlange empfangene Meldungen in die Journalwarteschlange kopiert werden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Message Queuing-Anwendung eine neue Anwendungswarteschlange erstellt, erstellt er automatisch eine zugeordnete Journalwarteschlange am gleichen Speicherort. Journalwarteschlange dient zum Nachverfolgen von Nachrichten aus einer Warteschlange entfernt. Durch Festlegen dieser Eigenschaft ändert die Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind.  
  
 Journalwarteschlange verfolgt keine Nachrichten aus der Warteschlange entfernt werden, denn ihre Zeit auf den Empfang der Zeitgeber ist abgelaufen, und verfolgt Nachrichten aus der Warteschlange gelöscht werden, mithilfe einen Message Queuing-Verzeichnisdienst (Informationsspeicher oder Active Directory).  
  
 Anwendungen können nicht zum Senden von Nachrichten an Journalwarteschlangen führen; Sie sind mit nur-Lese Zugriff auf diese Warteschlangen beschränkt. Darüber hinaus entfernt Message Queuing nie Nachrichten aus Journalwarteschlangen. Die Anwendung über die Warteschlange muss diese Nachrichten empfangen werden oder durch Löschen der Warteschlangenobjekts löschen.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Das systemeigene Handle zum Senden von Meldungen an die Meldungswarteschlange.</summary>
        <value>Ein Handle für das systemeigene Warteschlangenobjekt, das zum Senden von Meldungen an die Warteschlange verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.WriteHandle%2A> bietet eine systemeigene Windows-Handle für das Message Queue-Objekt, das zum Senden von Nachrichten an die Warteschlange verwendet wird. Wenn Sie den Pfad der Warteschlange zu ändern, wird durch einen neuen Wert das Handle geschlossen und erneut geöffnet.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokale Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remotecomputer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">In die Meldungswarteschlange kann nicht geschrieben werden.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>