<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5cc1b14c43ce0a9123bdd4d6ca66283b3d2743f8" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55400526" /></Metadata><TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Messaging.MessagingDescription("MessageQueueDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht den Zugriff auf eine Warteschlange auf einem Message Queuing-Server.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Message Queuing-Technologie ermöglicht Anwendungen, die zu unterschiedlichen Zeiten ausgeführt werden, für die Kommunikation über heterogene Netzwerke und Systeme, die vorübergehend offline sein können. Anwendungen senden, empfangen und Einsehen von (ohne lesen) Nachrichten aus Warteschlangen. Message Queuing ist eine optionale Komponente von [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] und Windows NT, und muss separat installiert werden.  
  
 Die <xref:System.Messaging.MessageQueue> Klasse ist ein Wrapper für Message Queuing. Es gibt mehrere Versionen der Message Queuing und Verwendung der <xref:System.Messaging.MessageQueue> Klasse kann dazu führen, etwas anderes Verhalten, je nach Betriebssystem Sie verwenden. Informationen zu bestimmten Funktionen der einzelnen Versionen von Message Queuing finden Sie unter im Thema "Was neu in Message Queuing ist" im Plattform-SDK in MSDN.  
  
 Die <xref:System.Messaging.MessageQueue> Klasse stellt einen Verweis auf eine Message Queuing-Warteschlange. Sie können einen Pfad im Angeben der <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor, um die Verbindung mit einer vorhandenen Ressource, oder Sie können eine neue Warteschlange erstellen, auf dem Server. Bevor Sie aufrufen können <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, oder <xref:System.Messaging.MessageQueue.Receive%2A>, müssen Sie die neue Instanz der Zuordnen der <xref:System.Messaging.MessageQueue> Klasse mit einer vorhandenen Warteschlange. An diesem Punkt können Sie ändern die Eigenschaften der Warteschlange wie z. B. <xref:System.Messaging.MessageQueue.Category%2A> und <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue> unterstützt zwei Arten von beim Abruf der Nachricht: synchron und asynchron. Die synchronen Methoden <xref:System.Messaging.MessageQueue.Peek%2A> und <xref:System.Messaging.MessageQueue.Receive%2A>, dazu führen, dass die Prozessthread wartet, während ein bestimmten Zeitintervalls für eine neue Nachricht in der Warteschlange eingehen. Die asynchronen Methoden <xref:System.Messaging.MessageQueue.BeginPeek%2A> und <xref:System.Messaging.MessageQueue.BeginReceive%2A>, kann die Ausführung der Hauptthread der Anwendung in einem separaten Thread fortgesetzt, bis eine Meldung in der Warteschlange eingeht. Diese Methoden funktionieren mit Rückruf und Zustandsobjekte für die Kommunikation zwischen Threads.  
  
 Wenn Sie eine neue Instanz der erstellen die <xref:System.Messaging.MessageQueue> -Klasse, erstellen Sie keine neue Message Queuing-Warteschlange. Sie können stattdessen die <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, und <xref:System.Messaging.MessageQueue.Purge%2A> Methoden zum Verwalten von Warteschlangen auf dem Server.  
  
 Im Gegensatz zu <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> und <xref:System.Messaging.MessageQueue.Delete%28System.String%29> sind `static` Elemente, damit Sie sie aufrufen können, ohne eine neue Instanz der Erstellung der <xref:System.Messaging.MessageQueue> Klasse.  
  
 Sie können festlegen, die <xref:System.Messaging.MessageQueue> des Objekts <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft mit einem der drei Namen: der Anzeigename der <xref:System.Messaging.MessageQueue.FormatName%2A>, oder die <xref:System.Messaging.MessageQueue.Label%2A>. Der angezeigte Name, der von der Warteschlange definiert ist <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaften ist <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> für eine öffentliche Warteschlange und <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> für eine private Warteschlange. Die <xref:System.Messaging.MessageQueue.FormatName%2A> Eigenschaft ermöglicht den Offlinezugriff auf Meldungswarteschlangen. Schließlich können Sie der Warteschlange <xref:System.Messaging.MessageQueue.Label%2A> -Eigenschaft zum Festlegen der Warteschlange <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Eine Liste der anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.Messaging.MessageQueue>, finden Sie unter den <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt neue <xref:System.Messaging.MessageQueue> -Objekte mit verschiedenen Syntaxtypen der Path-Namen. In jedem Fall sendet er eine Nachricht an die Warteschlange, deren Pfad in den Konstruktor definiert ist.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 Im folgenden Codebeispiel wird eine Nachricht an eine Warteschlange sendet und empfängt eine Nachricht aus einer Warteschlange, die über eine anwendungsspezifische Klasse namens `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Nur die <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> Methode ist threadsicher.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse. Nach dem Initialisieren der neuen Instanz durch den Standardkonstruktor muss die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft festgelegt werden, bevor die Instanz verwendet werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Überladung können Sie eine neue Instanz der erstellen die <xref:System.Messaging.MessageQueue> -Klasse, die nicht sofort an eine Warteschlange auf Message Queuing-Server verbunden ist. Vor der Verwendung dieser Instanz an, verbinden sie für eine vorhandene Message Queuing-Warteschlange durch Festlegen der <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft. Alternativ können Sie festlegen der <xref:System.Messaging.MessageQueue> Verweis auf die <xref:System.Messaging.MessageQueue.Create%28System.String%29> Rückgabewert der Methode, wodurch eine neue Message Queuing-Warteschlange.  
  
 Die <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor instanziiert eine neue Instanz der dem <xref:System.Messaging.MessageQueue> -Klasse eine neue Message Queuing-Warteschlange wird nicht erstellt.  
  
 In der folgende Tabelle werden die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.MessageQueue>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Die von den Standardkonstruktor des festgelegten Werte die <xref:System.Messaging.DefaultPropertiesToSend> Klasse.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Die von den Standardkonstruktor des festgelegten Werte die <xref:System.Messaging.MessagePropertyFilter> Klasse. Alle Filterwerte werden festgelegt, um `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein neues <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse, die auf die Message Queuing-Warteschlange am angegebenen Pfad verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die neue verknüpfen möchten, verwenden Sie diese Überladung <xref:System.Messaging.MessageQueue> Instanz an eine bestimmte, für die Sie den Pfad, den Formatnamen oder die Bezeichnung kennen Message Queuing-Warteschlange. Wenn Sie exklusiven Zugriff auf die erste Anwendung gewähren möchten, die auf die Warteschlange verweist, müssen Sie festlegen, die <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Eigenschaft `true` oder verwenden Sie den Konstruktor, der einen lesezugriffsbeschränkung-Parameter übergibt.  
  
 Die <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor instanziiert eine neue Instanz der dem <xref:System.Messaging.MessageQueue> -Klasse eine neue Message Queuing-Warteschlange wird nicht erstellt. Verwenden Sie zum Erstellen einer neuen Warteschlange in Message Queuing- <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Die Syntax der `path` Parameter hängt vom Typ der Warteschlange sie Verweise auf, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
|Computer-Journalwarteschlange|`MachineName`\\`Journal$`|  
|Computer Dead Letter-Warteschlange|`MachineName`\\`Deadletter$`|  
|Computer Transaktionswarteschlange für unzustellbare Nachrichten|`MachineName`\\`XactDeadletter$`|  
  
 Alternativ können Sie die <xref:System.Messaging.MessageQueue.FormatName%2A> oder <xref:System.Messaging.MessageQueue.Label%2A> Warteschlangenpfades für die, wie in der folgenden Tabelle gezeigt.  
  
|Referenz|Syntax|Beispiel|  
|---------------|------------|-------------|  
|Formatname|`FormatName:` [ *Formatnamen* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Bezeichnung|`Label:` [ *label* ]|`Label:` TheLabel|  
  
 Um offline zu arbeiten, müssen Sie die Syntax für Formatnamen, nicht der pfadnamensyntax für den Konstruktor verwenden. Andernfalls wird eine Ausnahme ausgelöst, da der primäre Domänencontroller nicht zum Auflösen des Pfads in den Formatnamen verfügbar ist.  
  
 In der folgende Tabelle werden die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.MessageQueue>. Diese Werte basieren auf den Eigenschaften des Message Queuing-Warteschlange mit dem vom angegebenen Pfad die `path` Parameter.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Die von den Standardkonstruktor des festgelegten Werte die <xref:System.Messaging.DefaultPropertiesToSend> Klasse.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, wenn Datenschutzebene für die Message Queuing-Warteschlange "Text;" ist andernfalls `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Der Wert des Computer-Name-Eigenschaft der Message Queuing-Warteschlange.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Die von den Standardkonstruktor des festgelegten Werte die <xref:System.Messaging.MessagePropertyFilter> Klasse.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, wenn kein Wert festgelegt, durch den Konstruktor.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, wenn kein Wert festgelegt, durch den Konstruktor.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, wenn das Message Queuing-Objekt Buch.-Einstellung aktiviert ist; andernfalls `false`.|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt neue <xref:System.Messaging.MessageQueue> -Objekte mit verschiedenen Syntaxtypen der Path-Namen. In jedem Fall sendet er eine Nachricht an die Warteschlange, deren Pfad in den Konstruktor definiert ist.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft ist ungültig. Möglicherweise wurde sie nicht festgelegt.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser kann für den lokalen Computer "." lauten.</param>
        <param name="sharedModeDenyReceive"><see langword="true" />, wenn der ersten Anwendung, die auf die Warteschlange zugreift, exklusiver Zugriff gewährt werden soll, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse mit der angegebenen Lesezugriffsbeschränkung, die auf die Message Queuing-Warteschlange unter dem angegebenen Pfad verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die neue verknüpfen möchten, verwenden Sie diese Überladung <xref:System.Messaging.MessageQueue> an eine bestimmte, für die Sie den Pfad, den Formatnamen oder die Bezeichnung kennen Message Queuing-Warteschlange. Wenn Sie exklusiven Zugriff auf die erste Anwendung gewähren möchten, die auf die Warteschlange verweist, legen Sie die `sharedModeDenyReceive` Parameter `true`. Legen Sie andernfalls `sharedModeDenyReceive` zu `false` oder verwenden Sie den Konstruktor, der nur eine `path` Parameter.  
  
 Festlegen von `sharedModeDenyReceive` zu `true` wirkt sich auf alle Objekte, die Message Queuing-Warteschlange, einschließlich von anderen Anwendungen zugreifen. Die Auswirkungen der Parameter sind nicht auf diese Anwendung beschränkt.  
  
 Die <xref:System.Messaging.MessageQueue.%23ctor%2A> -Konstruktor erstellt eine neue Instanz der dem <xref:System.Messaging.MessageQueue> -Klasse eine neue Message Queuing-Warteschlange wird nicht erstellt. Verwenden Sie zum Erstellen einer neuen Warteschlange in Message Queuing- <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Die Syntax der `path` Parameter hängt vom Typ der Warteschlange.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
|Computer-Journalwarteschlange|`MachineName`\\`Journal$`|  
|Computer Dead Letter-Warteschlange|`MachineName`\\`Deadletter$`|  
|Computer Transaktionswarteschlange für unzustellbare Nachrichten|`MachineName`\\`XactDeadletter$`|  
  
 Alternativ können Sie zum Beschreiben der Pfad der Warteschlange den Formatnamen oder die Beschriftung einer Message Queuing-Warteschlange.  
  
|Referenz|Syntax|Beispiel|  
|---------------|------------|-------------|  
|Formatname|`FormatName:` [ *Formatnamen* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Bezeichnung|`Label:` [ *label* ]|`Label:` TheLabel|  
  
 Um offline zu arbeiten, müssen Sie die Syntax für Formatnamen anstelle der Anzeigenamen der Syntax verwenden. Andernfalls wird eine Ausnahme ausgelöst, da der primäre Domänencontroller (Active Directory auf dem befindet) nicht zum Auflösen des Pfads in den Formatnamen verfügbar ist.  
  
 Wenn eine <xref:System.Messaging.MessageQueue> eine Warteschlange öffnet und die `sharedModeDenyReceive` Parametersatz zu `true`, <xref:System.Messaging.MessageQueue> , anschließend versucht, aus der Warteschlange gelesen generiert eine <xref:System.Messaging.MessageQueueException> wegen der freigabeverletzung. Ein <xref:System.Messaging.MessageQueueException> wird auch ausgelöst, wenn eine <xref:System.Messaging.MessageQueue> versucht, Zugriff auf die Warteschlange im exklusiven Modus, während eine andere <xref:System.Messaging.MessageQueue> bereits nicht exklusiven Zugriff auf die Warteschlange verfügt.  
  
 In der folgende Tabelle werden die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.Messaging.MessageQueue>. Diese Werte werden auf Basis der Eigenschaften der Message Queuing-Warteschlange, mit dem vom angegebenen Pfad die `path` Parameter.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Die von den Standardkonstruktor des festgelegten Werte die <xref:System.Messaging.DefaultPropertiesToSend> Klasse.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, wenn Datenschutzebene für die Message Queuing-Warteschlange "Text;" ist andernfalls `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Der Wert des Computer-Name-Eigenschaft der Message Queuing-Warteschlange.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Die von den Standardkonstruktor des festgelegten Werte die <xref:System.Messaging.MessagePropertyFilter> Klasse.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, wenn kein Wert festgelegt, durch den Konstruktor.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, wenn kein Wert festgelegt, durch den Konstruktor.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|Der Wert des `sharedModeDenyReceive`-Parameters.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, wenn das Message Queuing-Objekt Buch.-Einstellung aktiviert ist; andernfalls `false`.|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein neues <xref:System.Messaging.MessageQueue> mit exklusivem Zugriff legt den Pfad ein, und sendet eine Nachricht an die Warteschlange.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft ist ungültig. Möglicherweise wurde sie nicht festgelegt.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser kann für den lokalen Computer "." lauten.</param>
        <param name="accessMode">Einer der <see cref="T:System.Messaging.QueueAccessMode" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser kann für den lokalen Computer "." lauten.</param>
        <param name="sharedModeDenyReceive"><see langword="true" />, wenn der ersten Anwendung, die auf die Warteschlange zugreift, exklusiver Zugriff gewährt werden soll, andernfalls <see langword="false" />.</param>
        <param name="enableCache"><see langword="true" />, wenn ein Verbindungscache erstellt und verwendet wird, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel erstellt ein neues <xref:System.Messaging.MessageQueue> mit exklusivem Lesezugriff und Verbindung Zwischenspeichern aktiviert worden sein.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser kann für den lokalen Computer "." lauten.</param>
        <param name="sharedModeDenyReceive"><see langword="true" />, wenn der ersten Anwendung, die auf die Warteschlange zugreift, exklusiver Zugriff gewährt werden soll, andernfalls <see langword="false" />.</param>
        <param name="enableCache"><see langword="true" />, wenn ein Verbindungscache erstellt und verwendet wird, andernfalls <see langword="false" />.</param>
        <param name="accessMode">Einer der <see cref="T:System.Messaging.QueueAccessMode" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den Zugriffsmodus für die Warteschlange angibt.</summary>
        <value>Einer der <see cref="T:System.Messaging.QueueAccessMode" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standard-Webzugriffsmodus für eine Warteschlange ist `QueueAccessMode.SendAndReceive`, sofern nicht anders beim Aufrufen des Konstruktors angegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Warteschlange nur authentifizierte Meldungen akzeptiert, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Warteschlange nur authentifizierte Meldungen akzeptiert, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Nachrichtenauthentifizierung bietet eine Möglichkeit, die Nachrichtenintegrität sicherzustellen und zu überprüfen, die die Nachricht gesendet. Um eine Authentifizierung anzufordern, legt die sendende Anwendung der meldungsauthentifizierungsebene fest.  
  
 Wenn Sie festlegen, <xref:System.Messaging.MessageQueue.Authenticate%2A> zu `true`, einschränken möchten Zugriff auf die Warteschlange auf dem Server, nicht nur auf diese <xref:System.Messaging.MessageQueue> Instanz. Alle Clients, die auf derselben Message Queuing-Warteschlange sind betroffen.  
  
 Eine Warteschlange, die nur authentifizierte Meldungen akzeptiert, wird eine nicht authentifizierte Nachricht abgelehnt. Benachrichtigung der Ablehnung der Nachricht anfordern eine sendende Anwendung festlegen kann die <xref:System.Messaging.Message.AcknowledgeType%2A> -Eigenschaft der Nachricht. Da keine anderen Hinweis auf Ablehnung der Nachricht vorhanden ist, kann die sendende Anwendung die Nachricht verlieren, es sei denn, Sie fordern, dass sie in die Warteschlange für unzustellbare Nachrichten gesendet werden.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.Authenticate%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Basispriorität an, die von Message Queuing beim Weiterleiten von Meldungen einer öffentlichen Warteschlange über das Netzwerk verwendet wird, oder legt diese fest.</summary>
        <value>Die einzige Basispriorität für alle an die (öffentliche) Warteschlange gesendeten Meldungen. Der Standardwert ist null (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Basispriorität einer Nachrichtenwarteschlange festlegt, wie eine Nachricht dem Weg, Warteschlange behandelt wird, bei der Übertragung über das Netzwerk. Sie können festlegen, die <xref:System.Messaging.MessageQueue.BasePriority%2A> Eigenschaft, um eine höhere oder niedrigere Priorität für alle Nachrichten gesendet werden, an die angegebene Warteschlange als gesendet, um andere Warteschlangen übertragen. Durch Festlegen dieser Eigenschaft wird geändert, Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind.  
  
 Einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.BasePriority%2A> bezieht sich nicht auf die <xref:System.Messaging.Message.Priority%2A> Eigenschaft einer Nachricht, die die Reihenfolge angibt, in dem eine eingehende Nachricht in die Warteschlange gestellt wird.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> gilt nur öffentliche Warteschlangen, deren Pfade mit dem Formatnamen angegeben werden. Die Basispriorität für eine private Warteschlange ist immer 0 (null).  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.BasePriority%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Basispriorität wurde auf einen ungültigen Wert festgelegt.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <summary>Initiiert einen asynchronen Lesevorgang, indem Message Queuing angewiesen wird, mit dem Einsehen einer Meldung zu beginnen und nach Abschluss des Vorgangs den Ereignishandler zu benachrichtigen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiiert einen asynchronen Lesevorgang ohne Timeout. Die Operation wird erst abgeschlossen, wenn eine Meldung in der Warteschlange verfügbar ist.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginPeek%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis aus, wenn eine Nachricht in der Warteschlange verfügbar wird.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Verwendung von <xref:System.Messaging.MessageQueue.BeginPeek%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und ordnen sie Ihre Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginPeek%2A> initiiert einen asynchronen Lesevorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, über das Auslösen von der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen klicken Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> oder durch Abrufen, das Ergebnis wird mithilfe der <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> ist asynchron, können Sie ihn aufrufen zum Einsehen der Warteschlange, ohne Blockierung der Ausführung des aktuellen Threads. Verwenden Sie zum synchron einsehen die Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen zu halten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginPeek%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs, obwohl Sie in der Regel nicht erst verwenden <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Aber wenn Sie mehrere asynchrone Vorgänge starten, kann man die <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang abgeschlossen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft der <xref:System.IAsyncResult> zur Identifizierung des abgeschlossenen Vorgangs.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, das Abschlussereignis ausgelöst, aber es wird eine Ausnahme ausgelöst werden, beim Aufrufen von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Ereignishandler namens `MyPeekCompleted`, fügt es der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignishandlerdelegaten, und ruft <xref:System.Messaging.MessageQueue.BeginPeek%2A> , einen asynchronen Lesevorgang in der Warteschlange zu initiieren, die unter dem Pfad befindet ". \myQueue". Wenn eine <xref:System.Messaging.MessageQueue.PeekCompleted> -Ereignis ausgelöst wird, wird im Beispiel sieht die Meldung und gibt deren Text auf dem Bildschirm. Das Beispiel ruft dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aus, um einen weiteren asynchronen Lesevorgang zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <summary>Initiiert einen asynchronen Lesevorgang mit einem festgelegten Timeout. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginPeek%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis aus, wenn eine Nachricht zur Verfügung steht, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Verwendung von <xref:System.Messaging.MessageQueue.BeginPeek%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und ordnen sie Ihre Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginPeek%2A> initiiert einen asynchronen Lesevorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, über das Auslösen von der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen klicken Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> oder durch Abrufen, das Ergebnis wird mithilfe der <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> ist asynchron, können Sie ihn aufrufen zum Einsehen der Warteschlange, ohne Blockierung der Ausführung des aktuellen Threads. Verwenden Sie zum synchron einsehen die Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen zu halten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginPeek%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs, obwohl Sie in der Regel nicht erst verwenden <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Aber wenn Sie mehrere asynchrone Vorgänge starten, kann man die <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang abgeschlossen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft der <xref:System.IAsyncResult> zur Identifizierung des abgeschlossenen Vorgangs.  
  
 Diese Überladung gibt einen Timeout. Wenn das Zeitintervall, wird angegeben die `timeout` abläuft, Parameter, die diese Komponente löst die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis. Da keine Meldung vorhanden ist, einen nachfolgenden Aufruf von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wird eine Ausnahme ausgelöst.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, das Abschlussereignis ausgelöst, aber es wird eine Ausnahme ausgelöst werden, beim Aufrufen von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Lesevorgang, mit dem Warteschlangenpfad ". \myQueue". Erstellen ein ereignishandlers `MyPeekCompleted`, und fügt es der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignishandlerdelegaten. <xref:System.Messaging.MessageQueue.BeginPeek%2A> wird mit einem Timeout von einer Minute aufgerufen, um den asynchronen Lesevorgang zu initiieren. Wenn eine <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst, oder das Timeout abläuft, wird die Meldung abgerufen, wenn vorhanden, und der Text wird auf dem Bildschirm ausgegeben. Klicken Sie dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aufgerufen, um einen weiteren asynchronen Lesevorgang mit demselben Timeout zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="stateObject">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <summary>Initiiert einen asynchronen Lesevorgang mit einem angegebenen Timeout und einem angegebenen Zustandsobjekt, das während der Lebensdauer des Vorgangs Informationen für den Vorgang bereitstellt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginPeek%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis aus, wenn eine Nachricht zur Verfügung steht, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Verwenden Sie diese Überladung, um Informationen mit dem Vorgang zu verknüpfen, die Lebensdauer des Vorgangs beibehalten wird. Der Ereignishandler kann auf diese Informationen zugreifen, anhand der <xref:System.IAsyncResult.AsyncState%2A> Eigenschaft der <xref:System.IAsyncResult> , die dem Vorgang zugeordnet ist.  
  
 Verwendung von <xref:System.Messaging.MessageQueue.BeginPeek%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und ordnen sie Ihre Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginPeek%2A> initiiert einen asynchronen Lesevorgang; die <xref:System.Messaging.MessageQueue> benachrichtigt wird, über das Auslösen von der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen klicken Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> oder durch Abrufen, das Ergebnis wird mithilfe der <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> ist asynchron, können Sie ihn aufrufen zum Einsehen der Warteschlange, ohne Blockierung der Ausführung des aktuellen Threads. Verwenden Sie zum synchron einsehen die Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen zu halten.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Gibt eine <xref:System.IAsyncResult> , identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs, obwohl Sie in der Regel nicht erst verwenden <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Aber wenn Sie mehrere asynchrone Vorgänge starten, kann man die <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang abgeschlossen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft der <xref:System.IAsyncResult> zur Identifizierung des abgeschlossenen Vorgangs.  
  
 Diese Überladung gibt ein Timeout und ein Zustandsobjekt. Wenn das Zeitintervall, wird angegeben die `timeout` abläuft, Parameter, die diese Komponente löst die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis. Da keine Meldung vorhanden ist, einen nachfolgenden Aufruf von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wird eine Ausnahme ausgelöst.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Wenn Sie aufrufen, z. B. <xref:System.Messaging.MessageQueue.BeginPeek%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie festlegen, identifizieren jeden Vorgang über ein Zustandsobjekt, das Sie definieren. Zur Veranschaulichung dieses Szenarios finden Sie im Beispielabschnitt.  
  
 Sie können das Zustandsobjekt, das auch verwenden, um Informationen über die Verarbeitung der Prozessthreads zu übergeben. Wenn ein Thread gestartet, aber der Rückruf in einem anderen Thread in einem asynchronen Szenario ist, ist das Zustandsobjekt, das gemarshallt und zusammen mit Informationen, die von das Ereignis übergeben werden.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, das Abschlussereignis ausgelöst, aber es wird eine Ausnahme ausgelöst werden, beim Aufrufen von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Lesevorgang, mit dem Warteschlangenpfad ". \myQueue". Erstellen ein ereignishandlers `MyPeekCompleted`, und fügt es der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignishandlerdelegaten. <xref:System.Messaging.MessageQueue.BeginPeek%2A> wird mit einem Timeoutwert von einer Minute aufgerufen. Jeder Aufruf von <xref:System.Messaging.MessageQueue.BeginPeek%2A> verfügt über eine eindeutige ganze Zahl zugeordnet, die zum jeweiligen Vorgang identifiziert. Wenn eine <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst, oder das Timeout abgelaufen ist, falls vorhanden, wird die Nachricht abgerufen und die Text und der spezifische ganzzahlige Bezeichner, die auf dem Bildschirm ausgegeben werden. Klicken Sie dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aufgerufen, um einen weiteren asynchronen Lesevorgang mit dem Timeout und die zugehörigen ganze Zahl, von den gerade abgeschlossenen Vorgang zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="stateObject">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />, der die Benachrichtigung über den Abschluss des asynchronen Vorgangs erhält.</param>
        <summary>Initiiert einen asynchronen Lesevorgang mit einem angegebenen Timeout und einem angegebenen Zustandsobjekt, das während der Lebensdauer des Vorgangs Informationen für den Vorgang bereitstellt. Dieser Überladung wird in einem Rückruf die Identität des Ereignishandlers für den Vorgang mitgeteilt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Überladung verwenden, wird der Rückruf, der im Parameter "Callback" angegebene direkt aufgerufen, wenn es sich bei eine Nachricht zur Verfügung steht, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist; die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird nicht ausgelöst. Alle anderen Überladungen der <xref:System.Messaging.MessageQueue.BeginPeek%2A> basieren auf diese Komponente zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> ist asynchron, können Sie ihn aufrufen zum Einsehen der Warteschlange, ohne Blockierung der Ausführung des aktuellen Threads. Verwenden Sie zum synchron einsehen die Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen zu halten.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Gibt eine <xref:System.IAsyncResult> , identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs, obwohl Sie in der Regel nicht erst verwenden <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Aber wenn Sie mehrere asynchrone Vorgänge starten, kann man die <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang abgeschlossen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft der <xref:System.IAsyncResult> zur Identifizierung des abgeschlossenen Vorgangs.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Wenn Sie aufrufen, z. B. <xref:System.Messaging.MessageQueue.BeginPeek%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie festlegen, identifizieren jeden Vorgang über ein Zustandsobjekt, das Sie definieren.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Lesevorgang. Der Code-Beispiel sendet eine Nachricht in eine lokale Warteschlange, ruft dann <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, und übergeben Sie: ein Timeoutwert von 10 Sekunden, die eine eindeutige ganze Zahl, die die jeweilige Nachricht; und eine neue Instanz der identifiziert <xref:System.AsyncCallback> , identifiziert den Ereignishandler `MyPeekCompleted`. Wenn eine <xref:System.Messaging.MessageQueue.PeekCompleted> -Ereignis ausgelöst wird, wird der Ereignishandler sieht die Nachricht und schreibt den Nachrichtentext und die Integer-Nachrichten-ID auf dem Bildschirm.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <param name="action">Einer der <see cref="T:System.Messaging.PeekAction" />-Werte. Gibt an, ob die aktuelle oder die folgende Meldung in der Warteschlange eingesehen wird.</param>
        <param name="state">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />, der die Benachrichtigung über den Abschluss des asynchronen Vorgangs erhält.</param>
        <summary>Initiiert einen asynchronen Lesevorgang, der über einen angegebenen Timeout verfügt und für den ein Cursor, eine Suchaktion und ein Zustandsobjekt festgelegt sind. Das Zustandsobjekt stellt für die Lebensdauer des Vorgangs zugeordnete Informationen bereit. Dieser Überladung wird in einem Rückruf die Identität des Ereignishandlers für den Vorgang mitgeteilt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Überladung verwenden, wird der Rückruf, der im Parameter "Callback" angegeben direkt aufgerufen, wenn eine Nachricht zur Verfügung steht, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist. Die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird nicht ausgelöst. Alle anderen Überladungen der <xref:System.Messaging.MessageQueue.BeginPeek%2A> basieren auf diese Komponente zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> ist asynchron, können Sie ihn aufrufen zum Einsehen der Warteschlange, ohne Blockierung der Ausführung des aktuellen Threads. Verwenden Sie zum synchron einsehen die Warteschlange die <xref:System.Messaging.MessageQueue.Peek%2A> Methode.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen zu halten.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Gibt eine <xref:System.IAsyncResult> , die durch die Methode gestartete asynchrone Operation angibt. Hiermit können Sie <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs, obwohl Sie in der Regel nicht erst verwenden <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Aber wenn Sie mehrere asynchrone Vorgänge starten, kann man die <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang abgeschlossen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft der <xref:System.IAsyncResult> zur Identifizierung des abgeschlossenen Vorgangs.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Wenn Sie aufrufen, z. B. <xref:System.Messaging.MessageQueue.BeginPeek%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie festlegen, identifizieren jeden Vorgang über ein Zustandsobjekt, das Sie definieren.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für den <paramref name="action" />-Parameter wurde ein anderer Wert als <see langword="PeekAction.Current" /> oder <see langword="PeekAction.Next" /> angegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <summary>Initiiert eine asynchrone Receive-Methode, indem Message Queuing angewiesen wird, mit dem Empfangen einer Meldung zu beginnen und nach Abschluss des Vorgangs den Ereignishandler zu benachrichtigen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiiert eine asynchrone Receive-Methode ohne Timeout. Die Operation wird erst abgeschlossen, wenn eine Meldung in der Warteschlange verfügbar ist.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginReceive%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis aus, wenn eine Nachricht aus der Warteschlange entfernt wurde.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Verwendung von <xref:System.Messaging.MessageQueue.BeginReceive%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet, und ordnen sie Ihre Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert eine asynchrone receive-Methode. die <xref:System.Messaging.MessageQueue> benachrichtigt wird, über das Auslösen von der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen klicken Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> ist asynchron, können Sie aufrufen, um eine Nachricht aus der Warteschlange zu empfangen, ohne Blockierung der Ausführung des aktuellen Threads. Um Nachrichten synchron zu empfangen, verwenden Sie die <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen zu halten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs, obwohl Sie in der Regel nicht erst verwenden <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Aber wenn Sie mehrere asynchrone Vorgänge starten, kann man die <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang abgeschlossen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft der <xref:System.IAsyncResult> zur Identifizierung des abgeschlossenen Vorgangs.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, das Abschlussereignis ausgelöst, aber es wird eine Ausnahme ausgelöst werden, beim Aufrufen von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Verwenden Sie nicht den asynchronen Aufruf <xref:System.Messaging.MessageQueue.BeginReceive%2A> mit Transaktionen. Wenn Sie einen transaktionalen, asynchronen Vorgang ausführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, und fügen Sie die Transaktion und der (synchron) <xref:System.Messaging.MessageQueue.Receive%2A> Methode innerhalb des ereignishandlers, die Sie erstellen, für den Lesevorgang. Ihr Ereignishandler kann Funktionen enthalten, wie im folgenden C#-Code dargestellt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird verkettet asynchrone Anforderungen. Es wird davon ausgegangen, dass eine Warteschlange vorhanden ist, auf dem lokalen Computer mit dem Namen "MyQueue". Die `Main` Funktion beginnt den asynchronen Vorgang, die von behandelt wird die `MyReceiveCompleted` Routine. `MyReceiveCompleted` die aktuelle Nachricht verarbeitet und beginnt eine neue asynchrone receive-Methode.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 Das folgende Codebeispiel stellt die asynchrone Anforderungen Warteschlange. Der Aufruf von <xref:System.Messaging.MessageQueue.BeginReceive%2A> verwendet die <xref:System.IAsyncResult.AsyncWaitHandle%2A> im Rückgabewert. Die `Main` Routine wartet, bis alle asynchronen Vorgänge abgeschlossen werden, vor dem Beenden.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <summary>Initiiert eine asynchrone Receive-Methode mit einem festgelegten Timeout. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginReceive%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis aus, wenn eine Nachricht zur Verfügung steht, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Verwendung von <xref:System.Messaging.MessageQueue.BeginReceive%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet, und ordnen sie Ihre Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert eine asynchrone receive-Methode. die <xref:System.Messaging.MessageQueue> benachrichtigt wird, über das Auslösen von der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen klicken Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> oder abrufen, das Ergebnis wird mithilfe der <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> ist asynchron, können Sie aufrufen, um eine Nachricht aus der Warteschlange zu empfangen, ohne Blockierung der Ausführung des aktuellen Threads. Um Nachrichten synchron zu empfangen, verwenden Sie die <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen zu halten.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, das Abschlussereignis ausgelöst, aber es wird eine Ausnahme ausgelöst werden, beim Aufrufen von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs, obwohl Sie in der Regel nicht erst verwenden <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Aber wenn Sie mehrere asynchrone Vorgänge starten, kann man die <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang abgeschlossen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft der <xref:System.IAsyncResult> zur Identifizierung des abgeschlossenen Vorgangs.  
  
 Diese Überladung gibt einen Timeout. Wenn das Zeitintervall, wird angegeben die `timeout` abläuft, Parameter, die diese Komponente löst die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis. Da keine Meldung vorhanden ist, einen nachfolgenden Aufruf von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> wird eine Ausnahme ausgelöst.  
  
 Verwenden Sie nicht den asynchronen Aufruf <xref:System.Messaging.MessageQueue.BeginReceive%2A> mit Transaktionen. Wenn Sie einen transaktionalen, asynchronen Vorgang ausführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, und fügen Sie die Transaktion und der (synchron) <xref:System.Messaging.MessageQueue.Receive%2A> Methode innerhalb des ereignishandlers, die Sie erstellen, für den Lesevorgang. Ihr Ereignishandler kann Funktionen enthalten, wie im folgenden C#-Code dargestellt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine asynchrone receive-Methode. Das Codebeispiel erstellt einen Ereignishandler `MyReceiveCompleted`, und fügt es der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignishandlerdelegaten. Der Code-Beispiel sendet eine Nachricht in eine lokale Warteschlange, ruft dann <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, und übergeben Sie einen Timeoutwert von zehn Sekunden. Wenn eine <xref:System.Messaging.MessageQueue.ReceiveCompleted> -Ereignis ausgelöst wird, wird der Ereignishandler empfängt die Nachricht und schreibt den Nachrichtentext auf dem Bildschirm.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise wurde ein negativer Wert angegeben.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="stateObject">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <summary>Initiiert eine asynchrone Receive-Methode mit einem angegebenen Timeout und einem angegebenen Zustandsobjekt, das während der Lebensdauer des Vorgangs Informationen für den Vorgang bereitstellt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie bei der asynchronen Verarbeitung <xref:System.Messaging.MessageQueue.BeginReceive%2A> zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis aus, wenn eine Nachricht zur Verfügung steht, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Verwenden Sie diese Überladung, um Informationen mit dem Vorgang zu verknüpfen, die Lebensdauer des Vorgangs beibehalten wird. Der Ereignishandler kann erkennen, diese Informationen an die <xref:System.IAsyncResult.AsyncState%2A> Eigenschaft der <xref:System.IAsyncResult> , die dem Vorgang zugeordnet ist.  
  
 Verwendung von <xref:System.Messaging.MessageQueue.BeginReceive%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet, und ordnen sie Ihre Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert eine asynchrone receive-Methode. die <xref:System.Messaging.MessageQueue> benachrichtigt wird, über das Auslösen von der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen klicken Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> oder abrufen, das Ergebnis wird mithilfe der <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> ist asynchron, können Sie aufrufen, um eine Nachricht aus der Warteschlange zu empfangen, ohne Blockierung der Ausführung des aktuellen Threads. Um Nachrichten synchron zu empfangen, verwenden Sie die <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen zu halten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs, obwohl Sie in der Regel nicht erst verwenden <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Aber wenn Sie mehrere asynchrone Vorgänge starten, kann man die <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang abgeschlossen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft der <xref:System.IAsyncResult> zur Identifizierung des abgeschlossenen Vorgangs.  
  
 Diese Überladung gibt ein Timeout und ein Zustandsobjekt. Wenn das Zeitintervall, wird angegeben die `timeout` abläuft, Parameter, die diese Komponente löst die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis. Da keine Meldung vorhanden ist, einen nachfolgenden Aufruf von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> wird eine Ausnahme ausgelöst.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Wenn Sie aufrufen, z. B. <xref:System.Messaging.MessageQueue.BeginReceive%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie festlegen, identifizieren jeden Vorgang über ein Zustandsobjekt, das Sie definieren.  
  
 Sie können das Zustandsobjekt, das auch verwenden, um Informationen über die Verarbeitung der Prozessthreads zu übergeben. Wenn ein Thread gestartet, aber der Rückruf in einem anderen Thread in einem asynchronen Szenario ist, ist das Zustandsobjekt, das gemarshallt und zusammen mit Informationen, die von das Ereignis übergeben werden.  
  
 Verwenden Sie nicht den asynchronen Aufruf <xref:System.Messaging.MessageQueue.BeginReceive%2A> mit Transaktionen. Wenn Sie einen transaktionalen, asynchronen Vorgang ausführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, und fügen Sie die Transaktion und der (synchron) <xref:System.Messaging.MessageQueue.Receive%2A> Methode innerhalb des ereignishandlers, die Sie erstellen, für den Lesevorgang. Ihr Ereignishandler kann Funktionen enthalten, wie im folgenden C#-Code dargestellt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine asynchrone receive-Methode. Das Codebeispiel erstellt einen Ereignishandler `MyReceiveCompleted`, und fügt es der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignishandlerdelegaten. Der Code-Beispiel sendet eine Nachricht in eine lokale Warteschlange, ruft dann <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, und übergeben Sie einen Timeoutwert von 10 Sekunden und eine eindeutige ganze Zahl, die die jeweilige Nachricht identifiziert. Wenn eine <xref:System.Messaging.MessageQueue.ReceiveCompleted> -Ereignis ausgelöst wird, wird der Ereignishandler empfängt die Nachricht und schreibt den Nachrichtentext und die Integer-Nachrichten-ID auf dem Bildschirm.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="stateObject">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />, der die Benachrichtigung über den Abschluss des asynchronen Vorgangs erhält.</param>
        <summary>Initiiert eine asynchrone Receive-Methode mit einem angegebenen Timeout und einem angegebenen Zustandsobjekt, das während der Lebensdauer des Vorgangs Informationen für den Vorgang bereitstellt. Dieser Überladung wird in einem Rückruf die Identität des Ereignishandlers für den Vorgang mitgeteilt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Überladung verwenden, wird der Rückruf, der im Parameter "Callback" angegebene direkt aufgerufen, wenn es sich bei eine Nachricht zur Verfügung steht, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist; die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis wird nicht ausgelöst. Alle anderen Überladungen der <xref:System.Messaging.MessageQueue.BeginReceive%2A> basieren auf diese Komponente zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Verwendung von <xref:System.Messaging.MessageQueue.BeginReceive%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet, und ordnen sie Ihre Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert eine asynchrone receive-Methode. die <xref:System.Messaging.MessageQueue> benachrichtigt wird, über das Auslösen von der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen klicken Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> oder abrufen, das Ergebnis wird mithilfe der <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> ist asynchron, können Sie aufrufen, um eine Nachricht aus der Warteschlange zu empfangen, ohne Blockierung der Ausführung des aktuellen Threads. Um Nachrichten synchron zu empfangen, verwenden Sie die <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen zu halten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs, obwohl Sie in der Regel nicht erst verwenden <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Aber wenn Sie mehrere asynchrone Vorgänge starten, kann man die <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang abgeschlossen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft der <xref:System.IAsyncResult> zur Identifizierung des abgeschlossenen Vorgangs.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Wenn Sie aufrufen, z. B. <xref:System.Messaging.MessageQueue.BeginReceive%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie festlegen, identifizieren jeden Vorgang über ein Zustandsobjekt, das Sie definieren.  
  
 Sie können das Zustandsobjekt, das auch verwenden, um Informationen über die Verarbeitung der Prozessthreads zu übergeben. Wenn ein Thread gestartet, aber der Rückruf in einem anderen Thread in einem asynchronen Szenario ist, ist das Zustandsobjekt, das gemarshallt und zusammen mit Informationen, die von das Ereignis übergeben werden.  
  
 Verwenden Sie nicht den asynchronen Aufruf <xref:System.Messaging.MessageQueue.BeginReceive%2A> mit Transaktionen. Wenn Sie einen transaktionalen, asynchronen Vorgang ausführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, und fügen Sie die Transaktion und der (synchron) <xref:System.Messaging.MessageQueue.Receive%2A> Methode innerhalb des ereignishandlers, die Sie erstellen, für den Lesevorgang. Ihr Ereignishandler kann Funktionen enthalten, wie im folgenden C#-Code dargestellt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine asynchrone receive-Methode. Der Code-Beispiel sendet eine Nachricht in eine lokale Warteschlange, ruft dann <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, und übergeben Sie: ein Timeoutwert von 10 Sekunden, die eine eindeutige ganze Zahl, die die jeweilige Nachricht; und eine neue Instanz der identifiziert <xref:System.AsyncCallback> , identifiziert den Ereignishandler `MyReceiveCompleted`. Wenn eine <xref:System.Messaging.MessageQueue.ReceiveCompleted> -Ereignis ausgelöst wird, wird der Ereignishandler empfängt die Nachricht und schreibt den Nachrichtentext und die Integer-Nachrichten-ID auf dem Bildschirm.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <param name="state">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />, der die Benachrichtigung über den Abschluss des asynchronen Vorgangs erhält.</param>
        <summary>Initiiert einen asynchronen Receive-Vorgang, der über einen angegebenen Timeout verfügt und für den ein Cursor und ein Zustandsobjekt festgelegt sind. Das Zustandsobjekt stellt für die Lebensdauer des Vorgangs zugeordnete Informationen bereit. Dieser Überladung wird in einem Rückruf die Identität des Ereignishandlers für den Vorgang mitgeteilt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Überladung verwenden, wird der Rückruf, der im Parameter "Callback" angegebene direkt aufgerufen, wenn es sich bei eine Nachricht zur Verfügung steht, in der Warteschlange oder das angegebene Zeitintervall abgelaufen ist; die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis wird nicht ausgelöst. Alle anderen Überladungen der <xref:System.Messaging.MessageQueue.BeginReceive%2A> basieren auf diese Komponente zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> wird auch ausgelöst, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Verwendung von <xref:System.Messaging.MessageQueue.BeginReceive%2A>, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet, und ordnen sie Ihre Ereignisdelegat. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert eine asynchrone receive-Methode. die <xref:System.Messaging.MessageQueue> benachrichtigt wird, über das Auslösen von der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> erreichen klicken Sie dann die Nachricht durch den Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> oder abrufen, das Ergebnis wird mithilfe der <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A> Methode kehrt sofort zurück, aber der asynchrone Vorgang ist nicht abgeschlossen werden, bis der Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> ist asynchron, können Sie aufrufen, um eine Nachricht aus der Warteschlange zu empfangen, ohne Blockierung der Ausführung des aktuellen Threads. Um Nachrichten synchron zu empfangen, verwenden Sie die <xref:System.Messaging.MessageQueue.Receive%2A> Methode.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler für den Empfang von Benachrichtigungen zu halten.  
  
 Die <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegeben wird, identifiziert den asynchronen Vorgang, der die Methode gestartet. Hiermit können Sie <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs, obwohl Sie in der Regel nicht erst verwenden <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Aber wenn Sie mehrere asynchrone Vorgänge starten, kann man die <xref:System.IAsyncResult> Werte in einem Array und gibt an, ob warten, bis alle Vorgänge oder einem Vorgang abgeschlossen. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A> Eigenschaft der <xref:System.IAsyncResult> zur Identifizierung des abgeschlossenen Vorgangs.  
  
 Das Zustandsobjekt, das ordnet Zustandsinformationen des Vorgangs an. Wenn Sie aufrufen, z. B. <xref:System.Messaging.MessageQueue.BeginReceive%2A> mehrere Male auf, um mehrere Vorgänge zu initiieren, können Sie festlegen, identifizieren jeden Vorgang über ein Zustandsobjekt, das Sie definieren.  
  
 Sie können das Zustandsobjekt, das auch verwenden, um Informationen über die Verarbeitung der Prozessthreads zu übergeben. Wenn ein Thread gestartet, aber der Rückruf in einem anderen Thread in einem asynchronen Szenario ist, ist das Zustandsobjekt, das gemarshallt und zusammen mit Informationen, die von das Ereignis übergeben werden.  
  
 Verwenden Sie nicht den asynchronen Aufruf <xref:System.Messaging.MessageQueue.BeginReceive%2A> mit Transaktionen. Wenn Sie einen transaktionalen, asynchronen Vorgang ausführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, und fügen Sie die Transaktion und der (synchron) <xref:System.Messaging.MessageQueue.Receive%2A> Methode innerhalb des ereignishandlers, die Sie erstellen, für den Lesevorgang. Ihr Ereignishandler kann Funktionen enthalten, wie im folgenden C#-Code dargestellt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Messaging.MessageQueue" /> gelesen werden kann.</summary>
        <value><see langword="true" />, wenn die <see cref="T:System.Messaging.MessageQueue" /> vorhanden und ein Lesezugriff durch die Anwendung möglich ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> Gibt an, ob die Anwendung kann Meldungen einsehen oder empfangen aus der Warteschlange. Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> ist `true`, <xref:System.Messaging.MessageQueue> empfangen und Einsehen von Nachrichten aus der Warteschlange können. Andernfalls ist es nicht möglich.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false` , wenn eine Warteschlange bereits mit exklusivem Lesezugriff geöffnet wurde (oder geöffnet, und dies nicht exklusiven Zugriff ist <xref:System.Messaging.MessageQueue> exklusiven Zugriff anfordert), oder wenn die Anwendung nicht über ausreichende Rechte für den Zugriff verfügt. Wenn die Anwendung versucht, die aus einer Warteschlange gelesen beim <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, der Zugriff wurde verweigert.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.CanRead%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob in die <see cref="T:System.Messaging.MessageQueue" /> geschrieben werden kann.</summary>
        <value><see langword="true" />, wenn die <see cref="T:System.Messaging.MessageQueue" /> vorhanden und ein Schreibzugriff durch die Anwendung möglich ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> Gibt an, ob die Anwendung Nachrichten an die Warteschlange zu senden kann. Wenn <xref:System.Messaging.MessageQueue.CanWrite%2A> ist `true`, <xref:System.Messaging.MessageQueue> kann Nachrichten an die Warteschlange senden. Andernfalls ist es nicht möglich.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> ist `false` , wenn eine Warteschlange bereits mit exklusivem Schreibzugriff geöffnet wurde (oder geöffnet, und dies nicht exklusiven Zugriff ist <xref:System.Messaging.MessageQueue> exklusiven Zugriff anfordert), oder wenn die Anwendung nicht über ausreichende Rechte für den Zugriff verfügt. Wenn Ihre Anwendung, zum Schreiben in eine Warteschlange versucht beim <xref:System.Messaging.MessageQueue.CanWrite%2A> ist `false`, der Zugriff wurde verweigert.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.CanWrite%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Kategorie der Warteschlange ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Guid" />, die die Kategorie der Warteschlange (Message Queuing-Typenbezeichner) darstellt und mit der eine Anwendung ihre Warteschlangen kategorisieren kann. Die Standardeinstellung ist <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kategorie der Warteschlange kann es sich um eine Anwendung ihre Warteschlangen kategorisieren. Beispielsweise können Sie alle Warteschlangen für die Abrechnung in eine Kategorie und alle Order-Warteschlangen in einem anderen platzieren.  
  
 Die <xref:System.Messaging.MessageQueue.Category%2A> Eigenschaft bietet Zugriff auf die Message Queuing-Typ-ID-Eigenschaft (die Lese-/Schreibzugriff), über die **Warteschlangeneigenschaften** Dialogfeld in der Computerverwaltungskonsole. Sie können eine neue Kategorie definieren. Sie können zwar <xref:System.Guid.NewGuid%2A> einen Kategoriewert zu erstellen, die eindeutig für alle ist <xref:System.Guid> Werte, die Aktion ist nicht erforderlich. Der Kategoriewert muss nur von anderen Kategorien, die nicht von allen anderen unterscheiden <xref:System.Guid> Werte. Sie können z. B. zuweisen {00000000-0000-0000-0000-000000000001} als die <xref:System.Messaging.MessageQueue.Category%2A> für einen Satz von Warteschlangen und {00000000-0000-0000-0000-000000000002} als die <xref:System.Messaging.MessageQueue.Category%2A> für eine andere.  
  
 Es ist nicht notwendig, legen Sie die <xref:System.Messaging.MessageQueue.Category%2A>. Der Wert kann `null` sein.  
  
 Durch Festlegen dieser Eigenschaft wird geändert, Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.Category%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Kategorie der Warteschlange wurde auf einen ungültigen Wert festgelegt.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht den Verbindungscache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufruf <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, die im Cache gespeicherten Formatnamen entfernt, und Handles geöffnet und im Cache gespeicherten geschlossen.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A> aufgerufen.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der <see cref="T:System.Messaging.MessageQueue" /> reservierten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> Gibt alle zugeordnete Ressourcen frei, ein <xref:System.Messaging.MessageQueue>, einschließlich freigegebene Ressourcen bei Bedarf. Das System diese Ressourcen Wenn automatisch wieder zugewiesen sind sie dennoch verfügbar, z. B. beim Aufruf der <xref:System.Messaging.MessageQueue.Send%28System.Object%29> -Methode, wie im folgenden C#-Code.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 Beim Aufruf <xref:System.Messaging.MessageQueue.Close%2A>, dass alle <xref:System.Messaging.MessageQueue> Eigenschaften, die Message Queuing-Warteschlange direkten Zugriff auf gelöscht werden. Die <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, und <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> dennoch alle unverändert zu lassen.  
  
 <xref:System.Messaging.MessageQueue.Close%2A> nicht immer kostenlos die schreibgeschützte und Schreibhandles an eine Warteschlange, da sie gemeinsam genutzt werden können. Sie können keines der folgenden Schritte aus, um sicherzustellen, dass nutzen <xref:System.Messaging.MessageQueue.Close%2A> die Read- und Write-Handles an eine Warteschlange freigegeben:  
  
-   Erstellen der <xref:System.Messaging.MessageQueue> mit exklusivem Zugriff. Zu diesem Zweck rufen Sie die <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> oder <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor, und legen Sie die `sharedModeDenyReceive` Parameter `true`.  
  
-   Erstellen der <xref:System.Messaging.MessageQueue> Verbindung Zwischenspeicherung deaktiviert. Zu diesem Zweck rufen Sie die <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor, und legen die `enableConnectionCache` Parameter `false`.  
  
-   Deaktivieren Sie die Verbindung Zwischenspeichern. Zu diesem Zweck legen Sie die <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> Eigenschaft `false`.  
  
 Rufen Sie <xref:System.Messaging.MessageQueue.Close%2A> für eine Warteschlange, bevor Sie die Warteschlange auf dem Message Queuing-Server zu löschen. Andernfalls konnte an die Warteschlange gesendete Nachrichten, Auslösen von Ausnahmen oder angezeigt werden, in der Warteschlange für unzustellbare Nachrichten.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Message Queuing-Warteschlange geschlossen.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Warteschlange unter dem angegebenen Pfad auf einem Message Queuing-Server.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der zu erstellenden Warteschlange.</param>
        <summary>Erstellt eine nicht transaktionale Message Queuing-Warteschlange unter dem angegebenen Pfad.</summary>
        <returns>Eine <see cref="T:System.Messaging.MessageQueue" />, die die neue Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine nicht transaktionale Message Queuing-Warteschlange zu erstellen.  
  
 Erstellen Sie eine neue Instanz der dem <xref:System.Messaging.MessageQueue> Klasse in Ihrer Anwendung und für eine vorhandene Warteschlange zu binden, verwenden Sie die <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor. Rufen Sie zum Erstellen einer neuen Warteschlange in Message Queuing- <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Die Syntax für die `path` Parameter hängt vom Typ der Warteschlange sie Verweise auf, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
  
 Verwenden "." für den lokalen Computer. Weitere Informationen zur Syntax finden Sie unter den <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die öffentliche und private Warteschlangen erstellt. Er sendet eine Nachricht an ausgewählte Warteschlangen.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist <see langword="null" /> oder eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Unter dem angegebenen Pfad ist bereits eine Warteschlange vorhanden.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der zu erstellenden Warteschlange.</param>
        <param name="transactional"><see langword="true" />, um eine transaktionale Warteschlange zu erstellen, oder <see langword="false" />, wenn eine nicht transaktionale Warteschlange erstellt werden soll.</param>
        <summary>Erstellt eine transaktionale oder eine nicht transaktionale Message Queuing-Warteschlange unter dem angegebenen Pfad.</summary>
        <returns>Eine <see cref="T:System.Messaging.MessageQueue" />, die die neue Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Überladung verwenden, um eine transaktionale Warteschlange in Message Queuing zu erstellen. Sie können eine nicht transaktionale Warteschlange erstellen, durch Festlegen der `transactional` Parameter `false` oder durch die andere Überladung von Aufrufen <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Erstellen Sie eine neue Instanz der dem <xref:System.Messaging.MessageQueue> Klasse in Ihrer Anwendung und für eine vorhandene Warteschlange zu binden, verwenden Sie die <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor. Rufen Sie zum Erstellen einer neuen Warteschlange in Message Queuing- <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Die Syntax für die `path` Parameter hängt vom Typ der Warteschlange sie Verweise auf, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
  
 Verwenden "." für den lokalen Computer. Weitere Informationen zur Syntax finden Sie unter den <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt, öffentliche und private transaktionale Warteschlangen. Er sendet eine Nachricht an ausgewählte Warteschlangen.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist <see langword="null" /> oder eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Unter dem angegebenen Pfad ist bereits eine Warteschlange vorhanden.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Messaging.Cursor" /> für die aktuelle Meldungswarteschlange.</summary>
        <returns>Ein neuer <see cref="T:System.Messaging.Cursor" /> für die aktuelle Meldungswarteschlange. Mithilfe des Cursors kann beim Lesen der Warteschlangenmeldungen eine bestimmte Position in der Warteschlange beibehalten werden.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Zeit und Datum der Erstellung der Warteschlange in Message Queuing ab.</summary>
        <value>Eine <see cref="T:System.DateTime" />, die Erstellungsdatum und -uhrzeit der Warteschlange darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> bezieht sich nicht in die Warteschlange auf dem Message Queuing-Server die <xref:System.Messaging.MessageQueue> Instanz.  
  
 Wenn die Warteschlange vorhanden ist, stellt diese Eigenschaft die Uhrzeit der Erstellung die Warteschlange angepasst an die lokale Zeit des Servers, auf dem die Warteschlange vorhanden ist, die dar.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.CreateTime%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Eigenschaftswerte für Meldungen ab, die beim Senden einer Meldung an die Warteschlange standardmäßig verwendet werden.</summary>
        <value>Ein <see cref="T:System.Messaging.DefaultPropertiesToSend" /> mit den Standardeigenschaftswerten für Meldungen in Message Queuing, die verwendet werden, wenn die Anwendung andere Objekte als <see cref="T:System.Messaging.Message" />-Instanzen an die Warteschlange sendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Objekt, das nicht ist vom Typ senden <xref:System.Messaging.Message> an die Warteschlange für die <xref:System.Messaging.MessageQueue> fügt das Objekt in eine Message Queuing-Nachricht. Zu diesem Zeitpunkt wird die <xref:System.Messaging.MessageQueue> wendet auf die Nachricht die Eigenschaftswerte, die Sie, in angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft. Im Gegensatz dazu, wenn Sie senden eine <xref:System.Messaging.Message> an die Warteschlange für diese Eigenschaften sind bereits für die Instanz angegebenen selbst, also <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> wird ignoriert, die <xref:System.Messaging.Message>.  
  
 Obwohl Sie die Eigenschaften durch Festlegen der <xref:System.Messaging.MessageQueue> -Objekt, das <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> bezieht sich auf die Eigenschaften der Nachrichten, die an die Warteschlange für nicht auf die Warteschlange selbst gesendet werden.  
  
 Die Standardwerte für die Eigenschaften werden in der folgenden Tabelle angezeigt.  
  
|Eigenschaft|Standardwert|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|Null (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|Ein Array der Länge 0 (null) Bytes|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|eine leere Zeichenfolge ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet die Priorität einer Nachricht Standardeigenschaften, die zum Senden der Meldung zu bestimmen.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Standardeigenschaften konnten für diese Warteschlange nicht festgelegt werden. Möglicherweise ist eine der Eigenschaften ungültig.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der zu löschenden Warteschlange.</param>
        <summary>Löschte eine Warteschlange auf einem Message Queuing-Server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Syntax für die `path` Parameter hängt vom Typ der Warteschlange.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
  
 Weitere Informationen zur Syntax finden Sie unter den <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.  
  
 Alternativ können Sie die <xref:System.Messaging.MessageQueue.FormatName%2A> oder <xref:System.Messaging.MessageQueue.Label%2A> Warteschlangenpfades für die.  
  
|Referenz|Syntax|  
|---------------|------------|  
|Formatname|FormatName: [ *Formatnamen* ]|  
|Bezeichnung|Label:[ *label* ]|  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Message Queuing-Warteschlange, löscht, falls vorhanden.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist <see langword="null" /> oder eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Syntax für den <paramref name="path" />-Parameter ist ungültig.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob diese <see cref="T:System.Messaging.MessageQueue" /> über exklusive Zugriffsrechte für das Empfangen von Meldungen aus der Message Queuing-Warteschlange verfügt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn diese <see cref="T:System.Messaging.MessageQueue" /> über exklusive Zugriffsrechte für das Empfangen von Meldungen aus der Warteschlange verfügt, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Gibt den freigegebenen Modus des der Warteschlange, auf die von diesem <xref:System.Messaging.MessageQueue>. Legen Sie <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> zu `true` an, dass nur diese <xref:System.Messaging.MessageQueue> müssen den Zugriff auf einsehen oder Empfangen von Nachrichten aus der Warteschlange mit dem angegebenen <xref:System.Messaging.MessageQueue.Path%2A>. Wenn ein anderer <xref:System.Messaging.MessageQueue> oder einer anderen Anwendung bezieht sich auf die gleiche Warteschlangenressource, die Instanz oder Anwendung werden nicht in der Lage, Meldungen einsehen oder empfangen, aber sie können weiterhin senden sie.  
  
 Wenn <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> ist `false`, die Warteschlange für mehrere Anwendungen senden, einsehen oder Empfangen von Nachrichten verfügbar ist.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von der <see cref="T:System.Messaging.MessageQueue" />-Klasse verwendeten Ressourcen (mit Ausnahme des Speichers) frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> auf, wenn Sie <xref:System.Messaging.MessageQueue> nicht mehr benötigen. Die <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>-Methode bewirkt, dass <xref:System.Messaging.MessageQueue> nicht mehr verwendet werden kann. Nach dem Aufruf <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, Sie müssen alle Verweise auf Freigeben der <xref:System.Messaging.MessageQueue> , damit der belegte Speicher durch die Garbagecollection wieder zugänglich gemacht werden kann.  
  
 Rufen Sie <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> bereits vor der Veröffentlichung des letzten Verweis auf die <xref:System.Messaging.MessageQueue>. Andernfalls die Ressourcen der <xref:System.Messaging.MessageQueue> ist mit reserviert, bis der Garbage Collection-Aufrufe der <xref:System.Messaging.MessageQueue> Destruktor.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Anwendung einen Verbindungscache verwaltet, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn ein Verbindungscache erstellt und verwendet wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Verbindungscache ist eine Liste der Verweise auf Strukturen, die enthalten lesen oder Schreiben von Handles in Warteschlangen. Wenn <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> ist `true`, <xref:System.Messaging.MessageQueue> verwendet Handles aus dem Cache bei jedem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, oder <xref:System.Messaging.MessageQueue.Receive%2A>, anstatt neue Handles zu öffnen. Dadurch kann die Leistung verbessert. Verwenden eines Verbindungscache auch isoliert die <xref:System.Messaging.MessageQueue> von Änderungen in der Topologie des Netzwerks.  
  
 Wenn Sie eine neue Verbindung mit einer Warteschlange erstellen, wenn es sich bei der Verbindungscache voll ist, ist die <xref:System.Messaging.MessageQueue> überschreibt die am wenigsten zuletzt zugegriffen wurde Struktur mit der neuen Verbindung. Sie können den Cache löschen, entweder durch Aufrufen von <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, z. B. wenn die Formatnamen, der Sie arbeiten mit Warteschlangen geändert haben, damit die vorherige lesen und Schreiben von Handles sind nicht mehr gültig.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Warteschlange lediglich nicht private (nicht verschlüsselte) Meldungen akzeptiert, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.EncryptionRequired" />-Werte. Die Standardeinstellung ist <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie, dass die Verschlüsselung für die an eine Warteschlange gesendeten Nachrichten erforderlich ist angeben, werden nur die Nachrichtentexte verschlüsselt. Die anderen Mitglieder (z. B. die <xref:System.Messaging.Message.Label%2A> und <xref:System.Messaging.Message.SenderId%2A> Eigenschaften) kann nicht verschlüsselt werden.  
  
 Durch Festlegen dieser Eigenschaft wird geändert, Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind.  
  
 Verschlüsseln einer Nachricht, wird die Meldung privat. Sie können angeben, die Warteschlangen verschlüsselungsanforderung sein `None`, `Body`, oder `Optional` durch Festlegen der <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> Eigenschaft entsprechend. Die <xref:System.Messaging.Message.UseEncryption%2A> Einstellung der Nachricht muss mit der verschlüsselungsanforderung der Warteschlange entsprechen. Wenn die Nachricht nicht verschlüsselt ist, und gibt an, die Warteschlange `Body`, oder wenn die Nachricht verschlüsselt ist, und gibt an, die Warteschlange `None`, von der Warteschlange die Nachricht zurückgewiesen. Wenn die sendende Anwendung eine negativen Bestätigungsnachricht in diesem Ereignis anfordert, gibt das Message Queuing-Ablehnung der Nachricht, an die sendende Anwendung an. Wenn die <xref:System.Messaging.Message.UseDeadLetterQueue%2A> Eigenschaft `true`, eine Nachricht, die die Verschlüsselung versagt, wird an die Warteschlange für unzustellbare Nachrichten gesendet. Andernfalls ist die Nachricht verloren gehen.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das den abzuschließenden asynchronen Lesevorgang bestimmt und über das das Endergebnis abgerufen werden kann.</param>
        <summary>Schließt den angegebenen asynchronen Lesevorgang ab.</summary>
        <returns>Die dem abgeschlossenen asynchronen Vorgang zugeordnete <see cref="T:System.Messaging.Message" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> schließt den Vorgang ab, die von der Initiierung der <xref:System.Messaging.MessageQueue.BeginPeek%2A> aufrufen. Zu diesem Zweck <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> sieht die Meldung.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> können angeben, ein Timeout auf, wodurch die <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis ausgelöst wird, wenn das Timeout auftritt, bevor eine Nachricht in der Warteschlange angezeigt wird. Wenn ein Timeout auftritt, ohne dass eine Meldung, die in der Warteschlange, ein nachfolgender Aufruf von eingehenden <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> löst eine Ausnahme aus.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wird verwendet, um die Nachricht zu lesen, die aufgrund der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis ausgelöst wurde.  
  
 Wenn Sie zum asynchronen Einsehen von Nachrichten fortsetzen möchten, können Sie erneut aufrufen <xref:System.Messaging.MessageQueue.BeginPeek%2A> nach dem Aufruf <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Ereignishandler namens `MyPeekCompleted`, fügt es der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignishandlerdelegaten, und ruft <xref:System.Messaging.MessageQueue.BeginPeek%2A> , einen asynchronen Lesevorgang in der Warteschlange zu initiieren, die unter dem Pfad befindet ". \myQueue". Wenn eine <xref:System.Messaging.MessageQueue.PeekCompleted> -Ereignis ausgelöst wird, wird im Beispiel sieht die Meldung und gibt deren Text auf dem Bildschirm. Das Beispiel ruft dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aus, um einen weiteren asynchronen Lesevorgang zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="asyncResult" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="asyncResult" />-Parameters ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das die abzuschließende asynchrone Receive-Methode bestimmt und über das das Ergebnis abgerufen werden kann.</param>
        <summary>Schließt die angegebene asynchrone Receive-Methode ab.</summary>
        <returns>Die dem abgeschlossenen asynchronen Vorgang zugeordnete <see cref="T:System.Messaging.Message" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis wird ausgelöst, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> schließt den Vorgang ab, die von der Initiierung der <xref:System.Messaging.MessageQueue.BeginReceive%2A> aufrufen. Zu diesem Zweck <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> empfängt die Nachricht.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> können angeben, ein Timeout auf, wodurch die <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis ausgelöst wird, wenn das Timeout auftritt, bevor eine Nachricht in der Warteschlange angezeigt wird. Wenn ein Timeout auftritt, ohne dass eine Meldung, die in der Warteschlange, ein nachfolgender Aufruf von eingehenden <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> löst eine Ausnahme aus.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> wird verwendet, um (Entfernen Sie aus der Warteschlange) die Nachricht lesen, die aufgrund der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis ausgelöst wurde.  
  
 Wenn Sie weiterhin Nachrichten asynchron empfangen möchten, können Sie erneut aufrufen <xref:System.Messaging.MessageQueue.BeginReceive%2A> nach dem Aufruf <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird verkettet asynchrone Anforderungen. Es wird davon ausgegangen, dass eine Warteschlange vorhanden ist, auf dem lokalen Computer mit dem Namen "MyQueue". Die `Main` Funktion beginnt den asynchronen Vorgang, die von behandelt wird die `MyReceiveCompleted` Routine. `MyReceiveCompleted` die aktuelle Nachricht verarbeitet und beginnt eine neue asynchrone receive-Methode.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="asyncResult" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="asyncResult" />-Parameters ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der gesuchten Warteschlange.</param>
        <summary>Bestimmt, ob unter dem angegeben Pfad eine Message Queuing-Warteschlange vorhanden ist.</summary>
        <returns><see langword="true" />, wenn unter dem angegebenen Pfad eine Warteschlange vorhanden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Methode bestimmt, ob eine Message Queuing-Warteschlange in einem angegebenen Pfad vorhanden ist. Um zu bestimmen, ob eine Warteschlange mit einer angegebene Formatname vorhanden ist, ist keine Methode vorhanden. Weitere Informationen über die Syntax für Formatnamen und andere Syntaxformen, finden Sie unter den <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> ist ein aufwendiger Vorgang. Verwenden sie nur, wenn es in der Anwendung erforderlich ist.  
  
> [!NOTE]
>  Die <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Methode unterstützt nicht die <xref:System.Messaging.MessageQueue.FormatName%2A> Präfix.  
  
 Die Syntax für die `path` Parameter hängt vom Typ der Warteschlange aus, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> kann nicht aufgerufen werden, um zu überprüfen, ob eine private Remotewarteschlange vorhanden ist.  
  
 Weitere Informationen zur Syntax finden Sie unter den <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.  
  
 Alternativ können Sie die <xref:System.Messaging.MessageQueue.Label%2A> Warteschlangenpfades für die.  
  
|Referenz|Syntax|  
|---------------|------------|  
|Bezeichnung|Label:[ `label` ]|  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob eine Message Queuing-Warteschlange vorhanden ist, und anschließend gelöscht.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="path" />-Syntax ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.  
  
- oder - 
Die <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" />-Methode wird für eine private Remotewarteschlange aufgerufen.</exception>
        <exception cref="T:System.InvalidOperationException">In der Anwendung wurde eine Syntax für Formatnamen verwendet, um das Vorhandensein der Warteschlange zu überprüfen.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den eindeutigen Namen der Warteschlange ab, den Message Queuing beim Erstellen der Warteschlange erzeugt hat.</summary>
        <value>Der im Netzwerk eindeutige Name der Warteschlange.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.FormatName%2A> Eigenschaft enthält den Formatnamen der Warteschlange. Message Queuing verwendet den Formatnamen der Warteschlange zu öffnen und wie Sie darauf zugreifen zu identifizieren. Im Gegensatz zu den meisten Merkmale von einer Warteschlange ist der Formatnamen keine Message Queuing-Anwendung Warteschlange Eigenschaft, damit Sie sie nicht über das Message Queuing-Verwaltungstool zugreifen können. Der Formatname ist einfach einen eindeutigen Namen für die Warteschlange, die Message Queuing generiert, beim Erstellen der Warteschlange oder die Anwendung später generiert.  
  
 Wenn Sie einen Pfad mithilfe der pfadnamensyntax angeben (z. B. `myComputer\myQueue`) statt der Syntax für Formatnamen beim Lesen oder in die Warteschlange schreiben, die dem primären Domänencontroller (die Active Directory verwendet) übersetzt die <xref:System.Messaging.MessageQueue.Path%2A> in der zugehörigen <xref:System.Messaging.MessageQueue.FormatName%2A> vor dem Zugriff auf die Warteschlange. Wenn Ihre Anwendung im Offlinemodus ist, müssen Sie die Syntax für Formatnamen verwenden; Andernfalls wird der primäre Domänencontroller zum Durchführen der Übersetzung Pfad nicht verfügbar.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.FormatName%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> ist nicht festgelegt.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Formatierungsprogramm ab, oder legt das Formatierungsprogramm fest, das zum Serialisieren und Deserialisieren eines Objekts in bzw. aus dem Körper einer Meldung verwendet wird, die aus einer Warteschlange gelesen oder in eine Warteschlange geschrieben wird.</summary>
        <value>Der <see cref="T:System.Messaging.IMessageFormatter" />, der den Stream erstellt, der in den Meldungstext geschrieben oder aus diesem gelesen werden soll. Die Standardeinstellung ist <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft enthält eine Instanz eines Objekts Formatierer, der Nachrichten transformiert werden, wenn die Anwendung liest oder in die Warteschlange schreibt.  
  
 Wenn die Anwendung die Nachricht an die Warteschlange sendet, wird das Formatierungsprogramm serialisiert das Objekt in einen Datenstrom und fügt sie in den Nachrichtentext ein. Beim Lesen aus einer Warteschlange deserialisiert das Formatierungsprogramm die Nachrichtendaten in das <xref:System.Messaging.Message.Body%2A> Eigenschaft eine <xref:System.Messaging.Message>.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> lose verknüpft, daher es nicht notwendig ist, das gleiche Objekt, das Absender und Empfänger geben Sie bei diesem Format haben. Die <xref:System.Messaging.ActiveXMessageFormatter> und <xref:System.Messaging.BinaryMessageFormatter> serialisieren Sie die Daten in eine binäre Darstellung. Die <xref:System.Messaging.ActiveXMessageFormatter> wird beim Senden oder Empfangen von COM-Komponenten verwendet.  
  
 <xref:System.Messaging.BinaryMessageFormatter> und <xref:System.Messaging.ActiveXMessageFormatter> ermöglichen einen höheren Durchsatz als die <xref:System.Messaging.XmlMessageFormatter>. Die <xref:System.Messaging.ActiveXMessageFormatter> ermöglicht die Interoperabilität mit Visual Basic 6.0-Message Queuing-Anwendungen.  
  
 Wenn Ihre Anwendung die Nachrichten an die Warteschlange sendet die <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> gilt nur für diese Nachrichten, die die standardmäßigen Eigenschaften der Nachricht verwenden <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. Wenn Sie senden eine <xref:System.Messaging.Message> an die Warteschlange für Message Queuing verwendet der Formatierer, der definiert, der <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> Eigenschaft, um stattdessen den Text zu serialisieren.  
  
 Die <xref:System.Messaging.MessageQueue> Klasse verwendet immer eine <xref:System.Messaging.Message> empfangen oder Einsehen einer Nachricht aus der Warteschlange. Die Nachricht deserialisiert wird, mit der <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, Formatieren eines Nachrichtentexts mit <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, Formatieren eines Nachrichtentexts mit <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle Meldungen in der Warteschlange zurück.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Messaging.Message" />, das alle Meldungen aus der Warteschlange darstellt. Die Reihenfolge entspricht der Reihenfolge in der Message Queuing-Warteschlange.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Gibt eine statische Momentaufnahme der Nachrichten in der Warteschlange, anstelle von dynamischen Verknüpfungen zu diesen Nachrichten zurück. Sie können nicht aus diesem Grund Arrays verwenden, so ändern Sie die Nachrichten in der Warteschlange. Wenn Sie in Echtzeit, dynamische Interaktion mit der Warteschlange (z. B. die Möglichkeit, Nachrichten zu löschen) möchten, rufen Sie die <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> Methode, die eine dynamische Liste der Nachrichten in der Warteschlange zurückgibt.  
  
 Da <xref:System.Messaging.MessageQueue.GetAllMessages%2A> gibt eine Kopie der Nachrichten in der Warteschlange, die zum Zeitpunkt die Methode aufgerufen wurde, wird das Array ist nicht widerspiegeln, neue Nachrichten, die in der Warteschlange eingehen oder Nachrichten, die aus der Warteschlange entfernt werden.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Ruft nur die Eigenschaften, die nicht herausgefiltert, sondern durch die <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Listet die Meldungen in einer Warteschlange auf. <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> ist veraltet. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> sollte stattdessen verwendet werden.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />, der eine dynamische Verbindung mit den Meldungen in der Warteschlange bereitstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Name des Computers, der die Warteschlange enthält, ohne die zwei führenden umgekehrten Schrägstriche (\\\\).</param>
        <summary>Ruft den Computerbezeichner ab, auf dem sich die Warteschlange befindet, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist.</summary>
        <returns>Eine <see cref="T:System.Guid" />, die einen eindeutigen Bezeichner für den Computer darstellt, auf dem sich die Warteschlange befindet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Können Sie für zwei Zwecke, u. a.-ID des Computers: das Computerjournal lesen und Festlegen von Sicherheitszertifikaten. Rufen Sie jedoch nicht möglich <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> für einen Remotecomputer, wenn Sie offline arbeiten, da die Anwendung den Zugriff auf den Verzeichnisdienst auf dem Domänencontroller verfügen muss.  
  
 Der Bezeichner für Computer (oder die Computer-ID) ist eine <xref:System.Guid> , die Message Queuing erstellt, wenn ein Computer mit dem Unternehmen hinzugefügt wird. Message Queuing kombiniert den Bezeichner für den Computer mit der `Machine` und `Journal` Stichworte, um das Computerjournal Formatnamen zu erstellen, die Syntax der ist `Machine=<computeridentifier>;Journal`. Das Computerjournal, auch bekannt als der Journalwarteschlange ist eine Systemwarteschlange, die Kopien von speichert generierte Instanznachrichten an, wenn die <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> Eigenschaft `true`.  
  
 Diese Syntax für die Erfassung ist nur gültig, wenn Sie den Formatnamen der Warteschlange zu erstellen. Syntax für den Pfad lautet `MachineName` \\ `Journal$`.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokalen Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> aufgerufen.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Der Computerbezeichner konnte nicht abgerufen werden. Möglicherweise ist der Verzeichnisdienst nicht verfügbar (z. B. während der Ausführung im Offlinebetrieb).  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein Enumerationsobjekt für alle Meldungen in der Warteschlange. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> ist veraltet. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> sollte stattdessen verwendet werden.</summary>
        <returns>Ein <see cref="T:System.Messaging.MessageEnumerator" /> mit den in der Warteschlange enthaltenen Meldungen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> erstellt eine dynamische Liste aller Meldungen in einer Warteschlange. Sie können entfernen aus der Warteschlange die Nachricht am aktuellen Position des Enumerators durch den Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> für die <xref:System.Messaging.MessageEnumerator> , <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> zurückgibt.  
  
 Da der Cursor die dynamische Liste der Nachrichten in der Warteschlange zugeordnet ist, gibt die Enumeration jede Änderung, die Sie an die Nachrichten in der Warteschlange, wenn die Nachricht nach der aktuellen Cursorposition. Der Enumerator kann z. B. ein niedrigerer Priorität-Nachricht, die außerhalb der aktuellen Position des Cursors gespeichert, jedoch keine höhere Priorität-Nachricht, die vor dieser Position eingefügt automatisch zugreifen. Aber Sie können Zurücksetzen die Enumeration, und so den Cursor zurück an den Anfang der Liste durch Aufrufen <xref:System.Messaging.MessageEnumerator.Reset%2A> für die <xref:System.Messaging.MessageEnumerator>.  
  
 Die Reihenfolge der Nachrichten in der Enumeration gibt die Reihenfolge, in der Warteschlange wieder, damit Nachrichten höherer Priorität vor der niedrigeren Priorität angezeigt werden.  
  
 Wenn Sie eine statische Momentaufnahme der Nachrichten in der Warteschlange, anstatt eine dynamische Verbindung, die sie möchten, rufen <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Diese Methode gibt ein Array von <xref:System.Messaging.Message> Objekte, die die Nachrichten zum Zeitpunkt darstellen, die Methode wurde aufgerufen.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft eine dynamische Liste von Nachrichten in einer Warteschlange ab und zählt alle Nachrichten mit der <xref:System.Messaging.Message.Priority%2A> -Eigenschaftensatz auf <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein Enumerationsobjekt für alle Meldungen in der Warteschlange.</summary>
        <returns>Ein <see cref="T:System.Messaging.MessageEnumerator" /> mit den in der Warteschlange enthaltenen Meldungen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> erstellt eine dynamische Liste aller Meldungen in einer Warteschlange. Sie können entfernen aus der Warteschlange die Nachricht am aktuellen Position des Enumerators durch den Aufruf <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> für die <xref:System.Messaging.MessageEnumerator> , <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> zurückgibt.  
  
 Da der Cursor die dynamische Liste der Nachrichten in der Warteschlange zugeordnet ist, gibt die Enumeration jede Änderung, die Sie an die Nachrichten in der Warteschlange, wenn die Nachricht nach der aktuellen Cursorposition. Der Enumerator kann z. B. ein niedrigerer Priorität-Nachricht, die außerhalb der aktuellen Position des Cursors gespeichert, jedoch keine höhere Priorität-Nachricht, die vor dieser Position eingefügt automatisch zugreifen. Aber Sie können Zurücksetzen die Enumeration, und so den Cursor zurück an den Anfang der Liste durch Aufrufen <xref:System.Messaging.MessageEnumerator.Reset%2A> für die <xref:System.Messaging.MessageEnumerator>.  
  
 Die Reihenfolge der Nachrichten in der Enumeration gibt die Reihenfolge, in der Warteschlange wieder, damit Nachrichten höherer Priorität vor der niedrigeren Priorität angezeigt werden.  
  
 Wenn Sie eine statische Momentaufnahme der Nachrichten in der Warteschlange, anstatt eine dynamische Verbindung, die sie möchten, rufen <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Diese Methode gibt ein Array von <xref:System.Messaging.Message> Objekte, die die Nachrichten zum Zeitpunkt darstellen, die Methode wurde aufgerufen.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Enumerationsobjekt für eine dynamische Liste der öffentlichen Warteschlangen im Netzwerk.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt eine Vorwärts-Cursorsemantik zum Durchlaufen aller öffentlichen Warteschlangen im Netzwerk bereit.</summary>
        <returns>Ein <see cref="T:System.Messaging.MessageQueueEnumerator" />, der eine dynamische Liste aller öffentlichen Meldungswarteschlangen im Netzwerk bereitstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung der <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> gibt eine Enumeration aller öffentlichen Warteschlangen, die sich im Netzwerk befinden.  
  
 Da der Cursor eine dynamische Liste zugeordnet ist, gibt die Enumeration jede Änderung, die Sie an eine Warteschlangenliste für Warteschlangen gelöscht oder außerhalb der aktuellen Position des Cursors hinzugefügt. Hinzufügen oder Löschen von Warteschlangen vor der aktuellen Position des Cursors werden nicht berücksichtigt. Der Enumerator kann z. B. eine Warteschlange, die hinter der Cursor angefügt, aber keiner vor dieser Position eingefügt automatisch zugreifen. Aber Sie können Zurücksetzen die Enumeration, und so den Cursor zurück an den Anfang der Liste durch Aufrufen <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> für die <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Es ist keine festgelegte Reihenfolge von Warteschlangen in einem Netzwerk. Ein Enumerator sortiert, z. B. nach Computer "," Bezeichnung "," öffentlichen oder privaten Status "oder" zugegriffen werden kann andere Kriterien nicht.  
  
 Wenn Sie eine statische Momentaufnahme der Warteschlangen im Netzwerk, anstatt eine dynamische Verbindung mit der sie möchten, rufen <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> oder <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Jede dieser beiden Methoden gibt ein Array von <xref:System.Messaging.MessageQueue> Objekte, die die Warteschlangen zum Zeitpunkt darstellen, die Methode wurde aufgerufen.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokalen Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel durchläuft alle Meldungswarteschlangen im Netzwerk und untersucht den Pfad für jede Warteschlange. Schließlich wird die Anzahl von öffentlichen Warteschlangen im Netzwerk.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Ein <see cref="T:System.Messaging.MessageQueueCriteria" />, das die Kriterien zum Filtern der verfügbaren Meldungswarteschlangen enthält.</param>
        <summary>Stellt eine Vorwärts-Cursorsemantik zum Durchlaufen aller öffentlichen Warteschlangen im Netzwerk bereit, die die angegebenen Kriterien erfüllen.</summary>
        <returns>Ein <see cref="T:System.Messaging.MessageQueueEnumerator" />, der eine dynamische Liste der öffentlichen Meldungswarteschlangen im Netzwerk bereitstellt, die die im <paramref name="criteria" />-Parameter angegebenen Bedingungen erfüllen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung der <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> gibt eine Liste aller öffentlichen Warteschlangen im Netzwerk, die in den Anwendungskriterien definierte Kriterien erfüllen. Sie können angeben, dass die Kriterien eingeschlossen werden sollen, z. B. die objekterstellung oder-Änderung Zeit, Computername, Label, Kategorie oder eine beliebige Kombination dieser Warteschlange.  
  
 Da des Cursors eine dynamische Liste zugeordnet ist, gibt die Enumeration jede Änderung, die Sie an eine Warteschlange, die außerhalb der aktuellen Cursorposition auftritt. Änderungen an Warteschlangen vor der aktuellen Cursorposition werden nicht wiedergegeben. Der Enumerator kann z. B. eine Warteschlange, die hinter der Cursor angefügt, aber keiner vor dieser Position eingefügt automatisch zugreifen. Aber Sie können Zurücksetzen die Enumeration, und so den Cursor zurück an den Anfang der Liste durch Aufrufen <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> für die <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Es ist keine festgelegte Reihenfolge von Warteschlangen in einem Netzwerk. Ein Enumerator sortiert, z. B. nach Computer "," Bezeichnung "," öffentlichen oder privaten Status "oder" zugegriffen werden kann andere Kriterien nicht.  
  
 Wenn Sie eine statische Momentaufnahme der Warteschlangen im Netzwerk, anstatt eine dynamische Verbindung mit der sie möchten, geben Sie Kriterien für <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> oder rufen Sie <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Jede dieser beiden Methoden gibt ein Array von <xref:System.Messaging.MessageQueue> Objekte, die die Warteschlangen zum Zeitpunkt darstellen, die Methode wurde aufgerufen. Aufrufen von <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, oder <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> bietet die gleichen Ergebnisse wie das Aufrufen <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> mit den Filterkriterien des <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, und <xref:System.Messaging.MessageQueue.MachineName%2A>bzw.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokalen Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird Meldungswarteschlangen durchlaufen und zeigt den Pfad der jede Warteschlange, die in den letzten Tag erstellt wurde und vorhanden ist, auf dem Computer "MyComputer".  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Computer, dessen private Warteschlangen abgerufen werden sollen.</param>
        <summary>Ruft alle privaten Warteschlangen auf dem angegebenen Computer ab.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die abgerufenen privaten Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> Ruft eine statische Momentaufnahme der Warteschlangen auf einem angegebenen Computer ab.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft die Liste der Warteschlangen ab.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="machineName" />-Parameter ist <see langword="null" /> oder enthält eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk ab.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die abgerufenen öffentlichen Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn Sie eine vollständige Liste aller öffentlichen Warteschlangen im Netzwerk möchten. Wenn Sie z. B. die Liste nach bestimmten Kriterien einschränken möchten <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, oder die Uhrzeit der letzten Änderung mit einer anderen Überladung dieser Methode. (Alternativ können Sie <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, oder <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie zum interagieren mit einer dynamischen Liste der Warteschlangen <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokalen Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft die Liste der Warteschlangen ab.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Ein <see cref="T:System.Messaging.MessageQueueCriteria" />, das die Kriterien zum Filtern der Warteschlangen enthält.</param>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk ab, die die angegebenen Kriterien erfüllen.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die abgerufenen öffentlichen Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie alle öffentlichen Warteschlangen im Netzwerk nach Bezeichnung, Kategorie oder Computernamen filtern möchten die <xref:System.Messaging.MessageQueue> -Klasse enthält bestimmte Methoden, die diese Funktionen bereitstellen (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, und <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>bzw.). Verwenden Sie diese Überladung, um eine Liste aller öffentlichen Warteschlangen im Netzwerk zu erhalten, die mehr als eine der folgenden Kriterien erfüllen (beispielsweise, wenn Sie sowohl eine Bezeichnung und eine Kategorie angeben möchten). Sie können auch filtern, indem meldungskriterien außer <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, und <xref:System.Messaging.MessageQueue.MachineName%2A>. Beispielsweise verwenden Sie diese Überladung, um nach der Uhrzeit der letzten Änderung einer Warteschlange zu filtern. Erstellen Sie eine neue Instanz der einfach die <xref:System.Messaging.MessageQueueCriteria> Klasse, legen Sie die entsprechenden Eigenschaften in der Instanz, und übergeben Sie die Instanz als die `criteria` Parameter.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie zum interagieren mit einer dynamischen Liste der Warteschlangen <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokalen Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft die Liste der Warteschlangen ab.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">Eine <see cref="T:System.Guid" /> zum Gruppieren der Gruppe von abzurufenden Warteschlangen.</param>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk ab, die der angegebenen Kategorie angehören.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die abgerufenen öffentlichen Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um die öffentlichen Warteschlangen nach Kategorie filtern. Die <xref:System.Messaging.MessageQueue.Category%2A> Eigenschaft bietet Zugriff auf die Message Queuing-Type-ID-Eigenschaft (die Lese-/Schreibzugriff) einer bestimmten Warteschlange. Sie können zwar <xref:System.Guid.NewGuid%2A> einen Kategoriewert zu erstellen, die eindeutig für alle ist <xref:System.Guid> Werte, es ist nicht erforderlich. Der Kategoriewert muss nur von anderen Kategorien, die nicht von allen anderen unterscheiden <xref:System.Guid> Werte. Sie können z. B. zuweisen {00000000-0000-0000-0000-000000000001} als die <xref:System.Messaging.MessageQueue.Category%2A> für einen Satz von Warteschlangen und {00000000-0000-0000-0000-000000000002} als die <xref:System.Messaging.MessageQueue.Category%2A> für eine andere.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie zum interagieren mit einer dynamischen Liste der Warteschlangen <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Sie geben die Kategorie als Teil der <xref:System.Messaging.MessageQueueCriteria> Sie an die Methode übergeben.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokalen Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft die Liste der Warteschlangen ab.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">Eine Bezeichnung zum Gruppieren der Gruppe von abzurufenden Warteschlangen.</param>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk ab, die die angegebene Bezeichnung aufweisen.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die abgerufenen öffentlichen Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Filtern von öffentlichen Warteschlangen nach Bezeichnung an.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie zum interagieren mit einer dynamischen Liste der Warteschlangen <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Sie können die Bezeichnung angeben, als Teil der <xref:System.Messaging.MessageQueueCriteria> Sie an die Methode übergeben.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokalen Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft die Liste der Warteschlangen ab.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="label" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Name des Computers mit der Gruppe der abzurufenden öffentlichen Warteschlangen.</param>
        <summary>Ruft alle öffentlichen Warteschlangen auf dem angegebenen Computer ab.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die öffentlichen Warteschlangen auf dem Computer verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um öffentlichen Warteschlangen nach Computer filtern.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie zum interagieren mit einer dynamischen Liste der Warteschlangen <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Sie können den Namen des Computers angeben, als Teil der <xref:System.Messaging.MessageQueueCriteria> Sie an die Methode übergeben.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Lokalen Computer und direkten Formatnamen|Nein|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft die Liste der Warteschlangen ab.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="machineName" />-Parameters ist falsch.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Sicherheitskontext ab, den MSMQ zum Zeitpunkt des Aufrufs dem aktuellen Benutzer zuordnet (Threadidentität).</summary>
        <returns>Ein <see cref="T:System.Messaging.SecurityContext" />-Objekt mit dem Sicherheitskontext.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den eindeutigen Message Queuing-Bezeichner für die Warteschlange ab.</summary>
        <value>Eine <see cref="P:System.Messaging.MessageQueue.Id" />, die die von der Message Queuing-Anwendung generierte Meldungs-ID darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing-legt die <xref:System.Messaging.MessageQueue.Id%2A> Eigenschaft beim Erstellen der Warteschlange. Diese Eigenschaft ist nur für Öffentliche Warteschlangen verfügbar.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.Id%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt fest, dass für eine Warteschlange keine Größenbeschränkung besteht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member wird häufig verwendet, wenn Sie festlegen <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> oder <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Messaging.MessageQueue.InfiniteQueueSize> Member.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass für Methoden, die Meldungen einsehen oder empfangen, kein Timeout festgelegt ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> unterstützt zwei Arten von beim Abruf der Nachricht: synchron und asynchron. Die synchronen Methoden <xref:System.Messaging.MessageQueue.Peek%2A> und <xref:System.Messaging.MessageQueue.Receive%2A>, dazu führen, dass die Prozessthread wartet, während ein bestimmten Zeitintervalls für eine neue Nachricht in der Warteschlange eingehen. Wenn das angegebene Zeitintervall ist <xref:System.Messaging.MessageQueue.InfiniteTimeout>, der Prozessthread ist blockiert, bis eine neue Nachricht verfügbar ist. Auf der anderen Seite <xref:System.Messaging.MessageQueue.BeginPeek%2A> und <xref:System.Messaging.MessageQueue.BeginReceive%2A> (die asynchronen Methoden), kann die hauptanwendung Aufgaben in einem separaten Thread fortgesetzt, bis eine Meldung in der Warteschlange eingeht.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Messaging.MessageQueue.InfiniteTimeout> Member.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Beschreibung der Warteschlange ab oder legt diese fest.</summary>
        <value>Die Bezeichnung der Meldungswarteschlange. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die maximale Länge für die Bezeichnung einer Warteschlange beträgt 124 Zeichen.  
  
 Die <xref:System.Messaging.MessageQueue.Label%2A> Eigenschaft muss nicht für alle Warteschlangen eindeutig sein. Jedoch wenn Sie mehrere Warteschlangen denselben <xref:System.Messaging.MessageQueue.Label%2A>, können keine der <xref:System.Messaging.MessageQueue.Send%28System.Object%29> Methode, um eine Nachricht an alle übertragen. Bei Verwendung der Syntax der Volumebezeichnung für die <xref:System.Messaging.MessageQueue.Path%2A> -Eigenschaft, wenn Sie die Nachricht zu senden, eine Ausnahme wird ausgelöst, wenn die <xref:System.Messaging.MessageQueue.Label%2A> ist nicht eindeutig.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.Label%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Bezeichnung wurde auf einen ungültigen Wert festgelegt.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zeitpunkt ab, zu dem die Eigenschaften einer Warteschlange zuletzt geändert wurden.</summary>
        <value>Eine <see cref="T:System.DateTime" />, die den Zeitpunkt der letzten Änderung der Warteschlangeneigenschaften angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeitpunkt der letzten Änderung enthält, wenn die Warteschlange erstellt wurde und ein beliebiger <xref:System.Messaging.MessageQueue> -Eigenschaft, die die Message Queuing-Warteschlange, wie z. B. ändert <xref:System.Messaging.MessageQueue.BasePriority%2A>. Der Wert des der <xref:System.Messaging.MessageQueue.LastModifyTime%2A> Eigenschaft darstellt, die Systemzeit des lokalen Computers.  
  
 Rufen Sie <xref:System.Messaging.MessageQueue.Refresh%2A> vor dem Abrufen der <xref:System.Messaging.MessageQueue.LastModifyTime%2A> Eigenschaft ist; andernfalls, Zeitpunkt der Änderung zugeordnet <xref:System.Messaging.MessageQueue> möglicherweise keine aktuellen.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.LastModifyTime%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Computers ab, auf dem sich die Message Queuing-Warteschlange befindet, oder legt diesen fest.</summary>
        <value>Der Name des Computers, auf dem sich die Warteschlange befindet. Die Standardeinstellung von Message Queuing ist "." für den lokalen Computer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.MachineName%2A> ist ein Bestandteil der Syntax für den angezeigten Namen der Warteschlange <xref:System.Messaging.MessageQueue.Path%2A>. Die folgende Tabelle zeigt die Syntax, die Sie verwenden sollten, für eine Warteschlange eines angegebenen Typs, wenn der Pfad der Warteschlange über den Anzeigenamen angegeben werden sollen.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
|Computer-Journalwarteschlange|`MachineName`\\`Journal$`|  
|Computer Dead Letter-Warteschlange|`MachineName`\\`Deadletter$`|  
|Computer Transaktionswarteschlange für unzustellbare Nachrichten|`MachineName`\\`XactDeadletter$`|  
  
 Verwenden "." für den lokalen Computer, die beim Angeben der <xref:System.Messaging.MessageQueue.MachineName%2A>. Nur der Computernamen ist für diese Eigenschaft erkannt, z. B. `Server0`. Die <xref:System.Messaging.MessageQueue.MachineName%2A> Eigenschaft das Format der IP-Adresse nicht unterstützt.  
  
 Wenn Sie definieren die <xref:System.Messaging.MessageQueue.Path%2A> in Form von der <xref:System.Messaging.MessageQueue.MachineName%2A>, die Anwendung löst eine Ausnahme aus, wenn Sie offline arbeiten, da der Domänencontroller für die Pfad-Übersetzung erforderlich ist. Aus diesem Grund müssen Sie verwenden die <xref:System.Messaging.MessageQueue.FormatName%2A> für die <xref:System.Messaging.MessageQueue.Path%2A> Syntax, wenn Sie offline arbeiten.  
  
 Die <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, und <xref:System.Messaging.MessageQueue.QueueName%2A> sind Eigenschaften verknüpft. Ändern der <xref:System.Messaging.MessageQueue.MachineName%2A> Eigenschaft bewirkt, dass die <xref:System.Messaging.MessageQueue.Path%2A> zu ändernden Eigenschaft. Es basiert auf dem die neue <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A>. Ändern der <xref:System.Messaging.MessageQueue.Path%2A> (z. B. mit der Syntax für Formatnamen) setzt die <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaften zum Verweisen auf die neue Warteschlange. Wenn die <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaft leer ist, ist die <xref:System.Messaging.MessageQueue.Path%2A> auf dem Computer, die Sie angeben, der Journalwarteschlange festgelegt ist.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.MachineName%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.MessageQueue.MachineName" /> ist <see langword="null" />.        
- oder -

Der Computername ist ungültig. Möglicherweise wurde eine falsche Syntax verwendet.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe der Journalwarteschlange ab oder legt diese fest.</summary>
        <value>Die maximale Größe der Journalwarteschlange in Kilobyte. In der Standardeinstellung von Message Queuing ist keine Begrenzung festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> bietet Zugriff auf die speicherbegrenzung für Message Queuing-Journal. Es ist nur relevant, wenn <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> ist `true`. Durch Festlegen dieser Eigenschaft wird geändert, Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind  
  
 Wenn Sie Nachrichten in einer Journalwarteschlange oder Dead Letter-Warteschlange speichern, sollten Sie in regelmäßigen Abständen löschen die Warteschlange zum Entfernen von Nachrichten, die nicht mehr benötigt werden. Nachrichten in eine Warteschlange, die in der das Kontingent für den Computer, in dem sich die Warteschlange befindet, eingerechnet werden. (Der Administrator stellt das Computerkontingent.)  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die maximale Größe der Journalwarteschlange wurde auf einen ungültigen Wert festgelegt.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe der Warteschlange ab oder legt diese fest.</summary>
        <value>Die maximale Größe der Warteschlange in KB. In der Standardeinstellung von Message Queuing ist keine Begrenzung festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> ermöglicht den Zugriff auf die Message Queuing-Nachricht speicherbegrenzung, ist unabhängig vom Nachrichtenkontingent des Computers, die der Administrator definiert. Weitere Informationen zum Kontingent für die finden Sie unter <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 Durch Festlegen dieser Eigenschaft wird geändert, Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind  
  
 Wenn versucht wird, entweder die maximale Warteschlangengröße oder Kontingent für die Computer zu überschreiten, können Nachrichten verloren gehen. Wenn das Warteschlangenkontingent erreicht ist, benachrichtigt das Message Queuing die Verwaltungswarteschlange, die von der sendenden Anwendung, um anzugeben, dass die Warteschlange voll ist, durch Rückgabe einer negativen Bestätigungsnachricht. Message Queuing weiterhin negative Bestätigungen zu senden, bis die Gesamtgröße der Nachrichten in der Warteschlange unter dem Limit liegt.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die maximale Größe für die Warteschlange enthält einen negativen Wert.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Eigenschaftenfilter für das Empfangen oder Einsehen von Meldungen ab oder legt diesen fest.</summary>
        <value>Der <see cref="T:System.Messaging.MessagePropertyFilter" />, der von der Warteschlange zum Filtern der Eigenschaften verwendet wird, die mit einer Meldung empfangen oder eingesehen werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Filter ist ein Satz von booleschen Werten, die die Nachrichteneigenschaften zu beschränken, die die <xref:System.Messaging.MessageQueue> empfängt oder einsieht. Wenn die <xref:System.Messaging.MessageQueue> empfängt oder einsieht eine Nachricht aus der Serverwarteschlange abgerufen, nur die Eigenschaften für die die <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> Wert `true`.  
  
 Das folgende Beispiel zeigt die anfänglichen Eigenschaftswerte für die <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> Eigenschaft. Diese Einstellungen sind identisch mit Aufrufen <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> auf eine <xref:System.Messaging.MessagePropertyFilter>.  
  
|Eigenschaft|Standardwert|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 Byte|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 Byte|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 Byte|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> zu dem empfangenen Meldungseigenschaften.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Filter ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eingeführt in MSMQ 3.0. Ruft die der Warteschlange zugeordnete Multicastadresse ab oder oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.String" /> mit einer gültigen Multicastadresse (im nachfolgend angegebenen Format) oder <see langword="null" />. Letzteres gibt an, dass die Warteschlange keiner Multicastadresse zugeordnet ist.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.MulticastAddress%2A> Eigenschaft verwendet, um eine nicht transaktionale Warteschlange mit einer Multicastadresse zuzuordnen, die beim Senden von Nachrichten verwendet werden können. Sie können keine transaktionale Warteschlange mit einer Multicastadresse zuordnen. Wenn die sendende Anwendung Nachrichten an eine multicast-Adresse sendet, sendet das Message Queuing eine Kopie der Nachricht an jede Warteschlange, die mit dieser Adresse verknüpft ist.  
  
 IP-Multicast-Adressen müssen in der Klasse-D-Bereich von 224.0.0.0 bis 239.255.255.255, mit der Einstellung entspricht der ersten vier höherwertigen Bits auf 1110 gleich sein. Allerdings sind nur bestimmte Bereiche von Adressen in diesem Bereich nicht reserviert und für das Senden von Multicastnachrichten verfügbar. Die aktuelle Liste reservierter Multicastadressen, finden Sie unter den [Internet Assigned Number Authority (IANA) Internet-Multicastadressen](https://go.microsoft.com/fwlink/?linkid=3859) Webseite. Es gibt keine Einschränkungen für die Portnummer ein.  
  
 Wenn mehrere Quellcomputer multicast-Nachrichten senden, und Sie eine bestimmte Warteschlange zum Empfangen von Nachrichten von nur einem Quellcomputer möchten, muss jeder Quellcomputer Nachrichten an eine andere Kombination aus IP-Adresse und Port senden.  
  
 Legen Sie zum Aufheben der Zuordnung von einer Warteschlange zu einer Multicastadresse der <xref:System.Messaging.MessageQueue.MulticastAddress%2A> Eigenschaft, um eine Zeichenfolge der Länge 0 (null). Legen Sie sie nicht auf `null`, wie dies führt eine <xref:System.ArgumentNullException>.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad der Warteschlange ab oder legt diesen fest. Nach dem Festlegen des <see cref="P:System.Messaging.MessageQueue.Path" /> zeigt die <see cref="T:System.Messaging.MessageQueue" /> auf eine neue Warteschlange.</summary>
        <value>Die Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist. Die Standardeinstellung hängt vom verwendeten <see cref="M:System.Messaging.MessageQueue.#ctor" />-Konstruktor ab. Sie ist entweder <see langword="null" />, oder sie wird durch den <paramref name="path" />-Parameter des Konstruktors angegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Syntax für die <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft hängt vom Typ der Warteschlange sie Punkte zu, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
|Computer-Journalwarteschlange|`MachineName`\\`Journal$`|  
|Computer Dead Letter-Warteschlange|`MachineName`\\`Deadletter$`|  
|Computer Transaktionswarteschlange für unzustellbare Nachrichten|`MachineName`\\`XactDeadletter$`|  
  
 Verwenden "." auf den lokalen Computer darzustellen.  
  
 Die <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, und <xref:System.Messaging.MessageQueue.QueueName%2A> sind Eigenschaften verknüpft. Ändern der <xref:System.Messaging.MessageQueue.MachineName%2A> Eigenschaft bewirkt, dass die <xref:System.Messaging.MessageQueue.Path%2A> zu ändernden Eigenschaft. Es basiert auf dem die neue <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A>. Ändern der <xref:System.Messaging.MessageQueue.Path%2A> (z. B. mit der Syntax für Formatnamen) setzt die <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaften zum Verweisen auf die neue Warteschlange.  
  
 Alternativ können Sie die <xref:System.Messaging.MessageQueue.FormatName%2A> oder <xref:System.Messaging.MessageQueue.Label%2A> Warteschlangenpfades für die, wie in der folgenden Tabelle gezeigt.  
  
|Referenz|Syntax|Beispiel|  
|---------------|------------|-------------|  
|Formatname|`FormatName:` [ *Formatnamen* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Bezeichnung|`Label:` [ *label* ]|`Label:` TheLabel|  
  
 Bei Verwendung der Syntax der Volumebezeichnung für die <xref:System.Messaging.MessageQueue.Path%2A> -Eigenschaft, wenn Sie die Nachricht zu senden, eine Ausnahme wird ausgelöst, wenn die <xref:System.Messaging.MessageQueue.Label%2A> ist nicht eindeutig.  
  
 Um offline zu arbeiten, müssen Sie die Syntax für Formatnamen anstelle der Anzeigenamen der Syntax in der ersten Tabelle verwenden. Andernfalls wird eine Ausnahme ausgelöst, da der primäre Domänencontroller (Active Directory auf dem befindet) nicht zum Auflösen des Pfads in den Formatnamen verfügbar ist.  
  
 Festlegen von einen neuen Pfad die Nachrichtenwarteschlange geschlossen und alle Handles frei.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
> [!NOTE]
>  Sie können im Arbeitsgruppenmodus nur private Warteschlangen verwenden. Geben Sie den Pfad mit der Syntax für die private Warteschlange `MachineName` \\ `Private$` \\ `QueueName`.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt neue <xref:System.Messaging.MessageQueue> -Objekte mit verschiedenen Syntaxtypen der Path-Namen. In jedem Fall sendet er eine Nachricht an die Warteschlange, deren Pfad in den Konstruktor definiert ist.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist ungültig. Möglicherweise wurde eine falsche Syntax verwendet.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <summary>Gibt eine Kopie der ersten Meldung in der Warteschlange zurück, ohne die Meldung aus der Warteschlange zu entfernen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird beendet, ohne die erste Meldung in der Warteschlange zu entfernen (einzusehen), auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Die <see cref="M:System.Messaging.MessageQueue.Peek" />-Methode ist synchron. Sie blockiert daher den aktuellen Thread bis zum Eingang einer Meldung.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, die die erste Meldung in der Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung aus, um eine-Warteschlange einsehen und warten, bis eine Meldung in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode liest, wird jedoch nicht entfernt, die erste Nachricht aus der Warteschlange. Aus diesem Grund wiederholte Aufrufe von <xref:System.Messaging.MessageQueue.Peek%2A> derselben Nachricht, zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht. Die <xref:System.Messaging.MessageQueue.Receive%2A> -Methode auf der anderen Seite liest und die erste Nachricht aus der Warteschlange entfernt. Wiederholte Aufrufe von <xref:System.Messaging.MessageQueue.Receive%2A>, daher verschiedene Meldungen zurückgeben.  
  
 Message Queuing ordnet die Nachrichten in der Warteschlange nach Priorität und Ankunftszeiten. Eine neuere Nachricht wird vor einer älteren platziert werden, nur, wenn sie eine höhere Priorität hat.  
  
 Verwenden Sie <xref:System.Messaging.MessageQueue.Peek%2A>¸ wenn eine Blockade des aktuellen Threads bis zum Eingehen einer Nachricht in die Warteschlange akzeptabel ist. Da diese Überladung keinen Timeout angegeben ist, kann die Anwendung auf unbestimmte Zeit warten. Wenn die Anwendungsverarbeitung ohne Wartezeiten fortgesetzt werden soll, verwenden Sie die asynchrone <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode. Alternativ können Sie angeben, einen Timeout für eine Nachricht in der Warteschlange eintrifft, mit der Überladung von <xref:System.Messaging.MessageQueue.Peek%2A> , einen Timeout angibt.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Die folgenden Beispiele verwenden die <xref:System.Messaging.MessageQueue.Peek%2A> Methode in einer Warteschlange.  
  
 Im ersten Beispiel wartet die Anwendung eine Nachricht in der Warteschlange verfügbar wird. Beachten Sie, dass im erste Beispiel nicht die Meldung zugreift, die empfangen wird. Es wird lediglich angehalten, verarbeitet werden, bevor eine Nachricht eingeht. Wenn eine Nachricht in die Warteschlange bereits vorhanden ist, wird sofort zurückgegeben.  
  
 Im zweiten Beispiel, eine Nachricht mit einem anwendungsdefinierten `Order` Klasse an die Warteschlange gesendet wird, und klicken Sie dann aus der Warteschlange eingesehen.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die maximale Zeitspanne angibt, für die auf den Eingang einer Meldung gewartet werden soll.</param>
        <summary>Wird beendet, ohne die erste Meldung in der Warteschlange zu entfernen (einzusehen), auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Die <see cref="M:System.Messaging.MessageQueue.Peek" />-Methode ist synchron. Sie blockiert daher den aktuellen Thread, bis eine Meldung verfügbar wird oder der Timeout eintritt.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, die die erste Meldung in der Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Überladung können Sie eine Warteschlange einsehen, oder um einen angegebenen Zeitraum bis eine Nachricht zu warten, die in der Warteschlange vorhanden ist. Die Methode zurückgegeben sofort, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode liest, wird jedoch nicht entfernt, die erste Nachricht aus der Warteschlange. Aus diesem Grund wiederholte Aufrufe von <xref:System.Messaging.MessageQueue.Peek%2A> derselben Nachricht, zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht. Die <xref:System.Messaging.MessageQueue.Receive%2A> -Methode auf der anderen Seite liest und die erste Nachricht aus der Warteschlange entfernt. Wiederholte Aufrufe von <xref:System.Messaging.MessageQueue.Receive%2A>, daher verschiedene Meldungen zurückgeben.  
  
 Message Queuing ordnet die Nachrichten in der Warteschlange nach Priorität und Ankunftszeiten. Eine neuere Nachricht wird vor einer älteren platziert werden, nur, wenn sie eine höhere Priorität hat.  
  
 Verwenden Sie <xref:System.Messaging.MessageQueue.Peek%2A>¸ wenn eine Blockade des aktuellen Threads bis zum Eingehen einer Nachricht in die Warteschlange akzeptabel ist. Der Thread bis zu den angegebenen Zeitraum ist oder auf unbestimmte Zeit blockiert werden, wenn Sie angegeben haben <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Wenn die Anwendungsverarbeitung ohne Wartezeiten fortgesetzt werden soll, verwenden Sie die asynchrone <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Messaging.MessageQueue.Peek%2A> -Methode mit einem Timeoutwert von 0 (null), um zu überprüfen, ob die Warteschlange leer ist.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die maximale Zeitspanne angibt, für die auf den Eingang einer Meldung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <param name="action">Einer der <see cref="T:System.Messaging.PeekAction" />-Werte. Gibt an, ob die aktuelle oder die folgende Meldung in der Warteschlange eingesehen wird.</param>
        <summary>Wird beendet, ohne die aktuelle oder die nächste Meldung mithilfe des angegebenen Cursors zu entfernen (einzusehen). Die <see cref="M:System.Messaging.MessageQueue.Peek" />-Methode ist synchron. Sie blockiert daher den aktuellen Thread, bis eine Meldung verfügbar wird oder der Timeout eintritt.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die eine Meldung in der Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Überladung können Sie eine Warteschlange einsehen, oder um einen angegebenen Zeitraum bis eine Nachricht zu warten, die in der Warteschlange vorhanden ist. Die Methode zurückgegeben sofort, wenn eine Nachricht in die Warteschlange bereits vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode liest, wird jedoch nicht entfernt, eine Nachricht aus der Warteschlange. Die <xref:System.Messaging.MessageQueue.Receive%2A> -Methode auf der anderen Seite liest und eine Nachricht aus der Warteschlange entfernt.  
  
 Verwenden Sie <xref:System.Messaging.MessageQueue.Peek%2A>¸ wenn eine Blockade des aktuellen Threads bis zum Eingehen einer Nachricht in die Warteschlange akzeptabel ist. Der Thread ist bis zu den angegebenen Zeitraum ist oder auf unbestimmte Zeit blockiert, wenn Sie angegeben haben <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Wenn die Anwendungsverarbeitung ohne Wartezeiten fortgesetzt werden soll, verwenden Sie die asynchrone <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für den <paramref name="action" />-Parameter wurde ein anderer Wert als <see langword="PeekAction.Current" /> oder <see langword="PeekAction.Next" /> angegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig. Möglicherweise ist <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sieht eine Meldung mit der angegebenen Korrelations-ID ein.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der einzusehenden Meldung.</param>
        <summary>Sieht die Meldung mit der angegebenen Korrelations-ID ein und löst sofort eine Ausnahme aus, wenn in der Warteschlange derzeit keine Meldung mit der angegebenen Korrelations-ID vorhanden ist.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Warteschlange, auf die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Wenn keine Nachricht gefunden wird, entspricht die `correlationID` -Parameter wird eine Ausnahme ausgelöst.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht gesendet wird, in der Warteschlange zugeordnete Antwort, Bericht oder Bestätigung von Nachrichten zu verknüpfen.  
  
 Zwei andere Methoden können Sie einsehen von Nachrichten in einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode dient zum Abrufen einer Nachricht, indem Sie einen eindeutigen Bezeichner angeben.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht, die eine Bestellung in und aus einer Warteschlange enthält. Eine positive Bestätigung sie ausdrücklich angefordert, wenn die ursprüngliche Nachricht erreicht wurde oder wird aus der Warteschlange abgerufen.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="correlationId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der einzusehenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <summary>Sieht eine Meldung mit der angegebenen Korrelations-ID ein und wartet, bis eine Meldung mit der angegebenen Korrelations-ID in der Warteschlange verfügbar ist oder bis der Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Warteschlange, auf die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Wenn keine Nachricht gefunden wird, entspricht die `correlationID` Parameter und keine neue Nachricht eingeht, um innerhalb des Zeitraums, indem Sie in der Warteschlange die `timeout` -Parameter wird eine Ausnahme ausgelöst.  
  
 Die `timeout` -Parameter gibt keinen die Gesamtausführungszeit für diese Methode. Stattdessen gibt es die Wartezeit für eine neue Nachricht in der Warteschlange eingehen. Jedes Mal eine neue Nachricht eingeht, überprüft diese Methode die <xref:System.Messaging.Message.CorrelationId%2A> der neuen Nachricht um festzustellen, ob er entspricht der `correlationId` Parameter. Wenn dies nicht der Fall, diese Methode den Timeout-Zeitraum beginnt, und wartet auf das Eintreffen einer neuen Meldung. Daher Wenn neue Nachrichten innerhalb des Timeoutzeitraums eingehen weiterhin, ist es möglich, dass diese Methode, um weiterhin dauerhaft ausgeführt, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen, oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht der `correlationId` Parameter.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht gesendet wird, in der Warteschlange zugeordnete Antwort, Bericht oder Bestätigung von Nachrichten zu verknüpfen.  
  
 Zwei andere Methoden können Sie einsehen von Nachrichten in einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode dient zum Abrufen einer Nachricht, indem Sie einen eindeutigen Bezeichner angeben.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine Meldung mit der angegebenen <paramref name="correlationId" /> ist nicht in der Warteschlange vorhanden und nicht vor Ablauf des Timeouts eingegangen.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung eingegangen.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Kopie der Meldung mit der angegebenen Meldungs-ID zurück, ohne die Meldung aus der Warteschlange zu entfernen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der einzusehenden Meldung.</param>
        <summary>Sieht die Meldung ein, deren Meldungs-ID mit dem <paramref name="id" />-Parameter übereinstimmt.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft mit dem <paramref name="id" />-Parameter übereinstimmt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> zu lesen, ohne aus der Warteschlange zu entfernen, eine Meldung mit einer bekannten Nachrichten-ID. Der Bezeichner einer Nachricht ist eindeutig für die Message Queuing-Organisation, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter. Diese Überladung löst eine Ausnahme aus, wenn die Warteschlange derzeit nicht über die Nachricht enthält.  
  
 Zwei weitere Methoden ermöglichen es Ihnen zum Einsehen von Nachrichten in einer Warteschlange: <xref:System.Messaging.MessageQueue.Peek%2A> und <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Nachricht in der Warteschlange zurück. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> gibt eine Bestätigung, einen Bericht oder einer Anwendung generierten antwortmeldungen-Meldung, die als Ergebnis eine an die Warteschlange gesendete Nachricht erstellt wurde.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine Meldung mit der angegebenen <paramref name="id" /> vorhanden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der einzusehenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <summary>Sieht die Meldung ein, deren Meldungs-ID mit dem <paramref name="id" />-Parameter übereinstimmt. Wartet, bis die Meldung in der Warteschlange eingeht oder ein Timeout auftritt.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft mit dem <paramref name="id" />-Parameter übereinstimmt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> zu lesen, ohne aus der Warteschlange zu entfernen, eine Meldung mit einer bekannten Nachrichten-ID. Der Bezeichner einer Nachricht ist eindeutig für die Message Queuing-Organisation, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter. Diese Überladung löst eine Ausnahme aus, wenn die Warteschlange derzeit nicht die Meldung enthält und eine neue Nachricht nicht eingehen, bevor das Timeout auftritt.  
  
 Die `timeout` -Parameter gibt keinen die Gesamtausführungszeit für diese Methode. Stattdessen gibt es die Wartezeit für eine neue Nachricht in der Warteschlange eingehen. Jedes Mal eine neue Nachricht eingeht, überprüft diese Methode die <xref:System.Messaging.Message.Id%2A> der neuen Nachricht um festzustellen, ob er entspricht der `id` Parameter. Wenn dies nicht der Fall, diese Methode den Timeout-Zeitraum beginnt, und wartet auf das Eintreffen einer neuen Meldung. Daher Wenn neue Nachrichten innerhalb des Timeoutzeitraums eingehen weiterhin, ist es möglich, dass diese Methode, um weiterhin dauerhaft ausgeführt, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen, oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.Id%2A> entspricht der `id` Parameter.  
  
 Zwei weitere Methoden ermöglichen es Ihnen zum Einsehen von Nachrichten in einer Warteschlange: <xref:System.Messaging.MessageQueue.Peek%2A> und <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Nachricht in der Warteschlange zurück. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> gibt eine Bestätigung, einen Bericht oder einer Anwendung generierten antwortmeldungen-Meldung, die als Ergebnis eine an die Warteschlange gesendete Nachricht erstellt wurde.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine Meldung mit der angegebenen <paramref name="id" /> ist nicht in der Warteschlange vorhanden und nicht vor Ablauf der im <paramref name="timeout" />-Parameter angegebenen Zeitspanne eingegangen.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Eingeführt in MSMQ 3.0. Sieht eine bestimmte Meldung in der Warteschlange ein. Die Meldung kann anhand eines Suchbezeichners oder anhand der Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der einzusehenden Meldung.</param>
        <summary>Eingeführt in MSMQ 3.0. Sieht die Meldung ein, die dem angegebenen Suchbezeichner in einer nicht transaktionalen Warteschlange entspricht.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.LookupId" />-Eigenschaft dem übergebenen <paramref name="lookupId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Meldung mit einer bekannten Nachschlage-ID zu lesen, ohne sie aus der Warteschlange entfernen. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft einer Nachricht ist für die Warteschlange eindeutig, in dem die Meldung befindet, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `lookupId` Parameter.  
  
 Verwenden Sie zum Lesen einer Nachricht mit einer angegebenen Nachschlage-ID und entfernt sie aus der Warteschlange, die <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> Methode.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="lookupId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">Einer der <see cref="T:System.Messaging.MessageLookupAction" />-Werte, der angibt, wie die Meldung in der Warteschlange gelesen wird. Geben Sie eine der folgenden Optionen an: 
 <see langword="MessageLookupAction.Current" />: Sieht die durch die <paramref name="lookupId" /> angegebene Meldung ein.  
  
 <see langword="MessageLookupAction.Next" />: Sieht die Meldung ein, die auf die anhand der <paramref name="lookupId" /> angegebene Meldung folgt.  
  
 <see langword="MessageLookupAction.Previous" />: Sieht die Meldung ein, die der anhand der <paramref name="lookupId" /> angegebenen Meldung vorausgeht.  
  
 <see langword="MessageLookupAction.First" />: Sieht die erste Meldung in der Warteschlange ein. Der <paramref name="lookupId" />-Parameter muss auf 0 festgelegt werden.  
  
 <see langword="MessageLookupAction.Last" />: Sieht die letzte Meldung in der Warteschlange ein. Der <paramref name="lookupId" />-Parameter muss auf 0 festgelegt werden.</param>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der einzusehenden Meldung, andernfalls 0 (null). 0 wird beim Zugreifen auf die erste oder letzte Meldung in die Warteschlange verwendet.</param>
        <summary>Eingeführt in MSMQ 3.0. Sieht eine bestimmte Meldung in der Warteschlange ein. Die Meldung kann anhand eines Suchbezeichners oder anhand der Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
        <returns>Die durch den übergebenen <paramref name="action" />-Parameter und <paramref name="lookupId" />-Parameter angegebene <see cref="T:System.Messaging.Message" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Meldung mit einer bekannten Nachschlage-ID zu lesen, ohne sie aus der Warteschlange entfernen. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft einer Nachricht ist für die Warteschlange eindeutig, in dem die Meldung befindet, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `lookupId` Parameter.  
  
 Verwenden Sie zum Lesen einer Nachricht mit einem angegebenen Bezeichner und entfernt sie aus der Warteschlange, die <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> Methode.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="lookupId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="action" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageLookupAction" />-Member.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine Meldung gelesen wird, ohne sie aus der Warteschlange zu entfernen. Dies ist ein Ergebnis eines asynchronen <see cref="M:System.Messaging.MessageQueue.BeginPeek" />-Vorgangs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> wird verwendet, bei der asynchronen Verarbeitung zum Auslösen der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis aus, wenn eine Nachricht in der Warteschlange verfügbar ist.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> Dient zum Abschließen des Vorgangs, der durch einen Aufruf initiiert <xref:System.Messaging.MessageQueue.BeginPeek%2A> und zum Empfangen der Nachricht bei der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis wird ausgelöst.  
  
 Beim Erstellen eines <xref:System.Messaging.PeekCompletedEventHandler>-Delegaten bestimmen Sie die Methode für die Ereignisbehandlung. Um dem Ereignishandler das Ereignis zuzuordnen, fügen Sie dem Ereignis eine Instanz des Delegaten hinzu. Der Ereignishandler wird bei jedem Eintreten des Ereignisses aufgerufen, sofern der Delegat nicht entfernt wird. Weitere Informationen zu den Ereignishandlerdelegaten, finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Ereignishandler namens `MyPeekCompleted`, fügt es der <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignishandlerdelegaten, und ruft <xref:System.Messaging.MessageQueue.BeginPeek%2A> , einen asynchronen Lesevorgang in der Warteschlange zu initiieren, die unter dem Pfad befindet ". \myQueue". Wenn eine <xref:System.Messaging.MessageQueue.PeekCompleted> -Ereignis ausgelöst wird, wird im Beispiel sieht die Meldung und gibt deren Text auf dem Bildschirm. Das Beispiel ruft dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aus, um einen weiteren asynchronen Lesevorgang zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle in der Warteschlange enthaltenen Meldungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löschen der Warteschlange bewirkt, dass Message Queuing, fest, wodurch die wirkt sich auf die <xref:System.Messaging.MessageQueue.LastModifyTime%2A> Eigenschaft. Nachrichten, die aus der Warteschlange gelöscht werden, gehen verloren; Sie werden nicht an die Dead Letter-Warteschlange oder der Journalwarteschlange gesendet.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den angezeigten Namen für die Warteschlange ab oder legt diesen fest.</summary>
        <value>Der Name zur Bezeichnung der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Der Wert darf nicht <see langword="null" /> sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie kombinieren, können die <xref:System.Messaging.MessageQueue.QueueName%2A> mit der <xref:System.Messaging.MessageQueue.MachineName%2A> erstellen Sie einen aussagekräftigen <xref:System.Messaging.MessageQueue.Path%2A> Name für die Warteschlange. Die Syntax für den Anzeigenamen des der <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft hängt vom Typ der Warteschlange aus, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Verwenden "." auf den lokalen Computer darzustellen.  
  
 Ändern der <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaft wirkt sich auf die <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft. Setzen Sie die <xref:System.Messaging.MessageQueue.QueueName%2A> festlegen, ohne die <xref:System.Messaging.MessageQueue.MachineName%2A> -Eigenschaft, die <xref:System.Messaging.MessageQueue.Path%2A> Eigenschaft.\\ `QueueName`. Andernfalls die <xref:System.Messaging.MessageQueue.Path%2A> wird `MachineName` \\ `QueueName`.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Ja|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name der Warteschlange ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das systemeigene Handle zum Empfangen von Meldungen aus der Meldungswarteschlange ab.</summary>
        <value>Ein Handle für das systemeigene Warteschlangenobjekt, das zum Einsehen und Empfangen von Meldungen aus der Warteschlange verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.ReadHandle%2A> bietet ein systemeigenes Windows-Handle für das Message Queue-Objekt, das zum einsehen und Empfangen von Nachrichten aus der Warteschlange verwendet wird. Wenn Sie den Pfad der Warteschlange ändern, wird das Handle geschlossen und erneut geöffnet wird, durch einen neuen Wert.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <summary>Empfängt die erste Meldung aus der Warteschlange und entfernt sie aus der Warteschlange.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Empfängt die erste verfügbare Meldung aus der Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser Aufruf ist synchron und blockiert den aktuellen Ausführungsthread, bis eine Meldung verfügbar ist.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Meldung aus einer Warteschlange oder warten, bis die Nachrichten in die Warteschlange vorhanden sind.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchronen Lesen einer Nachricht, wodurch aus der Warteschlange entfernen. Nachfolgende Aufrufe von <xref:System.Messaging.MessageQueue.Receive%2A> die Nachrichten, die in der Warteschlange oder neue, führen Sie Nachrichten mit höhere Priorität zurück.  
  
 Um die erste Nachricht in einer Warteschlange lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Da diese Überladung von der <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt ein unendliches Timeout an, die Anwendung auf unbestimmte Zeit warten kann. Wenn die anwendungsverarbeitung ohne Wartezeiten für die Nachricht fortgesetzt werden soll, sollten Sie mit der asynchronen Methode, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Meldung aus einer Warteschlange empfangen und gibt Informationen über diese Meldung auf dem Bildschirm.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die erste verfügbare Meldung aus der transaktionalen Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser Aufruf ist synchron und blockiert den aktuellen Ausführungsthread, bis eine Meldung verfügbar ist.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht aus einer transaktionalen Warteschlange, die mithilfe von definierten internen Transaktionskontexts die `transaction` -Parameter oder warten, bis die Nachrichten in die Warteschlange vorhanden sind.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchronen Lesen einer Nachricht, wodurch aus der Warteschlange entfernen. Nachfolgende Aufrufe von <xref:System.Messaging.MessageQueue.Receive%2A> die Nachrichten, die Folgen in der Warteschlange zurück.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde der empfangenen Nachricht in die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um die erste Nachricht in einer Warteschlange lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen, die mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernt werden alle Nachrichten in der Warteschlange, es gäbe nichts durch einen Aufruf von Rollback <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Da diese Überladung von der <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt ein unendliches Timeout an, die Anwendung auf unbestimmte Zeit warten kann. Wenn die anwendungsverarbeitung ohne Wartezeiten für die Nachricht fortgesetzt werden soll, sollten Sie mit der asynchronen Methode, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einer transaktionalen Warteschlange auf dem lokalen Computer her und sendet eine Nachricht an die Warteschlange. Anschließend wird die Meldung, die eine Bestellung enthält empfangen. Wenn eine nicht transaktionale Warteschlange auftreten, löst diese Ausnahme ausgegeben und ein Rollback der Transaktion.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.  
  
- oder - 
Die Warteschlange ist nicht transaktional.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die erste verfügbare Meldung aus der Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser Aufruf ist synchron und blockiert den aktuellen Ausführungsthread, bis eine Meldung verfügbar ist.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht aus einer Warteschlange mithilfe von definierten Transaktionskontext der `transactionType` -Parameter oder warten, bis die Nachrichten in die Warteschlange vorhanden sind.  
  
 Geben Sie `Automatic` für die `transactionType` -Parameters, wenn es bereits ein externer Transaktionskontext ist an den Thread angefügt, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` sollten Sie die Nachricht als eine interne Transaktion empfangen. Sie können angeben, `None` sollten Sie eine Nachricht aus einer transaktionalen Warteschlange außerhalb eines Transaktionskontexts zu empfangen.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchronen Lesen einer Nachricht, wodurch aus der Warteschlange entfernen. Nachfolgende Aufrufe von <xref:System.Messaging.MessageQueue.Receive%2A> die Nachrichten, die Folgen in der Warteschlange zurück.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht aus einer transaktionalen Warteschlange zu empfangen, würde der empfangenen Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um die erste Nachricht in einer Warteschlange lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen, die mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernt werden alle Nachrichten in der Warteschlange, es gäbe nichts durch einen Aufruf von Rollback <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Da diese Überladung von der <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt ein unendliches Timeout an, die Anwendung auf unbestimmte Zeit warten kann. Wenn die anwendungsverarbeitung ohne Wartezeiten für die Nachricht fortgesetzt werden soll, sollten Sie mit der asynchronen Methode, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <summary>Empfängt die erste verfügbare Meldung aus der Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist, und wartet, bis eine Meldung in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Überladung können Sie eine Meldung empfangen und nach einer angegebenen Zeitspanne beenden, sofern sich keine Meldungen in der Warteschlange befinden.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchronen Lesen einer Nachricht aus der Warteschlange entfernen. Nachfolgende Aufrufe von <xref:System.Messaging.MessageQueue.Receive%2A> die Nachrichten, die in der Warteschlange oder neue, führen Sie Nachrichten mit höhere Priorität zurück.  
  
 Um die erste Nachricht in einer Warteschlange lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Der Thread für den angegebenen Zeitraum ist oder auf unbestimmte Zeit blockiert werden, wenn Sie den-Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter. Wenn die anwendungsverarbeitung ohne Wartezeiten für eine Nachricht fortgesetzt werden soll, sollten Sie mit der asynchronen Methode, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Meldung aus einer Warteschlange empfangen und gibt Informationen über diese Meldung auf dem Bildschirm. Im Beispiel hält die Ausführung bis zu fünf Sekunden während des Wartens auf einer Nachricht in der Warteschlange eintrifft.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <summary>Empfängt unter Verwendung des aktuellen Cursors die aktuelle Meldung in der Warteschlange. Wenn keine Meldung verfügbar ist, wartet diese Methode, bis eine Meldung verfügbar ist oder der Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode. 
Mit dieser Überladung können Sie eine Meldung empfangen und nach einer angegebenen Zeitspanne beenden, sofern sich keine Meldungen in der Warteschlange befinden.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die erste verfügbare Meldung aus der transaktionalen Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist, und wartet, bis eine Meldung in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht aus einer transaktionalen Warteschlange, die mithilfe von definierten internen Transaktionskontexts die `transaction` Parameter und Rückgabewert innerhalb eines angegebenen Zeitraums Zeit, wenn in der Warteschlange keine Nachrichten vorhanden sind.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchronen Lesen einer Nachricht, wodurch aus der Warteschlange entfernen. Nachfolgende Aufrufe von <xref:System.Messaging.MessageQueue.Receive%2A> die Nachrichten, die Folgen in der Warteschlange zurück.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde der empfangenen Nachricht in die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um die erste Nachricht in einer Warteschlange lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen, die mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernt werden alle Nachrichten in der Warteschlange, es gäbe nichts durch einen Aufruf von Rollback <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Der Thread für den angegebenen Zeitraum ist oder auf unbestimmte Zeit blockiert werden, wenn Sie den-Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter. Wenn die anwendungsverarbeitung ohne Wartezeiten für eine Nachricht fortgesetzt werden soll, sollten Sie mit der asynchronen Methode, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieser Methode veranschaulicht.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
- oder - 
Die Warteschlange ist nicht transaktional.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die erste verfügbare Meldung aus der Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser Aufruf ist synchron und wartet, bis entweder eine Meldung in der Warteschlange verfügbar ist oder der Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht aus einer Warteschlange mithilfe von definierten Transaktionskontext der `transactionType` Parameter und Rückgabewert in einen angegebenen Zeitraum, wenn in der Warteschlange keine Nachrichten vorhanden sind.  
  
 Geben Sie `Automatic` für die `transactionType` -Parameters, wenn es bereits ein externer Transaktionskontext ist an den Thread angefügt, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` sollten Sie die Nachricht als eine interne Transaktion empfangen. Sie können angeben, `None` sollten Sie eine Nachricht aus einer transaktionalen Warteschlange außerhalb eines Transaktionskontexts zu empfangen.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchronen Lesen einer Nachricht, wodurch aus der Warteschlange entfernen. Nachfolgende Aufrufe von <xref:System.Messaging.MessageQueue.Receive%2A> die Nachrichten, die Folgen in der Warteschlange zurück.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht aus einer transaktionalen Warteschlange zu empfangen, würde der empfangenen Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um die erste Nachricht in einer Warteschlange lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Die <xref:System.Messaging.MessageQueue.Peek%2A> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen, die mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernt werden alle Nachrichten in der Warteschlange, es gäbe nichts durch einen Aufruf von Rollback <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Der Thread für den angegebenen Zeitraum ist oder auf unbestimmte Zeit blockiert werden, wenn Sie den-Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter. Wenn die anwendungsverarbeitung ohne Wartezeiten für eine Nachricht fortgesetzt werden soll, sollten Sie mit der asynchronen Methode, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieser Methode veranschaulicht.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt unter Verwendung des aktuellen Cursors die aktuelle Meldung in der Warteschlange. Wenn keine Meldung verfügbar ist, wartet diese Methode, bis eine Meldung verfügbar ist oder der Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf eine Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht aus einer transaktionalen Warteschlange, die mithilfe von definierten internen Transaktionskontexts die `transaction` Parameter und Rückgabewert innerhalb eines angegebenen Zeitraums Zeit, wenn in der Warteschlange keine Nachrichten vorhanden sind.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchronen Lesen einer Nachricht, wodurch aus der Warteschlange entfernen. Nachfolgende Aufrufe von <xref:System.Messaging.MessageQueue.Receive%2A> die Nachrichten, die Folgen in der Warteschlange zurück.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, wird der empfangenen Nachricht in die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um eine Nachricht in eine Warteschlange lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Es ist kein Transaktionskontext zugewiesen, die mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernt werden alle Nachrichten in der Warteschlange, gibt es keine durch einen Aufruf von Rollback <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Der Thread wird für den angegebenen Zeitraum ist oder auf unbestimmte Zeit blockiert, wenn Sie den-Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter. Wenn die anwendungsverarbeitung ohne Wartezeiten für eine Nachricht fortgesetzt werden soll, sollten Sie mit der asynchronen Methode, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig. Möglicherweise ist <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
- oder - 
Die Warteschlange ist nicht transaktional.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt unter Verwendung des aktuellen Cursors die aktuelle Meldung in der Warteschlange. Wenn keine Meldung verfügbar ist, wartet diese Methode, bis eine Meldung verfügbar ist oder der Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf eine Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zum Empfangen einer Nachricht aus einer Warteschlange mithilfe von definierten Transaktionskontext der `transactionType` Parameter und Rückgabewert in einen angegebenen Zeitraum, wenn in der Warteschlange keine Nachrichten vorhanden sind.  
  
 Geben Sie `Automatic` für die `transactionType` -Parameters, wenn es bereits ein externer Transaktionskontext ist an den Thread angefügt, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` sollten Sie die Nachricht als eine interne Transaktion empfangen. Sie können angeben, `None` sollten Sie eine Nachricht aus einer transaktionalen Warteschlange außerhalb eines Transaktionskontexts zu empfangen.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode ermöglicht das synchronen Lesen einer Nachricht, wodurch aus der Warteschlange entfernen. Nachfolgende Aufrufe von <xref:System.Messaging.MessageQueue.Receive%2A> die Nachrichten, die Folgen in der Warteschlange zurück.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht aus einer transaktionalen Warteschlange zu empfangen, wird der empfangenen Nachricht in die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um eine Nachricht in eine Warteschlange lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.Peek%2A> Methode. Es ist kein Transaktionskontext zugewiesen, die mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.Peek%2A>. Da <xref:System.Messaging.MessageQueue.Peek%2A> nicht entfernt werden alle Nachrichten in der Warteschlange, gibt es keine durch einen Aufruf von Rollback <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Verwenden Sie einen Aufruf von <xref:System.Messaging.MessageQueue.Receive%2A> Wenn für den aktuellen Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft akzeptabel ist. Der Thread wird für den angegebenen Zeitraum ist oder auf unbestimmte Zeit blockiert, wenn Sie den-Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter. Wenn die anwendungsverarbeitung ohne Wartezeiten für eine Nachricht fortgesetzt werden soll, sollten Sie mit der asynchronen Methode, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig. Möglicherweise ist <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht threadsicher.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Empfängt eine Meldung mit der angegebenen Korrelations-ID.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID (aus einer nicht transaktionalen Warteschlange) und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen Korrelations-ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der nicht transaktionale Warteschlange, die auf die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Wenn keine Nachricht gefunden wird, entspricht die `correlationID` -Parameter wird eine Ausnahme ausgelöst. Andernfalls wird die Nachricht aus der Warteschlange entfernt und an die Anwendung zurückgegeben.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht gesendet wird, in der Warteschlange zugeordnete Antwort, Bericht oder Bestätigung von Nachrichten zu verknüpfen.  
  
 Zwei andere Methoden können Sie zum Empfangen von Nachrichten aus einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode ruft eine Meldung mit dem angegebenen eindeutigen Bezeichners ab.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht, die eine Bestellung in und aus einer Warteschlange enthält. Eine positive Bestätigung sie ausdrücklich angefordert, wenn die ursprüngliche Nachricht erreicht wurde oder wird aus der Warteschlange abgerufen.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="correlationId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID (aus einer transaktionalen Warteschlange) und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen Korrelations-ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der transaktionalen Warteschlange verweist die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Wenn keine Nachricht gefunden wird, entspricht die `correlationID` -Parameter wird eine Ausnahme ausgelöst. Andernfalls ist die Nachricht aus der Warteschlange entfernt und an die Anwendung mithilfe von definierten internen Transaktionskontext zurückgegeben der `transaction` Parameter.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde der empfangenen Nachricht in die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht gesendet wird, in der Warteschlange zugeordnete Antwort, Bericht oder Bestätigung von Nachrichten zu verknüpfen.  
  
 Zwei andere Methoden können Sie zum Empfangen von Nachrichten aus einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode dient zum Abrufen einer Nachricht, indem Sie einen eindeutigen Bezeichner angeben.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen, die mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nicht entfernt werden alle Nachrichten in der Warteschlange, gäbe es nichts zu berechnen, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="correlationId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Warteschlange ist nicht transaktional.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen Korrelations-ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Warteschlange, auf die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Wenn keine Nachricht gefunden wird, entspricht die `correlationID` -Parameter wird eine Ausnahme ausgelöst. Die Nachricht ist, andernfalls aus der Warteschlange entfernt und an die Anwendung mithilfe von definierten Transaktionskontext zurückgegeben, die `transactionType` Parameter.  
  
 Geben Sie `Automatic` für die `transactionType` -Parameters, wenn es bereits ein externer Transaktionskontext ist an den Thread angefügt, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` sollten Sie die Nachricht als eine interne Transaktion empfangen. Sie können angeben, `None` sollten Sie eine Nachricht aus einer transaktionalen Warteschlange außerhalb eines Transaktionskontexts zu empfangen.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht aus einer transaktionalen Warteschlange zu empfangen, würde der empfangenen Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht gesendet wird, in der Warteschlange zugeordnete Antwort, Bericht oder Bestätigung von Nachrichten zu verknüpfen.  
  
 Zwei andere Methoden können Sie zum Empfangen von Nachrichten aus einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode dient zum Abrufen einer Nachricht, indem Sie einen eindeutigen Bezeichner angeben.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen, die mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nicht entfernt werden alle Nachrichten in der Warteschlange, gäbe es nichts zu berechnen, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="correlationId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID (aus einer nicht transaktionalen Warteschlange) und wartet, bis eine Meldung mit der angegebenen Korrelations-ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der nicht transaktionale Warteschlange, die auf die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Diese Methode gibt sofort zurück, wenn die Nachricht mit der Korrelations-ID, wird angegeben die `correlationId` Parameter ist in der Warteschlange. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn Sie eine neue Nachricht nicht vor Ablauf des Timeouts, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` -Parameter gibt keinen die Gesamtausführungszeit für diese Methode. Stattdessen gibt es die Wartezeit für eine neue Nachricht in der Warteschlange eingehen. Jedes Mal eine neue Nachricht eingeht, überprüft diese Methode die <xref:System.Messaging.Message.CorrelationId%2A> der neuen Nachricht um festzustellen, ob er entspricht der `correlationId` Parameter. Wenn dies nicht der Fall, diese Methode den Timeout-Zeitraum beginnt, und wartet auf das Eintreffen einer neuen Meldung. Daher Wenn neue Nachrichten innerhalb des Timeoutzeitraums eingehen weiterhin, ist es möglich, dass diese Methode, um weiterhin dauerhaft ausgeführt, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen, oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht der `correlationId` Parameter.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht gesendet wird, in der Warteschlange zugeordnete Antwort, Bericht oder Bestätigung von Nachrichten zu verknüpfen.  
  
 Zwei andere Methoden können Sie zum Empfangen von Nachrichten aus einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode dient zum Abrufen einer Nachricht, indem Sie einen eindeutigen Bezeichner angeben.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Meldung mit der angegebenen <paramref name="correlationId" /> ist nicht in der Warteschlange vorhanden und nicht vor Ablauf des Timeouts eingegangen.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID (aus einer transaktionalen Warteschlange) und wartet, bis eine Meldung mit der angegebenen Korrelations-ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der transaktionalen Warteschlange verweist die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Diese Methode gibt sofort zurück, wenn die Nachricht mit der Korrelations-ID, wird angegeben die `correlationId` Parameter ist in der Warteschlange, die mithilfe von definierten internen Transaktionskontexts die `transaction` Parameter. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn Sie eine neue Nachricht nicht vor Ablauf des Timeouts, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` -Parameter gibt keinen die Gesamtausführungszeit für diese Methode. Stattdessen gibt es die Wartezeit für eine neue Nachricht in der Warteschlange eingehen. Jedes Mal eine neue Nachricht eingeht, überprüft diese Methode die <xref:System.Messaging.Message.CorrelationId%2A> der neuen Nachricht um festzustellen, ob er entspricht der `correlationId` Parameter. Wenn dies nicht der Fall, diese Methode den Timeout-Zeitraum beginnt, und wartet auf das Eintreffen einer neuen Meldung. Daher Wenn neue Nachrichten innerhalb des Timeoutzeitraums eingehen weiterhin, ist es möglich, dass diese Methode, um weiterhin dauerhaft ausgeführt, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen, oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht der `correlationId` Parameter.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde der empfangenen Nachricht in die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht gesendet wird, in der Warteschlange zugeordnete Antwort, Bericht oder Bestätigung von Nachrichten zu verknüpfen.  
  
 Zwei andere Methoden können Sie zum Empfangen von Nachrichten aus einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode dient zum Abrufen einer Nachricht, indem Sie einen eindeutigen Bezeichner angeben.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen, die mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nicht entfernt werden alle Nachrichten in der Warteschlange, gäbe es nichts zu berechnen, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Meldung mit der angegebenen <paramref name="correlationId" /> ist nicht in der Warteschlange vorhanden und nicht vor Ablauf des Timeouts eingegangen.  
  
- oder - 
Die Warteschlange ist nicht transaktional.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID und wartet, bis eine Meldung mit der angegebenen Korrelations-ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Warteschlange, auf die <xref:System.Messaging.MessageQueue> für eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht dem angegebenen `correlationId` Parameter. Diese Methode gibt sofort zurück, wenn die Nachricht mit der Korrelations-ID, wird angegeben die `correlationId` Parameter ist in der Warteschlange, die mithilfe von definierten Transaktionskontexts der `transactionType` Parameter. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn Sie eine neue Nachricht nicht vor Ablauf des Timeouts, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` -Parameter gibt keinen die Gesamtausführungszeit für diese Methode. Stattdessen gibt es die Wartezeit für eine neue Nachricht in der Warteschlange eingehen. Jedes Mal eine neue Nachricht eingeht, überprüft diese Methode die <xref:System.Messaging.Message.CorrelationId%2A> der neuen Nachricht um festzustellen, ob er entspricht der `correlationId` Parameter. Wenn dies nicht der Fall, diese Methode den Timeout-Zeitraum beginnt, und wartet auf das Eintreffen einer neuen Meldung. Daher Wenn neue Nachrichten innerhalb des Timeoutzeitraums eingehen weiterhin, ist es möglich, dass diese Methode, um weiterhin dauerhaft ausgeführt, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen, oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.CorrelationId%2A> entspricht der `correlationId` Parameter. Geben Sie `Automatic` für die `transactionType` -Parameters, wenn es bereits ein externer Transaktionskontext ist an den Thread angefügt, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` sollten Sie die Nachricht als eine interne Transaktion empfangen. Sie können angeben, `None` sollten Sie eine Nachricht aus einer transaktionalen Warteschlange außerhalb eines Transaktionskontexts zu empfangen.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht aus einer transaktionalen Warteschlange zu empfangen, würde der empfangenen Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A> Eigenschaft wird verwendet, um eine Nachricht gesendet wird, in der Warteschlange zugeordnete Antwort, Bericht oder Bestätigung von Nachrichten zu verknüpfen.  
  
 Zwei andere Methoden können Sie zum Empfangen von Nachrichten aus einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Methode dient zum Abrufen einer Nachricht, indem Sie einen eindeutigen Bezeichner angeben.  
  
 Um eine Nachricht mit einer angegebenen Korrelations-ID lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen, die mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nicht entfernt werden alle Nachrichten in der Warteschlange, gäbe es nichts zu berechnen, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="correlationId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Meldung mit der angegebenen <paramref name="correlationId" /> ist nicht in der Warteschlange vorhanden und nicht vor Ablauf des Timeouts eingegangen.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Empfängt die Meldung mit der angegebenen ID und entfernt sie aus der Warteschlange.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID aus einer nicht transaktionalen Warteschlange und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einer bekannten ID und entfernt sie aus der Warteschlange. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist eindeutig für die Message Queuing-Organisation, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter.  
  
 Zwei andere Methoden können Sie zum Empfangen von Nachrichten aus einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung, einen Bericht oder einer Anwendung generierten antwortmeldungen-Meldung, die als Ergebnis eine an die Warteschlange gesendete Nachricht erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="id" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID (aus einer transaktionalen Warteschlange) und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einer bekannten ID und entfernt sie aus der Warteschlange, mithilfe von definierten internen Transaktionskontext die `transaction` Parameter. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist eindeutig für die Message Queuing-Organisation, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde der empfangenen Nachricht in die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Zwei andere Methoden können Sie zum Empfangen von Nachrichten aus einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung, einen Bericht oder einer Anwendung generierten antwortmeldungen-Meldung, die als Ergebnis eine an die Warteschlange gesendete Nachricht erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen, die mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nicht entfernt werden alle Nachrichten in der Warteschlange, gäbe es nichts zu berechnen, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="id" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Warteschlange ist nicht transaktional.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einer bekannten ID und entfernt sie aus der Warteschlange. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist. Die Nachricht ist, andernfalls aus der Warteschlange entfernt und an die Anwendung mithilfe von definierten Transaktionskontext zurückgegeben, die `transactionType` Parameter.  
  
 Geben Sie `Automatic` für die `transactionType` -Parameters, wenn es bereits ein externer Transaktionskontext ist an den Thread angefügt, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` sollten Sie die Nachricht als eine interne Transaktion empfangen. Sie können angeben, `None` sollten Sie eine Nachricht aus einer transaktionalen Warteschlange außerhalb eines Transaktionskontexts zu empfangen.  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist eindeutig für die Message Queuing-Organisation, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter. Wenn die Nachricht mit dem angegebenen Bezeichner in einer Warteschlange als dem zugeordneten <xref:System.Messaging.MessageQueue> Instanz, die Nachricht wird nicht gefunden werden.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht aus einer transaktionalen Warteschlange zu empfangen, würde der empfangenen Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Zwei andere Methoden können Sie zum Empfangen von Nachrichten aus einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung, einen Bericht oder einer Anwendung generierten antwortmeldungen-Meldung, die als Ergebnis eine an die Warteschlange gesendete Nachricht erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen, die mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nicht entfernt werden alle Nachrichten in der Warteschlange, gäbe es nichts zu berechnen, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="id" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID (aus einer nicht transaktionalen Warteschlange) und wartet, bis eine Meldung mit der angegebenen ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einer bekannten ID und entfernt sie aus der Warteschlange. Diese Methode gibt sofort zurück, wenn die Meldung mit der ID, wird angegeben die `id` Parameter ist in der Warteschlange. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn Sie eine neue Nachricht nicht vor Ablauf des Timeouts, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` -Parameter gibt keinen die Gesamtausführungszeit für diese Methode. Stattdessen gibt es die Wartezeit für eine neue Nachricht in der Warteschlange eingehen. Jedes Mal eine neue Nachricht eingeht, überprüft diese Methode die <xref:System.Messaging.Message.Id%2A> der neuen Nachricht um festzustellen, ob er entspricht der `id` Parameter. Wenn dies nicht der Fall, diese Methode den Timeout-Zeitraum beginnt, und wartet auf das Eintreffen einer neuen Meldung. Daher Wenn neue Nachrichten innerhalb des Timeoutzeitraums eingehen weiterhin, ist es möglich, dass diese Methode, um weiterhin dauerhaft ausgeführt, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen, oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.Id%2A> entspricht der `id` Parameter.  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist eindeutig für die Message Queuing-Organisation, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter.  
  
 Verwenden Sie diese Überladung der <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> wann ist das zulässig, für den aktuellen Thread blockiert werden, solange neue Nachrichten weiterhin in der Warteschlange eingehen, innerhalb des Timeoutzeitraums gemäß der `timeout` Parameter. Der Thread blockiert werden für mindestens dem angegebenen Zeitraum ist oder auf unbestimmte Zeit, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter, oder wenn neue Nachrichten weiterhin in der Warteschlange eingehen, innerhalb des Timeoutzeitraums gemäß der `timeout` der Parameter.  
  
 Zwei andere Methoden können Sie zum Empfangen von Nachrichten aus einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung, einen Bericht oder einer Anwendung generierten antwortmeldungen-Meldung, die als Ergebnis eine an die Warteschlange gesendete Nachricht erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung mit der angegebenen <paramref name="id" /> in die Warteschlange eingegangen.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID (aus einer transaktionalen Warteschlange) und wartet, bis eine Meldung mit der angegebenen ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einer bekannten ID und entfernt sie aus der Warteschlange, mithilfe von definierten internen Transaktionskontext die `transaction` Parameter. Diese Methode gibt sofort zurück, wenn die Meldung mit der ID, wird angegeben die `id` Parameter ist in der Warteschlange. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn Sie eine neue Nachricht nicht vor Ablauf des Timeouts, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` -Parameter gibt keinen die Gesamtausführungszeit für diese Methode. Stattdessen gibt es die Wartezeit für eine neue Nachricht in der Warteschlange eingehen. Jedes Mal eine neue Nachricht eingeht, überprüft diese Methode die <xref:System.Messaging.Message.Id%2A> der neuen Nachricht um festzustellen, ob er entspricht der `id` Parameter. Wenn dies nicht der Fall, diese Methode den Timeout-Zeitraum beginnt, und wartet auf das Eintreffen einer neuen Meldung. Daher Wenn neue Nachrichten innerhalb des Timeoutzeitraums eingehen weiterhin, ist es möglich, dass diese Methode, um weiterhin dauerhaft ausgeführt, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen, oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.Id%2A> entspricht der `id` Parameter.  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist eindeutig für die Message Queuing-Organisation, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter.  
  
 Verwenden Sie diese Überladung der <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> wann ist das zulässig, für den aktuellen Thread blockiert werden, solange neue Nachrichten weiterhin in der Warteschlange eingehen, innerhalb des Timeoutzeitraums gemäß der `timeout` Parameter. Der Thread blockiert werden für mindestens dem angegebenen Zeitraum ist oder auf unbestimmte Zeit, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter, oder wenn neue Nachrichten weiterhin in der Warteschlange eingehen, innerhalb des Timeoutzeitraums gemäß der `timeout` der Parameter.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde der empfangenen Nachricht in die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Zwei andere Methoden können Sie zum Empfangen von Nachrichten aus einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung, einen Bericht oder einer Anwendung generierten antwortmeldungen-Meldung, die als Ergebnis eine an die Warteschlange gesendete Nachricht erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt immer die erste Meldung in der Warteschlange, nachfolgende Aufrufe der Methode die gleiche Nachricht zurück, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen, die mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nicht entfernt werden alle Nachrichten in der Warteschlange, gäbe es nichts zu berechnen, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung mit der angegebenen <paramref name="id" /> in die Warteschlange eingegangen.  
  
- oder - 
Die Warteschlange ist nicht transaktional.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID und wartet, bis eine Meldung mit der angegebenen ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einer bekannten ID und entfernt sie aus der Warteschlange. Diese Methode gibt sofort zurück, wenn die Meldung mit der ID, wird angegeben die `id` Parameter ist in der Warteschlange, die mithilfe von definierten Transaktionskontexts der `transactionType` Parameter. Andernfalls wartet die Methode den angegebenen Zeitraum für eine neue Nachricht eintrifft. Wenn Sie eine neue Nachricht nicht vor Ablauf des Timeouts, wird eine Ausnahme ausgelöst.  
  
 Die `timeout` -Parameter gibt keinen die Gesamtausführungszeit für diese Methode. Stattdessen gibt es die Wartezeit für eine neue Nachricht in der Warteschlange eingehen. Jedes Mal eine neue Nachricht eingeht, überprüft diese Methode die <xref:System.Messaging.Message.Id%2A> der neuen Nachricht um festzustellen, ob er entspricht der `id` Parameter. Wenn dies nicht der Fall, diese Methode den Timeout-Zeitraum beginnt, und wartet auf das Eintreffen einer neuen Meldung. Daher Wenn neue Nachrichten innerhalb des Timeoutzeitraums eingehen weiterhin, ist es möglich, dass diese Methode, um weiterhin dauerhaft ausgeführt, bis das Timeoutintervall abläuft, ohne alle neuen Nachrichten eintreffen, oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.Id%2A> entspricht der `id` Parameter.  
  
 Geben Sie `Automatic` für die `transactionType` -Parameters, wenn es bereits ein externer Transaktionskontext ist an den Thread angefügt, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` sollten Sie die Nachricht als eine interne Transaktion empfangen. Sie können angeben, `None` sollten Sie eine Nachricht aus einer transaktionalen Warteschlange außerhalb eines Transaktionskontexts zu empfangen.  
  
 Die <xref:System.Messaging.Message.Id%2A> Eigenschaft einer Nachricht ist eindeutig für die Message Queuing-Organisation, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `id` Parameter. Wenn die Nachricht mit dem angegebenen Bezeichner in einer Warteschlange als dem zugeordneten <xref:System.Messaging.MessageQueue> Instanz, die Nachricht wird nicht gefunden werden.  
  
 Verwenden Sie diese Überladung der <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> wann ist das zulässig, für den aktuellen Thread blockiert werden, solange neue Nachrichten weiterhin in der Warteschlange eingehen, innerhalb des Timeoutzeitraums gemäß der `timeout` Parameter. Der Thread blockiert werden für mindestens dem angegebenen Zeitraum ist oder auf unbestimmte Zeit, wenn Sie den Wert angegeben <xref:System.Messaging.MessageQueue.InfiniteTimeout> für die `timeout` Parameter, oder wenn neue Nachrichten weiterhin in der Warteschlange eingehen, innerhalb des Timeoutzeitraums gemäß der `timeout` der Parameter.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht aus einer transaktionalen Warteschlange zu empfangen, würde der empfangenen Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Zwei andere Methoden können Sie zum Empfangen von Nachrichten aus einer Warteschlange. Die <xref:System.Messaging.MessageQueue.Receive%2A> Methode gibt die erste Meldung in der Warteschlange und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> Methode dient zum Abrufen einer Bestätigung, einen Bericht oder einer Anwendung generierten antwortmeldungen-Meldung, die als Ergebnis eine an die Warteschlange gesendete Nachricht erstellt wurde.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Methode gibt die erste Meldung immer in der Warteschlange, sodass nachfolgende Aufrufe der Methode die gleiche Nachricht zurückgeben, es sei denn, ein Nachricht mit höherer Priorität in der Warteschlange eingeht. Es ist kein Transaktionskontext zugewiesen, die mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Da <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nicht entfernt werden alle Nachrichten in der Warteschlange, gäbe es nichts zu berechnen, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung mit der angegebenen <paramref name="id" /> in die Warteschlange eingegangen.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Eingeführt in MSMQ 3.0. Empfängt eine bestimmte Meldung aus der Warteschlange. Die Meldung kann anhand eines Suchbezeichners oder anhand der Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der zu empfangenden Meldung.</param>
        <summary>Eingeführt in MSMQ 3.0. Empfängt die Meldung, die dem angegebenen Suchbezeichner in einer nicht transaktionalen Warteschlange entspricht.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.LookupId" />-Eigenschaft dem übergebenen <paramref name="lookupId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einer bekannten Nachschlage-ID und entfernt sie aus der Warteschlange. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft einer Nachricht ist für die Warteschlange eindeutig, in dem die Meldung befindet, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `lookupId` Parameter.  
  
 Um eine Nachricht mit einer angegebenen Nachschlage-ID lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> Methode.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="lookupId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">Einer der <see cref="T:System.Messaging.MessageLookupAction" />-Werte, der angibt, wie die Meldung in der Warteschlange gelesen wird. Geben Sie eine der folgenden Optionen an: 
 <see langword="MessageLookupAction.Current" />: Empfängt die durch <paramref name="lookupId" /> angegebene Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.Next" />: Empfängt die Meldung nach der durch <paramref name="lookupId" /> angegebenen Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.Previous" />: Empfängt die Meldung vor der durch <paramref name="lookupId" /> angegebenen Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.First" />: Empfängt die erste Meldung aus der Warteschlange und entfernt sie aus dieser. Der <paramref name="lookupId" />-Parameter muss auf 0 festgelegt werden.  
  
 <see langword="MessageLookupAction.Last" />: Empfängt die letzte Meldung aus der Warteschlange und entfernt sie aus dieser. Der <paramref name="lookupId" />-Parameter muss auf 0 festgelegt werden.</param>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der zu empfangenden Meldung, andernfalls 0 (null). 0 wird beim Zugreifen auf die erste oder letzte Meldung in die Warteschlange verwendet.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Eingeführt in MSMQ 3.0. Empfängt eine bestimmte Meldung aus einer transaktionalen Warteschlange. Die Meldung kann anhand eines Suchbezeichners oder anhand der Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
        <returns>Die durch den übergebenen <paramref name="lookupId" />-Parameter und <paramref name="action" />-Parameter angegebene <see cref="T:System.Messaging.Message" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einer bekannten Nachschlage-ID und entfernt sie aus der Warteschlange, mithilfe von definierten Transaktionskontext der `transaction` Parameter. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft einer Nachricht ist für die Warteschlange eindeutig, in dem die Meldung befindet, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `lookupId` Parameter.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, würde der empfangenen Nachricht in die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> Methode. Es ist kein Transaktionskontext zugewiesen, die mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Da <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> nicht entfernt werden alle Nachrichten aus der Warteschlange, gäbe es nichts zu berechnen, wenn die Transaktion abgebrochen wurden.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="lookupId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.  
  
- oder - 
Die Warteschlange ist nicht transaktional.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="action" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageLookupAction" />-Member.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">Einer der <see cref="T:System.Messaging.MessageLookupAction" />-Werte, der angibt, wie die Meldung in der Warteschlange gelesen wird. Geben Sie eine der folgenden Optionen an: 
 <see langword="MessageLookupAction.Current" />: Empfängt die durch <paramref name="lookupId" /> angegebene Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.Next" />: Empfängt die Meldung nach der durch <paramref name="lookupId" /> angegebenen Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.Previous" />: Empfängt die Meldung vor der durch <paramref name="lookupId" /> angegebenen Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.First" />: Empfängt die erste Meldung aus der Warteschlange und entfernt sie aus dieser. Der <paramref name="lookupId" />-Parameter muss auf 0 festgelegt werden.  
  
 <see langword="MessageLookupAction.Last" />: Empfängt die letzte Meldung aus der Warteschlange und entfernt sie aus dieser. Der <paramref name="lookupId" />-Parameter muss auf 0 festgelegt werden.</param>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der zu empfangenden Meldung, andernfalls 0 (null). 0 wird beim Zugreifen auf die erste oder letzte Meldung in die Warteschlange verwendet.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Eingeführt in MSMQ 3.0. Empfängt unter Verwendung des angegebenen Transaktionskontexts eine bestimmte Meldung aus der Warteschlange. Die Meldung kann anhand eines Suchbezeichners oder anhand der Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
        <returns>Die durch den übergebenen <paramref name="action" />-Parameter und <paramref name="lookupId" />-Parameter angegebene <see cref="T:System.Messaging.Message" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen einer Nachricht mit einer bekannten Nachschlage-ID und entfernt sie aus der Warteschlange, mithilfe von definierten Transaktionskontext der `transactionType` Parameter. Diese Methode löst eine Ausnahme sofort aus, wenn die Nachricht nicht in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.Message.LookupId%2A> Eigenschaft einer Nachricht ist für die Warteschlange eindeutig, in dem die Meldung befindet, daher kann höchstens eine Meldung in der Warteschlange entsprechen den angegebenen `lookupId` Parameter.  
  
 Um eine Nachricht mit einem angegebenen Bezeichner lesen, ohne sie aus der Warteschlange entfernen, verwenden die <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> Methode. Es ist kein Transaktionskontext zugewiesen, die mit einer Meldung zurückgegeben, die durch einen Aufruf von <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Da <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> nicht entfernt werden alle Nachrichten aus der Warteschlange, gäbe es nichts zu berechnen, wenn die Transaktion abgebrochen wurden.  
  
 Geben Sie `Automatic` für die `transactionType` -Parameters, wenn es bereits ein externer Transaktionskontext ist an den Thread angefügt, die Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` sollten Sie die Nachricht als eine interne Transaktion empfangen. Sie können angeben, `None` sollten Sie eine Nachricht aus einer transaktionalen Warteschlange außerhalb eines Transaktionskontexts zu empfangen.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht aus einer transaktionalen Warteschlange zu empfangen, würde der empfangenen Nachricht an die Warteschlange zurückgegeben werden, wenn die Transaktion abgebrochen wird. Die Nachricht wird nicht dauerhaft aus der Warteschlange entfernt, bis die Transaktion ein Commit ausgeführt wird.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="lookupId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="action" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageLookupAction" />-Member.  
  
- oder - 
Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine Meldung aus der Warteschlange entfernt wurde. Dieses Ereignis wird von dem asynchronen <see cref="M:System.Messaging.MessageQueue.BeginReceive" />-Vorgang ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> wird verwendet, bei der asynchronen Verarbeitung zum Auslösen der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis aus, wenn eine Nachricht in der Warteschlange verfügbar ist.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> Dient zum Abschließen des Vorgangs, der durch einen Aufruf initiiert <xref:System.Messaging.MessageQueue.BeginReceive%2A> und zum Empfangen der Nachricht bei der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis wird ausgelöst.  
  
 Beim Erstellen eines <xref:System.Messaging.ReceiveCompletedEventHandler>-Delegaten bestimmen Sie die Methode für die Ereignisbehandlung. Um dem Ereignishandler das Ereignis zuzuordnen, fügen Sie dem Ereignis eine Instanz des Delegaten hinzu. Der Ereignishandler wird bei jedem Eintreten des Ereignisses aufgerufen, sofern der Delegat nicht entfernt wird. Weitere Informationen zu den Ereignishandlerdelegaten, finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Ereignishandler namens `MyReceiveCompleted`, fügt es der <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignishandlerdelegaten, und ruft <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert einen asynchronen receive-Methode in der Warteschlange, die sich unter dem Pfad befindet ". \myQueue". Wenn eine <xref:System.Messaging.MessageQueue.ReceiveCompleted> -Ereignis ausgelöst wird, wird im Beispiel empfängt die Nachricht und schreibt Text auf dem Bildschirm. Das Beispiel ruft dann <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut aus, um eine neue starten asynchrone receive-Methode.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktualisiert die von der <see cref="T:System.Messaging.MessageQueue" /> dargestellten Eigenschaften, sodass sie den aktuellen Zustand der Ressource wiedergeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> synchronisiert die Eigenschaften einer <xref:System.Messaging.MessageQueue> mit der zugehörigen Message Queuing-Serverressource. Wenn eine Eigenschaft, z. B. <xref:System.Messaging.MessageQueue.Label%2A> oder <xref:System.Messaging.MessageQueue.Category%2A>, auf dem Server geändert hat, die seit dem Zeitpunkt der <xref:System.Messaging.MessageQueue> erstellt wurde, <xref:System.Messaging.MessageQueue.Refresh%2A> Updates der <xref:System.Messaging.MessageQueue> mit den neuen Informationen.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die Berechtigungsliste auf die Standardwerte des Betriebssystems zurück. Entfernt sämtliche Berechtigungen für Warteschlangen, die an die Standardliste angefügt wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufruf <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, Sie die Berechtigungsliste auf seine Standardwerte zurück. Im Allgemeinen wird dieser Ersteller der Warteschlange alle Berechtigungen, und gibt der Gruppe "Jeder" die folgenden Rechte:  
  
-   Rufen Sie die Eigenschaften der Warteschlange.  
  
-   Rufen Sie die Berechtigungen für Warteschlange.  
  
-   Schreiben Sie in der Warteschlange.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet ein Objekt an eine Warteschlange.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <summary>Sendet ein Objekt an die nicht transaktionale Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter, um die Warteschlange, auf die <xref:System.Messaging.MessageQueue>. Das Objekt, das Sie an die Warteschlange senden, kann sein ein <xref:System.Messaging.Message> oder ein verwaltetes Objekt. Wenn Sie jedes beliebige Objekt außer senden eine <xref:System.Messaging.Message>, das Objekt wird serialisiert und in den Text der Nachricht eingefügt.  
  
 Wenn Sie diese Überladung verwenden, um eine Nachricht an eine transaktionale Warteschlange zu senden, wird die Nachricht an die Warteschlange für unzustellbare Nachrichten gesendet werden. Wenn Sie möchten die Nachricht als Teil einer Transaktion, die anderen Nachrichten enthält, verwenden Sie eine Überladung mit einem <xref:System.Messaging.MessageQueueTransaction> oder <xref:System.Messaging.MessageQueueTransactionType> als Parameter.  
  
 Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt nicht für jedes Objekt ein <xref:System.Messaging.Message>. Wenn Sie z. B. eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange gesendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einer Nachrichtenwarteschlange her und sendet eine Nachricht an die Warteschlange.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 Im folgenden Codebeispiel sendet eine anwendungsdefinierte `Order` Klasse an eine Warteschlange, und klicken Sie dann aus dieser Warteschlange eine Nachricht empfangen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Sendet ein Objekt an die transaktionale Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter an die transaktionale Warteschlange, die auf die verwiesen wird durch die <xref:System.Messaging.MessageQueue>, mithilfe von definierten Kontext für eine interne Transaktion die `transaction` Parameter. Das Objekt, das Sie an die Warteschlange senden, kann sein ein <xref:System.Messaging.Message> oder ein verwaltetes Objekt. Wenn Sie jedes beliebige Objekt außer senden eine <xref:System.Messaging.Message>, das Objekt wird serialisiert und in den Text der Nachricht eingefügt.  
  
 Wenn Sie diese Überladung, zum Senden einer Nachricht an eine nicht transaktionale Warteschlange verwenden, kann die Nachricht an die Warteschlange für unzustellbare Nachrichten gesendet werden, ohne eine Ausnahme auszulösen.  
  
 Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt nicht für jedes Objekt ein <xref:System.Messaging.Message>. Wenn Sie z. B. eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange gesendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 <xref:System.Messaging.MessageQueueTransaction> Apartmentthreading fähig ist, wenn der Apartmentzustand wurde also `STA`, können keine Transaktion in mehreren Threads. Visual Basic legt den Status der Hauptthread die `STA`, sodass Sie anwenden, müssen die <xref:System.MTAThreadAttribute> in die `Main` Unterroutine. Andernfalls wird durch das Senden einer Transaktionsmeldung mithilfe eines anderen Threads eine <xref:System.Messaging.MessageQueueException>-Ausnahme ausgelöst. Sie wenden die <xref:System.MTAThreadAttribute> mit dem folgenden Fragment.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Zeichenfolge an eine transaktionale Warteschlange gesendet, und klicken Sie dann aus dieser Warteschlange eine Nachricht empfangen.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
- oder - 
Die Message Queuing-Anwendung hat eine falsche Verwendung der Transaktion gemeldet.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Sendet ein Objekt an die Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter, um die Warteschlange, auf die <xref:System.Messaging.MessageQueue>, mithilfe von definierten Transaktionskontext der `transactionType` Parameter. Geben Sie `Automatic` für die `transactionType` -Parameters, wenn es bereits ein externer Transaktionskontext ist an den Thread angefügt, die Sie zum Senden der Nachricht verwenden möchten. Geben Sie `Single` sollten Sie die Nachricht als eine interne Transaktion zu senden. Sie können angeben, `None` Wenn eine transaktionale Meldung an einen nicht transaktionalen Thread gesendet werden sollen.  
  
 Das Objekt, das Sie an die Warteschlange senden, kann sein ein <xref:System.Messaging.Message> oder ein verwaltetes Objekt. Wenn Sie jedes beliebige Objekt außer senden eine <xref:System.Messaging.Message>, das Objekt wird serialisiert und in den Text der Nachricht eingefügt.  
  
 Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt nicht für jedes Objekt ein <xref:System.Messaging.Message>. Wenn Sie z. B. eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange gesendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <param name="label">Die Meldungsbezeichnung.</param>
        <summary>Sendet ein Objekt an die nicht transaktionale Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist, und gibt eine Bezeichnung für die Meldung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter, um die Warteschlange, auf die <xref:System.Messaging.MessageQueue>. Mit dieser Überladung können Sie die Bezeichnung Zeichenfolge angeben, die die Nachricht identifiziert. Das Objekt, das Sie an die Warteschlange senden, kann sein ein <xref:System.Messaging.Message>, eine Struktur, ein Objekt oder ein verwaltetes Objekt. Wenn Sie jedes beliebige Objekt außer senden eine <xref:System.Messaging.Message>, das Objekt wird serialisiert und in den Text der Nachricht eingefügt.  
  
 Die nachrichtenbezeichnung unterscheidet sich von der Bezeichnung der Warteschlange, aber beide sind abhängig von der Anwendung und haben keine Bedeutung für Message Queuing.  
  
 Wenn Sie diese Überladung verwenden, um eine Nachricht an eine transaktionale Warteschlange zu senden, wird die Nachricht an die Warteschlange für unzustellbare Nachrichten gesendet werden. Wenn Sie möchten die Nachricht als Teil einer Transaktion, die anderen Nachrichten enthält, verwenden Sie eine Überladung mit einem <xref:System.Messaging.MessageQueueTransaction> oder <xref:System.Messaging.MessageQueueTransactionType> als Parameter.  
  
 Die <xref:System.Messaging.MessageQueue.Path%2A> -Eigenschaft für diese <xref:System.Messaging.MessageQueue> Instanz muss angegeben werden, bevor Sie die Nachricht zu senden. Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt nicht für jedes Objekt ein <xref:System.Messaging.Message>. Wenn Sie z. B. eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange gesendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="label" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <param name="label">Die Meldungsbezeichnung.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Sendet ein Objekt an die transaktionale Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist, und gibt eine Bezeichnung für die Meldung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter an die transaktionale Warteschlange, die auf die verwiesen wird durch die <xref:System.Messaging.MessageQueue>, mithilfe von definierten Kontext für eine interne Transaktion die `transaction` Parameter. Mit dieser Überladung können Sie die Bezeichnung Zeichenfolge angeben, die die Nachricht identifiziert. Das Objekt, das Sie an die Warteschlange senden, kann sein ein <xref:System.Messaging.Message>, eine Struktur, ein Objekt oder ein verwaltetes Objekt. Wenn Sie jedes beliebige Objekt außer senden eine <xref:System.Messaging.Message>, das Objekt wird serialisiert und in den Text der Nachricht eingefügt.  
  
 Die nachrichtenbezeichnung unterscheidet sich von der Bezeichnung der Warteschlange, aber beide sind abhängig von der Anwendung und haben keine Bedeutung für Message Queuing.  
  
 Wenn Sie diese Überladung, zum Senden einer Nachricht an eine nicht transaktionale Warteschlange verwenden, kann die Nachricht an die Warteschlange für unzustellbare Nachrichten gesendet werden, ohne eine Ausnahme auszulösen.  
  
 Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt nicht für jedes Objekt ein <xref:System.Messaging.Message>. Wenn Sie z. B. eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange gesendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft  
  
 <xref:System.Messaging.MessageQueueTransaction> Apartmentthreading fähig ist, wenn der Apartmentzustand wurde also `STA`, können keine Transaktion in mehreren Threads. Visual Basic legt den Status der Hauptthread die `STA`, sodass Sie anwenden, müssen die <xref:System.MTAThreadAttribute> in die `Main` Unterroutine. Andernfalls wird durch das Senden einer Transaktionsmeldung mithilfe eines anderen Threads eine <xref:System.Messaging.MessageQueueException>-Ausnahme ausgelöst. Sie wenden die <xref:System.MTAThreadAttribute> mit dem folgenden Fragment.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="label" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
- oder - 
Die Message Queuing-Anwendung hat eine falsche Verwendung der Transaktion gemeldet.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <param name="label">Die Meldungsbezeichnung.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Sendet ein Objekt an die Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist, und gibt eine Bezeichnung für die Meldung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht zu senden, enthält die `obj` Parameter, um die Warteschlange, auf die <xref:System.Messaging.MessageQueue>, mithilfe von definierten Transaktionskontext der `transactionType` Parameter. Geben Sie `Automatic` für die `transactionType` -Parameters, wenn es bereits ein externer Transaktionskontext ist an den Thread angefügt, die Sie zum Senden der Nachricht verwenden möchten. Geben Sie `Single` sollten Sie die Nachricht als eine interne Transaktion zu senden. Sie können angeben, `None` Wenn eine transaktionale Meldung an einen nicht transaktionalen Thread gesendet werden sollen.  
  
 Das Objekt, das Sie an die Warteschlange senden, kann sein ein <xref:System.Messaging.Message> oder ein verwaltetes Objekt. Wenn Sie jedes beliebige Objekt außer senden eine <xref:System.Messaging.Message>, das Objekt wird serialisiert und in den Text der Nachricht eingefügt. Mit dieser Überladung können Sie die Bezeichnung Zeichenfolge angeben, die die Nachricht identifiziert.  
  
 Die nachrichtenbezeichnung unterscheidet sich von der Bezeichnung der Warteschlange, aber beide sind abhängig von der Anwendung und haben keine Bedeutung für Message Queuing.  
  
 Wenn Sie nicht Festlegen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft vor dem Aufruf <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, wird der Standardformatierer der <xref:System.Messaging.XmlMessageFormatter>.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Eigenschaft gilt nicht für jedes Objekt ein <xref:System.Messaging.Message>. Wenn Sie z. B. eine Bezeichnung oder eine Priorität mit angeben der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Member, diese Werte gelten, für jede Nachricht, die ein Objekt enthält, die nicht vom Typ <xref:System.Messaging.Message> Wenn Ihre Anwendung es an die Warteschlange gesendet. Beim Senden einer <xref:System.Messaging.Message>, legen Sie die Eigenschaftswerte für die <xref:System.Messaging.Message> haben Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, und der Meldung <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> -Eigenschaft Vorrang vor der Warteschlange <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="label" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">Die Message Queuing-Anwendung hat eine falsche Verwendung der Transaktion gemeldet.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt dem aktuellen Satz Berechtigungen hinzu. Hiermit wird festgelegt, wer Zugriff auf Eigenschaften und Meldungen in der Warteschlange erhält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">Eine <see cref="T:System.Messaging.AccessControlList" /> mit einem oder mehreren Zugriffsteuerungseinträgen, die die Vertrauensnehmer und die zu gewährenden Berechtigungen angeben.</param>
        <summary>Weist der Warteschlange anhand einer Zugriffssteuerungsliste Zugriffsrechte zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zu erteilen, verweigern oder widerrufen Rechte, indem Sie eine Auflistung von Zugriffssteuerungseinträgen Vertrauensnehmer und den Berechtigungen Informationen angeben. Dies ist z. B. verwendet, zum Gewähren von Berechtigungen für mehrere Benutzer gleichzeitig.  
  
 Der Vertrauensnehmer, die Sie angeben, wenn Sie erstellen die `ace` Parameter kann ein einzelner Benutzer, eine Gruppe von Benutzern oder ein Computer sein. Wenn der Vertrauensnehmer einer Person ist, verwenden Sie das Format `DOMAIN` \\ `user`. Sie können angeben, "." für den Vertrauensnehmer auf den lokalen Computer anzugeben.  
  
 Die Berechtigungen, die Sie über zuweisen <xref:System.Messaging.MessageQueue.SetPermissions%2A> Rechte für die vorhandene Liste hinzufügen. In der Standardeinstellung der Ersteller einer öffentlichen oder privaten Warteschlange verfügt über Vollzugriff, und der Domänengruppe "Jeder" verfügt über die Berechtigung zum Abrufen von Warteschlangeneigenschaften, Berechtigungen zu erhalten und in die Warteschlange schreiben. Beim Aufruf <xref:System.Messaging.MessageQueue.SetPermissions%2A>, die Berechtigungen für Benutzer und -Informationen an das Ende der vorhandenen Liste angefügt wird.  
  
 Das System untersucht jede <xref:System.Messaging.AccessControlEntry> nacheinander, bis eines der folgenden Ereignisse eintritt:  
  
-   Eine zugriffsverweigerung <xref:System.Messaging.AccessControlEntry> explizit verweigert keines der angeforderten über die Zugriffsrechte für einen Vertrauensnehmer aufgeführt, die im Zugriffstoken des Threads.  
  
-   Eine oder mehrere-Zugriff <xref:System.Messaging.AccessControlEntry> Elemente für Vertrauensnehmer im Zugriffstoken des Threads explizit aufgelistet alle angeforderten Zugriffsrechte gewähren.  
  
-   Alle <xref:System.Messaging.AccessControlEntry> Elemente überprüft wurden, und es ist noch mindestens ein angefordertes Zugriffsrecht, das nicht ausdrücklich in diesem Fall wird der Zugriff implizit verweigert gewährt hat,.  
  
 Beim Erstellen der `dacl` -Parameter, die Sie hinzufügen <xref:System.Messaging.AccessControlEntry> an Instanzen Ihrer <xref:System.Messaging.AccessControlList> Auflistung. Beim Erstellen jeder Zugriffssteuerungseintrag können Sie generische "oder" standard-Zugriffsrechte angeben. Die Rechte an eine Warteschlange können eine beliebige Kombination der folgenden sein:  
  
-   Löschen  
  
-   Sicherheit lesen  
  
-   Schreiben Sie die Sicherheit  
  
-   Synchronisieren  
  
-   Besitzer ändern  
  
-   Lesen  
  
-   Write  
  
-   Ausführen  
  
-   Erforderlich  
  
-   Alle  
  
-   None  
  
 Diese Rechte sind ein Satz von Bitflags, die Sie mit dem bitweisen OR-Operator kombinieren können.  
  
-   Vollzugriff  
  
-   Nachricht löschen  
  
-   Meldung  
  
-   Nachricht einsehen  
  
-   Journalnachricht empfangen  
  
-   Abrufen von Warteschlangeneigenschaften  
  
-   Festlegen von Eigenschaften  
  
-   Berechtigungen abrufen  
  
-   Festlegen von Berechtigungen  
  
-   Besitz übernehmen  
  
-   Nachricht schreiben  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">Ein <see cref="T:System.Messaging.MessageQueueAccessControlEntry" />, der einen Benutzer, einen Zugriffstyp und einen Berechtigungstyp angibt.</param>
        <summary>Weist der Warteschlange anhand eines Zugriffssteuerungseintrags Zugriffsrechte zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zu erteilen, verweigern oder widerrufen Berechtigungen mithilfe eines Zugriffssteuerungseintrags Vertrauensnehmer und Rechte an.  
  
 Der Vertrauensnehmer, die Sie angeben, wenn Sie erstellen die `ace` Parameter kann ein einzelner Benutzer, eine Gruppe von Benutzern oder ein Computer sein. Wenn der Vertrauensnehmer einer Person ist, verwenden Sie das Format `DOMAIN` \\ `user`. Sie können angeben, "." für den Vertrauensnehmer auf den lokalen Computer anzugeben.  
  
 Die Berechtigungen, die Sie über zuweisen <xref:System.Messaging.MessageQueue.SetPermissions%2A> Rechte für die vorhandene Liste hinzufügen. In der Standardeinstellung der Ersteller einer öffentlichen oder privaten Warteschlange verfügt über Vollzugriff, und der Domänengruppe "Jeder" verfügt über die Berechtigung zum Abrufen von Warteschlangeneigenschaften, Berechtigungen zu erhalten und in die Warteschlange schreiben. Beim Aufruf <xref:System.Messaging.MessageQueue.SetPermissions%2A>, die Berechtigungen für Benutzer und -Informationen an das Ende der vorhandenen Liste angefügt wird.  
  
 Das System untersucht jede <xref:System.Messaging.AccessControlEntry> nacheinander, bis eines der folgenden Ereignisse eintritt:  
  
-   Eine zugriffsverweigerung <xref:System.Messaging.AccessControlEntry> explizit verweigert keines der angeforderten über die Zugriffsrechte für einen Vertrauensnehmer aufgeführt, die im Zugriffstoken des Threads.  
  
-   Eine oder mehrere-Zugriff <xref:System.Messaging.AccessControlEntry> Elemente für Vertrauensnehmer im Zugriffstoken des Threads explizit aufgelistet alle angeforderten Zugriffsrechte gewähren.  
  
-   Alle <xref:System.Messaging.AccessControlEntry> Elemente überprüft wurden, und es ist noch mindestens ein angefordertes Zugriffsrecht, das nicht ausdrücklich in diesem Fall wird der Zugriff implizit verweigert gewährt hat,.  
  
 Die Rechte für eine Warteschlange, die Sie, in angeben der `rights` Parameter beim Erstellen Ihrer <xref:System.Messaging.MessageQueueAccessControlEntry>, kann eine beliebige Kombination der folgenden sein:  
  
-   Vollzugriff  
  
-   Nachricht löschen  
  
-   Meldung  
  
-   Nachricht einsehen  
  
-   Journalnachricht empfangen  
  
-   Abrufen von Warteschlangeneigenschaften  
  
-   Festlegen von Eigenschaften  
  
-   Berechtigungen abrufen  
  
-   Festlegen von Berechtigungen  
  
-   Besitz übernehmen  
  
-   Nachricht schreiben  
  
 Die `rights` Parameter, die Sie, im Konstruktor für angeben die `ace` -Parameter ist ein Flag, der die <xref:System.Messaging.MessageQueueAccessRights> Enumeration. Er stellt einen Satz von Bitflags, die Sie kombinieren können, mit dem bitweisen Operator oder beim Erstellen der `rights` Parameter.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">Der einzelne Benutzer, die Gruppe oder der Computer, der zusätzliche Rechte für die Warteschlange erhält.</param>
        <param name="rights">Ein <see cref="T:System.Messaging.MessageQueueAccessRights" />, das den Satz von Rechten für die Warteschlange darstellt, die Message Queuing dem übergebenen <paramref name="user" /> zuweist.</param>
        <summary>Gewährt einem Computer, einer Gruppe oder einem Benutzer die angegebenen Zugriffsrechte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um die angegebenen Rechte für einen einzelnen Benutzer gewährt. Der Benutzer kann eine beliebige gültige Vertrauensnehmer, sein, die einzelne Benutzer, Gruppen von Benutzern oder einem Computer enthält. Wenn der Benutzer eine Person ist, verwenden Sie das Format `DOMAIN` \\ `user` für die `user` Parameter. Sie können angeben, "." für die `user` Parameter, um den lokalen Computer anzugeben.  
  
 Die Berechtigungen, die Sie über zuweisen <xref:System.Messaging.MessageQueue.SetPermissions%2A> Rechte für die vorhandene Liste hinzufügen. In der Standardeinstellung der Ersteller einer öffentlichen oder privaten Warteschlange verfügt über Vollzugriff, und der Domänengruppe "Jeder" verfügt über die Berechtigung zum Abrufen von Warteschlangeneigenschaften, Berechtigungen zu erhalten und in die Warteschlange schreiben. Beim Aufruf <xref:System.Messaging.MessageQueue.SetPermissions%2A>, die Berechtigungen für Benutzer und -Informationen an das Ende der vorhandenen Liste angefügt wird.  
  
 Das System untersucht jede <xref:System.Messaging.AccessControlEntry> nacheinander, bis eines der folgenden Ereignisse eintritt:  
  
-   Eine zugriffsverweigerung <xref:System.Messaging.AccessControlEntry> explizit verweigert keines der angeforderten über die Zugriffsrechte für einen Vertrauensnehmer aufgeführt, die im Zugriffstoken des Threads.  
  
-   Eine oder mehrere-Zugriff <xref:System.Messaging.AccessControlEntry> Elemente für Vertrauensnehmer im Zugriffstoken des Threads explizit aufgelistet alle angeforderten Zugriffsrechte gewähren.  
  
-   Alle <xref:System.Messaging.AccessControlEntry> Elemente überprüft wurden, und es ist noch mindestens ein angefordertes Zugriffsrecht, das nicht ausdrücklich in diesem Fall wird der Zugriff implizit verweigert gewährt hat,.  
  
 Die Rechte für eine Warteschlange, angegeben der `rights` -Parameter kann eine beliebige Kombination der folgenden sein:  
  
-   Vollzugriff  
  
-   Nachricht löschen  
  
-   Meldung  
  
-   Nachricht einsehen  
  
-   Journalnachricht empfangen  
  
-   Abrufen von Warteschlangeneigenschaften  
  
-   Festlegen von Eigenschaften  
  
-   Berechtigungen abrufen  
  
-   Festlegen von Berechtigungen  
  
-   Besitz übernehmen  
  
-   Nachricht schreiben  
  
 Die <xref:System.Messaging.MessageQueueAccessRights> -Enumeration stellt einen Satz von Bitflags, die Sie kombinieren können, mit dem bitweisen Operator oder zum Erstellen der `rights` Parameter.  
  
 Mit dieser Überladung können Sie nur die Berechtigungen gewähren; Sie können nicht widerrufen oder verweigern sie. Sie müssen eine andere Überladung verwenden, um explizit alle gewähren <xref:System.Messaging.AccessControlEntryType> außer `Allow`.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="user" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">Der einzelne Benutzer, die Gruppe oder der Computer, der zusätzliche Rechte für die Warteschlange erhält.</param>
        <param name="rights">Ein <see cref="T:System.Messaging.MessageQueueAccessRights" />, das den Satz von Rechten für die Warteschlange darstellt, die Message Queuing dem übergebenen <paramref name="user" /> zuweist.</param>
        <param name="entryType">Ein <see cref="T:System.Messaging.AccessControlEntryType" />, der angibt, ob die im <paramref name="rights" />-Parameter angegebenen Berechtigungen gewährt, verweigert oder widerrufen werden sollen.</param>
        <summary>Gewährt einem Computer, einer Gruppe oder einem einzelnen Benutzer die angegebenen Zugriffsrechte mit dem angegebenen Zugriffssteuerungstyp (Zulassen, Verweigern, Widerrufen oder Festlegen).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung zu erteilen, verweigern oder widerrufen die angegebenen Rechte für einen einzelnen Benutzer. Der Benutzer kann eine beliebige gültige Vertrauensnehmer, sein, die einzelne Benutzer, Gruppen von Benutzern oder einem Computer enthält. Wenn der Benutzer eine Person ist, verwenden Sie das Format `DOMAIN` \\ `user` für die `user` Parameter. Sie können angeben, "." für die `user` Parameter, um den lokalen Computer anzugeben.  
  
 Die Berechtigungen, die Sie über zuweisen <xref:System.Messaging.MessageQueue.SetPermissions%2A> Rechte für die vorhandene Liste hinzufügen. In der Standardeinstellung der Ersteller einer öffentlichen oder privaten Warteschlange verfügt über Vollzugriff, und der Domänengruppe "Jeder" verfügt über die Berechtigung zum Abrufen von Warteschlangeneigenschaften, Berechtigungen zu erhalten und in die Warteschlange schreiben. Beim Aufruf <xref:System.Messaging.MessageQueue.SetPermissions%2A>, die Berechtigungen für Benutzer und -Informationen an das Ende der vorhandenen Liste angefügt wird.  
  
 Das System untersucht jede <xref:System.Messaging.AccessControlEntry> nacheinander, bis eines der folgenden Ereignisse eintritt:  
  
-   Eine zugriffsverweigerung <xref:System.Messaging.AccessControlEntry> explizit verweigert keines der angeforderten über die Zugriffsrechte für einen Vertrauensnehmer aufgeführt, die im Zugriffstoken des Threads.  
  
-   Eine oder mehrere-Zugriff <xref:System.Messaging.AccessControlEntry> Elemente für Vertrauensnehmer im Zugriffstoken des Threads explizit aufgelistet alle angeforderten Zugriffsrechte gewähren.  
  
-   Alle <xref:System.Messaging.AccessControlEntry> Elemente überprüft wurden, und es ist noch mindestens ein angefordertes Zugriffsrecht, das nicht ausdrücklich in diesem Fall wird der Zugriff implizit verweigert gewährt hat,.  
  
 Die Rechte für eine Warteschlange, angegeben der `rights` -Parameter kann eine beliebige Kombination der folgenden sein:  
  
-   Vollzugriff  
  
-   Nachricht löschen  
  
-   Meldung  
  
-   Nachricht einsehen  
  
-   Journalnachricht empfangen  
  
-   Abrufen von Warteschlangeneigenschaften  
  
-   Festlegen von Eigenschaften  
  
-   Berechtigungen abrufen  
  
-   Festlegen von Berechtigungen  
  
-   Besitz übernehmen  
  
-   Nachricht schreiben  
  
 Die <xref:System.Messaging.MessageQueueAccessRights> -Enumeration stellt einen Satz von Bitflags, die Sie kombinieren können, mit dem bitweisen Operator oder zum Erstellen der `rights` Parameter.  
  
 Die folgende Tabelle zeigt, ob diese Methode in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das den durch ein <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />-Ereignis oder ein <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />-Ereignis ausgelösten Ereignishandleraufruf marshallt, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, das das Objekt darstellt, das den durch ein <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />-Ereignis oder ein <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />-Ereignis ausgelösten Ereignishandleraufruf marshallt. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Messaging.MessageQueue.ReceiveCompleted> oder <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis tritt auf, aus einem <xref:System.Messaging.MessageQueue.BeginReceive%2A> oder <xref:System.Messaging.MessageQueue.BeginPeek%2A> anfordern, jeweils für einen bestimmten Thread. In der Regel die <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> wird festgelegt, wenn die zugehörige Komponente sich in einem Steuerelement oder Formular befindet, da diese Komponenten für einen bestimmten Thread gebunden sind.  
  
 Das Objekt synchronisierende marshallt in der Regel den Aufruf einer Methode in einem einzelnen Thread.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Warteschlange nur Transaktionen akzeptiert.</summary>
        <value><see langword="true" />, wenn die Warteschlange nur Meldungen akzeptiert, die als Teil einer Transaktion gesendet wurden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transaktionales messaging bezieht sich auf die Kopplung von mehrere verwandten Nachrichten in einer einzelnen Transaktion. Senden von Nachrichten als Teil einer Transaktion wird sichergestellt, dass die Nachrichten in der Reihenfolge zugestellt werden nur einmal übermittelt und erfolgreich in die Zielwarteschlange abgerufen.  
  
 Wenn eine Warteschlange transaktional ist, akzeptiert er nur Nachrichten, die als Teil einer Transaktion gesendet werden. Allerdings kann eine nicht transaktionale Nachricht senden oder empfangen aus einer lokalen Transaktionswarteschlange ohne explizit transaktional <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, und <xref:System.Messaging.MessageQueueTransaction.Abort%2A> Syntax. Wenn eine nicht transaktionale Meldung an eine transaktionale Warteschlange gesendet wird, erstellt diese Komponente Transaktion mit eine einzelnen Nachricht, außer im Fall von Verweisen auf eine Warteschlange auf einem Remotecomputer mit einem direkten Formatnamen. In diesem Fall, wenn Sie einen Transaktionskontext beim Senden einer Nachricht nicht angeben, wird eine nicht für Sie erstellt und die Nachricht wird an die Warteschlange für unzustellbare Nachrichten gesendet werden.  
  
 Wenn Sie eine nicht transaktionale Meldung an eine transaktionale Warteschlange senden, werden Sie nicht ein Rollback der Nachricht bei Auftreten einer Ausnahme können.  
  
 <xref:System.Messaging.MessageQueueTransaction> Apartmentthreading fähig ist, wenn der Apartmentzustand wurde also `STA`, können keine Transaktion in mehreren Threads. Visual Basic legt den Status der Hauptthread die `STA`, sodass Sie anwenden, müssen die <xref:System.MTAThreadAttribute> in die `Main` Unterroutine. Andernfalls wird durch das Senden einer Transaktionsmeldung mithilfe eines anderen Threads eine <xref:System.Messaging.MessageQueueException>-Ausnahme ausgelöst. Sie wenden die <xref:System.MTAThreadAttribute> mit dem folgenden Fragment.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.Transactional%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_UseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob abgerufene Meldungen in die Journalwarteschlange kopiert werden, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn aus der Warteschlange empfangene Meldungen in die Journalwarteschlange kopiert werden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Message Queuing-Anwendung eine neue Warteschlange erstellt wird, erstellt es automatisch eine zugeordnete Journalwarteschlange am gleichen Speicherort. Die Journalwarteschlange wird verwendet, um die aus der Warteschlange entfernten Nachrichten nachzuverfolgen. Durch Festlegen dieser Eigenschaft wird geändert, Message Queuing-Warteschlange. Aus diesem Grund alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen sind.  
  
 Die Journalwarteschlange verfolgt keine Nachrichten aus der Warteschlange entfernt werden, da ihre Zeit-zu-Eingang abgelaufen ist, noch es Nachverfolgen von Nachrichten aus der Warteschlange gelöscht werden ist, mithilfe einen Message Queuing-Verzeichnisdienst (Informationen Store oder Active Directory).  
  
 Anwendungen können nicht zum Senden von Nachrichten an Journalwarteschlangen führen; Sie sind nur-Lese Zugriff dieser Warteschlangen auf. Darüber hinaus entfernt Message Queuing-niemals Nachrichten aus Journalwarteschlangen. Die Anwendung mithilfe der Warteschlange, muss diese Nachrichten empfangen oder durch Löschen der Warteschlange löschen.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft ab und legt den Wert einer Nachrichtenwarteschlange <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> Eigenschaft.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Das systemeigene Handle zum Senden von Meldungen an die Meldungswarteschlange.</summary>
        <value>Ein Handle für das systemeigene Warteschlangenobjekt, das zum Senden von Meldungen an die Warteschlange verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.WriteHandle%2A> bietet ein systemeigenes Windows-Handle für das Message Queue-Objekt, das zum Senden von Nachrichten an die Warteschlange verwendet wird. Wenn Sie den Pfad der Warteschlange ändern, wird das Handle geschlossen und erneut geöffnet wird, durch einen neuen Wert.  
  
 Die folgende Tabelle zeigt, ob diese Eigenschaft in verschiedenen Modi für die Arbeitsgruppe verfügbar ist.  
  
|Im Arbeitsgruppenmodus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Lokalen Computer und direkten Formatnamen|Ja|  
|Remotecomputer|Nein|  
|Remote-Computer und direkten Formatnamen|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">In die Meldungswarteschlange kann nicht geschrieben werden.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>