<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata><Meta Name="ms.openlocfilehash" Value="955dbf0dee587fca5b4e84df42c8ef4af06762bd" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78699566" /></Metadata><TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" FrameworkAlternate="netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Messaging.MessagingDescription("MessageQueueDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht den Zugriff auf eine Warteschlange auf einem Message Queuing-Server.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Message Queuing-Technologie ermöglicht Anwendungen, die zu unterschiedlichen Zeitpunkten ausgeführt werden, über heterogene Netzwerke und Systeme zu kommunizieren, die vorübergehend offline sind. Anwendungen senden, empfangen oder einsehen (lesen, ohne zu entfernen) Nachrichten aus Warteschlangen. Message Queuing ist eine optionale Komponente von [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] und Windows NT und muss separat installiert werden.  
  
 Die <xref:System.Messaging.MessageQueue>-Klasse ist ein Wrapper um Message Queuing. Es gibt mehrere Versionen von Message Queuing, und die Verwendung der <xref:System.Messaging.MessageQueue>-Klasse kann je nach verwendetem Betriebssystem etwas anderes Verhalten zur Folge haben. Informationen zu bestimmten Features der einzelnen Versionen von Message Queuing finden Sie im Thema "What es New in Message Queuing" im Platform SDK in MSDN.  
  
 Die <xref:System.Messaging.MessageQueue>-Klasse stellt einen Verweis auf eine Message Queuing Warteschlange bereit. Sie können einen Pfad im <xref:System.Messaging.MessageQueue.%23ctor%2A>-Konstruktor angeben, um eine Verbindung mit einer vorhandenen Ressource herzustellen, oder Sie können eine neue Warteschlange auf dem Server erstellen. Bevor Sie <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>oder <xref:System.Messaging.MessageQueue.Receive%2A>abrufen können, müssen Sie die neue Instanz der <xref:System.Messaging.MessageQueue> Klasse einer vorhandenen Warteschlange zuordnen. An diesem Punkt können Sie die Warteschlangen Eigenschaften wie <xref:System.Messaging.MessageQueue.Category%2A> und <xref:System.Messaging.MessageQueue.Label%2A>bearbeiten.  
  
 <xref:System.Messaging.MessageQueue> unterstützt zwei Arten von Nachrichten Abruf: synchron und asynchron. Die synchronen Methoden, <xref:System.Messaging.MessageQueue.Peek%2A> und <xref:System.Messaging.MessageQueue.Receive%2A>, bewirken, dass der Prozess Thread ein angegebenes Zeitintervall wartet, bis eine neue Nachricht in der Warteschlange eintrifft. Die asynchronen Methoden <xref:System.Messaging.MessageQueue.BeginPeek%2A> und <xref:System.Messaging.MessageQueue.BeginReceive%2A>ermöglichen, dass die Haupt Anwendungsaufgaben in einem separaten Thread fortgesetzt werden, bis eine Nachricht in der Warteschlange eintrifft. Diese Methoden funktionieren, indem Sie Rückruf Objekte und Zustands Objekte verwenden, um Informationen zwischen Threads zu übermitteln.  
  
 Wenn Sie eine neue Instanz der <xref:System.Messaging.MessageQueue>-Klasse erstellen, erstellen Sie keine neue Message Queuing Warteschlange. Stattdessen können Sie die Methoden <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>und <xref:System.Messaging.MessageQueue.Purge%2A> zum Verwalten von Warteschlangen auf dem Server verwenden.  
  
 Im Gegensatz zu <xref:System.Messaging.MessageQueue.Purge%2A>sind <xref:System.Messaging.MessageQueue.Create%28System.String%29> und <xref:System.Messaging.MessageQueue.Delete%28System.String%29> `static` Member, sodass Sie Sie ohne Erstellen einer neuen Instanz der <xref:System.Messaging.MessageQueue>-Klasse anrufen können.  
  
 Sie können die <xref:System.Messaging.MessageQueue.Path%2A>-Eigenschaft des <xref:System.Messaging.MessageQueue> Objekts mit einem von drei Namen festlegen: dem anzeigen Amen, dem <xref:System.Messaging.MessageQueue.FormatName%2A>oder dem <xref:System.Messaging.MessageQueue.Label%2A>. Der Anzeige Name, der durch die Eigenschaften <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A> der Warteschlange definiert wird, wird für eine öffentliche Warteschlange <xref:System.Messaging.MessageQueue.MachineName%2A>\\<xref:System.Messaging.MessageQueue.QueueName%2A> und <xref:System.Messaging.MessageQueue.MachineName%2A>\\`Private$`\\<xref:System.Messaging.MessageQueue.QueueName%2A> für eine private Warteschlange. Die <xref:System.Messaging.MessageQueue.FormatName%2A>-Eigenschaft ermöglicht den Offline Zugriff auf Nachrichten Warteschlangen. Schließlich können Sie die <xref:System.Messaging.MessageQueue.Label%2A>-Eigenschaft der Warteschlange verwenden, um die <xref:System.Messaging.MessageQueue.Path%2A>der Warteschlange festzulegen.  
  
 Eine Liste der anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.Messaging.MessageQueue>finden Sie im <xref:System.Messaging.MessageQueue.%23ctor%2A>-Konstruktor.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden neue <xref:System.Messaging.MessageQueue>-Objekte mithilfe verschiedener Syntax Typen für Pfadnamen erstellt. In jedem Fall sendet Sie eine Nachricht an die Warteschlange, deren Pfad im Konstruktor definiert ist.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 Im folgenden Codebeispiel wird eine Nachricht an eine Warteschlange gesendet, und es wird eine Nachricht aus einer Warteschlange mit einer anwendungsspezifischen Klasse namens `Order`empfangen.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Nur die <see cref="M:System.Messaging.MessageQueue.GetAllMessages" />-Methode ist Thread sicher.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse. Nachdem der parameterlose Konstruktor die neue Instanz initialisiert hat, müssen Sie die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft der Instanz festlegen, bevor Sie die Instanz verwenden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine neue Instanz der <xref:System.Messaging.MessageQueue>-Klasse zu erstellen, die nicht direkt an eine Warteschlange auf dem Message Queuing Server gebunden ist. Bevor Sie diese Instanz verwenden, müssen Sie Sie mit einer vorhandenen Message Queuing Warteschlange verbinden, indem Sie die <xref:System.Messaging.MessageQueue.Path%2A>-Eigenschaft festlegen. Alternativ können Sie den <xref:System.Messaging.MessageQueue> Verweis auf den Rückgabewert der <xref:System.Messaging.MessageQueue.Create%28System.String%29> Methode festlegen und dadurch eine neue Message Queuing Warteschlange erstellen.  
  
 Der <xref:System.Messaging.MessageQueue.%23ctor%2A>-Konstruktor instanziiert eine neue Instanz der <xref:System.Messaging.MessageQueue>-Klasse. Es wird keine neue Message Queuing Warteschlange erstellt.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.Messaging.MessageQueue>angezeigt.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Die vom Parameter losen Konstruktor der <xref:System.Messaging.DefaultPropertiesToSend> Klasse festgelegten Werte.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Die vom Parameter losen Konstruktor der <xref:System.Messaging.MessagePropertyFilter> Klasse festgelegten Werte. Alle Filter Werte werden auf `true`festgelegt.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine neue <xref:System.Messaging.MessageQueue>erstellt.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse, die auf die Message Queuing-Warteschlange am angegebenen Pfad verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn Sie die neue <xref:System.Messaging.MessageQueue>-Instanz mit einer bestimmten Message Queuing Warteschlange verknüpfen möchten, für die Sie den Pfad, den Format Namen oder die Bezeichnung kennen. Wenn Sie exklusiven Zugriff auf die erste Anwendung gewähren möchten, die auf die Warteschlange verweist, müssen Sie die <xref:System.Messaging.MessageQueue.DenySharedReceive%2A>-Eigenschaft auf `true` festlegen oder den-Konstruktor verwenden, der einen Einschränkungs Parameter für den Lesezugriff übergibt.  
  
 Der <xref:System.Messaging.MessageQueue.%23ctor%2A>-Konstruktor instanziiert eine neue Instanz der <xref:System.Messaging.MessageQueue>-Klasse. Es wird keine neue Message Queuing Warteschlange erstellt. Um eine neue Warteschlange in Message Queuing zu erstellen, verwenden Sie <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Die Syntax des `path`-Parameters hängt vom Typ der Warteschlange ab, auf die er verweist, wie in der folgenden Tabelle dargestellt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|Öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|Private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
|Computer Journal Warteschlange|`MachineName`\\`Journal$`|  
|Warteschlange für unzustellbare Nachrichten|`MachineName`\\`Deadletter$`|  
|Computer transaktionale Warteschlange für unzustellbare Nachrichten|`MachineName`\\`XactDeadletter$`|  
  
 Alternativ können Sie die <xref:System.Messaging.MessageQueue.FormatName%2A> oder <xref:System.Messaging.MessageQueue.Label%2A> verwenden, um den Warteschlangen Pfad zu beschreiben, wie in der folgenden Tabelle dargestellt.  
  
|Referenz|Syntax|Beispiel|  
|---------------|------------|-------------|  
|Formatname|`FormatName:` [ *Format Name* ]|`FormatName:Public=` 5a5f 7535-AE9a-41d4-935c-845c2aff7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Bezeichnung|`Label:` [ *Bezeichnung* ]|`Label:` thelabel|  
  
 Um offline arbeiten zu können, müssen Sie die Format Namen Syntax verwenden, nicht die Pfadnamen Syntax für den Konstruktor. Andernfalls wird eine Ausnahme ausgelöst, da der primäre Domänen Controller nicht verfügbar ist, um den Pfad zum Format Namen aufzulösen.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.Messaging.MessageQueue>angezeigt. Diese Werte basieren auf den Eigenschaften der Message Queuing Warteschlange mit dem durch den Parameter `path` angegebenen Pfad.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Die vom Parameter losen Konstruktor der <xref:System.Messaging.DefaultPropertiesToSend> Klasse festgelegten Werte.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, wenn die Einstellung der Datenschutzebene der Message Queuing Warteschlange auf "Body" festgelegt ist. Andernfalls `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Der Wert der Eigenschaft "Computername" der Message Queuing Warteschlange.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Die vom Parameter losen Konstruktor der <xref:System.Messaging.MessagePropertyFilter> Klasse festgelegten Werte.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, wenn nicht durch den Konstruktor festgelegt.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, wenn nicht durch den Konstruktor festgelegt.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, wenn die Journal Einstellung des Message Queuing Objekts aktiviert ist. Andernfalls `false`.|  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden neue <xref:System.Messaging.MessageQueue>-Objekte mithilfe verschiedener Syntax Typen für Pfadnamen erstellt. In jedem Fall sendet Sie eine Nachricht an die Warteschlange, deren Pfad im Konstruktor definiert ist.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft ist ungültig. Möglicherweise wurde sie nicht festgelegt.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser kann für den lokalen Computer "." lauten.</param>
        <param name="sharedModeDenyReceive"><see langword="true" />, wenn der ersten Anwendung, die auf die Warteschlange zugreift, exklusiver Zugriff gewährt werden soll, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse mit der angegebenen Lesezugriffsbeschränkung, die auf die Message Queuing-Warteschlange unter dem angegebenen Pfad verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn Sie die neue <xref:System.Messaging.MessageQueue> mit einer bestimmten Message Queuing Warteschlange verknüpfen möchten, für die Sie den Pfad, den Format Namen oder die Bezeichnung kennen. Wenn Sie exklusiven Zugriff auf die erste Anwendung gewähren möchten, die auf die Warteschlange verweist, legen Sie den `sharedModeDenyReceive`-Parameter auf `true`fest. Legen Sie andernfalls `sharedModeDenyReceive` auf `false` oder verwenden Sie den-Konstruktor, der nur über einen `path`-Parameter verfügt.  
  
 Das Festlegen `sharedModeDenyReceive` auf `true` wirkt sich auf alle Objekte aus, die auf die Message Queuing Warteschlange zugreifen, einschließlich anderer Anwendungen Die Auswirkungen des-Parameters sind nicht auf diese Anwendung beschränkt.  
  
 Der <xref:System.Messaging.MessageQueue.%23ctor%2A>-Konstruktor erstellt eine neue Instanz der <xref:System.Messaging.MessageQueue>-Klasse. Es wird keine neue Message Queuing Warteschlange erstellt. Um eine neue Warteschlange in Message Queuing zu erstellen, verwenden Sie <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Die Syntax des `path`-Parameters hängt vom Typ der Warteschlange ab.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|Öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|Private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
|Computer Journal Warteschlange|`MachineName`\\`Journal$`|  
|Warteschlange für unzustellbare Nachrichten|`MachineName`\\`Deadletter$`|  
|Computer transaktionale Warteschlange für unzustellbare Nachrichten|`MachineName`\\`XactDeadletter$`|  
  
 Alternativ können Sie den Format Namen oder die Bezeichnung einer Message Queuing Warteschlange verwenden, um den Warteschlangen Pfad zu beschreiben.  
  
|Referenz|Syntax|Beispiel|  
|---------------|------------|-------------|  
|Formatname|`FormatName:` [ *Format Name* ]|`FormatName:Public=` 5a5f 7535-AE9a-41d4-935c-845c2aff7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Bezeichnung|`Label:` [ *Bezeichnung* ]|`Label:` thelabel|  
  
 Wenn Sie offline arbeiten möchten, müssen Sie anstelle der Syntax für den anzeigen Amen die Syntax Format Name verwenden. Andernfalls wird eine Ausnahme ausgelöst, da der primäre Domänen Controller (auf dem sich Active Directory befindet) nicht verfügbar ist, um den Pfad zum Format Namen aufzulösen.  
  
 Wenn eine <xref:System.Messaging.MessageQueue> eine Warteschlange öffnet, bei der der Parameter `sharedModeDenyReceive` auf `true`festgelegt ist, generiert jede <xref:System.Messaging.MessageQueue>, die anschließend versucht, aus der Warteschlange zu lesen, aufgrund einer Freigabe Verletzung eine <xref:System.Messaging.MessageQueueException>. Eine <xref:System.Messaging.MessageQueueException> wird auch ausgelöst, wenn ein <xref:System.Messaging.MessageQueue> versucht, im exklusiven Modus auf die Warteschlange zuzugreifen, während ein anderer <xref:System.Messaging.MessageQueue> bereits über nicht exklusiven Zugriff auf die Warteschlange verfügt.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.Messaging.MessageQueue>angezeigt. Diese Werte basieren auf den Eigenschaften der Message Queuing Warteschlange mit dem durch den `path`-Parameter angegebenen Pfad.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Die vom Parameter losen Konstruktor der <xref:System.Messaging.DefaultPropertiesToSend> Klasse festgelegten Werte.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, wenn die Einstellung der Datenschutzebene der Message Queuing Warteschlange auf "Body" festgelegt ist. Andernfalls `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Der Wert der Eigenschaft "Computername" der Message Queuing Warteschlange.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Die vom Parameter losen Konstruktor der <xref:System.Messaging.MessagePropertyFilter> Klasse festgelegten Werte.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, wenn nicht durch den Konstruktor festgelegt.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, wenn nicht durch den Konstruktor festgelegt.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|Der Wert des `sharedModeDenyReceive`-Parameters.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, wenn die Journal Einstellung des Message Queuing Objekts aktiviert ist. Andernfalls `false`.|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine neue <xref:System.Messaging.MessageQueue> mit exklusivem Zugriff erstellt, der Pfad festgelegt und eine Nachricht an die Warteschlange gesendet.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft ist ungültig. Möglicherweise wurde sie nicht festgelegt.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser kann für den lokalen Computer "." lauten.</param>
        <param name="accessMode">Einer der <see cref="T:System.Messaging.QueueAccessMode" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableCache" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser kann für den lokalen Computer "." lauten.</param>
        <param name="sharedModeDenyReceive"><see langword="true" />, wenn der ersten Anwendung, die auf die Warteschlange zugreift, exklusiver Zugriff gewährt werden soll, andernfalls <see langword="false" />.</param>
        <param name="enableCache"><see langword="true" />, wenn ein Verbindungscache erstellt und verwendet wird, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird eine neue <xref:System.Messaging.MessageQueue> mit exklusivem Lesezugriff und aktiviertem Verbindungs Zwischenspeichern erstellt.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableCache" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser kann für den lokalen Computer "." lauten.</param>
        <param name="sharedModeDenyReceive"><see langword="true" />, wenn der ersten Anwendung, die auf die Warteschlange zugreift, exklusiver Zugriff gewährt werden soll, andernfalls <see langword="false" />.</param>
        <param name="enableCache"><see langword="true" />, wenn ein Verbindungscache erstellt und verwendet wird, andernfalls <see langword="false" />.</param>
        <param name="accessMode">Einer der <see cref="T:System.Messaging.QueueAccessMode" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.MessageQueue" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den Zugriffsmodus für die Warteschlange angibt.</summary>
        <value>Einer der <see cref="T:System.Messaging.QueueAccessMode" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standard Zugriffsmodus für eine Warteschlange ist `QueueAccessMode.SendAndReceive`, es sei denn, Sie geben andernfalls an, wenn der Konstruktor aufgerufen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Warteschlange nur authentifizierte Meldungen akzeptiert, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Warteschlange nur authentifizierte Meldungen akzeptiert, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Nachrichten Authentifizierung bietet eine Möglichkeit, die Nachrichten Integrität sicherzustellen und zu überprüfen, wer die Nachricht gesendet hat. Zum Anfordern der Authentifizierung legt die sendende Anwendung die Authentifizierungs Ebene der Nachricht fest.  
  
 Wenn Sie <xref:System.Messaging.MessageQueue.Authenticate%2A> auf `true`festlegen, schränken Sie den Zugriff auf die Warteschlange auf dem Server ein, nicht nur auf diese <xref:System.Messaging.MessageQueue> Instanz. Alle Clients, die mit derselben Message Queuing Warteschlange arbeiten, sind betroffen.  
  
 Eine Warteschlange, die nur authentifizierte Nachrichten akzeptiert, lehnt eine nicht authentifizierte Nachricht ab. Um eine Benachrichtigung über die Nachrichten Ablehnung anzufordern, kann eine sendende Anwendung die <xref:System.Messaging.Message.AcknowledgeType%2A>-Eigenschaft der Nachricht festlegen. Da keine andere Angabe der Nachrichten Ablehnung vorhanden ist, kann die sendende Anwendung die Nachricht verlieren, es sei denn, Sie bitten, dass Sie an die Warteschlange für unzustellbare Nachrichten gesendet wird  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.Authenticate%2A>-Eigenschaft einer Nachrichten Warteschlange abgerufen und festgelegt.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Basispriorität an, die von Message Queuing beim Weiterleiten von Meldungen einer öffentlichen Warteschlange über das Netzwerk verwendet wird, oder legt diese fest.</summary>
        <value>Die einzige Basispriorität für alle an die (öffentliche) Warteschlange gesendeten Meldungen. Der Standardwert ist null (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Basis Priorität einer Nachrichten Warteschlange gibt an, wie eine Nachricht, die an diese Warteschlange weitergeleitet wird, beim Durchlaufen des Netzwerks behandelt wird. Sie können die <xref:System.Messaging.MessageQueue.BasePriority%2A>-Eigenschaft so festlegen, dass alle Nachrichten, die an die angegebene Warteschlange gesendet werden, höher oder niedriger sind als an andere Warteschlangen. Wenn Sie diese Eigenschaft festlegen, ändert sich die Message Queuing Warteschlange. Aus diesem Grund sind alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen.  
  
 Die <xref:System.Messaging.MessageQueue.BasePriority%2A> einer Nachrichten Warteschlange ist nicht mit der <xref:System.Messaging.Message.Priority%2A>-Eigenschaft einer Nachricht verknüpft, die die Reihenfolge angibt, in der eine eingehende Nachricht in die Warteschlange gestellt wird.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> gilt nur für öffentliche Warteschlangen, deren Pfade mit dem Format Namen angegeben werden. Die Basis Priorität einer privaten Warteschlange ist immer 0 (null).  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.BasePriority%2A>-Eigenschaft einer Nachrichten Warteschlange abgerufen und festgelegt.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Basispriorität wurde auf einen ungültigen Wert festgelegt.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <summary>Initiiert einen asynchronen Lesevorgang, indem Message Queuing angewiesen wird, mit dem Einsehen einer Meldung zu beginnen und nach Abschluss des Vorgangs den Ereignishandler zu benachrichtigen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiiert einen asynchronen Lesevorgang ohne Timeout. Die Operation wird erst abgeschlossen, wenn eine Meldung in der Warteschlange verfügbar ist.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der asynchronen Verarbeitung verwenden Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, um das <xref:System.Messaging.MessageQueue.PeekCompleted>-Ereignis zu erhöhen, wenn eine Nachricht in der Warteschlange verfügbar wird.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> wird auch ausgelöst, wenn eine Nachricht bereits in der Warteschlange vorhanden ist.  
  
 Um <xref:System.Messaging.MessageQueue.BeginPeek%2A>zu verwenden, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und dem Ereignis Delegaten zuordnet. <xref:System.Messaging.MessageQueue.BeginPeek%2A> initiiert einen asynchronen Peek-Vorgang. der <xref:System.Messaging.MessageQueue> wird durch das Auslösen des <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignisses benachrichtigt, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> können dann auf die Nachricht zugreifen, indem Sie <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufrufen oder das Ergebnis mithilfe der <xref:System.Messaging.PeekCompletedEventArgs>abrufen.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode wird sofort zurückgegeben, der asynchrone Vorgang wird jedoch erst abgeschlossen, wenn der-Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> asynchron ist, können Sie es zum Einsehen der Warteschlange, ohne dass der aktuelle Ausführungs Thread blockiert wird. Verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode, um die Warteschlange synchron zu sehen.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler abrufen, um weiterhin Benachrichtigungen zu empfangen.  
  
 Der von <xref:System.Messaging.MessageQueue.BeginPeek%2A> zurückgegebene <xref:System.IAsyncResult> identifiziert den asynchronen Vorgang, den die Methode gestartet hat. Sie können diese <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs verwenden, obwohl Sie Sie in der Regel erst verwenden, wenn <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Wenn Sie jedoch mehrere asynchrone Vorgänge starten, können Sie Ihre <xref:System.IAsyncResult> Werte in einem Array platzieren und angeben, ob auf den Abschluss aller Vorgänge oder eines Vorgangs gewartet werden soll. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A>-Eigenschaft des <xref:System.IAsyncResult>, um den abgeschlossenen Vorgang zu identifizieren.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> `false`ist, wird das Abschluss Ereignis ausgelöst, aber beim Aufrufen von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>wird eine Ausnahme ausgelöst.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignishandler mit dem Namen `MyPeekCompleted`erstellt, an den <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignishandlerdelegaten angehängt und <xref:System.Messaging.MessageQueue.BeginPeek%2A> aufgerufen, um einen asynchronen Peek-Vorgang in der Warteschlange zu initiieren, die sich im Pfad ".\MyQueue" befindet. Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis ausgelöst wird, zeigt das Beispiel die Nachricht an und schreibt Ihren Text auf den Bildschirm. Im Beispiel wird dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aufgerufen, um einen neuen asynchronen Peek-Vorgang zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <summary>Initiiert einen asynchronen Lesevorgang mit einem festgelegten Timeout. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der asynchronen Verarbeitung verwenden Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, um das <xref:System.Messaging.MessageQueue.PeekCompleted>-Ereignis zu erhöhen, wenn eine Nachricht in der Warteschlange verfügbar wird oder wenn das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> wird auch ausgelöst, wenn eine Nachricht bereits in der Warteschlange vorhanden ist.  
  
 Um <xref:System.Messaging.MessageQueue.BeginPeek%2A>zu verwenden, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und dem Ereignis Delegaten zuordnet. <xref:System.Messaging.MessageQueue.BeginPeek%2A> initiiert einen asynchronen Peek-Vorgang. der <xref:System.Messaging.MessageQueue> wird durch das Auslösen des <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignisses benachrichtigt, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> können dann auf die Nachricht zugreifen, indem Sie <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufrufen oder das Ergebnis mithilfe der <xref:System.Messaging.PeekCompletedEventArgs>abrufen.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode wird sofort zurückgegeben, der asynchrone Vorgang wird jedoch erst abgeschlossen, wenn der-Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> asynchron ist, können Sie es zum Einsehen der Warteschlange, ohne dass der aktuelle Ausführungs Thread blockiert wird. Verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode, um die Warteschlange synchron zu sehen.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler abrufen, um weiterhin Benachrichtigungen zu empfangen.  
  
 Der von <xref:System.Messaging.MessageQueue.BeginPeek%2A> zurückgegebene <xref:System.IAsyncResult> identifiziert den asynchronen Vorgang, den die Methode gestartet hat. Sie können diese <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs verwenden, obwohl Sie Sie in der Regel erst verwenden, wenn <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Wenn Sie jedoch mehrere asynchrone Vorgänge starten, können Sie Ihre <xref:System.IAsyncResult> Werte in einem Array platzieren und angeben, ob auf den Abschluss aller Vorgänge oder eines Vorgangs gewartet werden soll. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A>-Eigenschaft des <xref:System.IAsyncResult>, um den abgeschlossenen Vorgang zu identifizieren.  
  
 Diese Überladung gibt ein Timeout an. Wenn das durch den `timeout`-Parameter angegebene Intervall abläuft, löst diese Komponente das <xref:System.Messaging.MessageQueue.PeekCompleted>-Ereignis aus. Da keine Meldung vorhanden ist, löst ein nachfolgende-<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> eine Ausnahme aus.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> `false`ist, wird das Abschluss Ereignis ausgelöst, aber beim Aufrufen von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>wird eine Ausnahme ausgelöst.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Peek-Vorgang unter Verwendung des Warteschlangen Pfads ".\MyQueue". Er erstellt einen Ereignishandler, `MyPeekCompleted`und fügt ihn an den <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignishandlerdelegaten an. <xref:System.Messaging.MessageQueue.BeginPeek%2A> wird mit einem Timeout von einer Minute aufgerufen, um den asynchronen Peek-Vorgang zu initiieren. Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis ausgelöst wird oder das Timeout abläuft, wird die Nachricht abgerufen, wenn eine vorhanden ist, und Ihr Text wird auf den Bildschirm geschrieben. Anschließend wird <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aufgerufen, um einen neuen asynchronen Peek-Vorgang mit dem gleichen Timeout zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="stateObject">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <summary>Initiiert einen asynchronen Lesevorgang mit einem angegebenen Timeout und einem angegebenen Zustandsobjekt, das während der Lebensdauer des Vorgangs Informationen für den Vorgang bereitstellt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der asynchronen Verarbeitung verwenden Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>, um das <xref:System.Messaging.MessageQueue.PeekCompleted>-Ereignis zu erhöhen, wenn eine Nachricht in der Warteschlange verfügbar wird oder wenn das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> wird auch ausgelöst, wenn eine Nachricht bereits in der Warteschlange vorhanden ist.  
  
 Verwenden Sie diese Überladung, um dem Vorgang Informationen zuzuordnen, die während der gesamten Lebensdauer des Vorgangs beibehalten werden. Der Ereignishandler kann auf diese Informationen zugreifen, indem er die <xref:System.IAsyncResult.AsyncState%2A>-Eigenschaft des <xref:System.IAsyncResult> untersucht, die dem Vorgang zugeordnet ist.  
  
 Um <xref:System.Messaging.MessageQueue.BeginPeek%2A>zu verwenden, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und dem Ereignis Delegaten zuordnet. <xref:System.Messaging.MessageQueue.BeginPeek%2A> initiiert einen asynchronen Peek-Vorgang. der <xref:System.Messaging.MessageQueue> wird durch das Auslösen des <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignisses benachrichtigt, wenn eine Nachricht in der Warteschlange eintrifft. Die <xref:System.Messaging.MessageQueue> können dann auf die Nachricht zugreifen, indem Sie <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufrufen oder das Ergebnis mithilfe der <xref:System.Messaging.PeekCompletedEventArgs>abrufen.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode wird sofort zurückgegeben, der asynchrone Vorgang wird jedoch erst abgeschlossen, wenn der-Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> asynchron ist, können Sie es zum Einsehen der Warteschlange, ohne dass der aktuelle Ausführungs Thread blockiert wird. Verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode, um die Warteschlange synchron zu sehen.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler abrufen, um weiterhin Benachrichtigungen zu empfangen.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> gibt eine <xref:System.IAsyncResult> zurück, die den asynchronen Vorgang identifiziert, den die Methode gestartet hat. Sie können diese <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs verwenden, obwohl Sie Sie in der Regel erst verwenden, wenn <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Wenn Sie jedoch mehrere asynchrone Vorgänge starten, können Sie Ihre <xref:System.IAsyncResult> Werte in einem Array platzieren und angeben, ob auf den Abschluss aller Vorgänge oder eines Vorgangs gewartet werden soll. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A>-Eigenschaft des <xref:System.IAsyncResult>, um den abgeschlossenen Vorgang zu identifizieren.  
  
 Diese Überladung gibt ein Timeout und ein Zustands Objekt an. Wenn das durch den `timeout`-Parameter angegebene Intervall abläuft, löst diese Komponente das <xref:System.Messaging.MessageQueue.PeekCompleted>-Ereignis aus. Da keine Meldung vorhanden ist, löst ein nachfolgende-<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> eine Ausnahme aus.  
  
 Das Zustands Objekt ordnet dem Vorgang Zustandsinformationen zu. Wenn Sie z. b. <xref:System.Messaging.MessageQueue.BeginPeek%2A> mehrmals aufzurufen, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über ein separates Zustands Objekt identifizieren, das Sie definieren. Eine Abbildung dieses Szenarios finden Sie im Abschnitt "Beispiel".  
  
 Sie können auch das State-Objekt verwenden, um Informationen über Prozessthreads hinweg zu übergeben. Wenn ein Thread gestartet wird, der Rückruf aber in einem asynchronen Szenario in einem anderen Thread erfolgt, wird das Zustands Objekt gemarshallt und zusammen mit Informationen aus dem Ereignis zurückgegeben.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> `false`ist, wird das Abschluss Ereignis ausgelöst, aber beim Aufrufen von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>wird eine Ausnahme ausgelöst.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen asynchronen Peek-Vorgang unter Verwendung des Warteschlangen Pfads ".\MyQueue". Er erstellt einen Ereignishandler, `MyPeekCompleted`und fügt ihn an den <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignishandlerdelegaten an. <xref:System.Messaging.MessageQueue.BeginPeek%2A> wird mit einem Timeout von einer Minute aufgerufen. Jeder <xref:System.Messaging.MessageQueue.BeginPeek%2A> Aufrufe verfügt über eine eindeutige zugeordnete Ganzzahl, die den jeweiligen Vorgang identifiziert. Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis ausgelöst wird oder das Timeout abgelaufen ist, wird die Nachricht, sofern vorhanden, abgerufen, und der Text und der Vorgangs spezifische ganzzahlige Bezeichner werden auf den Bildschirm geschrieben. Anschließend wird <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aufgerufen, um einen neuen asynchronen Peek-Vorgang mit dem gleichen Timeout und der zugehörigen Ganzzahl des gerade abgeschlossenen Vorgangs zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="stateObject">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />, der die Benachrichtigung über den Abschluss des asynchronen Vorgangs erhält.</param>
        <summary>Initiiert einen asynchronen Lesevorgang mit einem angegebenen Timeout und einem angegebenen Zustandsobjekt, das während der Lebensdauer des Vorgangs Informationen für den Vorgang bereitstellt. Dieser Überladung wird in einem Rückruf die Identität des Ereignishandlers für den Vorgang mitgeteilt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Überladung verwenden, wird der im Rückruf Parameter angegebene Rückruf direkt aufgerufen, wenn eine Nachricht in der Warteschlange verfügbar wird oder wenn das angegebene Zeitintervall abgelaufen ist. Das <xref:System.Messaging.MessageQueue.PeekCompleted>-Ereignis wird nicht ausgelöst. Die anderen über Ladungen von <xref:System.Messaging.MessageQueue.BeginPeek%2A> die auf dieser Komponente basieren, um das <xref:System.Messaging.MessageQueue.PeekCompleted>-Ereignis zu erhöhen.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> wird auch ausgelöst, wenn eine Nachricht bereits in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode wird sofort zurückgegeben, der asynchrone Vorgang wird jedoch erst abgeschlossen, wenn der-Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> asynchron ist, können Sie es zum Einsehen der Warteschlange, ohne dass der aktuelle Ausführungs Thread blockiert wird. Verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode, um die Warteschlange synchron zu sehen.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler abrufen, um weiterhin Benachrichtigungen zu empfangen.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> gibt eine <xref:System.IAsyncResult> zurück, die den asynchronen Vorgang identifiziert, den die Methode gestartet hat. Sie können diese <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs verwenden, obwohl Sie Sie in der Regel erst verwenden, wenn <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Wenn Sie jedoch mehrere asynchrone Vorgänge starten, können Sie Ihre <xref:System.IAsyncResult> Werte in einem Array platzieren und angeben, ob auf den Abschluss aller Vorgänge oder eines Vorgangs gewartet werden soll. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A>-Eigenschaft des <xref:System.IAsyncResult>, um den abgeschlossenen Vorgang zu identifizieren.  
  
 Das Zustands Objekt ordnet dem Vorgang Zustandsinformationen zu. Wenn Sie z. b. <xref:System.Messaging.MessageQueue.BeginPeek%2A> mehrmals aufzurufen, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über ein separates Zustands Objekt identifizieren, das Sie definieren.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein asynchroner Peek-Vorgang erstellt. Im Codebeispiel wird eine Nachricht an eine lokale Meldungs Warteschlange gesendet. Anschließend werden <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>aufgerufen und übergeben: ein Timeout Wert von zehn Sekunden. eine eindeutige ganze Zahl, die diese bestimmte Nachricht identifiziert. und eine neue Instanz von <xref:System.AsyncCallback>, die den Ereignishandler identifiziert, `MyPeekCompleted`. Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis ausgelöst wird, sieht der Ereignishandler die Nachricht an und schreibt den Nachrichtentext und den ganzzahligen Nachrichten Bezeichner auf den Bildschirm.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, cursor As Cursor, action As PeekAction, state As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <param name="action">Einer der <see cref="T:System.Messaging.PeekAction" />-Werte. Gibt an, ob die aktuelle oder die folgende Meldung in der Warteschlange eingesehen wird.</param>
        <param name="state">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />, der die Benachrichtigung über den Abschluss des asynchronen Vorgangs erhält.</param>
        <summary>Initiiert einen asynchronen Lesevorgang, der über einen angegebenen Timeout verfügt und für den ein Cursor, eine Suchaktion und ein Zustandsobjekt festgelegt sind. Das Zustandsobjekt stellt für die Lebensdauer des Vorgangs zugeordnete Informationen bereit. Dieser Überladung wird in einem Rückruf die Identität des Ereignishandlers für den Vorgang mitgeteilt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Überladung verwenden, wird der im Rückruf Parameter angegebene Rückruf direkt aufgerufen, wenn eine Nachricht in der Warteschlange verfügbar wird oder wenn das angegebene Zeitintervall abgelaufen ist. Das <xref:System.Messaging.MessageQueue.PeekCompleted>-Ereignis wird nicht ausgelöst. Die anderen über Ladungen von <xref:System.Messaging.MessageQueue.BeginPeek%2A> die auf dieser Komponente basieren, um das <xref:System.Messaging.MessageQueue.PeekCompleted>-Ereignis zu erhöhen.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> wird auch ausgelöst, wenn eine Nachricht bereits in der Warteschlange vorhanden ist.  
  
 Die <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode wird sofort zurückgegeben, der asynchrone Vorgang wird jedoch erst abgeschlossen, wenn der-Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginPeek%2A> asynchron ist, können Sie es zum Einsehen der Warteschlange, ohne dass der aktuelle Ausführungs Thread blockiert wird. Verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode, um die Warteschlange synchron zu sehen.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler abrufen, um weiterhin Benachrichtigungen zu empfangen.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> gibt eine <xref:System.IAsyncResult> zurück, die den asynchronen Vorgang identifiziert, der von der-Methode gestartet wurde. Sie können diese <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs verwenden, obwohl Sie Sie in der Regel erst verwenden, wenn <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> aufgerufen wird. Wenn Sie jedoch mehrere asynchrone Vorgänge starten, können Sie Ihre <xref:System.IAsyncResult> Werte in einem Array platzieren und angeben, ob auf den Abschluss aller Vorgänge oder eines Vorgangs gewartet werden soll. Verwenden Sie in diesem Fall die <xref:System.IAsyncResult.AsyncWaitHandle%2A>-Eigenschaft des <xref:System.IAsyncResult>, um den abgeschlossenen Vorgang zu identifizieren.  
  
 Das Zustands Objekt ordnet dem Vorgang Zustandsinformationen zu. Wenn Sie z. b. <xref:System.Messaging.MessageQueue.BeginPeek%2A> mehrmals aufzurufen, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über ein separates Zustands Objekt identifizieren, das Sie definieren.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für den <paramref name="action" />-Parameter wurde ein anderer Wert als <see langword="PeekAction.Current" /> oder <see langword="PeekAction.Next" /> angegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <summary>Initiiert eine asynchrone Receive-Methode, indem Message Queuing angewiesen wird, mit dem Empfangen einer Meldung zu beginnen und nach Abschluss des Vorgangs den Ereignishandler zu benachrichtigen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiiert eine asynchrone Receive-Methode ohne Timeout. Die Operation wird erst abgeschlossen, wenn eine Meldung in der Warteschlange verfügbar ist.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der asynchronen Verarbeitung wird <xref:System.Messaging.MessageQueue.BeginReceive%2A> verwendet, um das <xref:System.Messaging.MessageQueue.ReceiveCompleted>-Ereignis zu erhöhen, wenn eine Nachricht aus der Warteschlange entfernt wurde.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> wird auch ausgelöst, wenn eine Nachricht bereits in der Warteschlange vorhanden ist.  
  
 Um <xref:System.Messaging.MessageQueue.BeginReceive%2A>zu verwenden, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und dem Ereignis Delegaten zuordnet. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert einen asynchronen Empfangsvorgang. der <xref:System.Messaging.MessageQueue> wird durch das Auslösen des <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignisses benachrichtigt, wenn eine Nachricht in der Warteschlange eintrifft. Der <xref:System.Messaging.MessageQueue> kann dann durch Aufrufen von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>auf die Nachricht zugreifen.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A>-Methode wird sofort zurückgegeben, der asynchrone Vorgang wird jedoch erst abgeschlossen, wenn der-Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> asynchron ist, können Sie es so abrufen, dass eine Nachricht aus der Warteschlange empfangen wird, ohne dass der aktuelle Ausführungs Thread blockiert wird. Um synchron eine Nachricht zu empfangen, verwenden Sie die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler abrufen, um weiterhin Benachrichtigungen zu empfangen.  
  
 Der von <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegebene <xref:System.IAsyncResult> identifiziert den asynchronen Vorgang, den die Methode gestartet hat. Sie können diese <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs verwenden, obwohl Sie Sie in der Regel erst verwenden, wenn <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Wenn Sie jedoch mehrere asynchrone Vorgänge starten, können Sie Ihre <xref:System.IAsyncResult> Werte in einem Array platzieren und angeben, ob auf den Abschluss aller Vorgänge oder eines Vorgangs gewartet werden soll. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A>-Eigenschaft des <xref:System.IAsyncResult>, um den abgeschlossenen Vorgang zu identifizieren.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> `false`ist, wird das Abschluss Ereignis ausgelöst, aber beim Aufrufen von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>wird eine Ausnahme ausgelöst.  
  
 Verwenden Sie den asynchronen <xref:System.Messaging.MessageQueue.BeginReceive%2A> nicht mit Transaktionen. Wenn Sie einen transaktionalen asynchronen Vorgang ausführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>auf, und platzieren Sie die Transaktion und die (synchrone) <xref:System.Messaging.MessageQueue.Receive%2A> Methode in dem Ereignishandler, den Sie für den Peek-Vorgang erstellen. Der Ereignishandler kann Funktionen enthalten, wie im folgenden C# Code gezeigt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden asynchrone Anforderungen verkettet. Es wird davon ausgegangen, dass auf dem lokalen Computer eine Warteschlange mit dem Namen "myQueue" vorhanden ist. Die `Main`-Funktion startet den asynchronen Vorgang, der von der `MyReceiveCompleted`-Routine verarbeitet wird. `MyReceiveCompleted` verarbeitet die aktuelle Nachricht und startet einen neuen asynchronen Empfangsvorgang.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 Im folgenden Codebeispiel werden asynchrone Anforderungen in eine Warteschlange gestellt. Der <xref:System.Messaging.MessageQueue.BeginReceive%2A>-Aufrufe verwendet die <xref:System.IAsyncResult.AsyncWaitHandle%2A> in seinem Rückgabewert. Die `Main` Routine wartet, bis alle asynchronen Vorgänge abgeschlossen sind, bevor Sie beendet wird.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <summary>Initiiert eine asynchrone Receive-Methode mit einem festgelegten Timeout. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der asynchronen Verarbeitung verwenden Sie <xref:System.Messaging.MessageQueue.BeginReceive%2A>, um das <xref:System.Messaging.MessageQueue.ReceiveCompleted>-Ereignis zu erhöhen, wenn eine Nachricht in der Warteschlange verfügbar wird oder wenn das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> wird auch ausgelöst, wenn eine Nachricht bereits in der Warteschlange vorhanden ist.  
  
 Um <xref:System.Messaging.MessageQueue.BeginReceive%2A>zu verwenden, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und dem Ereignis Delegaten zuordnet. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert einen asynchronen Empfangsvorgang. der <xref:System.Messaging.MessageQueue> wird durch das Auslösen des <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignisses benachrichtigt, wenn eine Nachricht in der Warteschlange eintrifft. Der <xref:System.Messaging.MessageQueue> kann dann auf die Nachricht zugreifen, indem Sie <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufrufen oder das Ergebnis mithilfe der <xref:System.Messaging.ReceiveCompletedEventArgs>abrufen.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A>-Methode wird sofort zurückgegeben, der asynchrone Vorgang wird jedoch erst abgeschlossen, wenn der-Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> asynchron ist, können Sie es so abrufen, dass eine Nachricht aus der Warteschlange empfangen wird, ohne dass der aktuelle Ausführungs Thread blockiert wird. Um synchron eine Nachricht zu empfangen, verwenden Sie die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler abrufen, um weiterhin Benachrichtigungen zu empfangen.  
  
 Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> `false`ist, wird das Abschluss Ereignis ausgelöst, aber beim Aufrufen von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>wird eine Ausnahme ausgelöst.  
  
 Der von <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegebene <xref:System.IAsyncResult> identifiziert den asynchronen Vorgang, den die Methode gestartet hat. Sie können diese <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs verwenden, obwohl Sie Sie in der Regel erst verwenden, wenn <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Wenn Sie jedoch mehrere asynchrone Vorgänge starten, können Sie Ihre <xref:System.IAsyncResult> Werte in einem Array platzieren und angeben, ob auf den Abschluss aller Vorgänge oder eines Vorgangs gewartet werden soll. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A>-Eigenschaft des <xref:System.IAsyncResult>, um den abgeschlossenen Vorgang zu identifizieren.  
  
 Diese Überladung gibt ein Timeout an. Wenn das durch den `timeout`-Parameter angegebene Intervall abläuft, löst diese Komponente das <xref:System.Messaging.MessageQueue.ReceiveCompleted>-Ereignis aus. Da keine Meldung vorhanden ist, löst ein nachfolgende-<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> eine Ausnahme aus.  
  
 Verwenden Sie den asynchronen <xref:System.Messaging.MessageQueue.BeginReceive%2A> nicht mit Transaktionen. Wenn Sie einen transaktionalen asynchronen Vorgang ausführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>auf, und platzieren Sie die Transaktion und die (synchrone) <xref:System.Messaging.MessageQueue.Receive%2A> Methode in dem Ereignishandler, den Sie für den Peek-Vorgang erstellen. Der Ereignishandler kann Funktionen enthalten, wie im folgenden C# Code gezeigt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein asynchroner Empfangsvorgang erstellt. Das Codebeispiel erstellt einen Ereignishandler, `MyReceiveCompleted`und fügt ihn an den <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignishandlerdelegaten an. Im Codebeispiel wird eine Nachricht an eine lokale Meldungs Warteschlange gesendet. Anschließend werden <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>aufgerufen und ein Timeout Wert von zehn Sekunden übergeben. Wenn ein <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis ausgelöst wird, empfängt der Ereignishandler die Nachricht und schreibt den Nachrichtentext auf den Bildschirm.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise wurde ein negativer Wert angegeben.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="stateObject">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <summary>Initiiert eine asynchrone Receive-Methode mit einem angegebenen Timeout und einem angegebenen Zustandsobjekt, das während der Lebensdauer des Vorgangs Informationen für den Vorgang bereitstellt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der asynchronen Verarbeitung verwenden Sie <xref:System.Messaging.MessageQueue.BeginReceive%2A>, um das <xref:System.Messaging.MessageQueue.ReceiveCompleted>-Ereignis zu erhöhen, wenn eine Nachricht in der Warteschlange verfügbar wird oder wenn das angegebene Zeitintervall abgelaufen ist.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> wird auch ausgelöst, wenn eine Nachricht bereits in der Warteschlange vorhanden ist.  
  
 Verwenden Sie diese Überladung, um dem Vorgang Informationen zuzuordnen, die während der gesamten Lebensdauer des Vorgangs beibehalten werden. Der Ereignishandler kann diese Informationen erkennen, indem er die <xref:System.IAsyncResult.AsyncState%2A>-Eigenschaft des <xref:System.IAsyncResult> untersucht, die dem Vorgang zugeordnet ist.  
  
 Um <xref:System.Messaging.MessageQueue.BeginReceive%2A>zu verwenden, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und dem Ereignis Delegaten zuordnet. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert einen asynchronen Empfangsvorgang. der <xref:System.Messaging.MessageQueue> wird durch das Auslösen des <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignisses benachrichtigt, wenn eine Nachricht in der Warteschlange eintrifft. Der <xref:System.Messaging.MessageQueue> kann dann auf die Nachricht zugreifen, indem Sie <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufrufen oder das Ergebnis mithilfe der <xref:System.Messaging.ReceiveCompletedEventArgs>abrufen.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A>-Methode wird sofort zurückgegeben, der asynchrone Vorgang wird jedoch erst abgeschlossen, wenn der-Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> asynchron ist, können Sie es so abrufen, dass eine Nachricht aus der Warteschlange empfangen wird, ohne dass der aktuelle Ausführungs Thread blockiert wird. Um synchron eine Nachricht zu empfangen, verwenden Sie die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler abrufen, um weiterhin Benachrichtigungen zu empfangen.  
  
 Der von <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegebene <xref:System.IAsyncResult> identifiziert den asynchronen Vorgang, den die Methode gestartet hat. Sie können diese <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs verwenden, obwohl Sie Sie in der Regel erst verwenden, wenn <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Wenn Sie jedoch mehrere asynchrone Vorgänge starten, können Sie Ihre <xref:System.IAsyncResult> Werte in einem Array platzieren und angeben, ob auf den Abschluss aller Vorgänge oder eines Vorgangs gewartet werden soll. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A>-Eigenschaft des <xref:System.IAsyncResult>, um den abgeschlossenen Vorgang zu identifizieren.  
  
 Diese Überladung gibt ein Timeout und ein Zustands Objekt an. Wenn das durch den `timeout`-Parameter angegebene Intervall abläuft, löst diese Komponente das <xref:System.Messaging.MessageQueue.ReceiveCompleted>-Ereignis aus. Da keine Meldung vorhanden ist, löst ein nachfolgende-<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> eine Ausnahme aus.  
  
 Das Zustands Objekt ordnet dem Vorgang Zustandsinformationen zu. Wenn Sie z. b. <xref:System.Messaging.MessageQueue.BeginReceive%2A> mehrmals aufzurufen, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über ein separates Zustands Objekt identifizieren, das Sie definieren.  
  
 Sie können auch das State-Objekt verwenden, um Informationen über Prozessthreads hinweg zu übergeben. Wenn ein Thread gestartet wird, der Rückruf aber in einem asynchronen Szenario in einem anderen Thread erfolgt, wird das Zustands Objekt gemarshallt und zusammen mit Informationen aus dem Ereignis zurückgegeben.  
  
 Verwenden Sie den asynchronen <xref:System.Messaging.MessageQueue.BeginReceive%2A> nicht mit Transaktionen. Wenn Sie einen transaktionalen asynchronen Vorgang ausführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>auf, und platzieren Sie die Transaktion und die (synchrone) <xref:System.Messaging.MessageQueue.Receive%2A> Methode in dem Ereignishandler, den Sie für den Peek-Vorgang erstellen. Der Ereignishandler kann Funktionen enthalten, wie im folgenden C# Code gezeigt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein asynchroner Empfangsvorgang erstellt. Das Codebeispiel erstellt einen Ereignishandler, `MyReceiveCompleted`und fügt ihn an den <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignishandlerdelegaten an. Im Codebeispiel wird eine Nachricht an eine lokale Meldungs Warteschlange gesendet. Anschließend werden <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>aufgerufen, wobei ein Timeout Wert von zehn Sekunden und eine eindeutige Ganzzahl, die diese bestimmte Nachricht identifiziert, übergeben werden. Wenn ein <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis ausgelöst wird, empfängt der Ereignishandler die Nachricht und schreibt den Nachrichtentext und den ganzzahligen Nachrichten Bezeichner auf den Bildschirm.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="stateObject">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />, der die Benachrichtigung über den Abschluss des asynchronen Vorgangs erhält.</param>
        <summary>Initiiert eine asynchrone Receive-Methode mit einem angegebenen Timeout und einem angegebenen Zustandsobjekt, das während der Lebensdauer des Vorgangs Informationen für den Vorgang bereitstellt. Dieser Überladung wird in einem Rückruf die Identität des Ereignishandlers für den Vorgang mitgeteilt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Überladung verwenden, wird der im Rückruf Parameter angegebene Rückruf direkt aufgerufen, wenn eine Nachricht in der Warteschlange verfügbar wird oder wenn das angegebene Zeitintervall abgelaufen ist. Das <xref:System.Messaging.MessageQueue.ReceiveCompleted>-Ereignis wird nicht ausgelöst. Die anderen über Ladungen von <xref:System.Messaging.MessageQueue.BeginReceive%2A> die auf dieser Komponente basieren, um das <xref:System.Messaging.MessageQueue.ReceiveCompleted>-Ereignis zu erhöhen.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> wird auch ausgelöst, wenn eine Nachricht bereits in der Warteschlange vorhanden ist.  
  
 Um <xref:System.Messaging.MessageQueue.BeginReceive%2A>zu verwenden, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und dem Ereignis Delegaten zuordnet. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert einen asynchronen Empfangsvorgang. der <xref:System.Messaging.MessageQueue> wird durch das Auslösen des <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignisses benachrichtigt, wenn eine Nachricht in der Warteschlange eintrifft. Der <xref:System.Messaging.MessageQueue> kann dann auf die Nachricht zugreifen, indem Sie <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufrufen oder das Ergebnis mithilfe der <xref:System.Messaging.ReceiveCompletedEventArgs>abrufen.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A>-Methode wird sofort zurückgegeben, der asynchrone Vorgang wird jedoch erst abgeschlossen, wenn der-Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> asynchron ist, können Sie es so abrufen, dass eine Nachricht aus der Warteschlange empfangen wird, ohne dass der aktuelle Ausführungs Thread blockiert wird. Um synchron eine Nachricht zu empfangen, verwenden Sie die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler abrufen, um weiterhin Benachrichtigungen zu empfangen.  
  
 Der von <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegebene <xref:System.IAsyncResult> identifiziert den asynchronen Vorgang, den die Methode gestartet hat. Sie können diese <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs verwenden, obwohl Sie Sie in der Regel erst verwenden, wenn <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Wenn Sie jedoch mehrere asynchrone Vorgänge starten, können Sie Ihre <xref:System.IAsyncResult> Werte in einem Array platzieren und angeben, ob auf den Abschluss aller Vorgänge oder eines Vorgangs gewartet werden soll. In diesem Fall verwenden Sie die <xref:System.IAsyncResult.AsyncWaitHandle%2A>-Eigenschaft des <xref:System.IAsyncResult>, um den abgeschlossenen Vorgang zu identifizieren.  
  
 Das Zustands Objekt ordnet dem Vorgang Zustandsinformationen zu. Wenn Sie z. b. <xref:System.Messaging.MessageQueue.BeginReceive%2A> mehrmals aufzurufen, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über ein separates Zustands Objekt identifizieren, das Sie definieren.  
  
 Sie können auch das State-Objekt verwenden, um Informationen über Prozessthreads hinweg zu übergeben. Wenn ein Thread gestartet wird, der Rückruf aber in einem asynchronen Szenario in einem anderen Thread erfolgt, wird das Zustands Objekt gemarshallt und zusammen mit Informationen aus dem Ereignis zurückgegeben.  
  
 Verwenden Sie den asynchronen <xref:System.Messaging.MessageQueue.BeginReceive%2A> nicht mit Transaktionen. Wenn Sie einen transaktionalen asynchronen Vorgang ausführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>auf, und platzieren Sie die Transaktion und die (synchrone) <xref:System.Messaging.MessageQueue.Receive%2A> Methode in dem Ereignishandler, den Sie für den Peek-Vorgang erstellen. Der Ereignishandler kann Funktionen enthalten, wie im folgenden C# Code gezeigt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein asynchroner Empfangsvorgang erstellt. Im Codebeispiel wird eine Nachricht an eine lokale Meldungs Warteschlange gesendet. Anschließend werden <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>aufgerufen und übergeben: ein Timeout Wert von zehn Sekunden. eine eindeutige ganze Zahl, die diese bestimmte Nachricht identifiziert. und eine neue Instanz von <xref:System.AsyncCallback>, die den Ereignishandler identifiziert, `MyReceiveCompleted`. Wenn ein <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis ausgelöst wird, empfängt der Ereignishandler die Nachricht und schreibt den Nachrichtentext und den ganzzahligen Nachrichten Bezeichner auf den Bildschirm.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, cursor As Cursor, state As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf eine verfügbare Meldung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <param name="state">Ein von der Anwendung angegebenes Zustandsobjekt, das dem asynchronen Vorgang zugeordnete Informationen enthält.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />, der die Benachrichtigung über den Abschluss des asynchronen Vorgangs erhält.</param>
        <summary>Initiiert einen asynchronen Receive-Vorgang, der über einen angegebenen Timeout verfügt und für den ein Cursor und ein Zustandsobjekt festgelegt sind. Das Zustandsobjekt stellt für die Lebensdauer des Vorgangs zugeordnete Informationen bereit. Dieser Überladung wird in einem Rückruf die Identität des Ereignishandlers für den Vorgang mitgeteilt. Der Vorgang ist abgeschlossen, wenn entweder eine Meldung in der Warteschlange verfügbar wird oder der Timeout auftritt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das die übermittelte asynchrone Anforderung bezeichnet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Überladung verwenden, wird der im Rückruf Parameter angegebene Rückruf direkt aufgerufen, wenn eine Nachricht in der Warteschlange verfügbar wird oder wenn das angegebene Zeitintervall abgelaufen ist. Das <xref:System.Messaging.MessageQueue.ReceiveCompleted>-Ereignis wird nicht ausgelöst. Die anderen über Ladungen von <xref:System.Messaging.MessageQueue.BeginReceive%2A> die auf dieser Komponente basieren, um das <xref:System.Messaging.MessageQueue.ReceiveCompleted>-Ereignis zu erhöhen.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> wird auch ausgelöst, wenn eine Nachricht bereits in der Warteschlange vorhanden ist.  
  
 Um <xref:System.Messaging.MessageQueue.BeginReceive%2A>zu verwenden, erstellen Sie einen Ereignishandler, der die Ergebnisse des asynchronen Vorgangs verarbeitet und dem Ereignis Delegaten zuordnet. <xref:System.Messaging.MessageQueue.BeginReceive%2A> initiiert einen asynchronen Empfangsvorgang. der <xref:System.Messaging.MessageQueue> wird durch das Auslösen des <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignisses benachrichtigt, wenn eine Nachricht in der Warteschlange eintrifft. Der <xref:System.Messaging.MessageQueue> kann dann auf die Nachricht zugreifen, indem Sie <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufrufen oder das Ergebnis mithilfe der <xref:System.Messaging.ReceiveCompletedEventArgs>abrufen.  
  
 Die <xref:System.Messaging.MessageQueue.BeginReceive%2A>-Methode wird sofort zurückgegeben, der asynchrone Vorgang wird jedoch erst abgeschlossen, wenn der-Ereignishandler aufgerufen wird.  
  
 Da <xref:System.Messaging.MessageQueue.BeginReceive%2A> asynchron ist, können Sie es so abrufen, dass eine Nachricht aus der Warteschlange empfangen wird, ohne dass der aktuelle Ausführungs Thread blockiert wird. Um synchron eine Nachricht zu empfangen, verwenden Sie die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode.  
  
 Wenn ein asynchroner Vorgang abgeschlossen ist, können Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A> oder <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut im Ereignishandler abrufen, um weiterhin Benachrichtigungen zu empfangen.  
  
 Der von <xref:System.Messaging.MessageQueue.BeginReceive%2A> zurückgegebene <xref:System.IAsyncResult> identifiziert den asynchronen Vorgang, den die Methode gestartet hat. Sie können diese <xref:System.IAsyncResult> während der gesamten Lebensdauer des Vorgangs verwenden, obwohl Sie Sie in der Regel erst verwenden, wenn <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> aufgerufen wird. Wenn Sie jedoch mehrere asynchrone Vorgänge starten, können Sie Ihre <xref:System.IAsyncResult> Werte in einem Array platzieren und angeben, ob auf den Abschluss aller Vorgänge oder eines Vorgangs gewartet werden soll. Verwenden Sie in diesem Fall die <xref:System.IAsyncResult.AsyncWaitHandle%2A>-Eigenschaft des <xref:System.IAsyncResult>, um den abgeschlossenen Vorgang zu identifizieren.  
  
 Das Zustands Objekt ordnet dem Vorgang Zustandsinformationen zu. Wenn Sie z. b. <xref:System.Messaging.MessageQueue.BeginReceive%2A> mehrmals aufzurufen, um mehrere Vorgänge zu initiieren, können Sie jeden Vorgang über ein separates Zustands Objekt identifizieren, das Sie definieren.  
  
 Sie können auch das State-Objekt verwenden, um Informationen über Prozessthreads hinweg zu übergeben. Wenn ein Thread gestartet wird, der Rückruf aber in einem asynchronen Szenario in einem anderen Thread erfolgt, wird das Zustands Objekt gemarshallt und zusammen mit Informationen aus dem Ereignis zurückgegeben.  
  
 Verwenden Sie den asynchronen <xref:System.Messaging.MessageQueue.BeginReceive%2A> nicht mit Transaktionen. Wenn Sie einen transaktionalen asynchronen Vorgang ausführen möchten, rufen Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A>auf, und platzieren Sie die Transaktion und die (synchrone) <xref:System.Messaging.MessageQueue.Receive%2A> Methode in dem Ereignishandler, den Sie für den Peek-Vorgang erstellen. Der Ereignishandler kann Funktionen enthalten, wie im folgenden C# Code gezeigt.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Messaging.MessageQueue" /> gelesen werden kann.</summary>
        <value><see langword="true" />, wenn die <see cref="T:System.Messaging.MessageQueue" /> vorhanden und ein Lesezugriff durch die Anwendung möglich ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> gibt an, ob die Anwendung Nachrichten aus der Warteschlange einsehen oder empfangen kann. Wenn <xref:System.Messaging.MessageQueue.CanRead%2A> `true`ist, kann der <xref:System.Messaging.MessageQueue> Nachrichten aus der Warteschlange empfangen oder einsehen. Andernfalls ist dies nicht möglich.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> ist `false`, wenn eine Warteschlange bereits mit exklusivem Lesezugriff geöffnet ist (oder wenn Sie mit einem nicht exklusiven Zugriff geöffnet ist und dieser <xref:System.Messaging.MessageQueue> exklusiven Zugriff anfordert) oder wenn die Anwendung nicht über ausreichende Zugriffsrechte für den Zugriff verfügt. Wenn die Anwendung versucht, aus einer Warteschlange zu lesen, wenn <xref:System.Messaging.MessageQueue.CanRead%2A> `false`ist, wird der Zugriff verweigert.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.CanRead%2A>-Eigenschaft einer Nachrichten Warteschlange angezeigt.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob in die <see cref="T:System.Messaging.MessageQueue" /> geschrieben werden kann.</summary>
        <value><see langword="true" />, wenn die <see cref="T:System.Messaging.MessageQueue" /> vorhanden und ein Schreibzugriff durch die Anwendung möglich ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> gibt an, ob die Anwendung Nachrichten an die Warteschlange senden kann. Wenn <xref:System.Messaging.MessageQueue.CanWrite%2A> `true`ist, kann der <xref:System.Messaging.MessageQueue> Nachrichten an die Warteschlange senden. Andernfalls ist dies nicht möglich.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> ist `false`, wenn eine Warteschlange bereits mit exklusivem Schreibzugriff geöffnet ist (oder wenn Sie mit einem nicht exklusiven Zugriff geöffnet ist und dieser <xref:System.Messaging.MessageQueue> exklusiven Zugriff anfordert) oder wenn die Anwendung nicht über ausreichende Zugriffsrechte für den Zugriff verfügt. Wenn Ihre Anwendung versucht, in eine Warteschlange zu schreiben, wenn <xref:System.Messaging.MessageQueue.CanWrite%2A> `false`ist, wird der Zugriff verweigert.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.CanWrite%2A>-Eigenschaft einer Nachrichten Warteschlange angezeigt.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Kategorie der Warteschlange ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Guid" />, die die Kategorie der Warteschlange (Message Queuing-Typenbezeichner) darstellt und mit der eine Anwendung ihre Warteschlangen kategorisieren kann. Der Standardwert ist <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der Kategorie Warteschlange kann eine Anwendung ihre Warteschlangen kategorisieren. Beispielsweise können Sie alle Abrechnungs Warteschlangen in einer Kategorie und alle Auftrags Warteschlangen in einer anderen Kategorie platzieren.  
  
 Die <xref:System.Messaging.MessageQueue.Category%2A>-Eigenschaft ermöglicht den Zugriff auf die Eigenschaft Message Queuing Typ-ID (mit Lese-/Schreibzugriff), auf die Sie über das Dialogfeld **Warteschlangen Eigenschaften** in der Computer Verwaltungskonsole zugreifen können. Sie können eine neue Kategorie definieren. Obwohl Sie mit <xref:System.Guid.NewGuid%2A> einen Kategoriewert erstellen können, der für alle <xref:System.Guid> Werte eindeutig ist, ist eine solche Aktion nicht erforderlich. Der Kategoriewert muss sich nur von anderen Kategorien unterscheiden, nicht von allen anderen <xref:System.Guid> Werten. Beispielsweise können Sie {00000000-0000-0000-0000-000000000001} als <xref:System.Messaging.MessageQueue.Category%2A> für einen Satz von Warteschlangen zuweisen und als <xref:System.Messaging.MessageQueue.Category%2A> für eine andere Gruppe {00000000-0000-0000-0000-000000000002}.  
  
 Das <xref:System.Messaging.MessageQueue.Category%2A>muss nicht festgelegt werden. Der Wert kann `null` sein.  
  
 Wenn Sie diese Eigenschaft festlegen, ändert sich die Message Queuing Warteschlange. Aus diesem Grund sind alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.Category%2A>-Eigenschaft einer Nachrichten Warteschlange abgerufen und festgelegt.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Kategorie der Warteschlange wurde auf einen ungültigen Wert festgelegt.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht den Verbindungscache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>aufrufen, werden die im Cache gespeicherten Format Namen entfernt, und die im Cache geöffneten und gespeicherten Handles werden geschlossen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Ja|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A> aufgerufen.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der <see cref="T:System.Messaging.MessageQueue" /> reservierten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> gibt alle einer <xref:System.Messaging.MessageQueue>zugeordneten Ressourcen frei, einschließlich der freigegebenen Ressourcen. Diese Ressourcen werden vom System automatisch erneut angefordert, wenn Sie weiterhin verfügbar sind, beispielsweise wenn Sie die <xref:System.Messaging.MessageQueue.Send%28System.Object%29>-Methode wie im folgenden C# Code aufgerufen haben.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 Wenn Sie <xref:System.Messaging.MessageQueue.Close%2A>aufrufen, werden alle <xref:System.Messaging.MessageQueue> Eigenschaften, die direkt auf die Message Queuing Warteschlange zugreifen, gelöscht. Die <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>und <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> bleiben unverändert.  
  
 die Lese-und Schreib Handles werden von <xref:System.Messaging.MessageQueue.Close%2A> nicht immer in einer Warteschlange freigegeben, da Sie möglicherweise freigegeben werden. Sie können einen der folgenden Schritte ausführen, um sicherzustellen, dass <xref:System.Messaging.MessageQueue.Close%2A> die Lese-und Schreib Handles in einer Warteschlange freigibt:  
  
-   Erstellen Sie die <xref:System.Messaging.MessageQueue> mit exklusivem Zugriff. Hierzu müssen Sie den <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29>-oder <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>-Konstruktor aufrufen und den `sharedModeDenyReceive`-Parameter auf `true`festlegen.  
  
-   Erstellen Sie die <xref:System.Messaging.MessageQueue> mit deaktiviertem Verbindungs Caching. Dazu müssen Sie den <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>-Konstruktor aufrufen und den `enableConnectionCache`-Parameter auf `false`festlegen.  
  
-   Deaktivieren Sie die Verbindungs Zwischenspeicherung. Legen Sie zu diesem Zweck die <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>-Eigenschaft auf `false`fest.  
  
 Sie sollten <xref:System.Messaging.MessageQueue.Close%2A> für eine Warteschlange anrufen, bevor Sie die Warteschlange auf dem Message Queuing Server löschen. Andernfalls könnten an die Warteschlange gesendete Nachrichten Ausnahmen auslösen oder in der Warteschlange für unzustellbare Nachrichten angezeigt werden.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Ja|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Message Queuing Warteschlange geschlossen.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Warteschlange unter dem angegebenen Pfad auf einem Message Queuing-Server.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der zu erstellenden Warteschlange.</param>
        <summary>Erstellt eine nicht transaktionale Message Queuing-Warteschlange unter dem angegebenen Pfad.</summary>
        <returns>Eine <see cref="T:System.Messaging.MessageQueue" />, die die neue Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine nicht transaktionale Message Queuing Warteschlange zu erstellen.  
  
 Um eine neue Instanz der <xref:System.Messaging.MessageQueue>-Klasse in der Anwendung zu erstellen und Sie an eine vorhandene Warteschlange zu binden, verwenden Sie den <xref:System.Messaging.MessageQueue.%23ctor%2A>-Konstruktor. Um eine neue Warteschlange in Message Queuing zu erstellen, rufen Sie <xref:System.Messaging.MessageQueue.Create%28System.String%29>auf.  
  
 Die Syntax für den `path`-Parameter hängt vom Typ der Warteschlange ab, auf die er verweist, wie in der folgenden Tabelle dargestellt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|Öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|Private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
  
 Verwenden Sie "." für den lokalen Computer. Weitere Informationen zur Syntax finden Sie in der <xref:System.Messaging.MessageQueue.Path%2A>-Eigenschaft.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden öffentliche und private Warteschlangen erstellt. Es sendet eine Meldung an ausgewählte Warteschlangen.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist <see langword="null" /> oder eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Unter dem angegebenen Pfad ist bereits eine Warteschlange vorhanden.  
  
 - oder -  
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der zu erstellenden Warteschlange.</param>
        <param name="transactional"><see langword="true" />, um eine transaktionale Warteschlange zu erstellen, oder <see langword="false" />, wenn eine nicht transaktionale Warteschlange erstellt werden soll.</param>
        <summary>Erstellt eine transaktionale oder eine nicht transaktionale Message Queuing-Warteschlange unter dem angegebenen Pfad.</summary>
        <returns>Eine <see cref="T:System.Messaging.MessageQueue" />, die die neue Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Überladung können Sie eine transaktionale Warteschlange in Message Queuing erstellen. Sie können eine nicht transaktionale Warteschlange erstellen, indem Sie den `transactional`-Parameter auf `false` festlegen oder indem Sie die andere Überladung von <xref:System.Messaging.MessageQueue.Create%28System.String%29>aufrufen.  
  
 Um eine neue Instanz der <xref:System.Messaging.MessageQueue>-Klasse in der Anwendung zu erstellen und Sie an eine vorhandene Warteschlange zu binden, verwenden Sie den <xref:System.Messaging.MessageQueue.%23ctor%2A>-Konstruktor. Um eine neue Warteschlange in Message Queuing zu erstellen, rufen Sie <xref:System.Messaging.MessageQueue.Create%28System.String%29>auf.  
  
 Die Syntax für den `path`-Parameter hängt vom Typ der Warteschlange ab, auf die er verweist, wie in der folgenden Tabelle dargestellt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|Öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|Private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
  
 Verwenden Sie "." für den lokalen Computer. Weitere Informationen zur Syntax finden Sie in der <xref:System.Messaging.MessageQueue.Path%2A>-Eigenschaft.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden öffentliche und private Transaktions Warteschlangen erstellt. Es sendet eine Meldung an ausgewählte Warteschlangen.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist <see langword="null" /> oder eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Unter dem angegebenen Pfad ist bereits eine Warteschlange vorhanden.  
  
 - oder -  
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Messaging.Cursor" /> für die aktuelle Meldungswarteschlange.</summary>
        <returns>Ein neuer <see cref="T:System.Messaging.Cursor" /> für die aktuelle Meldungswarteschlange. Mithilfe des Cursors kann beim Lesen der Warteschlangenmeldungen eine bestimmte Position in der Warteschlange beibehalten werden.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Zeit und Datum der Erstellung der Warteschlange in Message Queuing ab.</summary>
        <value>Eine <see cref="T:System.DateTime" />, die Erstellungsdatum und -uhrzeit der Warteschlange darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> verweist auf die Warteschlange auf dem Message Queuing Server, nicht auf die <xref:System.Messaging.MessageQueue> Instanz.  
  
 Wenn die Warteschlange vorhanden ist, stellt diese Eigenschaft den Zeitpunkt dar, zu dem die Warteschlange erstellt wurde, und zwar entsprechend der lokalen Zeit des Servers, auf dem die Warteschlange vorhanden ist.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.CreateTime%2A>-Eigenschaft einer Nachrichten Warteschlange angezeigt.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Eigenschaftswerte für Meldungen ab, die beim Senden einer Meldung an die Warteschlange standardmäßig verwendet werden.</summary>
        <value>Ein <see cref="T:System.Messaging.DefaultPropertiesToSend" /> mit den Standardeigenschaftswerten für Meldungen in Message Queuing, die verwendet werden, wenn die Anwendung andere Objekte als <see cref="T:System.Messaging.Message" />-Instanzen an die Warteschlange sendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Objekt, das nicht vom Typ <xref:System.Messaging.Message> ist, an die Warteschlange senden, fügt das <xref:System.Messaging.MessageQueue> das Objekt in eine Message Queuing Nachricht ein. Zu diesem Zeitpunkt gilt die <xref:System.Messaging.MessageQueue> für die Meldung die Eigenschaftswerte, die Sie in der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>-Eigenschaft angeben. Wenn Sie hingegen eine <xref:System.Messaging.Message> an die Warteschlange senden, werden diese Eigenschaften bereits für die Instanz selbst angegeben, sodass <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> für die <xref:System.Messaging.Message>ignoriert wird.  
  
 Obwohl Sie die Eigenschaften über das <xref:System.Messaging.MessageQueue> Objekt festlegen, bezieht sich der <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> auf die Eigenschaften der Nachrichten, die an die Warteschlange gesendet werden, nicht an die Warteschlange selbst.  
  
 Die Standardwerte für die Eigenschaften sind in der folgenden Tabelle aufgeführt.  
  
|Eigenschaft|Standardwert|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|Null (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|Ein Bytearray der Länge 0 (null).|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|leere Zeichenfolge ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Ja|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Priorität einer Nachricht verwendet, um die Standardeigenschaften zu bestimmen, die für die Nachricht gesendet werden sollen.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Standardeigenschaften konnten für diese Warteschlange nicht festgelegt werden. Möglicherweise ist eine der Eigenschaften ungültig.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der zu löschenden Warteschlange.</param>
        <summary>Löschte eine Warteschlange auf einem Message Queuing-Server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Syntax für den `path`-Parameter hängt vom Typ der Warteschlange ab.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|Öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|Private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
  
 Weitere Informationen zur Syntax finden Sie in der <xref:System.Messaging.MessageQueue.Path%2A>-Eigenschaft.  
  
 Alternativ können Sie die <xref:System.Messaging.MessageQueue.FormatName%2A> oder <xref:System.Messaging.MessageQueue.Label%2A> verwenden, um den Warteschlangen Pfad zu beschreiben.  
  
|Referenz|Syntax|  
|---------------|------------|  
|Formatname|Format Name: [ *Format Name* ]|  
|Bezeichnung|Bezeichnung: [ *Bezeichnung* ]|  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Message Queuing Warteschlange gelöscht, sofern vorhanden.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist <see langword="null" /> oder eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Syntax für den <paramref name="path" />-Parameter ist ungültig.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob diese <see cref="T:System.Messaging.MessageQueue" /> über exklusive Zugriffsrechte für das Empfangen von Meldungen aus der Message Queuing-Warteschlange verfügt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn diese <see cref="T:System.Messaging.MessageQueue" /> über exklusive Zugriffsrechte für das Empfangen von Meldungen aus der Warteschlange verfügt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> gibt den freigegebenen Modus der Warteschlange an, auf die von diesem <xref:System.Messaging.MessageQueue>verwiesen wird. Legen Sie <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> auf `true` fest, um anzugeben, dass nur dieser <xref:System.Messaging.MessageQueue> Zugriff haben soll, um Nachrichten aus der Warteschlange mit dem angegebenen <xref:System.Messaging.MessageQueue.Path%2A>einsehen oder empfangen zu können. Wenn eine andere <xref:System.Messaging.MessageQueue> oder eine andere Anwendung derselben Warteschlangen Ressource zugeordnet ist, kann diese Instanz oder Anwendung keine Nachrichten einsehen oder empfangen, Sie kann jedoch dennoch gesendet werden.  
  
 Wenn <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> `false`ist, steht die Warteschlange mehreren Anwendungen zum Senden, übermitteln oder empfangen von Nachrichten zur Verfügung.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Ja|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.DenySharedReceive%2A>-Eigenschaft einer Nachrichten Warteschlange abgerufen und festgelegt.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von der <see cref="T:System.Messaging.MessageQueue" />-Klasse verwendeten Ressourcen (mit Ausnahme des Speichers) frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> auf, wenn Sie <xref:System.Messaging.MessageQueue> nicht mehr benötigen. Die <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>-Methode bewirkt, dass <xref:System.Messaging.MessageQueue> nicht mehr verwendet werden kann. Nachdem Sie <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>aufgerufen haben, müssen Sie alle Verweise auf die <xref:System.Messaging.MessageQueue> freigeben, damit der Arbeitsspeicher, den Sie belegen, von Garbage Collection freigegeben werden kann.  
  
 Sie sollten <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> anrufen, bevor Sie den letzten Verweis auf die <xref:System.Messaging.MessageQueue>freigeben. Andernfalls werden die Ressourcen, die von der <xref:System.Messaging.MessageQueue> verwendet werden, erst freigegeben, wenn Garbage Collection den Dekonstruktor des <xref:System.Messaging.MessageQueue> Objekts aufruft.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Anwendung einen Verbindungscache verwaltet, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn ein Verbindungscache erstellt und verwendet wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Verbindungs Cache ist eine Liste von Verweisen auf Strukturen, die Lese-oder Schreib Handles für Warteschlangen enthalten. Wenn <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> `true`ist, werden bei jedem Aufrufen von <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>oder <xref:System.Messaging.MessageQueue.Receive%2A>, anstatt neue Handles zu öffnen, Handles aus dem Cache vom <xref:System.Messaging.MessageQueue>. Dies kann die Leistung verbessern. Die Verwendung eines Verbindungs Caches isoliert auch die <xref:System.Messaging.MessageQueue> von Änderungen in der Netzwerktopologie.  
  
 Wenn Sie eine neue Verbindung mit einer Warteschlange erstellen, wenn der Verbindungs Cache voll ist, überschreibt der <xref:System.Messaging.MessageQueue> die-Struktur, auf die zuletzt zugegriffen wurde, mit der neuen Verbindung. Sie können den Cache vollständig löschen, indem Sie <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>aufrufen, z. b. wenn die Format Namen der Warteschlangen, mit denen Sie arbeiten, so geändert wurden, dass die vorherigen Lese-und Schreib Handles nicht mehr gültig sind.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Ja|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>-Eigenschaft einer Nachrichten Warteschlange abgerufen und festgelegt.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Warteschlange lediglich nicht private (nicht verschlüsselte) Meldungen akzeptiert, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Messaging.EncryptionRequired" />-Werte. Der Standardwert ist <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie angeben, dass die Verschlüsselung für die an eine Warteschlange gesendeten Nachrichten erforderlich ist, werden nur die Nachrichtentexte verschlüsselt. Die anderen Member (z. b. die Eigenschaften <xref:System.Messaging.Message.Label%2A> und <xref:System.Messaging.Message.SenderId%2A>) können nicht verschlüsselt werden.  
  
 Wenn Sie diese Eigenschaft festlegen, ändert sich die Message Queuing Warteschlange. Aus diesem Grund sind alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen.  
  
 Durch das Verschlüsseln einer Nachricht wird die Nachricht als privat angezeigt. Sie können die Verschlüsselungs Anforderung der Warteschlange so angeben, dass Sie `None`, `Body`oder `Optional` werden soll, indem Sie die <xref:System.Messaging.MessageQueue.EncryptionRequired%2A>-Eigenschaft entsprechend festlegen. Die <xref:System.Messaging.Message.UseEncryption%2A> Einstellung der Nachricht muss mit der Verschlüsselungs Anforderung der Warteschlange übereinstimmen. Wenn die Nachricht nicht verschlüsselt ist, aber die Warteschlange `Body`angibt, oder wenn die Nachricht verschlüsselt ist, aber in der Warteschlange `None`angegeben ist, wird die Nachricht von der Warteschlange abgelehnt. Wenn die sendende Anwendung in diesem Ereignis eine negative Bestätigungsnachricht anfordert, gibt Message Queuing die Ablehnung der Nachricht an die sendende Anwendung an. Wenn die <xref:System.Messaging.Message.UseDeadLetterQueue%2A>-Eigenschaft `true`ist, wird eine Meldung, die nicht verschlüsselt werden kann, an die Warteschlange für unzustellbare Nachrichten gesendet Andernfalls geht die Nachricht verloren.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.EncryptionRequired%2A>-Eigenschaft einer Nachrichten Warteschlange abgerufen und festgelegt.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das den abzuschließenden asynchronen Lesevorgang bestimmt und über das das Endergebnis abgerufen werden kann.</param>
        <summary>Schließt den angegebenen asynchronen Lesevorgang ab.</summary>
        <returns>Die dem abgeschlossenen asynchronen Vorgang zugeordnete <see cref="T:System.Messaging.Message" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das <xref:System.Messaging.MessageQueue.PeekCompleted>-Ereignis ausgelöst wird, schließt <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> den Vorgang ab, der durch den <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Befehl initiiert wurde. Zu diesem Zweck <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> die Nachricht ein.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> können einen Timeout Wert angeben, der bewirkt, dass das <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis ausgelöst wird, wenn das Timeout auftritt, bevor eine Nachricht in der Warteschlange angezeigt wird. Wenn ein Timeout auftritt, ohne dass eine Nachricht in der Warteschlange eintrifft, wird bei einem nachfolgenden Aufruf von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> eine Ausnahme ausgelöst.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wird zum Lesen der Nachricht verwendet, die bewirkt hat, dass das <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis ausgelöst wurde.  
  
 Wenn Sie Nachrichten fortsetzen möchten, können Sie <xref:System.Messaging.MessageQueue.BeginPeek%2A> nach dem Aufrufen von <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>erneut aufrufen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignishandler mit dem Namen `MyPeekCompleted`erstellt, an den <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignishandlerdelegaten angehängt und <xref:System.Messaging.MessageQueue.BeginPeek%2A> aufgerufen, um einen asynchronen Peek-Vorgang in der Warteschlange zu initiieren, die sich im Pfad ".\MyQueue" befindet. Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis ausgelöst wird, zeigt das Beispiel die Nachricht an und schreibt Ihren Text auf den Bildschirm. Im Beispiel wird dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aufgerufen, um einen neuen asynchronen Peek-Vorgang zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="asyncResult" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="asyncResult" />-Parameters ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das die abzuschließende asynchrone Receive-Methode bestimmt und über das das Ergebnis abgerufen werden kann.</param>
        <summary>Schließt die angegebene asynchrone Receive-Methode ab.</summary>
        <returns>Die dem abgeschlossenen asynchronen Vorgang zugeordnete <see cref="T:System.Messaging.Message" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das <xref:System.Messaging.MessageQueue.ReceiveCompleted>-Ereignis ausgelöst wird, schließt <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> den Vorgang ab, der durch den <xref:System.Messaging.MessageQueue.BeginReceive%2A>-Befehl initiiert wurde. Zu diesem Zweck empfängt <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> die Nachricht.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> können einen Timeout Wert angeben, der bewirkt, dass das <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis ausgelöst wird, wenn das Timeout auftritt, bevor eine Nachricht in der Warteschlange angezeigt wird. Wenn ein Timeout auftritt, ohne dass eine Nachricht in der Warteschlange eintrifft, wird bei einem nachfolgenden Aufruf von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> eine Ausnahme ausgelöst.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> wird verwendet, um die Meldung zu lesen (aus der Warteschlange zu entfernen), die bewirkt hat, dass das <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis ausgelöst wurde.  
  
 Wenn Sie Nachrichten weiterhin asynchron empfangen möchten, können Sie <xref:System.Messaging.MessageQueue.BeginReceive%2A> nach dem Aufrufen von <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>erneut aufrufen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden asynchrone Anforderungen verkettet. Es wird davon ausgegangen, dass auf dem lokalen Computer eine Warteschlange mit dem Namen "myQueue" vorhanden ist. Die `Main`-Funktion startet den asynchronen Vorgang, der von der `MyReceiveCompleted`-Routine verarbeitet wird. `MyReceiveCompleted` verarbeitet die aktuelle Nachricht und startet einen neuen asynchronen Empfangsvorgang.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="asyncResult" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="asyncResult" />-Parameters ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Speicherort der gesuchten Warteschlange.</param>
        <summary>Bestimmt, ob unter dem angegeben Pfad eine Message Queuing-Warteschlange vorhanden ist.</summary>
        <returns><see langword="true" />, wenn unter dem angegebenen Pfad eine Warteschlange vorhanden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.Exists%28System.String%29>-Methode bestimmt, ob eine Message Queuing Warteschlange an einem angegebenen Pfad vorhanden ist. Es ist keine Methode vorhanden, um zu bestimmen, ob eine Warteschlange mit einem angegebenen Format Namen vorhanden ist. Weitere Informationen zur Syntax von Format Namen und anderen Pfad Syntax Formularen finden Sie in der <xref:System.Messaging.MessageQueue.Path%2A>-Eigenschaft.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> ist ein kostspieliger Vorgang. Verwenden Sie Sie nur, wenn dies innerhalb der Anwendung erforderlich ist.  
  
> [!NOTE]
>  Das <xref:System.Messaging.MessageQueue.FormatName%2A>-Präfix wird von der <xref:System.Messaging.MessageQueue.Exists%28System.String%29>-Methode nicht unterstützt.  
  
 Die Syntax für den `path`-Parameter hängt vom Typ der Warteschlange ab, wie in der folgenden Tabelle gezeigt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|Öffentliche Warteschlange|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> kann nicht aufgerufen werden, um das vorhanden sein einer privaten Remote Warteschlange zu überprüfen.  
  
 Weitere Informationen zur Syntax finden Sie in der <xref:System.Messaging.MessageQueue.Path%2A>-Eigenschaft.  
  
 Alternativ können Sie den <xref:System.Messaging.MessageQueue.Label%2A> verwenden, um den Warteschlangen Pfad zu beschreiben.  
  
|Referenz|Syntax|  
|---------------|------------|  
|Bezeichnung|Bezeichnung: [`label`]|  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Nein|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob eine Message Queuing Warteschlange vorhanden ist, und Sie wird dann gelöscht.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <paramref name="path" />-Syntax ist ungültig.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.  
  
- oder - 
Die <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" />-Methode wird für eine private Remotewarteschlange aufgerufen.</exception>
        <exception cref="T:System.InvalidOperationException">In der Anwendung wurde eine Syntax für Formatnamen verwendet, um das Vorhandensein der Warteschlange zu überprüfen.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den eindeutigen Namen der Warteschlange ab, den Message Queuing beim Erstellen der Warteschlange erzeugt hat.</summary>
        <value>Der im Netzwerk eindeutige Name der Warteschlange.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.FormatName%2A>-Eigenschaft enthält den Format Namen der Warteschlange. Message Queuing verwendet den Format Namen, um zu ermitteln, welche Warteschlange geöffnet werden soll und wie darauf zugegriffen werden kann. Im Gegensatz zu den meisten Merkmalen einer Warteschlange ist der Format Name keine Message Queuing Anwendungs Warteschlangen-Eigenschaft, sodass Sie nicht über das Message Queuing Verwaltungs Tool darauf zugreifen können. Der Format Name ist einfach ein eindeutiger Name für die Warteschlange, der Message Queuing generiert, wenn er die Warteschlange erstellt oder die Anwendung zu einem späteren Zeitpunkt generiert wird.  
  
 Wenn Sie einen Pfad mit der Syntax für den Pfadnamen angeben (z. b. `myComputer\myQueue`), anstatt die Format Namen Syntax beim Lesen oder schreiben in die Warteschlange zu verwenden, übersetzt der primäre Domänen Controller (der Active Directory verwendet) die <xref:System.Messaging.MessageQueue.Path%2A> in die zugeordnete <xref:System.Messaging.MessageQueue.FormatName%2A>, bevor Sie auf die Warteschlange zugreifen. Wenn Ihre Anwendung offline arbeitet, müssen Sie die Format Namen Syntax verwenden. Andernfalls ist der primäre Domänen Controller nicht zum Ausführen der Pfad Übersetzung verfügbar.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Ja|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.FormatName%2A>-Eigenschaft einer Nachrichten Warteschlange angezeigt.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> ist nicht festgelegt.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Formatierungsprogramm ab, oder legt das Formatierungsprogramm fest, das zum Serialisieren und Deserialisieren eines Objekts in bzw. aus dem Körper einer Meldung verwendet wird, die aus einer Warteschlange gelesen oder in eine Warteschlange geschrieben wird.</summary>
        <value>Der <see cref="T:System.Messaging.IMessageFormatter" />, der den Stream erstellt, der in den Meldungstext geschrieben oder aus diesem gelesen werden soll. Der Standardwert ist <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.Formatter%2A>-Eigenschaft enthält eine Instanz eines Formatiererobjekts, das Nachrichten transformiert, wenn Ihre Anwendung Lese-oder Schreibvorgänge in die Warteschlange durchsetzt.  
  
 Wenn die Anwendung eine Nachricht an die Warteschlange sendet, serialisiert der Formatierer das Objekt in einen Stream und fügt es in den Nachrichtentext ein. Beim Lesen aus einer Warteschlange deserialisiert der Formatierer die Nachrichten Daten in die <xref:System.Messaging.Message.Body%2A>-Eigenschaft einer <xref:System.Messaging.Message>.  
  
 Der <xref:System.Messaging.XmlMessageFormatter> ist lose gekoppelt, sodass es nicht erforderlich ist, bei Verwendung dieses Formats denselben Objekttyp für den Absender und den Empfänger zu verwenden. Der <xref:System.Messaging.ActiveXMessageFormatter> und <xref:System.Messaging.BinaryMessageFormatter> die Daten in die binäre Darstellung serialisieren. Beim Senden oder empfangen von COM-Komponenten wird der <xref:System.Messaging.ActiveXMessageFormatter> verwendet.  
  
 <xref:System.Messaging.BinaryMessageFormatter> und <xref:System.Messaging.ActiveXMessageFormatter> bieten einen schnelleren Durchsatz als die <xref:System.Messaging.XmlMessageFormatter>. Der-<xref:System.Messaging.ActiveXMessageFormatter> ermöglicht die Interoperabilität mit Visual Basic 6,0 Message Queuing-Anwendungen.  
  
 Wenn die Anwendung Nachrichten an die Warteschlange sendet, gilt der <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> nur für die Nachrichten, die die Standard Nachrichten Eigenschaften <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>verwenden. Wenn Sie ein <xref:System.Messaging.Message> an die Warteschlange senden, verwendet Message Queuing den Formatierer, der in der <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>-Eigenschaft definiert ist, um stattdessen den Text zu serialisieren.  
  
 Die <xref:System.Messaging.MessageQueue>-Klasse verwendet immer eine <xref:System.Messaging.Message>, um eine Nachricht aus der Warteschlange zu empfangen oder zu einsehen. Die Nachricht wird mit der <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>-Eigenschaft deserialisiert.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Formatieren eines Nachrichten Texts mithilfe von <xref:System.Messaging.BinaryMessageFormatter>veranschaulicht.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Im folgenden Codebeispiel wird das Formatieren eines Nachrichten Texts mithilfe von <xref:System.Messaging.XmlMessageFormatter>veranschaulicht.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle Meldungen in der Warteschlange zurück.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Messaging.Message" />, das alle Meldungen aus der Warteschlange darstellt. Die Reihenfolge entspricht der Reihenfolge in der Message Queuing-Warteschlange.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> gibt eine statische Momentaufnahme der Nachrichten in der Warteschlange zurück, nicht dynamische Links zu diesen Nachrichten. Daher können Sie das Array nicht verwenden, um die Nachrichten in der Warteschlange zu ändern. Wenn Sie in Echtzeit dynamische Interaktionen mit der Warteschlange (z. b. die Möglichkeit zum Löschen von Nachrichten) wünschen, müssen Sie die <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>-Methode abrufen, die eine dynamische Liste der Nachrichten in der Warteschlange zurückgibt.  
  
 Da <xref:System.Messaging.MessageQueue.GetAllMessages%2A> eine Kopie der Nachrichten in der Warteschlange zum Zeitpunkt des Aufrufs der-Methode zurückgibt, reflektiert das Array keine neuen Nachrichten, die in der Warteschlange eintreffen, oder Nachrichten, die aus der Warteschlange entfernt werden.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> ruft nur die Eigenschaften ab, die von der <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>-Eigenschaft nicht herausgefiltert wurden.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Listet die Meldungen in einer Warteschlange auf. <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> ist veraltet. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> sollte stattdessen verwendet werden.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />, der eine dynamische Verbindung mit den Meldungen in der Warteschlange bereitstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Name des Computers, der die Warteschlange enthält, ohne die zwei führenden umgekehrten Schrägstriche (\\\\).</param>
        <summary>Ruft den Computerbezeichner ab, auf dem sich die Warteschlange befindet, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist.</summary>
        <returns>Eine <see cref="T:System.Guid" />, die einen eindeutigen Bezeichner für den Computer darstellt, auf dem sich die Warteschlange befindet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den Bezeichner eines Computers für zwei Zwecke verwenden: zum Lesen des Computer Journals und zum Festlegen von Sicherheitszertifikaten. Es ist jedoch nicht möglich, <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> für einen Remote Computer aufzurufen, wenn Sie offline arbeiten, da die Anwendung Zugriff auf den Verzeichnisdienst auf dem Domänen Controller haben muss.  
  
 Der Computer Bezeichner (oder Computer Bezeichner) ist eine <xref:System.Guid>, die Message Queuing erstellt, wenn dem Unternehmen ein Computer hinzugefügt wird. Message Queuing kombiniert den Computer Bezeichner mit den Schlüsselwörtern `Machine` und `Journal`, um den Format Namen des Computer Journals zu erstellen, der über die Syntax `Machine=<computeridentifier>;Journal`verfügt. Das Computer Journal, das auch als Journal Warteschlange bezeichnet wird, ist eine System Warteschlange, die Kopien der von der Anwendung generierten Nachrichten speichert, wenn die <xref:System.Messaging.MessageQueue.UseJournalQueue%2A>-Eigenschaft `true`ist.  
  
 Diese Syntax für das Journal ist nur gültig, wenn der Format Name für die Warteschlange erstellt wird. Die Syntax für den Pfadnamen ist `MachineName`\\`Journal$`.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Name des lokalen Computers und des direkten Formats|Nein|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> aufgerufen.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Der Computerbezeichner konnte nicht abgerufen werden. Möglicherweise ist der Verzeichnisdienst nicht verfügbar (z. B. während der Ausführung im Offlinebetrieb).  
  
 - oder -  
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein Enumerationsobjekt für alle Meldungen in der Warteschlange. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> ist veraltet. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> sollte stattdessen verwendet werden.</summary>
        <returns>Ein <see cref="T:System.Messaging.MessageEnumerator" /> mit den in der Warteschlange enthaltenen Meldungen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> erstellt eine dynamische Liste aller Nachrichten in einer Warteschlange. Sie können die Nachricht aus der Warteschlange an der aktuellen Position des Enumerators entfernen, indem Sie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> für die <xref:System.Messaging.MessageEnumerator> aufrufen, die <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> zurückgibt.  
  
 Da der Cursor der dynamischen Liste von Nachrichten in der Warteschlange zugeordnet ist, spiegelt die Enumeration alle Änderungen wider, die Sie an den Nachrichten in der Warteschlange vornehmen, wenn die Nachricht außerhalb der aktuellen Cursorposition liegt. Der Enumerator kann z. b. automatisch auf eine Nachricht mit niedrigerer Priorität über die aktuelle Position des Cursors zugreifen, aber keine Nachricht mit höherer Priorität, die vor dieser Position eingefügt wird. Sie können jedoch die Enumeration zurücksetzen und den Cursor zurück an den Anfang der Liste bewegen, indem Sie <xref:System.Messaging.MessageEnumerator.Reset%2A> für die <xref:System.Messaging.MessageEnumerator>aufrufen.  
  
 Die Reihenfolge der Nachrichten in der-Enumeration spiegelt ihre Reihenfolge in der Warteschlange wider, sodass Nachrichten mit höherer Priorität vor einer niedrigeren Priorität angezeigt werden.  
  
 Wenn Sie eine statische Momentaufnahme der Nachrichten in der Warteschlange anstatt einer dynamischen Verbindung zu diesen erstellen möchten, wenden Sie <xref:System.Messaging.MessageQueue.GetAllMessages%2A>an. Diese Methode gibt ein Array von <xref:System.Messaging.Message>-Objekten zurück, die die Nachrichten zum Zeitpunkt des Aufrufs der-Methode darstellen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Ja|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine dynamische Liste von Nachrichten in einer Warteschlange abgerufen und alle Nachrichten gezählt, deren <xref:System.Messaging.Message.Priority%2A>-Eigenschaft auf <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>festgelegt ist.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein Enumerationsobjekt für alle Meldungen in der Warteschlange.</summary>
        <returns>Ein <see cref="T:System.Messaging.MessageEnumerator" /> mit den in der Warteschlange enthaltenen Meldungen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> erstellt eine dynamische Liste aller Nachrichten in einer Warteschlange. Sie können die Nachricht aus der Warteschlange an der aktuellen Position des Enumerators entfernen, indem Sie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> für die <xref:System.Messaging.MessageEnumerator> aufrufen, die <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> zurückgibt.  
  
 Da der Cursor der dynamischen Liste von Nachrichten in der Warteschlange zugeordnet ist, spiegelt die Enumeration alle Änderungen wider, die Sie an den Nachrichten in der Warteschlange vornehmen, wenn die Nachricht außerhalb der aktuellen Cursorposition liegt. Der Enumerator kann z. b. automatisch auf eine Nachricht mit niedrigerer Priorität über die aktuelle Position des Cursors zugreifen, aber keine Nachricht mit höherer Priorität, die vor dieser Position eingefügt wird. Sie können jedoch die Enumeration zurücksetzen und den Cursor zurück an den Anfang der Liste bewegen, indem Sie <xref:System.Messaging.MessageEnumerator.Reset%2A> für die <xref:System.Messaging.MessageEnumerator>aufrufen.  
  
 Die Reihenfolge der Nachrichten in der-Enumeration spiegelt ihre Reihenfolge in der Warteschlange wider, sodass Nachrichten mit höherer Priorität vor einer niedrigeren Priorität angezeigt werden.  
  
 Wenn Sie eine statische Momentaufnahme der Nachrichten in der Warteschlange anstatt einer dynamischen Verbindung zu diesen erstellen möchten, wenden Sie <xref:System.Messaging.MessageQueue.GetAllMessages%2A>an. Diese Methode gibt ein Array von <xref:System.Messaging.Message>-Objekten zurück, die die Nachrichten zum Zeitpunkt des Aufrufs der-Methode darstellen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Ja|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Enumerationsobjekt für eine dynamische Liste der öffentlichen Warteschlangen im Netzwerk.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt eine Vorwärts-Cursorsemantik zum Durchlaufen aller öffentlichen Warteschlangen im Netzwerk bereit.</summary>
        <returns>Ein <see cref="T:System.Messaging.MessageQueueEnumerator" />, der eine dynamische Liste aller öffentlichen Meldungswarteschlangen im Netzwerk bereitstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung von <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> gibt eine Enumeration aller öffentlichen Warteschlangen im Netzwerk zurück.  
  
 Da der Cursor einer dynamischen Auflistung zugeordnet ist, spiegelt die Enumeration alle Änderungen wider, die Sie an einer Warteschlangen Liste für Warteschlangen vornehmen, die nach der aktuellen Position des Cursors gelöscht oder hinzugefügt wurden. Das Hinzufügen oder Löschen von Warteschlangen, die sich vor der aktuellen Position des Cursors befinden, wird nicht berücksichtigt. Beispielsweise kann der Enumerator automatisch auf eine Warteschlange zugreifen, die über die Cursorposition hinaus angefügt ist, aber nicht vor dieser Position eingefügt wird. Sie können jedoch die Enumeration zurücksetzen und den Cursor zurück an den Anfang der Liste bewegen, indem Sie <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> für die <xref:System.Messaging.MessageQueueEnumerator>aufrufen.  
  
 Es gibt keine definierte Reihenfolge von Warteschlangen in einem Netzwerk. Ein Enumerator sortiert Sie z. b. nicht nach Computer, Bezeichnung, öffentlichem oder privatem Status oder anderen zugänglichen Kriterien.  
  
 Wenn Sie anstelle einer dynamischen Verbindung eine statische Momentaufnahme der Warteschlangen im Netzwerk benötigen, wenden Sie <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> oder <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>an. Jede dieser beiden Methoden gibt ein Array von <xref:System.Messaging.MessageQueue>-Objekten zurück, die die Warteschlangen zum Zeitpunkt des Aufrufs der-Methode darstellen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Name des lokalen Computers und des direkten Formats|Nein|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle Nachrichten Warteschlangen im Netzwerk durchlaufen und der Pfad für die einzelnen Warteschlangen überprüft. Schließlich wird die Anzahl der öffentlichen Warteschlangen im Netzwerk angezeigt.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Ein <see cref="T:System.Messaging.MessageQueueCriteria" />, das die Kriterien zum Filtern der verfügbaren Meldungswarteschlangen enthält.</param>
        <summary>Stellt eine Vorwärts-Cursorsemantik zum Durchlaufen aller öffentlichen Warteschlangen im Netzwerk bereit, die die angegebenen Kriterien erfüllen.</summary>
        <returns>Ein <see cref="T:System.Messaging.MessageQueueEnumerator" />, der eine dynamische Liste der öffentlichen Meldungswarteschlangen im Netzwerk bereitstellt, die die im <paramref name="criteria" />-Parameter angegebenen Bedingungen erfüllen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung von <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> gibt eine Auflistung aller öffentlichen Warteschlangen im Netzwerk zurück, die Kriterien erfüllen, die in den Anwendungskriterien definiert sind. Sie können die einzuschließenden Kriterien angeben, z. b. Warteschlangen Erstellung oder Änderungszeit, Computername, Bezeichnung, Kategorie oder eine beliebige Kombination dieser Werte.  
  
 Da der Cursor einer dynamischen Auflistung zugeordnet ist, spiegelt die Enumeration alle Änderungen wider, die Sie an einer Warteschlange vornehmen, die hinter der aktuellen Position des Cursors liegt. Änderungen an Warteschlangen, die sich vor der aktuellen Position des Cursors befinden, werden nicht widergespiegelt. Beispielsweise kann der Enumerator automatisch auf eine Warteschlange zugreifen, die über die Cursorposition hinaus angefügt ist, aber nicht vor dieser Position eingefügt wird. Sie können jedoch die Enumeration zurücksetzen und den Cursor zurück an den Anfang der Liste bewegen, indem Sie <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> für die <xref:System.Messaging.MessageQueueEnumerator>aufrufen.  
  
 Es gibt keine definierte Reihenfolge von Warteschlangen in einem Netzwerk. Ein Enumerator sortiert Sie z. b. nicht nach Computer, Bezeichnung, öffentlichem oder privatem Status oder anderen zugänglichen Kriterien.  
  
 Wenn Sie anstelle einer dynamischen Verbindung eine statische Momentaufnahme der Warteschlangen im Netzwerk erstellen möchten, geben Sie die Kriterien für <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> an, oder geben Sie <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>an. Jede dieser beiden Methoden gibt ein Array von <xref:System.Messaging.MessageQueue>-Objekten zurück, die die Warteschlangen zum Zeitpunkt des Aufrufs der-Methode darstellen. Aufrufen von <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, oder <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> bietet die gleichen Ergebnisse wie das Aufrufen <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> mit den Filterkriterien des <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, und <xref:System.Messaging.MessageQueue.MachineName%2A>bzw.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Name des lokalen Computers und des direkten Formats|Nein|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel durchläuft Nachrichten Warteschlangen und zeigt den Pfad der einzelnen Warteschlangen an, die am letzten Tag erstellt wurden und auf dem Computer "MyComputer" vorhanden sind.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Computer, dessen private Warteschlangen abgerufen werden sollen.</param>
        <summary>Ruft alle privaten Warteschlangen auf dem angegebenen Computer ab.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die abgerufenen privaten Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> Ruft eine statische Momentaufnahme der Warteschlangen auf einem angegebenen Computer ab.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Ja|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Listen von Warteschlangen abgerufen.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="machineName" />-Parameter ist <see langword="null" /> oder enthält eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk ab.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die abgerufenen öffentlichen Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn Sie eine vollständige Liste aller öffentlichen Warteschlangen im Netzwerk verwenden möchten. Wenn Sie die Liste nach bestimmten Kriterien einschränken möchten, z. b. <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>oder Uhrzeit der letzten Änderung, verwenden Sie eine andere Überladung dieser Methode. (Alternativ können Sie <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>oder <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>verwenden.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>, um mit einer dynamischen Liste der Warteschlangen zu interagieren.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Name des lokalen Computers und des direkten Formats|Nein|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Listen von Warteschlangen abgerufen.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Ein <see cref="T:System.Messaging.MessageQueueCriteria" />, das die Kriterien zum Filtern der Warteschlangen enthält.</param>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk ab, die die angegebenen Kriterien erfüllen.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die abgerufenen öffentlichen Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie alle öffentlichen Warteschlangen im Netzwerk nach Bezeichnung, Kategorie oder Computername filtern möchten, enthält die <xref:System.Messaging.MessageQueue> Klasse bestimmte Methoden, die diese Funktionalität bereitstellen (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>und <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>). Verwenden Sie diese Überladung, um eine Liste aller öffentlichen Warteschlangen im Netzwerk zu erhalten, die mehr als eines dieser Kriterien erfüllen (z. b. Wenn Sie sowohl eine Bezeichnung als auch eine Kategorie angeben möchten). Sie können auch nach anderen Nachrichten Kriterien als <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>und <xref:System.Messaging.MessageQueue.MachineName%2A>filtern. Beispielsweise verwenden Sie diese Überladung, um nach dem Zeitpunkt der letzten Änderung einer Warteschlange zu filtern. Erstellen Sie einfach eine neue Instanz der <xref:System.Messaging.MessageQueueCriteria>-Klasse, legen Sie die entsprechenden Eigenschaften in der-Instanz fest, und übergeben Sie die Instanz als `criteria`-Parameter.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>, um mit einer dynamischen Liste der Warteschlangen zu interagieren.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Name des lokalen Computers und des direkten Formats|Nein|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Listen von Warteschlangen abgerufen.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">Eine <see cref="T:System.Guid" /> zum Gruppieren der Gruppe von abzurufenden Warteschlangen.</param>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk ab, die der angegebenen Kategorie angehören.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die abgerufenen öffentlichen Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um die öffentlichen Warteschlangen nach Kategorie zu filtern. Die <xref:System.Messaging.MessageQueue.Category%2A>-Eigenschaft ermöglicht den Zugriff auf die Eigenschaft Message Queuing Type ID (Lese-/Schreibzugriff) einer bestimmten Warteschlange. Obwohl Sie mit <xref:System.Guid.NewGuid%2A> einen Kategoriewert erstellen können, der für alle <xref:System.Guid> Werte eindeutig ist, ist dies nicht erforderlich. Der Kategoriewert muss sich nur von anderen Kategorien unterscheiden, nicht von allen anderen <xref:System.Guid> Werten. Beispielsweise können Sie {00000000-0000-0000-0000-000000000001} als <xref:System.Messaging.MessageQueue.Category%2A> für einen Satz von Warteschlangen zuweisen und als <xref:System.Messaging.MessageQueue.Category%2A> für eine andere Gruppe {00000000-0000-0000-0000-000000000002}.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>, um mit einer dynamischen Liste der Warteschlangen zu interagieren. Sie können die Kategorie als Teil der <xref:System.Messaging.MessageQueueCriteria> angeben, die Sie an die Methode übergeben.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Name des lokalen Computers und des direkten Formats|Nein|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Listen von Warteschlangen abgerufen.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">Eine Bezeichnung zum Gruppieren der Gruppe von abzurufenden Warteschlangen.</param>
        <summary>Ruft alle öffentlichen Warteschlangen im Netzwerk ab, die die angegebene Bezeichnung aufweisen.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die abgerufenen öffentlichen Warteschlangen verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um die öffentlichen Warteschlangen nach Bezeichnung zu filtern.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>, um mit einer dynamischen Liste der Warteschlangen zu interagieren. Sie können die Bezeichnung als Teil der <xref:System.Messaging.MessageQueueCriteria> angeben, die Sie an die Methode übergeben.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Name des lokalen Computers und des direkten Formats|Nein|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Listen von Warteschlangen abgerufen.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="label" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Name des Computers mit der Gruppe der abzurufenden öffentlichen Warteschlangen.</param>
        <summary>Ruft alle öffentlichen Warteschlangen auf dem angegebenen Computer ab.</summary>
        <returns>Ein Array von <see cref="T:System.Messaging.MessageQueue" />-Objekten, die auf die öffentlichen Warteschlangen auf dem Computer verweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um die öffentlichen Warteschlangen nach Computern zu filtern.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> Ruft eine statische Momentaufnahme der Warteschlangen ab. Verwenden Sie <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>, um mit einer dynamischen Liste der Warteschlangen zu interagieren. Sie können den Computernamen als Teil der <xref:System.Messaging.MessageQueueCriteria> angeben, die Sie an die-Methode übergeben.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Nein|  
|Name des lokalen Computers und des direkten Formats|Nein|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Listen von Warteschlangen abgerufen.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="machineName" />-Parameters ist falsch.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Sicherheitskontext ab, den MSMQ zum Zeitpunkt des Aufrufs dem aktuellen Benutzer zuordnet (Threadidentität).</summary>
        <returns>Ein <see cref="T:System.Messaging.SecurityContext" />-Objekt mit dem Sicherheitskontext.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den eindeutigen Message Queuing-Bezeichner für die Warteschlange ab.</summary>
        <value>Eine <see cref="P:System.Messaging.MessageQueue.Id" />, die die von der Message Queuing-Anwendung generierte Meldungs-ID darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing legt die <xref:System.Messaging.MessageQueue.Id%2A>-Eigenschaft fest, wenn die Warteschlange erstellt wird. Diese Eigenschaft ist nur für öffentliche Warteschlangen verfügbar.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.Id%2A>-Eigenschaft einer Nachrichten Warteschlange angezeigt.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt fest, dass für eine Warteschlange keine Größenbeschränkung besteht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member wird häufig beim Festlegen von <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> oder <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Messaging.MessageQueue.InfiniteQueueSize>-Members veranschaulicht.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass für Methoden, die Meldungen einsehen oder empfangen, kein Timeout festgelegt ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> unterstützt zwei Arten von Nachrichten Abruf: synchron und asynchron. Die synchronen Methoden, <xref:System.Messaging.MessageQueue.Peek%2A> und <xref:System.Messaging.MessageQueue.Receive%2A>, bewirken, dass der Prozess Thread ein angegebenes Zeitintervall wartet, bis eine neue Nachricht in der Warteschlange eintrifft. Wenn das angegebene Zeitintervall <xref:System.Messaging.MessageQueue.InfiniteTimeout>ist, bleibt der Prozess Thread blockiert, bis eine neue Nachricht verfügbar ist. Auf der anderen Seite <xref:System.Messaging.MessageQueue.BeginPeek%2A> und <xref:System.Messaging.MessageQueue.BeginReceive%2A> (die asynchronen Methoden) zulassen, dass die Haupt Anwendungsaufgaben in einem separaten Thread fortgesetzt werden, bis eine Nachricht in der Warteschlange eintrifft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Messaging.MessageQueue.InfiniteTimeout>-Members veranschaulicht.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Beschreibung der Warteschlange ab oder legt diese fest.</summary>
        <value>Die Bezeichnung der Meldungswarteschlange. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die maximale Länge einer Nachrichten Warteschlangen Bezeichnung beträgt 124 Zeichen.  
  
 Die <xref:System.Messaging.MessageQueue.Label%2A>-Eigenschaft muss in allen Warteschlangen nicht eindeutig sein. Wenn jedoch mehrere Warteschlangen dieselbe <xref:System.Messaging.MessageQueue.Label%2A>haben, können Sie die <xref:System.Messaging.MessageQueue.Send%28System.Object%29>-Methode nicht verwenden, um eine Nachricht an alle zu senden. Wenn Sie die Bezeichnungs Syntax für die <xref:System.Messaging.MessageQueue.Path%2A>-Eigenschaft verwenden, wenn Sie die Nachricht senden, wird eine Ausnahme ausgelöst, wenn die <xref:System.Messaging.MessageQueue.Label%2A> nicht eindeutig ist.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.Label%2A>-Eigenschaft einer Nachrichten Warteschlange abgerufen und festgelegt.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Bezeichnung wurde auf einen ungültigen Wert festgelegt.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zeitpunkt ab, zu dem die Eigenschaften einer Warteschlange zuletzt geändert wurden.</summary>
        <value>Eine <see cref="T:System.DateTime" />, die den Zeitpunkt der letzten Änderung der Warteschlangeneigenschaften angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Zeitpunkt der letzten Änderung umfasst das Erstellen der Warteschlange und jede <xref:System.Messaging.MessageQueue> Eigenschaft, die die Message Queuing Warteschlange ändert, z. b. <xref:System.Messaging.MessageQueue.BasePriority%2A>. Der Wert der <xref:System.Messaging.MessageQueue.LastModifyTime%2A>-Eigenschaft stellt die Systemzeit des lokalen Computers dar.  
  
 Sie müssen <xref:System.Messaging.MessageQueue.Refresh%2A> vor dem Abrufen der <xref:System.Messaging.MessageQueue.LastModifyTime%2A>-Eigenschaft abrufen. Andernfalls ist die diesem <xref:System.Messaging.MessageQueue> zugeordnete Änderungszeit möglicherweise nicht aktuell.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.LastModifyTime%2A>-Eigenschaft einer Nachrichten Warteschlange angezeigt.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Computers ab, auf dem sich die Message Queuing-Warteschlange befindet, oder legt diesen fest.</summary>
        <value>Der Name des Computers, auf dem sich die Warteschlange befindet. Die Standardeinstellung von Message Queuing ist "." für den lokalen Computer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Messaging.MessageQueue.MachineName%2A> ist eine integrale Komponente der Anzeige namens Syntax der Warteschlangen <xref:System.Messaging.MessageQueue.Path%2A>. Die folgende Tabelle zeigt die Syntax, die Sie für eine Warteschlange eines bestimmten Typs verwenden sollten, wenn Sie den Warteschlangen Pfad mit dem anzeigen Amen identifizieren möchten.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|Öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|Private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
|Computer Journal Warteschlange|`MachineName`\\`Journal$`|  
|Warteschlange für unzustellbare Nachrichten|`MachineName`\\`Deadletter$`|  
|Computer transaktionale Warteschlange für unzustellbare Nachrichten|`MachineName`\\`XactDeadletter$`|  
  
 Verwenden Sie "." für den lokalen Computer, wenn Sie die <xref:System.Messaging.MessageQueue.MachineName%2A>angeben. Für diese Eigenschaft wird nur der Computername erkannt, z. b. `Server0`. Das IP-Adressformat wird von der <xref:System.Messaging.MessageQueue.MachineName%2A>-Eigenschaft nicht unterstützt.  
  
 Wenn Sie die <xref:System.Messaging.MessageQueue.Path%2A> in Bezug auf die <xref:System.Messaging.MessageQueue.MachineName%2A>definieren, löst die Anwendung eine Ausnahme aus, wenn Sie offline arbeiten, da der Domänen Controller für die Pfad Übersetzung erforderlich ist. Daher müssen Sie die-<xref:System.Messaging.MessageQueue.FormatName%2A> für die <xref:System.Messaging.MessageQueue.Path%2A> Syntax verwenden, wenn Sie offline arbeiten.  
  
 Die Eigenschaften <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>und <xref:System.Messaging.MessageQueue.QueueName%2A> sind miteinander verknüpft. Das Ändern der <xref:System.Messaging.MessageQueue.MachineName%2A>-Eigenschaft bewirkt, dass die <xref:System.Messaging.MessageQueue.Path%2A>-Eigenschaft geändert wird. Es basiert auf dem neuen <xref:System.Messaging.MessageQueue.MachineName%2A> und der <xref:System.Messaging.MessageQueue.QueueName%2A>. Wenn Sie die <xref:System.Messaging.MessageQueue.Path%2A> ändern (z. b. zur Verwendung der Format Namen Syntax), werden die <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaften zurückgesetzt, sodass Sie auf die neue Warteschlange verweisen. Wenn die <xref:System.Messaging.MessageQueue.QueueName%2A>-Eigenschaft leer ist, wird der <xref:System.Messaging.MessageQueue.Path%2A> auf die Journal Warteschlange des Computers festgelegt, den Sie angeben.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Ja|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.MachineName%2A>-Eigenschaft einer Nachrichten Warteschlange abgerufen und festgelegt.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.MessageQueue.MachineName" /> ist <see langword="null" />.        
- oder -

Der Computername ist ungültig. Möglicherweise wurde eine falsche Syntax verwendet.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe der Journalwarteschlange ab oder legt diese fest.</summary>
        <value>Die maximale Größe der Journalwarteschlange in Kilobyte. In der Standardeinstellung von Message Queuing ist keine Begrenzung festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> bietet Zugriff auf die Speicherbeschränkung für das Message Queuing Journal. Dies ist nur relevant, wenn <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> `true`ist. Wenn Sie diese Eigenschaft festlegen, ändert sich die Message Queuing Warteschlange. Aus diesem Grund sind alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen.  
  
 Wenn Sie Nachrichten in einem Journal oder in einer Warteschlange für unzustellbare Nachrichten speichern, sollten Sie die Warteschlange regelmäßig löschen, um nicht mehr benötigte Nachrichten zu entfernen. Nachrichten in dieser Warteschlange zählen in Richtung des Nachrichten Kontingents für den Computer, auf dem sich die Warteschlange befindet. (Vom Administrator wird das Computer Kontingent festgelegt.)  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>-Eigenschaft einer Nachrichten Warteschlange abgerufen und festgelegt.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die maximale Größe der Journalwarteschlange wurde auf einen ungültigen Wert festgelegt.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe der Warteschlange ab oder legt diese fest.</summary>
        <value>Die maximale Größe der Warteschlange in KB. In der Standardeinstellung von Message Queuing ist keine Begrenzung festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> bietet Zugriff auf das Speicherlimit für Message Queuing Nachrichten, das von dem vom Administrator definierten Nachrichten Kontingent des Computers getrennt ist. Weitere Informationen zum Nachrichten Kontingent finden Sie unter <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 Wenn Sie diese Eigenschaft festlegen, ändert sich die Message Queuing Warteschlange. Aus diesem Grund sind alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen.  
  
 Wenn versucht wird, entweder die maximale Warteschlangen Größe oder das Kontingent für Computernachrichten zu überschreiten, können Nachrichten verloren gehen. Wenn das Warteschlangen Kontingent erreicht ist, benachrichtigt Message Queuing die Verwaltungs Warteschlange der sendenden Anwendung, um anzugeben, dass die Warteschlange voll ist, indem eine negative Bestätigungsnachricht zurückgegeben wird. Message Queuing sendet weiterhin negative Bestätigungen, bis die Gesamtgröße der Nachrichten in der Warteschlange unter den Grenzwert fällt.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>-Eigenschaft einer Nachrichten Warteschlange abgerufen und festgelegt.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die maximale Größe für die Warteschlange enthält einen negativen Wert.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Eigenschaftenfilter für das Empfangen oder Einsehen von Meldungen ab oder legt diesen fest.</summary>
        <value>Der <see cref="T:System.Messaging.MessagePropertyFilter" />, der von der Warteschlange zum Filtern der Eigenschaften verwendet wird, die mit einer Meldung empfangen oder eingesehen werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Filter ist ein Satz von booleschen Werten, die die Nachrichten Eigenschaften einschränken, die der <xref:System.Messaging.MessageQueue> empfängt oder sieht. Wenn die <xref:System.Messaging.MessageQueue> eine Nachricht von der Server Warteschlange empfängt oder empfängt, ruft Sie nur die Eigenschaften ab, für die der <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> Wert `true`ist.  
  
 Im folgenden werden die anfänglichen Eigenschaftswerte für die <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>-Eigenschaft gezeigt. Diese Einstellungen sind identisch mit dem Aufrufen von <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> auf einem <xref:System.Messaging.MessagePropertyFilter>.  
  
|Eigenschaft|Standardwert|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1.024 Bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 Bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 Bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Ja|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die-<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> verwendet, um die empfangenen Nachrichten Eigenschaften einzuschränken.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Filter ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eingeführt in MSMQ 3.0. Ruft die der Warteschlange zugeordnete Multicastadresse ab oder oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.String" /> mit einer gültigen Multicastadresse (im nachfolgend angegebenen Format) oder <see langword="null" />. Letzteres gibt an, dass die Warteschlange keiner Multicastadresse zugeordnet ist.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.MessageQueue.MulticastAddress%2A>-Eigenschaft wird verwendet, um eine nicht transaktionale Warteschlange einer Multicast Adresse zuzuordnen, die beim Senden von Nachrichten verwendet werden kann. Eine transaktionale Warteschlange kann nicht mit einer Multicast Adresse verknüpft werden. Wenn die sendende Anwendung Nachrichten an eine Multicast Adresse sendet, sendet Message Queuing eine Kopie der Nachricht an jede dieser Adresse zugeordnete Warteschlange.  
  
 IP-Multicast Adressen müssen sich im Bereich der Klasse D von 224.0.0.0 bis 239.255.255.255 befinden, was dem Festlegen der ersten vier höherwertigen Bits entspricht, die 1110 entsprechen. Allerdings sind nur bestimmte Adressbereiche in diesem Bereich nicht reserviert und sind zum Senden von Multicast Nachrichten verfügbar. Die aktuelle Liste der reservierten Multicast Adressen finden Sie auf der Webseite Internet [Assigned Number Authority (IANA) Internet Multicast Adressen](https://go.microsoft.com/fwlink/?linkid=3859) . Es gibt keine Einschränkungen für die Portnummer.  
  
 Wenn mehrere Quellcomputer Multicast Nachrichten senden und eine bestimmte Warteschlange Nachrichten von nur einem Quellcomputer empfangen soll, muss jeder Quellcomputer Nachrichten an eine andere Kombination von IP-Adresse und Portnummer senden.  
  
 Legen Sie die <xref:System.Messaging.MessageQueue.MulticastAddress%2A>-Eigenschaft auf eine Zeichenfolge der Länge 0 (null) fest, um eine Warteschlange von einer Multicast Adresse zu trennen. Legen Sie Sie nicht auf "`null`" fest, da dies zu einer <xref:System.ArgumentNullException>führt.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad der Warteschlange ab oder legt diesen fest. Nach dem Festlegen des <see cref="P:System.Messaging.MessageQueue.Path" /> zeigt die <see cref="T:System.Messaging.MessageQueue" /> auf eine neue Warteschlange.</summary>
        <value>Die Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist. Die Standardeinstellung hängt vom verwendeten <see cref="M:System.Messaging.MessageQueue.#ctor" />-Konstruktor ab. Sie ist entweder <see langword="null" />, oder sie wird durch den <paramref name="path" />-Parameter des Konstruktors angegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Syntax für die <xref:System.Messaging.MessageQueue.Path%2A>-Eigenschaft hängt vom Typ der Warteschlange ab, auf die Sie verweist, wie in der folgenden Tabelle dargestellt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|Öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|Private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
|Computer Journal Warteschlange|`MachineName`\\`Journal$`|  
|Warteschlange für unzustellbare Nachrichten|`MachineName`\\`Deadletter$`|  
|Computer transaktionale Warteschlange für unzustellbare Nachrichten|`MachineName`\\`XactDeadletter$`|  
  
 Verwenden Sie ".", um den lokalen Computer darzustellen.  
  
 Die Eigenschaften <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>und <xref:System.Messaging.MessageQueue.QueueName%2A> sind miteinander verknüpft. Das Ändern der <xref:System.Messaging.MessageQueue.MachineName%2A>-Eigenschaft bewirkt, dass die <xref:System.Messaging.MessageQueue.Path%2A>-Eigenschaft geändert wird. Es basiert auf dem neuen <xref:System.Messaging.MessageQueue.MachineName%2A> und der <xref:System.Messaging.MessageQueue.QueueName%2A>. Wenn Sie die <xref:System.Messaging.MessageQueue.Path%2A> ändern (z. b. zur Verwendung der Format Namen Syntax), werden die <xref:System.Messaging.MessageQueue.MachineName%2A> und <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaften zurückgesetzt, sodass Sie auf die neue Warteschlange verweisen.  
  
 Alternativ können Sie die <xref:System.Messaging.MessageQueue.FormatName%2A> oder <xref:System.Messaging.MessageQueue.Label%2A> verwenden, um den Warteschlangen Pfad zu beschreiben, wie in der folgenden Tabelle dargestellt.  
  
|Referenz|Syntax|Beispiel|  
|---------------|------------|-------------|  
|Formatname|`FormatName:` [ *Format Name* ]|`FormatName:Public=` 5a5f 7535-AE9a-41d4-935c-845c2aff7112|  
|Bezeichnung|`Label:` [ *Bezeichnung* ]|`Label:` thelabel|  
  
 Wenn Sie die Bezeichnungs Syntax für die <xref:System.Messaging.MessageQueue.Path%2A>-Eigenschaft verwenden, wenn Sie die Nachricht senden, wird eine Ausnahme ausgelöst, wenn die <xref:System.Messaging.MessageQueue.Label%2A> nicht eindeutig ist.  
  
 Um offline arbeiten zu können, müssen Sie anstelle der Syntax für den anzeigen Amen in der ersten Tabelle die Syntax Format Name verwenden. Andernfalls wird eine Ausnahme ausgelöst, da der primäre Domänen Controller (auf dem sich Active Directory befindet) nicht verfügbar ist, um den Pfad zum Format Namen aufzulösen.  
  
 Wenn Sie einen neuen Pfad festlegen, wird die Nachrichten Warteschlange geschlossen und alle Handles freigegeben  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Ja|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
> [!NOTE]
>  Im Arbeitsgruppen Modus können Sie nur private Warteschlangen verwenden. Sie geben den Pfad mithilfe der Syntax für die private Warteschlange `MachineName`\\`Private$`\\`QueueName`an.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden neue <xref:System.Messaging.MessageQueue>-Objekte mithilfe verschiedener Syntax Typen für Pfadnamen erstellt. In jedem Fall sendet Sie eine Nachricht an die Warteschlange, deren Pfad im Konstruktor definiert ist.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist ungültig. Möglicherweise wurde eine falsche Syntax verwendet.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <summary>Gibt eine Kopie der ersten Meldung in der Warteschlange zurück, ohne die Meldung aus der Warteschlange zu entfernen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird beendet, ohne die erste Meldung in der Warteschlange zu entfernen (einzusehen), auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Die <see cref="M:System.Messaging.MessageQueue.Peek" />-Methode ist synchron. Sie blockiert daher den aktuellen Thread bis zum Eingang einer Meldung.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, die die erste Meldung in der Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Warteschlange zu sehen oder zu warten, bis eine Nachricht in der Warteschlange vorhanden ist.  
  
 Mit der <xref:System.Messaging.MessageQueue.Peek%2A>-Methode wird die erste Meldung aus der Warteschlange gelesen, aber nicht entfernt. Daher wird bei wiederholten Aufrufen von <xref:System.Messaging.MessageQueue.Peek%2A> dieselbe Nachricht zurückgegeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen. Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode hingegen liest und entfernt die erste Meldung aus der Warteschlange. Bei wiederholten Aufrufen von <xref:System.Messaging.MessageQueue.Receive%2A>werden daher verschiedene Nachrichten zurückgegeben.  
  
 Message Queuing sortiert Nachrichten in der Warteschlange entsprechend der Priorität und der Eingangszeit. Eine neuere Nachricht wird nur dann vor einer älteren Nachricht eingefügt, wenn Sie eine höhere Priorität hat.  
  
 Verwenden Sie <xref:System.Messaging.MessageQueue.Peek%2A>¸ wenn eine Blockade des aktuellen Threads bis zum Eingehen einer Nachricht in die Warteschlange akzeptabel ist. Da diese Überladung keinen Timeout angibt, wartet die Anwendung möglicherweise unbegrenzt. Wenn die Anwendungsverarbeitung ohne Wartezeiten fortgesetzt werden soll, verwenden Sie die asynchrone <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode. Sie können auch angeben, dass ein Timeout für eine Nachricht in der Warteschlange eintreffen soll, indem Sie die Überladung von <xref:System.Messaging.MessageQueue.Peek%2A> verwenden, die ein Timeout angibt.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 In den folgenden Beispielen wird die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode für eine Warteschlange verwendet.  
  
 Im ersten Beispiel wartet die Anwendung, bis eine Nachricht in der Warteschlange verfügbar wird. Beachten Sie, dass das erste Beispiel nicht auf die eingehende Nachricht zugreift. die Verarbeitung wird nur angehalten, bis eine Nachricht eingeht. Wenn eine Nachricht in der Warteschlange bereits vorhanden ist, wird Sie sofort zurückgegeben.  
  
 Im zweiten Beispiel wird eine Nachricht, die eine von der Anwendung definierte `Order` Klasse enthält, an die Warteschlange gesendet und dann in der Warteschlange angezeigt.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die maximale Zeitspanne angibt, für die auf den Eingang einer Meldung gewartet werden soll.</param>
        <summary>Wird beendet, ohne die erste Meldung in der Warteschlange zu entfernen (einzusehen), auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Die <see cref="M:System.Messaging.MessageQueue.Peek" />-Methode ist synchron. Sie blockiert daher den aktuellen Thread, bis eine Meldung verfügbar wird oder der Timeout eintritt.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, die die erste Meldung in der Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Warteschlange zu sehen oder eine angegebene Zeitspanne zu warten, bis eine Nachricht in der Warteschlange vorhanden ist. Die Methode wird sofort zurückgegeben, wenn eine Nachricht bereits in der Warteschlange vorhanden ist.  
  
 Mit der <xref:System.Messaging.MessageQueue.Peek%2A>-Methode wird die erste Meldung aus der Warteschlange gelesen, aber nicht entfernt. Daher wird bei wiederholten Aufrufen von <xref:System.Messaging.MessageQueue.Peek%2A> dieselbe Nachricht zurückgegeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen. Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode hingegen liest und entfernt die erste Meldung aus der Warteschlange. Bei wiederholten Aufrufen von <xref:System.Messaging.MessageQueue.Receive%2A>werden daher verschiedene Nachrichten zurückgegeben.  
  
 Message Queuing sortiert Nachrichten in der Warteschlange entsprechend der Priorität und der Eingangszeit. Eine neuere Nachricht wird nur dann vor einer älteren Nachricht eingefügt, wenn Sie eine höhere Priorität hat.  
  
 Verwenden Sie <xref:System.Messaging.MessageQueue.Peek%2A>¸ wenn eine Blockade des aktuellen Threads bis zum Eingehen einer Nachricht in die Warteschlange akzeptabel ist. Der Thread wird bis zum angegebenen Zeitraum blockiert oder unbegrenzt, wenn Sie <xref:System.Messaging.MessageQueue.InfiniteTimeout>angegeben haben. Wenn die Anwendungsverarbeitung ohne Wartezeiten fortgesetzt werden soll, verwenden Sie die asynchrone <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode mit einem Timeout von 0 verwendet, um zu überprüfen, ob die Warteschlange leer ist.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan, cursor As Cursor, action As PeekAction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die maximale Zeitspanne angibt, für die auf den Eingang einer Meldung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <param name="action">Einer der <see cref="T:System.Messaging.PeekAction" />-Werte. Gibt an, ob die aktuelle oder die folgende Meldung in der Warteschlange eingesehen wird.</param>
        <summary>Wird beendet, ohne die aktuelle oder die nächste Meldung mithilfe des angegebenen Cursors zu entfernen (einzusehen). Die <see cref="M:System.Messaging.MessageQueue.Peek" />-Methode ist synchron. Sie blockiert daher den aktuellen Thread, bis eine Meldung verfügbar wird oder der Timeout eintritt.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die eine Meldung in der Warteschlange darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Warteschlange zu sehen oder eine angegebene Zeitspanne zu warten, bis eine Nachricht in der Warteschlange vorhanden ist. Die Methode wird sofort zurückgegeben, wenn eine Nachricht bereits in der Warteschlange vorhanden ist.  
  
 Mit der <xref:System.Messaging.MessageQueue.Peek%2A>-Methode wird eine Nachricht aus der Warteschlange gelesen, aber nicht entfernt. Mit der <xref:System.Messaging.MessageQueue.Receive%2A>-Methode hingegen wird eine Nachricht aus der Warteschlange gelesen und daraus entfernt.  
  
 Verwenden Sie <xref:System.Messaging.MessageQueue.Peek%2A>¸ wenn eine Blockade des aktuellen Threads bis zum Eingehen einer Nachricht in die Warteschlange akzeptabel ist. Der Thread ist bis zum angegebenen Zeitraum blockiert oder unbegrenzt, wenn Sie <xref:System.Messaging.MessageQueue.InfiniteTimeout>angegeben haben. Wenn die Anwendungsverarbeitung ohne Wartezeiten fortgesetzt werden soll, verwenden Sie die asynchrone <xref:System.Messaging.MessageQueue.BeginPeek%2A>-Methode.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für den <paramref name="action" />-Parameter wurde ein anderer Wert als <see langword="PeekAction.Current" /> oder <see langword="PeekAction.Next" /> angegeben.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig. Möglicherweise ist <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sieht eine Meldung mit der angegebenen Korrelations-ID ein.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der einzusehenden Meldung.</param>
        <summary>Sieht die Meldung mit der angegebenen Korrelations-ID ein und löst sofort eine Ausnahme aus, wenn in der Warteschlange derzeit keine Meldung mit der angegebenen Korrelations-ID vorhanden ist.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Warteschlange, auf die vom <xref:System.Messaging.MessageQueue> verwiesen wird, nach einer Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> mit dem angegebenen `correlationId` Parameter übereinstimmt. Wenn keine Nachricht gefunden wird, die mit dem `correlationID`-Parameter übereinstimmt, wird eine Ausnahme ausgelöst.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A>-Eigenschaft wird verwendet, um eine an die Warteschlange gesendete Nachricht an zugeordnete Antwort-, Berichts-oder Bestätigungsnachrichten zu binden.  
  
 Mit zwei anderen Methoden können Sie Nachrichten in einer Warteschlange einsehen. Die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode gibt die erste Nachricht in der Warteschlange zurück, und die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>-Methode wird verwendet, um eine Nachricht abzurufen, indem Sie Ihren eindeutigen Bezeichner angibt.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Nachricht gesendet und empfangen, die eine Bestellung zu und aus einer Warteschlange enthält. Insbesondere wird eine positive Bestätigung angefordert, wenn die ursprüngliche Nachricht erreicht oder aus der Warteschlange abgerufen wird.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="correlationId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der einzusehenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <summary>Sieht eine Meldung mit der angegebenen Korrelations-ID ein und wartet, bis eine Meldung mit der angegebenen Korrelations-ID in der Warteschlange verfügbar ist oder bis der Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Warteschlange, auf die vom <xref:System.Messaging.MessageQueue> verwiesen wird, nach einer Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> mit dem angegebenen `correlationId` Parameter übereinstimmt. Wenn keine Nachricht gefunden wird, die mit dem `correlationID`-Parameter übereinstimmt, und innerhalb des vom `timeout`-Parameter angegebenen Zeitraums keine neue Nachricht in der Warteschlange eintrifft, wird eine Ausnahme ausgelöst.  
  
 Der `timeout`-Parameter gibt nicht die Gesamtlaufzeit für diese Methode an. Stattdessen wird die Zeit angegeben, die gewartet werden soll, bis eine neue Nachricht in der Warteschlange eintrifft. Jedes Mal, wenn eine neue Nachricht eingeht, untersucht diese Methode den <xref:System.Messaging.Message.CorrelationId%2A> der neuen Nachricht, um zu ermitteln, ob Sie mit dem Parameter `correlationId` übereinstimmt. Andernfalls startet diese Methode den Timeout Zeitraum und wartet darauf, dass eine andere neue Nachricht eintrifft. Wenn neue Nachrichten innerhalb des Timeout Zeitraums eingehen, ist es daher möglich, dass diese Methode unbegrenzt ausgeführt wird, entweder bis der Timeout Zeitraum abläuft, ohne dass neue Nachrichten eintreffen, oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.CorrelationId%2A> mit dem `correlationId` Parameter übereinstimmt.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A>-Eigenschaft wird verwendet, um eine an die Warteschlange gesendete Nachricht an zugeordnete Antwort-, Berichts-oder Bestätigungsnachrichten zu binden.  
  
 Mit zwei anderen Methoden können Sie Nachrichten in einer Warteschlange einsehen. Die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode gibt die erste Nachricht in der Warteschlange zurück, und die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>-Methode wird verwendet, um eine Nachricht abzurufen, indem Sie Ihren eindeutigen Bezeichner angibt.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine Meldung mit der angegebenen <paramref name="correlationId" /> ist nicht in der Warteschlange vorhanden und nicht vor Ablauf des Timeouts eingegangen.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung eingegangen.  
  
 - oder -  
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Kopie der Meldung mit der angegebenen Meldungs-ID zurück, ohne die Meldung aus der Warteschlange zu entfernen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der einzusehenden Meldung.</param>
        <summary>Sieht die Meldung ein, deren Meldungs-ID mit dem <paramref name="id" />-Parameter übereinstimmt.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft mit dem <paramref name="id" />-Parameter übereinstimmt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>, ohne aus der Warteschlange zu entfernen, eine Nachricht mit einer bekannten Nachrichten Kennung. Der Bezeichner einer Nachricht ist in der Message Queuing Enterprise eindeutig, sodass in der Warteschlange höchstens eine Nachricht vorhanden ist, die mit dem angegebenen `id` Parameter übereinstimmt. Diese Überladung löst eine Ausnahme aus, wenn die Warteschlange die Nachricht derzeit nicht enthält.  
  
 Mit zwei zusätzlichen Methoden können Sie Nachrichten in einer Warteschlange einsehen: <xref:System.Messaging.MessageQueue.Peek%2A> und <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode gibt die erste Meldung in der Warteschlange zurück. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> gibt eine Bestätigung, einen Bericht oder eine von der Anwendung generierte Antwortnachricht zurück, die als Ergebnis einer an die Warteschlange gesendeten Nachricht erstellt wurde.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Es ist keine Meldung mit der angegebenen <paramref name="id" /> vorhanden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der einzusehenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <summary>Sieht die Meldung ein, deren Meldungs-ID mit dem <paramref name="id" />-Parameter übereinstimmt. Wartet, bis die Meldung in der Warteschlange eingeht oder ein Timeout auftritt.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft mit dem <paramref name="id" />-Parameter übereinstimmt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>, ohne aus der Warteschlange zu entfernen, eine Nachricht mit einer bekannten Nachrichten Kennung. Der Bezeichner einer Nachricht ist in der Message Queuing Enterprise eindeutig, sodass in der Warteschlange höchstens eine Nachricht vorhanden ist, die mit dem angegebenen `id` Parameter übereinstimmt. Diese Überladung löst eine Ausnahme aus, wenn die Warteschlange die Nachricht zurzeit nicht enthält und vor dem Timeout keine neue Nachricht eingeht.  
  
 Der `timeout`-Parameter gibt nicht die Gesamtlaufzeit für diese Methode an. Stattdessen wird die Zeit angegeben, die gewartet werden soll, bis eine neue Nachricht in der Warteschlange eintrifft. Jedes Mal, wenn eine neue Nachricht eingeht, untersucht diese Methode den <xref:System.Messaging.Message.Id%2A> der neuen Nachricht, um zu ermitteln, ob Sie mit dem Parameter `id` übereinstimmt. Andernfalls startet diese Methode den Timeout Zeitraum und wartet darauf, dass eine andere neue Nachricht eintrifft. Wenn neue Nachrichten innerhalb des Timeout Zeitraums eingehen, ist es daher möglich, dass diese Methode unbegrenzt ausgeführt wird, entweder bis der Timeout Zeitraum abläuft, ohne dass neue Nachrichten eintreffen, oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.Id%2A> mit dem `id` Parameter übereinstimmt.  
  
 Mit zwei zusätzlichen Methoden können Sie Nachrichten in einer Warteschlange einsehen: <xref:System.Messaging.MessageQueue.Peek%2A> und <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode gibt die erste Meldung in der Warteschlange zurück. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> gibt eine Bestätigung, einen Bericht oder eine von der Anwendung generierte Antwortnachricht zurück, die als Ergebnis einer an die Warteschlange gesendeten Nachricht erstellt wurde.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine Meldung mit der angegebenen <paramref name="id" /> ist nicht in der Warteschlange vorhanden und nicht vor Ablauf der im <paramref name="timeout" />-Parameter angegebenen Zeitspanne eingegangen.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Eingeführt in MSMQ 3.0. Sieht eine bestimmte Meldung in der Warteschlange ein. Die Meldung kann anhand eines Suchbezeichners oder anhand der Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der einzusehenden Meldung.</param>
        <summary>Eingeführt in MSMQ 3.0. Sieht die Meldung ein, die dem angegebenen Suchbezeichner in einer nicht transaktionalen Warteschlange entspricht.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.LookupId" />-Eigenschaft dem übergebenen <paramref name="lookupId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bekannten Such Bezeichner zu lesen, ohne Sie aus der Warteschlange zu entfernen. Diese Methode löst sofort eine Ausnahme aus, wenn sich die Nachricht nicht in der Warteschlange befindet.  
  
 Die <xref:System.Messaging.Message.LookupId%2A>-Eigenschaft einer Nachricht ist eindeutig für die Warteschlange, in der sich die Nachricht befindet. es wird also höchstens eine Nachricht in der Warteschlange angezeigt, die mit dem angegebenen `lookupId` Parameter übereinstimmt.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>-Methode, um eine Nachricht mit einem angegebenen Such Bezeichner zu lesen und aus der Warteschlange zu entfernen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="lookupId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">Einer der <see cref="T:System.Messaging.MessageLookupAction" />-Werte, der angibt, wie die Meldung in der Warteschlange gelesen wird. Geben Sie eine der folgenden Optionen an: 
 <see langword="MessageLookupAction.Current" />: Sieht die durch die <paramref name="lookupId" /> angegebene Meldung ein.  
  
 <see langword="MessageLookupAction.Next" />: Sieht die Meldung ein, die auf die anhand der <paramref name="lookupId" /> angegebene Meldung folgt.  
  
 <see langword="MessageLookupAction.Previous" />: Sieht die Meldung ein, die der anhand der <paramref name="lookupId" /> angegebenen Meldung vorausgeht.  
  
 <see langword="MessageLookupAction.First" />: Sieht die erste Meldung in der Warteschlange ein. Der <paramref name="lookupId" />-Parameter muss auf 0 festgelegt werden.  
  
 <see langword="MessageLookupAction.Last" />: Sieht die letzte Meldung in der Warteschlange ein. Der <paramref name="lookupId" />-Parameter muss auf 0 festgelegt werden.</param>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der einzusehenden Meldung, andernfalls 0 (null). 0 wird beim Zugreifen auf die erste oder letzte Meldung in die Warteschlange verwendet.</param>
        <summary>Eingeführt in MSMQ 3.0. Sieht eine bestimmte Meldung in der Warteschlange ein. Die Meldung kann anhand eines Suchbezeichners oder anhand der Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
        <returns>Die durch den übergebenen <paramref name="action" />-Parameter und <paramref name="lookupId" />-Parameter angegebene <see cref="T:System.Messaging.Message" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bekannten Such Bezeichner zu lesen, ohne Sie aus der Warteschlange zu entfernen. Diese Methode löst sofort eine Ausnahme aus, wenn sich die Nachricht nicht in der Warteschlange befindet.  
  
 Die <xref:System.Messaging.Message.LookupId%2A>-Eigenschaft einer Nachricht ist eindeutig für die Warteschlange, in der sich die Nachricht befindet. es wird also höchstens eine Nachricht in der Warteschlange angezeigt, die mit dem angegebenen `lookupId` Parameter übereinstimmt.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>-Methode, um eine Meldung mit einem angegebenen Bezeichner zu lesen und aus der Warteschlange zu entfernen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="lookupId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="action" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageLookupAction" />-Member.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine Meldung gelesen wird, ohne sie aus der Warteschlange zu entfernen. Dies ist ein Ergebnis eines asynchronen <see cref="M:System.Messaging.MessageQueue.BeginPeek" />-Vorgangs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> wird bei der asynchronen Verarbeitung verwendet, um das <xref:System.Messaging.MessageQueue.PeekCompleted>-Ereignis zu erhöhen, wenn eine Nachricht in der Warteschlange verfügbar ist.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wird verwendet, um den Vorgang abzuschließen, der von einem <xref:System.Messaging.MessageQueue.BeginPeek%2A> aufgerufen wurde, und die Meldung einsehen, wenn das <xref:System.Messaging.MessageQueue.PeekCompleted>-Ereignis ausgelöst wird.  
  
 Beim Erstellen eines <xref:System.Messaging.PeekCompletedEventHandler>-Delegaten bestimmen Sie die Methode für die Ereignisbehandlung. Um dem Ereignishandler das Ereignis zuzuordnen, fügen Sie dem Ereignis eine Instanz des Delegaten hinzu. Der Ereignishandler wird bei jedem Eintreten des Ereignisses aufgerufen, sofern der Delegat nicht entfernt wird. Weitere Informationen zu Ereignishandlerdelegaten finden Sie unter [behandeln und Auswerfen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignishandler mit dem Namen `MyPeekCompleted`erstellt, an den <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignishandlerdelegaten angehängt und <xref:System.Messaging.MessageQueue.BeginPeek%2A> aufgerufen, um einen asynchronen Peek-Vorgang in der Warteschlange zu initiieren, die sich im Pfad ".\MyQueue" befindet. Wenn ein <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis ausgelöst wird, zeigt das Beispiel die Nachricht an und schreibt Ihren Text auf den Bildschirm. Im Beispiel wird dann <xref:System.Messaging.MessageQueue.BeginPeek%2A> erneut aufgerufen, um einen neuen asynchronen Peek-Vorgang zu initiieren.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle in der Warteschlange enthaltenen Meldungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Löschen der Warteschlange bewirkt, dass Message Queuing das Flag für die Warteschlangen Änderung festgelegt, das sich auf die Eigenschaft <xref:System.Messaging.MessageQueue.LastModifyTime%2A> auswirkt. Nachrichten, die aus der Warteschlange gelöscht werden, gehen verloren. Sie werden nicht an die Warteschlange für unzustellbare Nachrichten oder an die Journal Warteschlange gesendet.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den angezeigten Namen für die Warteschlange ab oder legt diesen fest.</summary>
        <value>Der Name zur Bezeichnung der Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist. Der Wert darf nicht <see langword="null" /> sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Messaging.MessageQueue.QueueName%2A> mit dem <xref:System.Messaging.MessageQueue.MachineName%2A> kombinieren, um einen <xref:System.Messaging.MessageQueue.Path%2A> benutzerfreundlichen Namen für die Warteschlange zu erstellen. Die Syntax für die Anzeige namens Variation der <xref:System.Messaging.MessageQueue.Path%2A>-Eigenschaft hängt vom Typ der Warteschlange ab, wie in der folgenden Tabelle dargestellt.  
  
|Warteschlangentyp|Syntax|  
|----------------|------------|  
|Öffentliche Warteschlange|`MachineName`\\`QueueName`|  
|Private Warteschlange|`MachineName`\\`Private$`\\`QueueName`|  
|Journalwarteschlange|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Verwenden Sie ".", um den lokalen Computer darzustellen.  
  
 Das Ändern der <xref:System.Messaging.MessageQueue.QueueName%2A> Eigenschaft wirkt sich auf die <xref:System.Messaging.MessageQueue.Path%2A>-Eigenschaft aus. Wenn Sie die <xref:System.Messaging.MessageQueue.QueueName%2A> festlegen, ohne die <xref:System.Messaging.MessageQueue.MachineName%2A>-Eigenschaft festzulegen, wird die <xref:System.Messaging.MessageQueue.Path%2A>-Eigenschaft zu.\\`QueueName`. Andernfalls wird der <xref:System.Messaging.MessageQueue.Path%2A> `MachineName`\\`QueueName`.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Ja|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.QueueName%2A>-Eigenschaft einer Nachrichten Warteschlange abgerufen und festgelegt.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name der Warteschlange ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das systemeigene Handle zum Empfangen von Meldungen aus der Meldungswarteschlange ab.</summary>
        <value>Ein Handle für das systemeigene Warteschlangenobjekt, das zum Einsehen und Empfangen von Meldungen aus der Warteschlange verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Messaging.MessageQueue.ReadHandle%2A> stellt ein System eigenes Windows-Handle für das Nachrichten Warteschlangen Objekt bereit, das zum einsehen und empfangen von Nachrichten aus der Warteschlange verwendet wird. Wenn Sie den Pfad der Warteschlange ändern, wird das Handle geschlossen und mit einem neuen Wert erneut geöffnet.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <summary>Empfängt die erste Meldung aus der Warteschlange und entfernt sie aus der Warteschlange.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Empfängt die erste verfügbare Meldung aus der Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser Aufruf ist synchron und blockiert den aktuellen Ausführungsthread, bis eine Meldung verfügbar ist.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht aus einer Warteschlange zu empfangen, oder warten Sie, bis Nachrichten in der Warteschlange vorliegen.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode ermöglicht das synchrone Lesen einer Nachricht, wodurch Sie aus der Warteschlange entfernt wird. Bei nachfolgenden Aufrufen von <xref:System.Messaging.MessageQueue.Receive%2A> werden die Nachrichten in der Warteschlange zurückgegeben, oder es werden neue Nachrichten mit höherer Priorität zurückgegeben.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode, um die erste Nachricht in einer Warteschlange zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen.  
  
 Verwenden Sie einen-<xref:System.Messaging.MessageQueue.Receive%2A>, wenn es zulässig ist, dass der aktuelle Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft. Da diese Überladung der <xref:System.Messaging.MessageQueue.Receive%2A>-Methode ein unendliches Timeout angibt, wartet die Anwendung möglicherweise unbegrenzt. Wenn die Anwendungs Verarbeitung fortgesetzt werden soll, ohne auf die Meldung zu warten, sollten Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>verwenden.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Nachricht aus einer Warteschlange empfangen und Informationen über diese Nachricht an den Bildschirm ausgegeben.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die erste verfügbare Meldung aus der transaktionalen Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser Aufruf ist synchron und blockiert den aktuellen Ausführungsthread, bis eine Meldung verfügbar ist.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht aus einer Transaktions Warteschlange mit dem internen Transaktionskontext zu empfangen, der vom `transaction`-Parameter definiert wird, oder warten Sie, bis Nachrichten in der Warteschlange vorhanden sind.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode ermöglicht das synchrone Lesen einer Nachricht, wodurch Sie aus der Warteschlange entfernt wird. Bei nachfolgenden Aufrufen von <xref:System.Messaging.MessageQueue.Receive%2A> werden die Nachrichten in der Warteschlange zurückgegeben.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird erst endgültig aus der Warteschlange entfernt, wenn ein Commit für die Transaktion ausgeführt wird.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode, um die erste Nachricht in einer Warteschlange zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen. Eine Meldung, die von einem <xref:System.Messaging.MessageQueue.Peek%2A>aufgerufen wird, ist kein Transaktionskontext zugeordnet. Da <xref:System.Messaging.MessageQueue.Peek%2A> keine Nachrichten in der Warteschlange entfernt, wäre es aufgrund eines Aufrufens von <xref:System.Messaging.MessageQueueTransaction.Abort%2A>nichts zu tun.  
  
 Verwenden Sie einen-<xref:System.Messaging.MessageQueue.Receive%2A>, wenn es zulässig ist, dass der aktuelle Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft. Da diese Überladung der <xref:System.Messaging.MessageQueue.Receive%2A>-Methode ein unendliches Timeout angibt, wartet die Anwendung möglicherweise unbegrenzt. Wenn die Anwendungs Verarbeitung fortgesetzt werden soll, ohne auf die Meldung zu warten, sollten Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>verwenden.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einer Transaktions Warteschlange auf dem lokalen Computer hergestellt und eine Nachricht an die Warteschlange gesendet. Anschließend wird die Nachricht empfangen, die eine Bestellung enthält. Wenn eine nicht transaktionale Warteschlange festgestellt wird, löst Sie eine Ausnahme aus und führt einen Rollback für die Transaktion aus.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.  
  
 - oder -  
  
 Die Warteschlange ist nicht transaktional.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die erste verfügbare Meldung aus der Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser Aufruf ist synchron und blockiert den aktuellen Ausführungsthread, bis eine Meldung verfügbar ist.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht aus einer Warteschlange zu empfangen, indem Sie einen vom `transactionType` Parameter definierten Transaktionskontext verwenden, oder warten Sie, bis Nachrichten in der Warteschlange vorliegen.  
  
 Geben Sie `Automatic` für den `transactionType` Parameter an, wenn bereits ein externer Transaktionskontext an den Thread angefügt ist, den Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` an, wenn die Nachricht als einzelne interne Transaktion empfangen werden soll. Sie können `None` angeben, wenn Sie eine Nachricht von einer Transaktions Warteschlange außerhalb eines Transaktions Kontexts empfangen möchten.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode ermöglicht das synchrone Lesen einer Nachricht, wodurch Sie aus der Warteschlange entfernt wird. Bei nachfolgenden Aufrufen von <xref:System.Messaging.MessageQueue.Receive%2A> werden die Nachrichten in der Warteschlange zurückgegeben.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht aus einer Transaktions Warteschlange zu empfangen, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird erst endgültig aus der Warteschlange entfernt, wenn ein Commit für die Transaktion ausgeführt wird.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode, um die erste Nachricht in einer Warteschlange zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen. Eine Meldung, die von einem <xref:System.Messaging.MessageQueue.Peek%2A>aufgerufen wird, ist kein Transaktionskontext zugeordnet. Da <xref:System.Messaging.MessageQueue.Peek%2A> keine Nachrichten in der Warteschlange entfernt, wäre es aufgrund eines Aufrufens von <xref:System.Messaging.MessageQueueTransaction.Abort%2A>nichts zu tun.  
  
 Verwenden Sie einen-<xref:System.Messaging.MessageQueue.Receive%2A>, wenn es zulässig ist, dass der aktuelle Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft. Da diese Überladung der <xref:System.Messaging.MessageQueue.Receive%2A>-Methode ein unendliches Timeout angibt, wartet die Anwendung möglicherweise unbegrenzt. Wenn die Anwendungs Verarbeitung fortgesetzt werden soll, ohne auf die Meldung zu warten, sollten Sie die asynchrone Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>verwenden.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <summary>Empfängt die erste verfügbare Meldung aus der Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist, und wartet, bis eine Meldung in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Überladung können Sie eine Meldung empfangen und nach einer angegebenen Zeitspanne beenden, sofern sich keine Meldungen in der Warteschlange befinden.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode ermöglicht das synchrone Lesen einer Nachricht, wobei Sie aus der Warteschlange entfernt wird. Bei nachfolgenden Aufrufen von <xref:System.Messaging.MessageQueue.Receive%2A> werden die Nachrichten in der Warteschlange zurückgegeben, oder es werden neue Nachrichten mit höherer Priorität zurückgegeben.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode, um die erste Nachricht in einer Warteschlange zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen.  
  
 Verwenden Sie einen-<xref:System.Messaging.MessageQueue.Receive%2A>, wenn es zulässig ist, dass der aktuelle Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft. Der Thread wird für die angegebene Zeitspanne blockiert oder unbegrenzt, wenn Sie den Wert <xref:System.Messaging.MessageQueue.InfiniteTimeout> für den Parameter `timeout` angegeben haben. Wenn die Anwendungs Verarbeitung fortgesetzt werden soll, ohne auf eine Nachricht zu warten, sollten Sie die Verwendung der asynchronen Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>in Erwägung gezogen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Nachricht aus einer Warteschlange empfangen und Informationen über diese Nachricht an den Bildschirm ausgegeben. Im Beispiel wird die Ausführung von bis zu fünf Sekunden angehalten, während darauf gewartet wird, dass eine Nachricht in der Warteschlange eintrifft.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
 - oder -  
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, cursor As Cursor) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <summary>Empfängt unter Verwendung des aktuellen Cursors die aktuelle Meldung in der Warteschlange. Wenn keine Meldung verfügbar ist, wartet diese Methode, bis eine Meldung verfügbar ist oder der Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
 - oder -  
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.  
  
 Mit dieser Überladung können Sie eine Meldung empfangen und nach einer angegebenen Zeitspanne beenden, sofern sich keine Meldungen in der Warteschlange befinden.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die erste verfügbare Meldung aus der transaktionalen Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist, und wartet, bis eine Meldung in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht aus einer Transaktions Warteschlange zu empfangen, indem Sie den internen Transaktionskontext verwenden, der vom `transaction`-Parameter definiert wird, und innerhalb eines angegebenen Zeitraums zurückgeben, wenn keine Nachrichten in der Warteschlange vorhanden sind.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode ermöglicht das synchrone Lesen einer Nachricht, wodurch Sie aus der Warteschlange entfernt wird. Bei nachfolgenden Aufrufen von <xref:System.Messaging.MessageQueue.Receive%2A> werden die Nachrichten in der Warteschlange zurückgegeben.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird erst endgültig aus der Warteschlange entfernt, wenn ein Commit für die Transaktion ausgeführt wird.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode, um die erste Nachricht in einer Warteschlange zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen. Eine Meldung, die von einem <xref:System.Messaging.MessageQueue.Peek%2A>aufgerufen wird, ist kein Transaktionskontext zugeordnet. Da <xref:System.Messaging.MessageQueue.Peek%2A> keine Nachrichten in der Warteschlange entfernt, wäre es aufgrund eines Aufrufens von <xref:System.Messaging.MessageQueueTransaction.Abort%2A>nichts zu tun.  
  
 Verwenden Sie einen-<xref:System.Messaging.MessageQueue.Receive%2A>, wenn es zulässig ist, dass der aktuelle Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft. Der Thread wird für die angegebene Zeitspanne blockiert oder unbegrenzt, wenn Sie den Wert <xref:System.Messaging.MessageQueue.InfiniteTimeout> für den Parameter `timeout` angegeben haben. Wenn die Anwendungs Verarbeitung fortgesetzt werden soll, ohne auf eine Nachricht zu warten, sollten Sie die Verwendung der asynchronen Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>in Erwägung gezogen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieser Methode veranschaulicht.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
 - oder -  
  
 Die Warteschlange ist nicht transaktional.  
  
 - oder -  
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die erste verfügbare Meldung aus der Warteschlange, auf die die <see cref="T:System.Messaging.MessageQueue" /> verweist. Dieser Aufruf ist synchron und wartet, bis entweder eine Meldung in der Warteschlange verfügbar ist oder der Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf die erste Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht aus einer Warteschlange zu empfangen, indem Sie einen vom `transactionType`-Parameter definierten Transaktionskontext verwenden und in einem angegebenen Zeitraum zurückgeben, wenn keine Nachrichten in der Warteschlange vorhanden sind.  
  
 Geben Sie `Automatic` für den `transactionType` Parameter an, wenn bereits ein externer Transaktionskontext an den Thread angefügt ist, den Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` an, wenn die Nachricht als einzelne interne Transaktion empfangen werden soll. Sie können `None` angeben, wenn Sie eine Nachricht von einer Transaktions Warteschlange außerhalb eines Transaktions Kontexts empfangen möchten.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode ermöglicht das synchrone Lesen einer Nachricht, wodurch Sie aus der Warteschlange entfernt wird. Bei nachfolgenden Aufrufen von <xref:System.Messaging.MessageQueue.Receive%2A> werden die Nachrichten in der Warteschlange zurückgegeben.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht aus einer Transaktions Warteschlange zu empfangen, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird erst endgültig aus der Warteschlange entfernt, wenn ein Commit für die Transaktion ausgeführt wird.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode, um die erste Nachricht in einer Warteschlange zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen. Eine Meldung, die von einem <xref:System.Messaging.MessageQueue.Peek%2A>aufgerufen wird, ist kein Transaktionskontext zugeordnet. Da <xref:System.Messaging.MessageQueue.Peek%2A> keine Nachrichten in der Warteschlange entfernt, wäre es aufgrund eines Aufrufens von <xref:System.Messaging.MessageQueueTransaction.Abort%2A>nichts zu tun.  
  
 Verwenden Sie einen-<xref:System.Messaging.MessageQueue.Receive%2A>, wenn es zulässig ist, dass der aktuelle Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft. Der Thread wird für die angegebene Zeitspanne blockiert oder unbegrenzt, wenn Sie den Wert <xref:System.Messaging.MessageQueue.InfiniteTimeout> für den Parameter `timeout` angegeben haben. Wenn die Anwendungs Verarbeitung fortgesetzt werden soll, ohne auf eine Nachricht zu warten, sollten Sie die Verwendung der asynchronen Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>in Erwägung gezogen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieser Methode veranschaulicht.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
 - oder -  
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, cursor As Cursor, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt unter Verwendung des aktuellen Cursors die aktuelle Meldung in der Warteschlange. Wenn keine Meldung verfügbar ist, wartet diese Methode, bis eine Meldung verfügbar ist oder der Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf eine Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht aus einer Transaktions Warteschlange zu empfangen, indem Sie den internen Transaktionskontext verwenden, der vom `transaction`-Parameter definiert wird, und innerhalb eines angegebenen Zeitraums zurückgeben, wenn keine Nachrichten in der Warteschlange vorhanden sind.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode ermöglicht das synchrone Lesen einer Nachricht, wodurch Sie aus der Warteschlange entfernt wird. Nachfolgende Aufrufe von <xref:System.Messaging.MessageQueue.Receive%2A> geben die Nachrichten zurück, die in der Warteschlange befolgt werden.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird erst endgültig aus der Warteschlange entfernt, wenn ein Commit für die Transaktion ausgeführt wird.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode, um eine Nachricht in einer Warteschlange zu lesen, ohne Sie aus der Warteschlange zu entfernen. Eine Meldung, die von einem <xref:System.Messaging.MessageQueue.Peek%2A>aufgerufen wird, ist kein Transaktionskontext zugeordnet. Da <xref:System.Messaging.MessageQueue.Peek%2A> keine Nachrichten in der Warteschlange entfernt, gibt es nichts, was durch einen <xref:System.Messaging.MessageQueueTransaction.Abort%2A>aufgerufen werden kann.  
  
 Verwenden Sie einen-<xref:System.Messaging.MessageQueue.Receive%2A>, wenn es zulässig ist, dass der aktuelle Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft. Der Thread wird für den angegebenen Zeitraum oder unbegrenzt blockiert, wenn Sie den Wert <xref:System.Messaging.MessageQueue.InfiniteTimeout> für den Parameter `timeout` angegeben haben. Wenn die Anwendungs Verarbeitung fortgesetzt werden soll, ohne auf eine Nachricht zu warten, sollten Sie die Verwendung der asynchronen Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>in Erwägung gezogen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig. Möglicherweise ist <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
 - oder -  
  
 Die Warteschlange ist nicht transaktional.  
  
 - oder -  
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, cursor As Cursor, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="cursor">Ein <see cref="T:System.Messaging.Cursor" />, der eine bestimmte Position in der Meldungswarteschlange beibehält.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt unter Verwendung des aktuellen Cursors die aktuelle Meldung in der Warteschlange. Wenn keine Meldung verfügbar ist, wartet diese Methode, bis eine Meldung verfügbar ist oder der Timeout abläuft.</summary>
        <returns>Eine <see cref="T:System.Messaging.Message" />, die auf eine Meldung in der Warteschlange verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht aus einer Warteschlange zu empfangen, indem Sie einen vom `transactionType`-Parameter definierten Transaktionskontext verwenden und in einem angegebenen Zeitraum zurückgeben, wenn keine Nachrichten in der Warteschlange vorhanden sind.  
  
 Geben Sie `Automatic` für den `transactionType` Parameter an, wenn bereits ein externer Transaktionskontext an den Thread angefügt ist, den Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` an, wenn die Nachricht als einzelne interne Transaktion empfangen werden soll. Sie können `None` angeben, wenn Sie eine Nachricht von einer Transaktions Warteschlange außerhalb eines Transaktions Kontexts empfangen möchten.  
  
 Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode ermöglicht das synchrone Lesen einer Nachricht, wodurch Sie aus der Warteschlange entfernt wird. Nachfolgende Aufrufe von <xref:System.Messaging.MessageQueue.Receive%2A> geben die Nachrichten zurück, die in der Warteschlange befolgt werden.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht aus einer Transaktions Warteschlange zu empfangen, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird erst endgültig aus der Warteschlange entfernt, wenn ein Commit für die Transaktion ausgeführt wird.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.Peek%2A>-Methode, um eine Nachricht in einer Warteschlange zu lesen, ohne Sie aus der Warteschlange zu entfernen. Eine Meldung, die von einem <xref:System.Messaging.MessageQueue.Peek%2A>aufgerufen wird, ist kein Transaktionskontext zugeordnet. Da <xref:System.Messaging.MessageQueue.Peek%2A> keine Nachrichten in der Warteschlange entfernt, gibt es nichts, was durch einen <xref:System.Messaging.MessageQueueTransaction.Abort%2A>aufgerufen werden kann.  
  
 Verwenden Sie einen-<xref:System.Messaging.MessageQueue.Receive%2A>, wenn es zulässig ist, dass der aktuelle Thread blockiert wird, während er darauf wartet, dass eine Nachricht in der Warteschlange eintrifft. Der Thread wird für den angegebenen Zeitraum oder unbegrenzt blockiert, wenn Sie den Wert <xref:System.Messaging.MessageQueue.InfiniteTimeout> für den Parameter `timeout` angegeben haben. Wenn die Anwendungs Verarbeitung fortgesetzt werden soll, ohne auf eine Nachricht zu warten, sollten Sie die Verwendung der asynchronen Methode <xref:System.Messaging.MessageQueue.BeginReceive%2A>in Erwägung gezogen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="cursor" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist nicht gültig. Möglicherweise ist <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung in der Warteschlange eingegangen.  
  
 - oder -  
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <threadsafe>Die Methode ist nicht Thread sicher.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Empfängt eine Meldung mit der angegebenen Korrelations-ID.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID (aus einer nicht transaktionalen Warteschlange) und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen Korrelations-ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der nicht transaktionalen Warteschlange, auf die vom <xref:System.Messaging.MessageQueue> verwiesen wird, auf eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> mit dem angegebenen `correlationId`-Parameter übereinstimmt. Wenn keine Nachricht gefunden wird, die mit dem `correlationID`-Parameter übereinstimmt, wird eine Ausnahme ausgelöst. Andernfalls wird die Nachricht aus der Warteschlange entfernt und an die Anwendung zurückgegeben.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A>-Eigenschaft wird verwendet, um eine an die Warteschlange gesendete Nachricht an zugeordnete Antwort-, Berichts-oder Bestätigungsnachrichten zu binden.  
  
 Zwei weitere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode gibt die erste Nachricht in der Warteschlange zurück, und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>-Methode ruft eine Nachricht durch Angabe Ihres eindeutigen Bezeichners ab.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>-Methode, um eine Meldung mit einer angegebenen Korrelations-ID zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Nachricht gesendet und empfangen, die eine Bestellung zu und aus einer Warteschlange enthält. Insbesondere wird eine positive Bestätigung angefordert, wenn die ursprüngliche Nachricht erreicht oder aus der Warteschlange abgerufen wird.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="correlationId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID (aus einer transaktionalen Warteschlange) und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen Korrelations-ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Transaktions Warteschlange, auf die vom <xref:System.Messaging.MessageQueue> verwiesen wird, auf eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> mit dem angegebenen `correlationId`-Parameter übereinstimmt. Wenn keine Nachricht gefunden wird, die mit dem `correlationID`-Parameter übereinstimmt, wird eine Ausnahme ausgelöst. Andernfalls wird die Nachricht aus der Warteschlange entfernt und mithilfe des internen Transaktions Kontexts, der durch den `transaction`-Parameter definiert wird, an die Anwendung zurückgegeben.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird erst endgültig aus der Warteschlange entfernt, wenn ein Commit für die Transaktion ausgeführt wird.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A>-Eigenschaft wird verwendet, um eine an die Warteschlange gesendete Nachricht an zugeordnete Antwort-, Berichts-oder Bestätigungsnachrichten zu binden.  
  
 Zwei weitere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode gibt die erste Nachricht in der Warteschlange zurück, und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>-Methode wird verwendet, um eine Nachricht abzurufen, indem Sie Ihren eindeutigen Bezeichner angibt.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>-Methode, um eine Meldung mit einer angegebenen Korrelations-ID zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen. Eine Meldung, die von einem <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>aufgerufen wird, ist kein Transaktionskontext zugeordnet. Da <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> keine Nachrichten in der Warteschlange entfernt, wäre es nicht sinnvoll, einen Rollback auszuführen, wenn die Transaktion abgebrochen wurde.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="correlationId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Warteschlange ist nicht transaktional.  
  
 - oder -  
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen Korrelations-ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Warteschlange, auf die vom <xref:System.Messaging.MessageQueue> verwiesen wird, nach einer Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> mit dem angegebenen `correlationId` Parameter übereinstimmt. Wenn keine Nachricht gefunden wird, die mit dem `correlationID`-Parameter übereinstimmt, wird eine Ausnahme ausgelöst. Andernfalls wird die Nachricht aus der Warteschlange entfernt und mithilfe eines Transaktions Kontexts, der durch den `transactionType`-Parameter definiert wird, an die Anwendung zurückgegeben.  
  
 Geben Sie `Automatic` für den `transactionType` Parameter an, wenn bereits ein externer Transaktionskontext an den Thread angefügt ist, den Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` an, wenn die Nachricht als einzelne interne Transaktion empfangen werden soll. Sie können `None` angeben, wenn Sie eine Nachricht von einer Transaktions Warteschlange außerhalb eines Transaktions Kontexts empfangen möchten.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht aus einer Transaktions Warteschlange zu empfangen, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird erst endgültig aus der Warteschlange entfernt, wenn ein Commit für die Transaktion ausgeführt wird.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A>-Eigenschaft wird verwendet, um eine an die Warteschlange gesendete Nachricht an zugeordnete Antwort-, Berichts-oder Bestätigungsnachrichten zu binden.  
  
 Zwei weitere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode gibt die erste Nachricht in der Warteschlange zurück, und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>-Methode wird verwendet, um eine Nachricht abzurufen, indem Sie Ihren eindeutigen Bezeichner angibt.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>-Methode, um eine Meldung mit einer angegebenen Korrelations-ID zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen. Eine Meldung, die von einem <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>aufgerufen wird, ist kein Transaktionskontext zugeordnet. Da <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> keine Nachrichten in der Warteschlange entfernt, wäre es nicht sinnvoll, einen Rollback auszuführen, wenn die Transaktion abgebrochen wurde.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="correlationId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID (aus einer nicht transaktionalen Warteschlange) und wartet, bis eine Meldung mit der angegebenen Korrelations-ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der nicht transaktionalen Warteschlange, auf die vom <xref:System.Messaging.MessageQueue> verwiesen wird, auf eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> mit dem angegebenen `correlationId`-Parameter übereinstimmt. Diese Methode wird sofort zurückgegeben, wenn sich die Nachricht mit der vom `correlationId`-Parameter angegebenen Korrelations-ID in der Warteschlange befindet. Andernfalls wartet die-Methode den angegebenen Zeitraum, bis eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eintrifft, wird eine Ausnahme ausgelöst.  
  
 Der `timeout`-Parameter gibt nicht die Gesamtlaufzeit für diese Methode an. Stattdessen wird die Zeit angegeben, die gewartet werden soll, bis eine neue Nachricht in der Warteschlange eintrifft. Jedes Mal, wenn eine neue Nachricht eingeht, untersucht diese Methode den <xref:System.Messaging.Message.CorrelationId%2A> der neuen Nachricht, um zu ermitteln, ob Sie mit dem Parameter `correlationId` übereinstimmt. Andernfalls startet diese Methode den Timeout Zeitraum und wartet darauf, dass eine andere neue Nachricht eintrifft. Wenn neue Nachrichten innerhalb des Timeout Zeitraums eingehen, ist es daher möglich, dass diese Methode unbegrenzt ausgeführt wird, entweder bis der Timeout Zeitraum abläuft, ohne dass neue Nachrichten eintreffen, oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.CorrelationId%2A> mit dem `correlationId` Parameter übereinstimmt.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A>-Eigenschaft wird verwendet, um eine an die Warteschlange gesendete Nachricht an zugeordnete Antwort-, Berichts-oder Bestätigungsnachrichten zu binden.  
  
 Zwei weitere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode gibt die erste Nachricht in der Warteschlange zurück, und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>-Methode wird verwendet, um eine Nachricht abzurufen, indem Sie Ihren eindeutigen Bezeichner angibt.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>-Methode, um eine Meldung mit einer angegebenen Korrelations-ID zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Meldung mit der angegebenen <paramref name="correlationId" /> ist nicht in der Warteschlange vorhanden und nicht vor Ablauf des Timeouts eingegangen.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID (aus einer transaktionalen Warteschlange) und wartet, bis eine Meldung mit der angegebenen Korrelations-ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Transaktions Warteschlange, auf die vom <xref:System.Messaging.MessageQueue> verwiesen wird, auf eine Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> mit dem angegebenen `correlationId`-Parameter übereinstimmt. Diese Methode wird sofort zurückgegeben, wenn die Nachricht mit der vom `correlationId`-Parameter angegebenen Korrelations-ID in der Warteschlange ist. dabei wird der interne Transaktionskontext verwendet, der vom `transaction`-Parameter definiert wird. Andernfalls wartet die-Methode den angegebenen Zeitraum, bis eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eintrifft, wird eine Ausnahme ausgelöst.  
  
 Der `timeout`-Parameter gibt nicht die Gesamtlaufzeit für diese Methode an. Stattdessen wird die Zeit angegeben, die gewartet werden soll, bis eine neue Nachricht in der Warteschlange eintrifft. Jedes Mal, wenn eine neue Nachricht eingeht, untersucht diese Methode den <xref:System.Messaging.Message.CorrelationId%2A> der neuen Nachricht, um zu ermitteln, ob Sie mit dem Parameter `correlationId` übereinstimmt. Andernfalls startet diese Methode den Timeout Zeitraum und wartet darauf, dass eine andere neue Nachricht eintrifft. Wenn neue Nachrichten innerhalb des Timeout Zeitraums eingehen, ist es daher möglich, dass diese Methode unbegrenzt ausgeführt wird, entweder bis der Timeout Zeitraum abläuft, ohne dass neue Nachrichten eintreffen, oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.CorrelationId%2A> mit dem `correlationId` Parameter übereinstimmt.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird erst endgültig aus der Warteschlange entfernt, wenn ein Commit für die Transaktion ausgeführt wird.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A>-Eigenschaft wird verwendet, um eine an die Warteschlange gesendete Nachricht an zugeordnete Antwort-, Berichts-oder Bestätigungsnachrichten zu binden.  
  
 Zwei weitere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode gibt die erste Nachricht in der Warteschlange zurück, und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>-Methode wird verwendet, um eine Nachricht abzurufen, indem Sie Ihren eindeutigen Bezeichner angibt.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>-Methode, um eine Meldung mit einer angegebenen Korrelations-ID zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen. Eine Meldung, die von einem <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>aufgerufen wird, ist kein Transaktionskontext zugeordnet. Da <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> keine Nachrichten in der Warteschlange entfernt, wäre es nicht sinnvoll, einen Rollback auszuführen, wenn die Transaktion abgebrochen wurde.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Meldung mit der angegebenen <paramref name="correlationId" /> ist nicht in der Warteschlange vorhanden und nicht vor Ablauf des Timeouts eingegangen.  
  
- oder - 
Die Warteschlange ist nicht transaktional.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Die <see cref="P:System.Messaging.Message.CorrelationId" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen Korrelations-ID und wartet, bis eine Meldung mit der angegebenen Korrelations-ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.CorrelationId" /> dem übergebenen <paramref name="correlationId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht in der Warteschlange, auf die vom <xref:System.Messaging.MessageQueue> verwiesen wird, nach einer Nachricht, deren <xref:System.Messaging.Message.CorrelationId%2A> mit dem angegebenen `correlationId` Parameter übereinstimmt. Diese Methode wird sofort zurückgegeben, wenn die Nachricht mit der vom `correlationId`-Parameter angegebenen Korrelations-ID in der Warteschlange ist. dabei wird ein vom `transactionType`-Parameter definierter Transaktionskontext verwendet. Andernfalls wartet die-Methode den angegebenen Zeitraum, bis eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eintrifft, wird eine Ausnahme ausgelöst.  
  
 Der `timeout`-Parameter gibt nicht die Gesamtlaufzeit für diese Methode an. Stattdessen wird die Zeit angegeben, die gewartet werden soll, bis eine neue Nachricht in der Warteschlange eintrifft. Jedes Mal, wenn eine neue Nachricht eingeht, untersucht diese Methode den <xref:System.Messaging.Message.CorrelationId%2A> der neuen Nachricht, um zu ermitteln, ob Sie mit dem Parameter `correlationId` übereinstimmt. Andernfalls startet diese Methode den Timeout Zeitraum und wartet darauf, dass eine andere neue Nachricht eintrifft. Wenn neue Nachrichten innerhalb des Timeout Zeitraums eingehen, ist es daher möglich, dass diese Methode unbegrenzt ausgeführt wird, entweder bis der Timeout Zeitraum abläuft, ohne dass neue Nachrichten eintreffen, oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.CorrelationId%2A> mit dem `correlationId` Parameter übereinstimmt. Geben Sie `Automatic` für den `transactionType` Parameter an, wenn bereits ein externer Transaktionskontext an den Thread angefügt ist, den Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` an, wenn die Nachricht als einzelne interne Transaktion empfangen werden soll. Sie können `None` angeben, wenn Sie eine Nachricht von einer Transaktions Warteschlange außerhalb eines Transaktions Kontexts empfangen möchten.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht aus einer Transaktions Warteschlange zu empfangen, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird erst endgültig aus der Warteschlange entfernt, wenn ein Commit für die Transaktion ausgeführt wird.  
  
 Die <xref:System.Messaging.Message.CorrelationId%2A>-Eigenschaft wird verwendet, um eine an die Warteschlange gesendete Nachricht an zugeordnete Antwort-, Berichts-oder Bestätigungsnachrichten zu binden.  
  
 Zwei weitere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode gibt die erste Nachricht in der Warteschlange zurück, und die <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>-Methode wird verwendet, um eine Nachricht abzurufen, indem Sie Ihren eindeutigen Bezeichner angibt.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>-Methode, um eine Meldung mit einer angegebenen Korrelations-ID zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen. Eine Meldung, die von einem <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>aufgerufen wird, ist kein Transaktionskontext zugeordnet. Da <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> keine Nachrichten in der Warteschlange entfernt, wäre es nicht sinnvoll, einen Rollback auszuführen, wenn die Transaktion abgebrochen wurde.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="correlationId" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="correlationId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Eine Meldung mit der angegebenen <paramref name="correlationId" /> ist nicht in der Warteschlange vorhanden und nicht vor Ablauf des Timeouts eingegangen.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Empfängt die Meldung mit der angegebenen ID und entfernt sie aus der Warteschlange.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID aus einer nicht transaktionalen Warteschlange und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bekannten Bezeichner zu lesen und aus der Warteschlange zu entfernen. Diese Methode löst sofort eine Ausnahme aus, wenn sich die Nachricht nicht in der Warteschlange befindet.  
  
 Die <xref:System.Messaging.Message.Id%2A>-Eigenschaft einer Nachricht ist in der Message Queuing Enterprise eindeutig, sodass es höchstens eine Nachricht in der Warteschlange gibt, die mit dem angegebenen `id` Parameter übereinstimmt.  
  
 Zwei weitere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode gibt die erste Nachricht in der Warteschlange zurück, und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>-Methode wird zum Abrufen einer Bestätigung, eines Berichts oder einer Anwendungs generierten Antwortnachricht verwendet, die als Ergebnis einer an die Warteschlange gesendeten Nachricht erstellt wurde.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>-Methode, um eine Nachricht mit einem angegebenen Bezeichner zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="id" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID (aus einer transaktionalen Warteschlange) und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bekannten Bezeichner zu lesen und aus der Warteschlange zu entfernen, indem Sie den internen Transaktionskontext verwenden, der vom `transaction`-Parameter definiert wird. Diese Methode löst sofort eine Ausnahme aus, wenn sich die Nachricht nicht in der Warteschlange befindet.  
  
 Die <xref:System.Messaging.Message.Id%2A>-Eigenschaft einer Nachricht ist in der Message Queuing Enterprise eindeutig, sodass es höchstens eine Nachricht in der Warteschlange gibt, die mit dem angegebenen `id` Parameter übereinstimmt.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird erst endgültig aus der Warteschlange entfernt, wenn ein Commit für die Transaktion ausgeführt wird.  
  
 Zwei weitere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode gibt die erste Nachricht in der Warteschlange zurück, und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>-Methode wird zum Abrufen einer Bestätigung, eines Berichts oder einer Anwendungs generierten Antwortnachricht verwendet, die als Ergebnis einer an die Warteschlange gesendeten Nachricht erstellt wurde.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>-Methode, um eine Nachricht mit einem angegebenen Bezeichner zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen. Eine Meldung, die von einem <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>aufgerufen wird, ist kein Transaktionskontext zugeordnet. Da <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> keine Nachrichten in der Warteschlange entfernt, wäre es nicht sinnvoll, einen Rollback auszuführen, wenn die Transaktion abgebrochen wurde.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="id" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die Warteschlange ist nicht transaktional.  
  
 - oder -  
  
 Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID und löst sofort eine Ausnahme aus, wenn sich derzeit keine Meldung mit der angegebenen ID in der Warteschlange befindet.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bekannten Bezeichner zu lesen und aus der Warteschlange zu entfernen. Diese Methode löst sofort eine Ausnahme aus, wenn sich die Nachricht nicht in der Warteschlange befindet. Andernfalls wird die Nachricht aus der Warteschlange entfernt und mithilfe eines Transaktions Kontexts, der durch den `transactionType`-Parameter definiert wird, an die Anwendung zurückgegeben.  
  
 Geben Sie `Automatic` für den `transactionType` Parameter an, wenn bereits ein externer Transaktionskontext an den Thread angefügt ist, den Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` an, wenn die Nachricht als einzelne interne Transaktion empfangen werden soll. Sie können `None` angeben, wenn Sie eine Nachricht von einer Transaktions Warteschlange außerhalb eines Transaktions Kontexts empfangen möchten.  
  
 Die <xref:System.Messaging.Message.Id%2A>-Eigenschaft einer Nachricht ist in der Message Queuing Enterprise eindeutig, sodass es höchstens eine Nachricht in der Warteschlange gibt, die mit dem angegebenen `id` Parameter übereinstimmt. Wenn sich die Nachricht mit dem angegebenen Bezeichner in einer Warteschlange befindet, die mit dieser <xref:System.Messaging.MessageQueue> Instanz verknüpft ist, wird die Nachricht nicht gefunden.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht aus einer Transaktions Warteschlange zu empfangen, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird erst endgültig aus der Warteschlange entfernt, wenn ein Commit für die Transaktion ausgeführt wird.  
  
 Zwei weitere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode gibt die erste Nachricht in der Warteschlange zurück, und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>-Methode wird zum Abrufen einer Bestätigung, eines Berichts oder einer Anwendungs generierten Antwortnachricht verwendet, die als Ergebnis einer an die Warteschlange gesendeten Nachricht erstellt wurde.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>-Methode, um eine Nachricht mit einem angegebenen Bezeichner zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen. Eine Meldung, die von einem <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>aufgerufen wird, ist kein Transaktionskontext zugeordnet. Da <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> keine Nachrichten in der Warteschlange entfernt, wäre es nicht sinnvoll, einen Rollback auszuführen, wenn die Transaktion abgebrochen wurde.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="id" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID (aus einer nicht transaktionalen Warteschlange) und wartet, bis eine Meldung mit der angegebenen ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bekannten Bezeichner zu lesen und aus der Warteschlange zu entfernen. Diese Methode wird sofort zurückgegeben, wenn die Nachricht mit dem Bezeichner, der vom `id`-Parameter angegeben wird, in der Warteschlange ist Andernfalls wartet die-Methode den angegebenen Zeitraum, bis eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eintrifft, wird eine Ausnahme ausgelöst.  
  
 Der `timeout`-Parameter gibt nicht die Gesamtlaufzeit für diese Methode an. Stattdessen wird die Zeit angegeben, die gewartet werden soll, bis eine neue Nachricht in der Warteschlange eintrifft. Jedes Mal, wenn eine neue Nachricht eingeht, untersucht diese Methode den <xref:System.Messaging.Message.Id%2A> der neuen Nachricht, um zu ermitteln, ob Sie mit dem Parameter `id` übereinstimmt. Andernfalls startet diese Methode den Timeout Zeitraum und wartet darauf, dass eine andere neue Nachricht eintrifft. Wenn neue Nachrichten innerhalb des Timeout Zeitraums eingehen, ist es daher möglich, dass diese Methode unbegrenzt ausgeführt wird, entweder bis der Timeout Zeitraum abläuft, ohne dass neue Nachrichten eintreffen, oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.Id%2A> mit dem `id` Parameter übereinstimmt.  
  
 Die <xref:System.Messaging.Message.Id%2A>-Eigenschaft einer Nachricht ist in der Message Queuing Enterprise eindeutig, sodass es höchstens eine Nachricht in der Warteschlange gibt, die mit dem angegebenen `id` Parameter übereinstimmt.  
  
 Verwenden Sie diese Überladung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>, wenn es zulässig ist, dass der aktuelle Thread blockiert wird, solange neue Nachrichten in der Warteschlange innerhalb der durch den `timeout`-Parameter angegebenen Timeout Periode weiterhin eintreffen. Der Thread wird für mindestens den angegebenen Zeitraum oder unbegrenzt blockiert, wenn Sie den Wert <xref:System.Messaging.MessageQueue.InfiniteTimeout> für den Parameter `timeout` angegeben haben oder wenn neue Nachrichten in der Warteschlange innerhalb des durch den Parameter `timeout` angegebenen Timeout Zeitraums weiterhin eintreffen.  
  
 Zwei weitere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode gibt die erste Nachricht in der Warteschlange zurück, und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>-Methode wird zum Abrufen einer Bestätigung, eines Berichts oder einer Anwendungs generierten Antwortnachricht verwendet, die als Ergebnis einer an die Warteschlange gesendeten Nachricht erstellt wurde.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>-Methode, um eine Nachricht mit einem angegebenen Bezeichner zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung mit der angegebenen <paramref name="id" /> in die Warteschlange eingegangen.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID (aus einer transaktionalen Warteschlange) und wartet, bis eine Meldung mit der angegebenen ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bekannten Bezeichner zu lesen und aus der Warteschlange zu entfernen, indem Sie den internen Transaktionskontext verwenden, der vom `transaction`-Parameter definiert wird. Diese Methode wird sofort zurückgegeben, wenn die Nachricht mit dem Bezeichner, der vom `id`-Parameter angegeben wird, in der Warteschlange ist Andernfalls wartet die-Methode den angegebenen Zeitraum, bis eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eintrifft, wird eine Ausnahme ausgelöst.  
  
 Der `timeout`-Parameter gibt nicht die Gesamtlaufzeit für diese Methode an. Stattdessen wird die Zeit angegeben, die gewartet werden soll, bis eine neue Nachricht in der Warteschlange eintrifft. Jedes Mal, wenn eine neue Nachricht eingeht, untersucht diese Methode den <xref:System.Messaging.Message.Id%2A> der neuen Nachricht, um zu ermitteln, ob Sie mit dem Parameter `id` übereinstimmt. Andernfalls startet diese Methode den Timeout Zeitraum und wartet darauf, dass eine andere neue Nachricht eintrifft. Wenn neue Nachrichten innerhalb des Timeout Zeitraums eingehen, ist es daher möglich, dass diese Methode unbegrenzt ausgeführt wird, entweder bis der Timeout Zeitraum abläuft, ohne dass neue Nachrichten eintreffen, oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.Id%2A> mit dem `id` Parameter übereinstimmt.  
  
 Die <xref:System.Messaging.Message.Id%2A>-Eigenschaft einer Nachricht ist in der Message Queuing Enterprise eindeutig, sodass es höchstens eine Nachricht in der Warteschlange gibt, die mit dem angegebenen `id` Parameter übereinstimmt.  
  
 Verwenden Sie diese Überladung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>, wenn es zulässig ist, dass der aktuelle Thread blockiert wird, solange neue Nachrichten in der Warteschlange innerhalb der durch den `timeout`-Parameter angegebenen Timeout Periode weiterhin eintreffen. Der Thread wird für mindestens den angegebenen Zeitraum oder unbegrenzt blockiert, wenn Sie den Wert <xref:System.Messaging.MessageQueue.InfiniteTimeout> für den Parameter `timeout` angegeben haben oder wenn neue Nachrichten in der Warteschlange weiterhin innerhalb des durch den `timeout`-Parameter angegebenen Timeout Zeitraums eintreffen.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird erst endgültig aus der Warteschlange entfernt, wenn ein Commit für die Transaktion ausgeführt wird.  
  
 Zwei weitere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode gibt die erste Nachricht in der Warteschlange zurück, und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>-Methode wird zum Abrufen einer Bestätigung, eines Berichts oder einer Anwendungs generierten Antwortnachricht verwendet, die als Ergebnis einer an die Warteschlange gesendeten Nachricht erstellt wurde.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>-Methode, um eine Nachricht mit einem angegebenen Bezeichner zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen. Eine Meldung, die von einem <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>aufgerufen wird, ist kein Transaktionskontext zugeordnet. Da <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> keine Nachrichten in der Warteschlange entfernt, wäre es nicht sinnvoll, einen Rollback auszuführen, wenn die Transaktion abgebrochen wurde.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung mit der angegebenen <paramref name="id" /> in die Warteschlange eingegangen.  
  
- oder - 
Die Warteschlange ist nicht transaktional.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.Messaging.Message.Id" /> der zu empfangenden Meldung.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, für die auf den Eingang einer neuen Meldung zur Überprüfung gewartet werden soll.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Empfängt die Meldung mit der angegebenen ID und wartet, bis eine Meldung mit der angegebenen ID in der Warteschlange verfügbar ist oder das Timeout abläuft.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Id" />-Eigenschaft dem übergebenen <paramref name="id" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bekannten Bezeichner zu lesen und aus der Warteschlange zu entfernen. Diese Methode wird sofort zurückgegeben, wenn sich die Nachricht mit dem durch den `id`-Parameter angegebenen Bezeichner in der Warteschlange befindet. dabei wird ein vom `transactionType`-Parameter definierter Transaktionskontext verwendet. Andernfalls wartet die-Methode den angegebenen Zeitraum, bis eine neue Nachricht eintrifft. Wenn eine neue Nachricht nicht vor Ablauf des Timeouts eintrifft, wird eine Ausnahme ausgelöst.  
  
 Der `timeout`-Parameter gibt nicht die Gesamtlaufzeit für diese Methode an. Stattdessen wird die Zeit angegeben, die gewartet werden soll, bis eine neue Nachricht in der Warteschlange eintrifft. Jedes Mal, wenn eine neue Nachricht eingeht, untersucht diese Methode den <xref:System.Messaging.Message.Id%2A> der neuen Nachricht, um zu ermitteln, ob Sie mit dem Parameter `id` übereinstimmt. Andernfalls startet diese Methode den Timeout Zeitraum und wartet darauf, dass eine andere neue Nachricht eintrifft. Wenn neue Nachrichten innerhalb des Timeout Zeitraums eingehen, ist es daher möglich, dass diese Methode unbegrenzt ausgeführt wird, entweder bis der Timeout Zeitraum abläuft, ohne dass neue Nachrichten eintreffen, oder bis eine Nachricht eingeht, deren <xref:System.Messaging.Message.Id%2A> mit dem `id` Parameter übereinstimmt.  
  
 Geben Sie `Automatic` für den `transactionType` Parameter an, wenn bereits ein externer Transaktionskontext an den Thread angefügt ist, den Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` an, wenn die Nachricht als einzelne interne Transaktion empfangen werden soll. Sie können `None` angeben, wenn Sie eine Nachricht von einer Transaktions Warteschlange außerhalb eines Transaktions Kontexts empfangen möchten.  
  
 Die <xref:System.Messaging.Message.Id%2A>-Eigenschaft einer Nachricht ist in der Message Queuing Enterprise eindeutig, sodass es höchstens eine Nachricht in der Warteschlange gibt, die mit dem angegebenen `id` Parameter übereinstimmt. Wenn sich die Nachricht mit dem angegebenen Bezeichner in einer Warteschlange befindet, die mit dieser <xref:System.Messaging.MessageQueue> Instanz verknüpft ist, wird die Nachricht nicht gefunden.  
  
 Verwenden Sie diese Überladung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>, wenn es zulässig ist, dass der aktuelle Thread blockiert wird, solange neue Nachrichten in der Warteschlange innerhalb der durch den `timeout`-Parameter angegebenen Timeout Periode weiterhin eintreffen. Der Thread wird für mindestens den angegebenen Zeitraum oder unbegrenzt blockiert, wenn Sie den Wert <xref:System.Messaging.MessageQueue.InfiniteTimeout> für den Parameter `timeout` angegeben haben oder wenn neue Nachrichten in der Warteschlange innerhalb des durch den Parameter `timeout` angegebenen Timeout Zeitraums weiterhin eintreffen.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht aus einer Transaktions Warteschlange zu empfangen, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird erst endgültig aus der Warteschlange entfernt, wenn ein Commit für die Transaktion ausgeführt wird.  
  
 Zwei weitere Methoden ermöglichen es Ihnen, Nachrichten aus einer Warteschlange zu empfangen. Die <xref:System.Messaging.MessageQueue.Receive%2A>-Methode gibt die erste Nachricht in der Warteschlange zurück, und die <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>-Methode wird zum Abrufen einer Bestätigung, eines Berichts oder einer Anwendungs generierten Antwortnachricht verwendet, die als Ergebnis einer an die Warteschlange gesendeten Nachricht erstellt wurde.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>-Methode, um eine Nachricht mit einem angegebenen Bezeichner zu lesen, ohne Sie aus der Warteschlange zu entfernen. Die <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>-Methode gibt immer die erste Nachricht in der Warteschlange zurück, sodass nachfolgende Aufrufe der Methode dieselbe Nachricht zurückgeben, es sei denn, eine Nachricht mit höherer Priorität wird in der Warteschlange eintreffen. Eine Meldung, die von einem <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>aufgerufen wird, ist kein Transaktionskontext zugeordnet. Da <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> keine Nachrichten in der Warteschlange entfernt, wäre es nicht sinnvoll, einen Rollback auszuführen, wenn die Transaktion abgebrochen wurde.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="id" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für den <paramref name="timeout" />-Parameter angegebene Wert ist ungültig. Möglicherweise ist der <paramref name="timeout" /> kleiner als <see cref="F:System.TimeSpan.Zero" /> oder größer als der <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Vor Ablauf des Timeouts ist keine Meldung mit der angegebenen <paramref name="id" /> in die Warteschlange eingegangen.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Eingeführt in MSMQ 3.0. Empfängt eine bestimmte Meldung aus der Warteschlange. Die Meldung kann anhand eines Suchbezeichners oder anhand der Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der zu empfangenden Meldung.</param>
        <summary>Eingeführt in MSMQ 3.0. Empfängt die Meldung, die dem angegebenen Suchbezeichner in einer nicht transaktionalen Warteschlange entspricht.</summary>
        <returns>Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.LookupId" />-Eigenschaft dem übergebenen <paramref name="lookupId" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bekannten Such Bezeichner zu lesen und aus der Warteschlange zu entfernen. Diese Methode löst sofort eine Ausnahme aus, wenn sich die Nachricht nicht in der Warteschlange befindet.  
  
 Die <xref:System.Messaging.Message.LookupId%2A>-Eigenschaft einer Nachricht ist eindeutig für die Warteschlange, in der sich die Nachricht befindet. es wird also höchstens eine Nachricht in der Warteschlange angezeigt, die mit dem angegebenen `lookupId` Parameter übereinstimmt.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>-Methode, um eine Nachricht mit einem angegebenen Such Bezeichner zu lesen, ohne Sie aus der Warteschlange zu entfernen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="lookupId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">Einer der <see cref="T:System.Messaging.MessageLookupAction" />-Werte, der angibt, wie die Meldung in der Warteschlange gelesen wird. Geben Sie eine der folgenden Optionen an: 
 <see langword="MessageLookupAction.Current" />: Empfängt die durch <paramref name="lookupId" /> angegebene Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.Next" />: Empfängt die Meldung nach der durch <paramref name="lookupId" /> angegebenen Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.Previous" />: Empfängt die Meldung vor der durch <paramref name="lookupId" /> angegebenen Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.First" />: Empfängt die erste Meldung aus der Warteschlange und entfernt sie aus dieser. Der <paramref name="lookupId" />-Parameter muss auf 0 festgelegt werden.  
  
 <see langword="MessageLookupAction.Last" />: Empfängt die letzte Meldung aus der Warteschlange und entfernt sie aus dieser. Der <paramref name="lookupId" />-Parameter muss auf 0 festgelegt werden.</param>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der zu empfangenden Meldung, andernfalls 0 (null). 0 wird beim Zugreifen auf die erste oder letzte Meldung in die Warteschlange verwendet.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Eingeführt in MSMQ 3.0. Empfängt eine bestimmte Meldung aus einer transaktionalen Warteschlange. Die Meldung kann anhand eines Suchbezeichners oder anhand der Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
        <returns>Die durch den übergebenen <paramref name="lookupId" />-Parameter und <paramref name="action" />-Parameter angegebene <see cref="T:System.Messaging.Message" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bekannten Such Bezeichner zu lesen und aus der Warteschlange zu entfernen, indem Sie einen Transaktionskontext verwenden, der vom `transaction`-Parameter definiert wird. Diese Methode löst sofort eine Ausnahme aus, wenn sich die Nachricht nicht in der Warteschlange befindet.  
  
 Die <xref:System.Messaging.Message.LookupId%2A>-Eigenschaft einer Nachricht ist eindeutig für die Warteschlange, in der sich die Nachricht befindet. es wird also höchstens eine Nachricht in der Warteschlange angezeigt, die mit dem angegebenen `lookupId` Parameter übereinstimmt.  
  
 Da diese Methode für eine transaktionale Warteschlange aufgerufen wird, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird erst endgültig aus der Warteschlange entfernt, wenn ein Commit für die Transaktion ausgeführt wird.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>-Methode, um eine Nachricht mit einem angegebenen Bezeichner zu lesen, ohne Sie aus der Warteschlange zu entfernen. Eine Meldung, die von einem <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>aufgerufen wird, ist kein Transaktionskontext zugeordnet. Da <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> keine Nachrichten aus der Warteschlange entfernt, wäre es nicht sinnvoll, einen Rollback auszuführen, wenn die Transaktion abgebrochen wurde.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="lookupId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.  
  
 - oder -  
  
 Die Warteschlange ist nicht transaktional.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="action" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageLookupAction" />-Member.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">Einer der <see cref="T:System.Messaging.MessageLookupAction" />-Werte, der angibt, wie die Meldung in der Warteschlange gelesen wird. Geben Sie eine der folgenden Optionen an: 
 <see langword="MessageLookupAction.Current" />: Empfängt die durch <paramref name="lookupId" /> angegebene Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.Next" />: Empfängt die Meldung nach der durch <paramref name="lookupId" /> angegebenen Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.Previous" />: Empfängt die Meldung vor der durch <paramref name="lookupId" /> angegebenen Meldung und entfernt sie aus der Warteschlange.  
  
 <see langword="MessageLookupAction.First" />: Empfängt die erste Meldung aus der Warteschlange und entfernt sie aus dieser. Der <paramref name="lookupId" />-Parameter muss auf 0 festgelegt werden.  
  
 <see langword="MessageLookupAction.Last" />: Empfängt die letzte Meldung aus der Warteschlange und entfernt sie aus dieser. Der <paramref name="lookupId" />-Parameter muss auf 0 festgelegt werden.</param>
        <param name="lookupId">Die <see cref="P:System.Messaging.Message.LookupId" /> der zu empfangenden Meldung, andernfalls 0 (null). 0 wird beim Zugreifen auf die erste oder letzte Meldung in die Warteschlange verwendet.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Eingeführt in MSMQ 3.0. Empfängt unter Verwendung des angegebenen Transaktionskontexts eine bestimmte Meldung aus der Warteschlange. Die Meldung kann anhand eines Suchbezeichners oder anhand der Position am Anfang oder am Ende der Warteschlange angegeben werden.</summary>
        <returns>Die durch den übergebenen <paramref name="action" />-Parameter und <paramref name="lookupId" />-Parameter angegebene <see cref="T:System.Messaging.Message" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine Nachricht mit einem bekannten Such Bezeichner zu lesen und aus der Warteschlange zu entfernen, indem Sie einen Transaktionskontext verwenden, der vom `transactionType`-Parameter definiert wird. Diese Methode löst sofort eine Ausnahme aus, wenn sich die Nachricht nicht in der Warteschlange befindet.  
  
 Die <xref:System.Messaging.Message.LookupId%2A>-Eigenschaft einer Nachricht ist eindeutig für die Warteschlange, in der sich die Nachricht befindet. es wird also höchstens eine Nachricht in der Warteschlange angezeigt, die mit dem angegebenen `lookupId` Parameter übereinstimmt.  
  
 Verwenden Sie die <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>-Methode, um eine Nachricht mit einem angegebenen Bezeichner zu lesen, ohne Sie aus der Warteschlange zu entfernen. Eine Meldung, die von einem <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>aufgerufen wird, ist kein Transaktionskontext zugeordnet. Da <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> keine Nachrichten aus der Warteschlange entfernt, wäre es nicht sinnvoll, einen Rollback auszuführen, wenn die Transaktion abgebrochen wurde.  
  
 Geben Sie `Automatic` für den `transactionType` Parameter an, wenn bereits ein externer Transaktionskontext an den Thread angefügt ist, den Sie zum Empfangen der Nachricht verwenden möchten. Geben Sie `Single` an, wenn die Nachricht als einzelne interne Transaktion empfangen werden soll. Sie können `None` angeben, wenn Sie eine Nachricht von einer Transaktions Warteschlange außerhalb eines Transaktions Kontexts empfangen möchten.  
  
 Wenn diese Methode aufgerufen wird, um eine Nachricht aus einer Transaktions Warteschlange zu empfangen, wird die empfangene Nachricht an die Warteschlange zurückgegeben, wenn die Transaktion abgebrochen wird. Die Nachricht wird erst endgültig aus der Warteschlange entfernt, wenn ein Commit für die Transaktion ausgeführt wird.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 ist nicht installiert.</exception>
        <exception cref="T:System.InvalidOperationException">Die Meldung mit der angegebenen <paramref name="lookupId" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="action" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageLookupAction" />-Member.  
  
- oder - 
Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine Meldung aus der Warteschlange entfernt wurde. Dieses Ereignis wird von dem asynchronen <see cref="M:System.Messaging.MessageQueue.BeginReceive" />-Vorgang ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> wird bei der asynchronen Verarbeitung verwendet, um das <xref:System.Messaging.MessageQueue.ReceiveCompleted>-Ereignis zu erhöhen, wenn eine Nachricht in der Warteschlange verfügbar ist.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> wird verwendet, um den Vorgang abzuschließen, der von einem <xref:System.Messaging.MessageQueue.BeginReceive%2A> aufgerufen wurde, und die Meldung einsehen, wenn das <xref:System.Messaging.MessageQueue.ReceiveCompleted>-Ereignis ausgelöst wird.  
  
 Beim Erstellen eines <xref:System.Messaging.ReceiveCompletedEventHandler>-Delegaten bestimmen Sie die Methode für die Ereignisbehandlung. Um dem Ereignishandler das Ereignis zuzuordnen, fügen Sie dem Ereignis eine Instanz des Delegaten hinzu. Der Ereignishandler wird bei jedem Eintreten des Ereignisses aufgerufen, sofern der Delegat nicht entfernt wird. Weitere Informationen zu Ereignishandlerdelegaten finden Sie unter [behandeln und Auswerfen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Ereignishandler mit dem Namen `MyReceiveCompleted`erstellt, an den <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignishandlerdelegaten angehängt und <xref:System.Messaging.MessageQueue.BeginReceive%2A> aufgerufen, um einen asynchronen Empfangsvorgang in der Warteschlange zu initiieren, die sich im Pfad ".\MyQueue" befindet. Wenn ein <xref:System.Messaging.MessageQueue.ReceiveCompleted> Ereignis ausgelöst wird, empfängt das Beispiel die Nachricht und schreibt Ihren Text auf den Bildschirm. Im Beispiel wird dann <xref:System.Messaging.MessageQueue.BeginReceive%2A> erneut aufgerufen, um einen neuen asynchronen Empfangsvorgang zu initiieren.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktualisiert die von der <see cref="T:System.Messaging.MessageQueue" /> dargestellten Eigenschaften, sodass sie den aktuellen Zustand der Ressource wiedergeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> synchronisiert die Eigenschaften einer <xref:System.Messaging.MessageQueue> mit der zugehörigen Message Queuing Server Ressource. Wenn eine Eigenschaft, z. b. <xref:System.Messaging.MessageQueue.Label%2A> oder <xref:System.Messaging.MessageQueue.Category%2A>, seit dem Zeitpunkt der Erstellung des <xref:System.Messaging.MessageQueue> auf dem Server geändert wurde, aktualisiert <xref:System.Messaging.MessageQueue.Refresh%2A> den <xref:System.Messaging.MessageQueue> mit den neuen Informationen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die Berechtigungsliste auf die Standardwerte des Betriebssystems zurück. Entfernt sämtliche Berechtigungen für Warteschlangen, die an die Standardliste angefügt wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie <xref:System.Messaging.MessageQueue.ResetPermissions%2A>aufgerufen haben, wird die Berechtigungs Liste auf die Standardwerte zurückgegeben. Im Allgemeinen werden dem Warteschlangen Ersteller alle Berechtigungen gewährt, und die Gruppe erhält alle die folgenden Rechte:  
  
-   Die Eigenschaften der Warteschlange werden angezeigt.  
  
-   Warteschlangen Berechtigungen erhalten.  
  
-   Schreiben in die Warteschlange.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet ein Objekt an eine Warteschlange.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <summary>Sendet ein Objekt an die nicht transaktionale Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht mit dem `obj`-Parameter an die Warteschlange zu senden, auf die vom <xref:System.Messaging.MessageQueue>verwiesen wird. Das Objekt, das Sie an die Warteschlange senden, kann ein <xref:System.Messaging.Message> oder ein beliebiges verwaltetes Objekt sein. Wenn Sie ein anderes Objekt als einen <xref:System.Messaging.Message>senden, wird das Objekt serialisiert und in den Nachrichtentext eingefügt.  
  
 Wenn Sie diese Überladung verwenden, um eine Nachricht an eine Transaktions Warteschlange zu senden, wird die Nachricht an die Warteschlange für unzustellbare Nachrichten gesendet. Wenn Sie möchten, dass die Nachricht Teil einer Transaktion mit anderen Meldungen ist, verwenden Sie eine Überladung, die eine <xref:System.Messaging.MessageQueueTransaction> oder <xref:System.Messaging.MessageQueueTransactionType> als Parameter annimmt.  
  
 Wenn Sie die <xref:System.Messaging.MessageQueue.Formatter%2A>-Eigenschaft nicht vor dem Aufrufen von <xref:System.Messaging.MessageQueue.Send%28System.Object%29>festlegen, wird der Standardwert <xref:System.Messaging.XmlMessageFormatter>für das Formatierprogramm verwendet.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>-Eigenschaft gilt für ein beliebiges Objekt, das keine <xref:System.Messaging.Message>ist. Wenn Sie z. b. eine Bezeichnung oder eine Priorität mit dem <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>-Element angeben, gelten diese Werte für jede Nachricht, die ein Objekt enthält, das nicht vom Typ <xref:System.Messaging.Message> ist, wenn Ihre Anwendung Sie an die Warteschlange sendet. Beim Senden eines <xref:System.Messaging.Message>haben die für die <xref:System.Messaging.Message> festgelegten Eigenschaftswerte Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, und die <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>-Eigenschaft der Nachricht hat Vorrang vor der <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>-Eigenschaft der Warteschlange.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einer Nachrichten Warteschlange hergestellt und eine Nachricht an die Warteschlange gesendet.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 Im folgenden Codebeispiel wird eine von der Anwendung definierte `Order` Klasse an eine Warteschlange gesendet, und dann wird eine Nachricht aus dieser Warteschlange empfangen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Sendet ein Objekt an die transaktionale Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht mit dem `obj`-Parameter an die Transaktions Warteschlange zu senden, auf die durch die <xref:System.Messaging.MessageQueue>verwiesen wird, wobei ein interner Transaktionskontext verwendet wird, der durch den `transaction`-Parameter Das Objekt, das Sie an die Warteschlange senden, kann ein <xref:System.Messaging.Message> oder ein beliebiges verwaltetes Objekt sein. Wenn Sie ein anderes Objekt als einen <xref:System.Messaging.Message>senden, wird das Objekt serialisiert und in den Nachrichtentext eingefügt.  
  
 Wenn Sie diese Überladung verwenden, um eine Nachricht an eine nicht transaktionale Warteschlange zu senden, wird die Nachricht möglicherweise an die Warteschlange für unzustellbare Nachrichten gesendet, ohne dass eine Ausnahme ausgelöst wird.  
  
 Wenn Sie die <xref:System.Messaging.MessageQueue.Formatter%2A>-Eigenschaft nicht vor dem Aufrufen von <xref:System.Messaging.MessageQueue.Send%28System.Object%29>festlegen, wird der Standardwert <xref:System.Messaging.XmlMessageFormatter>für das Formatierprogramm verwendet.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>-Eigenschaft gilt für ein beliebiges Objekt, das keine <xref:System.Messaging.Message>ist. Wenn Sie z. b. eine Bezeichnung oder eine Priorität mit dem <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>-Element angeben, gelten diese Werte für jede Nachricht, die ein Objekt enthält, das nicht vom Typ <xref:System.Messaging.Message> ist, wenn Ihre Anwendung Sie an die Warteschlange sendet. Beim Senden eines <xref:System.Messaging.Message>haben die für die <xref:System.Messaging.Message> festgelegten Eigenschaftswerte Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, und die <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>-Eigenschaft der Nachricht hat Vorrang vor der <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>-Eigenschaft der Warteschlange.  
  
 <xref:System.Messaging.MessageQueueTransaction> das Thread-Apartment unterstützt, können Sie die Transaktion nicht in mehreren Threads verwenden, wenn der Apartment Zustand `STA`ist. Visual Basic den Status des Haupt Threads auf `STA`festlegt, müssen Sie die <xref:System.MTAThreadAttribute> in der `Main` Unterroutine anwenden. Andernfalls wird durch das Senden einer Transaktionsmeldung mithilfe eines anderen Threads eine <xref:System.Messaging.MessageQueueException>-Ausnahme ausgelöst. Sie wenden das <xref:System.MTAThreadAttribute> mit dem folgenden Fragment an.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Zeichenfolge an eine transaktionale Warteschlange gesendet, und dann wird eine Nachricht aus dieser Warteschlange empfangen.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
- oder - 
Die Message Queuing-Anwendung hat eine falsche Verwendung der Transaktion gemeldet.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Sendet ein Objekt an die Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht mit dem `obj`-Parameter an die Warteschlange zu senden, auf die vom <xref:System.Messaging.MessageQueue>verwiesen wird. dabei wird ein vom `transactionType`-Parameter definierter Transaktionskontext verwendet. Geben Sie `Automatic` für den `transactionType` Parameter an, wenn bereits ein externer Transaktionskontext an den Thread angefügt ist, den Sie zum Senden der Nachricht verwenden möchten. Geben Sie `Single` an, wenn Sie die Nachricht als einzelne interne Transaktion senden möchten. Sie können `None` angeben, wenn Sie eine transaktionale Nachricht an einen nicht transaktionalen Thread senden möchten.  
  
 Das Objekt, das Sie an die Warteschlange senden, kann ein <xref:System.Messaging.Message> oder ein beliebiges verwaltetes Objekt sein. Wenn Sie ein anderes Objekt als einen <xref:System.Messaging.Message>senden, wird das Objekt serialisiert und in den Nachrichtentext eingefügt.  
  
 Wenn Sie die <xref:System.Messaging.MessageQueue.Formatter%2A>-Eigenschaft nicht vor dem Aufrufen von <xref:System.Messaging.MessageQueue.Send%28System.Object%29>festlegen, wird der Standardwert <xref:System.Messaging.XmlMessageFormatter>für das Formatierprogramm verwendet.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>-Eigenschaft gilt für ein beliebiges Objekt, das keine <xref:System.Messaging.Message>ist. Wenn Sie z. b. eine Bezeichnung oder eine Priorität mit dem <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>-Element angeben, gelten diese Werte für jede Nachricht, die ein Objekt enthält, das nicht vom Typ <xref:System.Messaging.Message> ist, wenn Ihre Anwendung Sie an die Warteschlange sendet. Beim Senden eines <xref:System.Messaging.Message>haben die für die <xref:System.Messaging.Message> festgelegten Eigenschaftswerte Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, und die <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>-Eigenschaft der Nachricht hat Vorrang vor der <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>-Eigenschaft der Warteschlange.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <param name="label">Die Meldungsbezeichnung.</param>
        <summary>Sendet ein Objekt an die nicht transaktionale Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist, und gibt eine Bezeichnung für die Meldung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht mit dem `obj`-Parameter an die Warteschlange zu senden, auf die vom <xref:System.Messaging.MessageQueue>verwiesen wird. Mit dieser Überladung können Sie die Zeichen folgen Bezeichnung angeben, die die Meldung identifiziert. Das an die Warteschlange gesendete Objekt kann eine <xref:System.Messaging.Message>, eine Struktur, ein Datenobjekt oder ein beliebiges verwaltetes Objekt sein. Wenn Sie ein anderes Objekt als einen <xref:System.Messaging.Message>senden, wird das Objekt serialisiert und in den Nachrichtentext eingefügt.  
  
 Die Nachrichten Bezeichnung unterscheidet sich von der Bezeichnung der Nachrichten Warteschlange, beide sind aber anwendungsabhängig und weisen keine Bedeutung für Message Queuing auf.  
  
 Wenn Sie diese Überladung verwenden, um eine Nachricht an eine Transaktions Warteschlange zu senden, wird die Nachricht an die Warteschlange für unzustellbare Nachrichten gesendet. Wenn Sie möchten, dass die Nachricht Teil einer Transaktion mit anderen Meldungen ist, verwenden Sie eine Überladung, die eine <xref:System.Messaging.MessageQueueTransaction> oder <xref:System.Messaging.MessageQueueTransactionType> als Parameter annimmt.  
  
 Die <xref:System.Messaging.MessageQueue.Path%2A>-Eigenschaft für diese <xref:System.Messaging.MessageQueue> Instanz muss angegeben werden, bevor die Nachricht gesendet wird. Wenn Sie die <xref:System.Messaging.MessageQueue.Formatter%2A>-Eigenschaft nicht vor dem Aufrufen von <xref:System.Messaging.MessageQueue.Send%28System.Object%29>festlegen, wird der Standardwert <xref:System.Messaging.XmlMessageFormatter>für das Formatierprogramm verwendet.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>-Eigenschaft gilt für ein beliebiges Objekt, das keine <xref:System.Messaging.Message>ist. Wenn Sie z. b. eine Bezeichnung oder eine Priorität mit dem <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>-Element angeben, gelten diese Werte für jede Nachricht, die ein Objekt enthält, das nicht vom Typ <xref:System.Messaging.Message> ist, wenn Ihre Anwendung Sie an die Warteschlange sendet. Beim Senden eines <xref:System.Messaging.Message>haben die für die <xref:System.Messaging.Message> festgelegten Eigenschaftswerte Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, und die <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>-Eigenschaft der Nachricht hat Vorrang vor der <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>-Eigenschaft der Warteschlange.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="label" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <param name="label">Die Meldungsbezeichnung.</param>
        <param name="transaction">Das <see cref="T:System.Messaging.MessageQueueTransaction" />-Objekt.</param>
        <summary>Sendet ein Objekt an die transaktionale Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist, und gibt eine Bezeichnung für die Meldung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht mit dem `obj`-Parameter an die Transaktions Warteschlange zu senden, auf die durch die <xref:System.Messaging.MessageQueue>verwiesen wird, wobei ein interner Transaktionskontext verwendet wird, der durch den `transaction`-Parameter Mit dieser Überladung können Sie die Zeichen folgen Bezeichnung angeben, die die Meldung identifiziert. Das an die Warteschlange gesendete Objekt kann eine <xref:System.Messaging.Message>, eine Struktur, ein Datenobjekt oder ein beliebiges verwaltetes Objekt sein. Wenn Sie ein anderes Objekt als einen <xref:System.Messaging.Message>senden, wird das Objekt serialisiert und in den Nachrichtentext eingefügt.  
  
 Die Nachrichten Bezeichnung unterscheidet sich von der Bezeichnung der Nachrichten Warteschlange, beide sind aber anwendungsabhängig und weisen keine Bedeutung für Message Queuing auf.  
  
 Wenn Sie diese Überladung verwenden, um eine Nachricht an eine nicht transaktionale Warteschlange zu senden, wird die Nachricht möglicherweise an die Warteschlange für unzustellbare Nachrichten gesendet, ohne dass eine Ausnahme ausgelöst wird.  
  
 Wenn Sie die <xref:System.Messaging.MessageQueue.Formatter%2A>-Eigenschaft nicht vor dem Aufrufen von <xref:System.Messaging.MessageQueue.Send%28System.Object%29>festlegen, wird der Standardwert <xref:System.Messaging.XmlMessageFormatter>für das Formatierprogramm verwendet.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>-Eigenschaft gilt für ein beliebiges Objekt, das keine <xref:System.Messaging.Message>ist. Wenn Sie z. b. eine Bezeichnung oder eine Priorität mit dem <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>-Element angeben, gelten diese Werte für jede Nachricht, die ein Objekt enthält, das nicht vom Typ <xref:System.Messaging.Message> ist, wenn Ihre Anwendung Sie an die Warteschlange sendet. Beim Senden eines <xref:System.Messaging.Message>haben die für die <xref:System.Messaging.Message> festgelegten Eigenschaftswerte Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, und die <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>-Eigenschaft der Nachricht hat Vorrang vor der <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>-Eigenschaft der Warteschlange.  
  
 <xref:System.Messaging.MessageQueueTransaction> das Thread-Apartment unterstützt, können Sie die Transaktion nicht in mehreren Threads verwenden, wenn der Apartment Zustand `STA`ist. Visual Basic den Status des Haupt Threads auf `STA`festlegt, müssen Sie die <xref:System.MTAThreadAttribute> in der `Main` Unterroutine anwenden. Andernfalls wird durch das Senden einer Transaktionsmeldung mithilfe eines anderen Threads eine <xref:System.Messaging.MessageQueueException>-Ausnahme ausgelöst. Sie wenden das <xref:System.MTAThreadAttribute> mit dem folgenden Fragment an.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="label" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="transaction" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
- oder - 
Die Message Queuing-Anwendung hat eine falsche Verwendung der Transaktion gemeldet.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Das an die Warteschlange zu sendende Objekt.</param>
        <param name="label">Die Meldungsbezeichnung.</param>
        <param name="transactionType">Einer der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Werte, der den Typ des Transaktionskontexts beschreibt, der der Meldung zugeordnet werden soll.</param>
        <summary>Sendet ein Objekt an die Warteschlange, auf die diese <see cref="T:System.Messaging.MessageQueue" /> verweist, und gibt eine Bezeichnung für die Meldung an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Nachricht mit dem `obj`-Parameter an die Warteschlange zu senden, auf die vom <xref:System.Messaging.MessageQueue>verwiesen wird. dabei wird ein vom `transactionType`-Parameter definierter Transaktionskontext verwendet. Geben Sie `Automatic` für den `transactionType` Parameter an, wenn bereits ein externer Transaktionskontext an den Thread angefügt ist, den Sie zum Senden der Nachricht verwenden möchten. Geben Sie `Single` an, wenn Sie die Nachricht als einzelne interne Transaktion senden möchten. Sie können `None` angeben, wenn Sie eine transaktionale Nachricht an einen nicht transaktionalen Thread senden möchten.  
  
 Das Objekt, das Sie an die Warteschlange senden, kann ein <xref:System.Messaging.Message> oder ein beliebiges verwaltetes Objekt sein. Wenn Sie ein anderes Objekt als einen <xref:System.Messaging.Message>senden, wird das Objekt serialisiert und in den Nachrichtentext eingefügt. Mit dieser Überladung können Sie die Zeichen folgen Bezeichnung angeben, die die Meldung identifiziert.  
  
 Die Nachrichten Bezeichnung unterscheidet sich von der Bezeichnung der Nachrichten Warteschlange, beide sind aber anwendungsabhängig und weisen keine Bedeutung für Message Queuing auf.  
  
 Wenn Sie die <xref:System.Messaging.MessageQueue.Formatter%2A>-Eigenschaft nicht vor dem Aufrufen von <xref:System.Messaging.MessageQueue.Send%28System.Object%29>festlegen, wird der Standardwert <xref:System.Messaging.XmlMessageFormatter>für das Formatierprogramm verwendet.  
  
 Die <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>-Eigenschaft gilt für ein beliebiges Objekt, das keine <xref:System.Messaging.Message>ist. Wenn Sie z. b. eine Bezeichnung oder eine Priorität mit dem <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>-Element angeben, gelten diese Werte für jede Nachricht, die ein Objekt enthält, das nicht vom Typ <xref:System.Messaging.Message> ist, wenn Ihre Anwendung Sie an die Warteschlange sendet. Beim Senden eines <xref:System.Messaging.Message>haben die für die <xref:System.Messaging.Message> festgelegten Eigenschaftswerte Vorrang vor <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, und die <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>-Eigenschaft der Nachricht hat Vorrang vor der <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>-Eigenschaft der Warteschlange.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="label" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">Die Message Queuing-Anwendung hat eine falsche Verwendung der Transaktion gemeldet.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der <paramref name="transactionType" />-Parameter ist keiner der <see cref="T:System.Messaging.MessageQueueTransactionType" />-Member.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Die <see cref="P:System.Messaging.MessageQueue.Path" />-Eigenschaft wurde nicht festgelegt.  
  
- oder - 
Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt dem aktuellen Satz Berechtigungen hinzu. Hiermit wird festgelegt, wer Zugriff auf Eigenschaften und Meldungen in der Warteschlange erhält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">Eine <see cref="T:System.Messaging.AccessControlList" /> mit einem oder mehreren Zugriffsteuerungseinträgen, die die Vertrauensnehmer und die zu gewährenden Berechtigungen angeben.</param>
        <summary>Weist der Warteschlange anhand einer Zugriffssteuerungsliste Zugriffsrechte zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um Rechte zu erteilen, zu verweigern oder zu widerrufen, indem Sie eine Auflistung von Zugriffs Steuerungs Einträgen verwenden, um Informationen zum Treuhänder und Berechtigungen anzugeben Dies wird z. b. verwendet, um mehreren Benutzern gleichzeitig Berechtigungen zu erteilen.  
  
 Der Treuhänder, den Sie beim Erstellen des `ace`-Parameters angeben, kann ein einzelner Benutzer, eine Gruppe von Benutzern oder ein Computer sein. Wenn der Vertrauens nehmer eine Person ist, verwenden Sie das Format `DOMAIN`\\`user`. Sie können "." angeben, um den Vertrauens nehmer anzugeben, um den lokalen Computer anzugeben.  
  
 Mit den Berechtigungen, die Sie über <xref:System.Messaging.MessageQueue.SetPermissions%2A> zuweisen, können Sie der vorhandenen Liste Rechte hinzufügen. Standardmäßig verfügt der Ersteller einer öffentlichen oder privaten Warteschlange über Vollzugriff, und die Domänen Gruppe "jeder" verfügt über die Berechtigung zum erhalten von Warteschlangen Eigenschaften, zum erhalten von Berechtigungen und zum Schreiben in die Warteschlange. Wenn Sie <xref:System.Messaging.MessageQueue.SetPermissions%2A>aufzurufen, werden die Benutzer-und Berechtigungsinformationen an den Ende der vorhandenen Liste angehängt.  
  
 Das System untersucht jede <xref:System.Messaging.AccessControlEntry> nacheinander, bis eines der folgenden Ereignisse eintritt:  
  
-   Ein "Zugriff verweigert"-<xref:System.Messaging.AccessControlEntry> verweigert allen angeforderten Zugriffsrechten explizit einen der Treuhänder, die im Zugriffs Token des Threads aufgeführt sind.  
  
-   Mindestens ein Zugriffs zulässiger <xref:System.Messaging.AccessControlEntry> Elemente für Treuhänder, die im Zugriffs Token des Threads aufgeführt sind, gewährt explizit alle angeforderten Zugriffsrechte.  
  
-   Alle <xref:System.Messaging.AccessControlEntry> Elemente wurden geprüft, und es gibt noch mindestens ein angefordertes Zugriffsrecht, das nicht explizit zugelassen wurde. in diesem Fall wird der Zugriff implizit verweigert.  
  
 Wenn Sie den `dacl`-Parameter erstellen, fügen Sie der <xref:System.Messaging.AccessControlList> Auflistung <xref:System.Messaging.AccessControlEntry> Instanzen hinzu. Wenn Sie jeden Zugriffs Steuerungs Eintrag erstellen, können Sie allgemeine oder standardmäßige Zugriffsrechte angeben. Die Rechte für eine Warteschlange können eine beliebige Kombination der folgenden sein:  
  
-   Löschen  
  
-   Sicherheit lesen  
  
-   Sicherheit schreiben  
  
-   Synchronisieren  
  
-   Besitzer ändern  
  
-   Lesen  
  
-   Write  
  
-   Ausführen  
  
-   Erforderlich  
  
-   Alle  
  
-   Keine  
  
 Diese Rechte sind ein Satz von Bitflags, die Sie mit dem-oder bitweisen-Operator kombinieren können.  
  
-   Vollzugriff  
  
-   Löschen einer Nachricht  
  
-   Nachricht empfangen  
  
-   Nachricht einsehen  
  
-   Journal Nachricht empfangen  
  
-   Warteschlangen Eigenschaften erhalten  
  
-   Festlegen von Warteschlangen Eigenschaften  
  
-   Berechtigungen erhalten  
  
-   Festlegen von Berechtigungen  
  
-   Besitz der Warteschlange beanspruchen  
  
-   Nachricht schreiben  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">Ein <see cref="T:System.Messaging.MessageQueueAccessControlEntry" />, der einen Benutzer, einen Zugriffstyp und einen Berechtigungstyp angibt.</param>
        <summary>Weist der Warteschlange anhand eines Zugriffssteuerungseintrags Zugriffsrechte zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um Rechte mithilfe eines Zugriffs Steuerungs Eintrags zu erteilen, zu verweigern oder aufzuheben, um Vertrauens nehmer-und Rechte Informationen anzugeben.  
  
 Der Treuhänder, den Sie beim Erstellen des `ace`-Parameters angeben, kann ein einzelner Benutzer, eine Gruppe von Benutzern oder ein Computer sein. Wenn der Vertrauens nehmer eine Person ist, verwenden Sie das Format `DOMAIN`\\`user`. Sie können "." angeben, um den Vertrauens nehmer anzugeben, um den lokalen Computer anzugeben.  
  
 Mit den Berechtigungen, die Sie über <xref:System.Messaging.MessageQueue.SetPermissions%2A> zuweisen, können Sie der vorhandenen Liste Rechte hinzufügen. Standardmäßig verfügt der Ersteller einer öffentlichen oder privaten Warteschlange über Vollzugriff, und die Domänen Gruppe "jeder" verfügt über die Berechtigung zum erhalten von Warteschlangen Eigenschaften, zum erhalten von Berechtigungen und zum Schreiben in die Warteschlange. Wenn Sie <xref:System.Messaging.MessageQueue.SetPermissions%2A>aufzurufen, werden die Benutzer-und Berechtigungsinformationen an den Ende der vorhandenen Liste angehängt.  
  
 Das System untersucht jede <xref:System.Messaging.AccessControlEntry> nacheinander, bis eines der folgenden Ereignisse eintritt:  
  
-   Ein "Zugriff verweigert"-<xref:System.Messaging.AccessControlEntry> verweigert allen angeforderten Zugriffsrechten explizit einen der Treuhänder, die im Zugriffs Token des Threads aufgeführt sind.  
  
-   Mindestens ein Zugriffs zulässiger <xref:System.Messaging.AccessControlEntry> Elemente für Treuhänder, die im Zugriffs Token des Threads aufgeführt sind, gewährt explizit alle angeforderten Zugriffsrechte.  
  
-   Alle <xref:System.Messaging.AccessControlEntry> Elemente wurden geprüft, und es gibt noch mindestens ein angefordertes Zugriffsrecht, das nicht explizit zugelassen wurde. in diesem Fall wird der Zugriff implizit verweigert.  
  
 Die Rechte für eine Warteschlange, die Sie beim Erstellen des <xref:System.Messaging.MessageQueueAccessControlEntry>im `rights`-Parameter angeben, können eine beliebige Kombination der folgenden sein:  
  
-   Vollzugriff  
  
-   Löschen einer Nachricht  
  
-   Nachricht empfangen  
  
-   Nachricht einsehen  
  
-   Journal Nachricht empfangen  
  
-   Warteschlangen Eigenschaften erhalten  
  
-   Festlegen von Warteschlangen Eigenschaften  
  
-   Berechtigungen erhalten  
  
-   Festlegen von Berechtigungen  
  
-   Besitz der Warteschlange beanspruchen  
  
-   Nachricht schreiben  
  
 Der `rights` Parameter, den Sie im Konstruktor für den `ace`-Parameter angeben, ist ein Flag der <xref:System.Messaging.MessageQueueAccessRights>-Enumeration. Sie stellt einen Satz von Bitflags dar, die Sie mithilfe des bitweisen-Operators oder beim Erstellen des `rights`-Parameters kombinieren können.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">Der einzelne Benutzer, die Gruppe oder der Computer, der zusätzliche Rechte für die Warteschlange erhält.</param>
        <param name="rights">Ein <see cref="T:System.Messaging.MessageQueueAccessRights" />, das den Satz von Rechten für die Warteschlange darstellt, die Message Queuing dem übergebenen <paramref name="user" /> zuweist.</param>
        <summary>Gewährt einem Computer, einer Gruppe oder einem Benutzer die angegebenen Zugriffsrechte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um einem einzelnen Benutzer bestimmte Rechte zu gewähren. Der Benutzer kann ein beliebiger gültiger Vertrauens nehmer sein, der einzelne Benutzer, Gruppen von Benutzern oder einen Computer einschließt. Wenn der Benutzer eine Person ist, verwenden Sie das Format `DOMAIN`\\`user` für den `user` Parameter. Sie können "." für den `user`-Parameter angeben, um den lokalen Computer anzugeben.  
  
 Mit den Berechtigungen, die Sie über <xref:System.Messaging.MessageQueue.SetPermissions%2A> zuweisen, können Sie der vorhandenen Liste Rechte hinzufügen. Standardmäßig verfügt der Ersteller einer öffentlichen oder privaten Warteschlange über Vollzugriff, und die Domänen Gruppe "jeder" verfügt über die Berechtigung zum erhalten von Warteschlangen Eigenschaften, zum erhalten von Berechtigungen und zum Schreiben in die Warteschlange. Wenn Sie <xref:System.Messaging.MessageQueue.SetPermissions%2A>aufzurufen, werden die Benutzer-und Berechtigungsinformationen an den Ende der vorhandenen Liste angehängt.  
  
 Das System untersucht jede <xref:System.Messaging.AccessControlEntry> nacheinander, bis eines der folgenden Ereignisse eintritt:  
  
-   Ein "Zugriff verweigert"-<xref:System.Messaging.AccessControlEntry> verweigert allen angeforderten Zugriffsrechten explizit einen der Treuhänder, die im Zugriffs Token des Threads aufgeführt sind.  
  
-   Mindestens ein Zugriffs zulässiger <xref:System.Messaging.AccessControlEntry> Elemente für Treuhänder, die im Zugriffs Token des Threads aufgeführt sind, gewährt explizit alle angeforderten Zugriffsrechte.  
  
-   Alle <xref:System.Messaging.AccessControlEntry> Elemente wurden geprüft, und es gibt noch mindestens ein angefordertes Zugriffsrecht, das nicht explizit zugelassen wurde. in diesem Fall wird der Zugriff implizit verweigert.  
  
 Die Rechte für eine Warteschlange, die im `rights`-Parameter angegeben wird, können aus einer beliebigen Kombination folgender Punkte bestehen:  
  
-   Vollzugriff  
  
-   Löschen einer Nachricht  
  
-   Nachricht empfangen  
  
-   Nachricht einsehen  
  
-   Journal Nachricht empfangen  
  
-   Warteschlangen Eigenschaften erhalten  
  
-   Festlegen von Warteschlangen Eigenschaften  
  
-   Berechtigungen erhalten  
  
-   Festlegen von Berechtigungen  
  
-   Besitz der Warteschlange beanspruchen  
  
-   Nachricht schreiben  
  
 Die <xref:System.Messaging.MessageQueueAccessRights>-Enumeration stellt einen Satz von Bitflags dar, die Sie mit dem bitweisen-Operator kombinieren können, oder, um den `rights`-Parameter zu erstellen.  
  
 Mit dieser Überladung können Sie nur Berechtigungen erteilen. Sie können Sie nicht widerrufen oder verweigern. Sie müssen eine andere Überladung verwenden, um andere <xref:System.Messaging.AccessControlEntryType> als `Allow`explizit zu erteilen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="user" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">Der einzelne Benutzer, die Gruppe oder der Computer, der zusätzliche Rechte für die Warteschlange erhält.</param>
        <param name="rights">Ein <see cref="T:System.Messaging.MessageQueueAccessRights" />, das den Satz von Rechten für die Warteschlange darstellt, die Message Queuing dem übergebenen <paramref name="user" /> zuweist.</param>
        <param name="entryType">Ein <see cref="T:System.Messaging.AccessControlEntryType" />, der angibt, ob die im <paramref name="rights" />-Parameter angegebenen Berechtigungen gewährt, verweigert oder widerrufen werden sollen.</param>
        <summary>Gewährt einem Computer, einer Gruppe oder einem einzelnen Benutzer die angegebenen Zugriffsrechte mit dem angegebenen Zugriffssteuerungstyp (Zulassen, Verweigern, Widerrufen oder Festlegen).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um bestimmte Rechte für einen einzelnen Benutzer zu erteilen, zu verweigern oder aufzuheben. Der Benutzer kann ein beliebiger gültiger Vertrauens nehmer sein, der einzelne Benutzer, Gruppen von Benutzern oder einen Computer einschließt. Wenn der Benutzer eine Person ist, verwenden Sie das Format `DOMAIN`\\`user` für den `user` Parameter. Sie können "." für den `user`-Parameter angeben, um den lokalen Computer anzugeben.  
  
 Mit den Berechtigungen, die Sie über <xref:System.Messaging.MessageQueue.SetPermissions%2A> zuweisen, können Sie der vorhandenen Liste Rechte hinzufügen. Standardmäßig verfügt der Ersteller einer öffentlichen oder privaten Warteschlange über Vollzugriff, und die Domänen Gruppe "jeder" verfügt über die Berechtigung zum erhalten von Warteschlangen Eigenschaften, zum erhalten von Berechtigungen und zum Schreiben in die Warteschlange. Wenn Sie <xref:System.Messaging.MessageQueue.SetPermissions%2A>aufzurufen, werden die Benutzer-und Berechtigungsinformationen an den Ende der vorhandenen Liste angehängt.  
  
 Das System untersucht jede <xref:System.Messaging.AccessControlEntry> nacheinander, bis eines der folgenden Ereignisse eintritt:  
  
-   Ein "Zugriff verweigert"-<xref:System.Messaging.AccessControlEntry> verweigert allen angeforderten Zugriffsrechten explizit einen der Treuhänder, die im Zugriffs Token des Threads aufgeführt sind.  
  
-   Mindestens ein Zugriffs zulässiger <xref:System.Messaging.AccessControlEntry> Elemente für Treuhänder, die im Zugriffs Token des Threads aufgeführt sind, gewährt explizit alle angeforderten Zugriffsrechte.  
  
-   Alle <xref:System.Messaging.AccessControlEntry> Elemente wurden geprüft, und es gibt noch mindestens ein angefordertes Zugriffsrecht, das nicht explizit zugelassen wurde. in diesem Fall wird der Zugriff implizit verweigert.  
  
 Die Rechte für eine Warteschlange, die im `rights`-Parameter angegeben wird, können aus einer beliebigen Kombination folgender Punkte bestehen:  
  
-   Vollzugriff  
  
-   Löschen einer Nachricht  
  
-   Nachricht empfangen  
  
-   Nachricht einsehen  
  
-   Journal Nachricht empfangen  
  
-   Warteschlangen Eigenschaften erhalten  
  
-   Festlegen von Warteschlangen Eigenschaften  
  
-   Berechtigungen erhalten  
  
-   Festlegen von Berechtigungen  
  
-   Besitz der Warteschlange beanspruchen  
  
-   Nachricht schreiben  
  
 Die <xref:System.Messaging.MessageQueueAccessRights>-Enumeration stellt einen Satz von Bitflags dar, die Sie mit dem bitweisen-Operator kombinieren können, oder, um den `rights`-Parameter zu erstellen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Methode in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das den durch ein <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />-Ereignis oder ein <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />-Ereignis ausgelösten Ereignishandleraufruf marshallt, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, das das Objekt darstellt, das den durch ein <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />-Ereignis oder ein <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />-Ereignis ausgelösten Ereignishandleraufruf marshallt. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Messaging.MessageQueue.ReceiveCompleted> oder <xref:System.Messaging.MessageQueue.PeekCompleted> Ereignis ergibt sich aus einer <xref:System.Messaging.MessageQueue.BeginReceive%2A> oder einer <xref:System.Messaging.MessageQueue.BeginPeek%2A> Anforderung zu einem bestimmten Thread. In der Regel wird der <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> festgelegt, wenn die zugehörige Komponente in einem-Steuerelement oder in einem-Formular abgelegt wird, da diese Komponenten an einen bestimmten Thread gebunden sind.  
  
 Normalerweise Marshalls das Synchronisierungs Objekt einen Methoden aufrufin einem einzelnen Thread.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Warteschlange nur Transaktionen akzeptiert.</summary>
        <value><see langword="true" />, wenn die Warteschlange nur Meldungen akzeptiert, die als Teil einer Transaktion gesendet wurden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transaktionales Messaging bezieht sich auf die Kopplung mehrerer verwandter Nachrichten in einer einzelnen Transaktion. Das Senden von Nachrichten als Teil einer Transaktion stellt sicher, dass die Nachrichten in der richtigen Reihenfolge zugestellt, nur einmal zugestellt und erfolgreich aus der Ziel Warteschlange abgerufen werden.  
  
 Wenn eine Warteschlange transaktional ist, werden nur Nachrichten akzeptiert, die als Teil einer Transaktion gesendet werden. Allerdings kann eine nicht transaktionale Nachricht über eine lokale Transaktions Warteschlange gesendet oder empfangen werden, ohne explizit Transaktions <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>und <xref:System.Messaging.MessageQueueTransaction.Abort%2A> Syntax zu verwenden. Wenn eine nicht transaktionale Nachricht an eine Transaktions Warteschlange gesendet wird, erstellt diese Komponente eine Transaktion mit nur einer Nachricht, außer im Fall eines Verweises auf eine Warteschlange auf einem Remote Computer mit einem direkten Format Namen. Wenn Sie in dieser Situation keinen Transaktionskontext beim Senden einer Nachricht angeben, wird eine nicht für Sie erstellt, und die Nachricht wird an die Warteschlange für unzustellbare Nachrichten gesendet.  
  
 Wenn Sie eine nicht transaktionale Nachricht an eine transaktionale Warteschlange senden, können Sie die Nachricht im Falle einer Ausnahme nicht zurücksetzen.  
  
 <xref:System.Messaging.MessageQueueTransaction> das Thread-Apartment unterstützt, können Sie die Transaktion nicht in mehreren Threads verwenden, wenn der Apartment Zustand `STA`ist. Visual Basic den Status des Haupt Threads auf `STA`festlegt, müssen Sie die <xref:System.MTAThreadAttribute> in der `Main` Unterroutine anwenden. Andernfalls wird durch das Senden einer Transaktionsmeldung mithilfe eines anderen Threads eine <xref:System.Messaging.MessageQueueException>-Ausnahme ausgelöst. Sie wenden das <xref:System.MTAThreadAttribute> mit dem folgenden Fragment an.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.Transactional%2A>-Eigenschaft einer Nachrichten Warteschlange angezeigt.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_UseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob abgerufene Meldungen in die Journalwarteschlange kopiert werden, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn aus der Warteschlange empfangene Meldungen in die Journalwarteschlange kopiert werden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Message Queuing-Anwendung eine neue Anwendungs Warteschlange erstellt, wird automatisch eine zugehörige Journal Warteschlange am gleichen Speicherort erstellt. Die Journal Warteschlange dient zum Nachverfolgen der aus einer Warteschlange entfernten Nachrichten. Wenn Sie diese Eigenschaft festlegen, ändert sich die Message Queuing Warteschlange. Aus diesem Grund sind alle anderen <xref:System.Messaging.MessageQueue> Instanzen von der Änderung betroffen.  
  
 Von der Journal Warteschlange werden keine Nachrichten nachverfolgt, die aus der Warteschlange entfernt wurden, weil der Zeitgeber abgelaufen ist, und es werden keine Nachrichten nachverfolgt, die mithilfe eines Message Queuing Verzeichnis Diensts (Informationsspeicher oder Active Directory) aus der Warteschlange gelöscht wurden.  
  
 Anwendungen können keine Nachrichten an Journal Warteschlangen senden. Sie sind auf den schreibgeschützten Zugriff auf diese Warteschlangen beschränkt. Außerdem werden Message Queuing nie Nachrichten aus Journal Warteschlangen entfernt. Die Anwendung, die die Warteschlange verwendet, muss diese Nachrichten entweder durch Empfang oder durch Löschen der Warteschlange löschen.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Nein|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Messaging.MessageQueue.UseJournalQueue%2A>-Eigenschaft einer Nachrichten Warteschlange abgerufen und festgelegt.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Fehler beim Zugriff auf eine Message Queuing-Methode.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Das systemeigene Handle zum Senden von Meldungen an die Meldungswarteschlange.</summary>
        <value>Ein Handle für das systemeigene Warteschlangenobjekt, das zum Senden von Meldungen an die Warteschlange verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Messaging.MessageQueue.WriteHandle%2A> stellt ein System eigenes Windows-Handle für das Nachrichten Warteschlangen Objekt bereit, das zum Senden von Nachrichten an die Warteschlange verwendet wird. Wenn Sie den Pfad der Warteschlange ändern, wird das Handle geschlossen und mit einem neuen Wert erneut geöffnet.  
  
 In der folgenden Tabelle wird gezeigt, ob diese Eigenschaft in verschiedenen Arbeitsgruppen Modi verfügbar ist.  
  
|Arbeitsgruppen Modus|Verfügbar|  
|--------------------|---------------|  
|Lokaler Computer|Ja|  
|Name des lokalen Computers und des direkten Formats|Ja|  
|Remote Computer|Nein|  
|Name des Remote Computers und des direkten Formats|Ja|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">In die Meldungswarteschlange kann nicht geschrieben werden.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>
