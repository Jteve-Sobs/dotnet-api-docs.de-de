<Type Name="BinaryMessageFormatter" FullName="System.Messaging.BinaryMessageFormatter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f9220f5130f7d9cf8c72cc71ccc34de42e5e8ede" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30460014" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BinaryMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BinaryMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.BinaryMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class BinaryMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class BinaryMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Serialisiert bzw. deserialisiert ein Objekt oder ein ganzes Diagramm verbundener Objekte unter Verwendung eines binären Formats in bzw. aus dem Text einer Message Queuing-Meldung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.BinaryMessageFormatter> ist sehr effizient und kann verwendet werden, um die meisten Objekte zu serialisieren. Das Ergebnis ist sehr kompakt und kann schnell analysiert, aber nicht zulässig ist, für die lose gekoppeltes Messagingsystem als die <xref:System.Messaging.XmlMessageFormatter> verfügt. Lose verbundene bedeutet, dass der Client und Server unabhängig Version der Typ können, die gesendet und empfangen wird.  
  
 Wenn die Anwendung sendet eine Nachricht an die Warteschlange mit einer Instanz von der <xref:System.Messaging.MessageQueue> -Klasse, die Formatierer serialisiert das Objekt in einen Stream und fügt es in den Nachrichtentext. Beim Lesen aus einer Warteschlange mit einer <xref:System.Messaging.MessageQueue>, deserialisiert die Nachrichtendaten in das Formatierungsprogramm der <xref:System.Messaging.Message.Body%2A> Eigenschaft eine <xref:System.Messaging.Message>.  
  
 <xref:System.Messaging.BinaryMessageFormatter> bietet höheren Durchsatz als die <xref:System.Messaging.XmlMessageFormatter>. Verwenden der <xref:System.Messaging.BinaryMessageFormatter> bei reinen Geschwindigkeit statt lose gekoppelt messaging erwünscht.  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.XmlMessageFormatter" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="P:System.Messaging.Message.Formatter" />
    <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.BinaryMessageFormatter" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BinaryMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.BinaryMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BinaryMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.BinaryMessageFormatter" />-Klasse ohne Angabe eines Typ- oder Assemblyformats für das oberste Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie Werte für die <xref:System.Messaging.BinaryMessageFormatter.TopObjectFormat%2A> -Eigenschaft (die definiert, wie das Stammobjekt in einem Diagramm verteilt werden) und die <xref:System.Messaging.BinaryMessageFormatter.TypeFormat%2A> -Eigenschaft (die definiert, wie Typ objektbeschreibungen angeordnet werden) vor dem Verwenden einer Instanz von der <xref:System.Messaging.BinaryMessageFormatter> Klasse Serialisieren und Senden einer Nachricht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BinaryMessageFormatter (System.Runtime.Serialization.Formatters.FormatterAssemblyStyle topObjectFormat, System.Runtime.Serialization.Formatters.FormatterTypeStyle typeFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Runtime.Serialization.Formatters.FormatterAssemblyStyle topObjectFormat, valuetype System.Runtime.Serialization.Formatters.FormatterTypeStyle typeFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.BinaryMessageFormatter.#ctor(System.Runtime.Serialization.Formatters.FormatterAssemblyStyle,System.Runtime.Serialization.Formatters.FormatterTypeStyle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (topObjectFormat As FormatterAssemblyStyle, typeFormat As FormatterTypeStyle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BinaryMessageFormatter(System::Runtime::Serialization::Formatters::FormatterAssemblyStyle topObjectFormat, System::Runtime::Serialization::Formatters::FormatterTypeStyle typeFormat);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="topObjectFormat" Type="System.Runtime.Serialization.Formatters.FormatterAssemblyStyle" />
        <Parameter Name="typeFormat" Type="System.Runtime.Serialization.Formatters.FormatterTypeStyle" />
      </Parameters>
      <Docs>
        <param name="topObjectFormat">Bestimmt das Layout des obersten Objekts (Stammobjekt) eines Diagramms im serialisierten Stream.</param>
        <param name="typeFormat">Bestimmt das Layout von Typbeschreibungen im serialisierten Stream.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.BinaryMessageFormatter" />-Klasse, wobei das Format für das Stammobjekt und die Typbeschreibungen angegeben wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.BinaryMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">Die zu untersuchende <see cref="T:System.Messaging.Message" />.</param>
        <summary>Bestimmt, ob das Formatierungsprogramm den Inhalt der Meldung deserialisieren kann.</summary>
        <returns>
          <see langword="true" />, wenn das Formatierungsprogramm für binäre Meldungen die Meldung deserialisieren kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.BinaryMessageFormatter.CanRead%2A> Gibt `false` ist der Nachrichtentext kein binäres Objekt.  
  
 Auf dem empfangenden Computer <xref:System.Messaging.BinaryMessageFormatter.CanRead%2A> gibt `true` , wenn die Assembly für die Klasse zu deserialisierende lokal vorhanden ist. Die Assembly muss im globalen Assemblycache vorhanden sein oder mit der Anwendung verknüpft werden (beispielsweise, wenn das Objekt eine benutzerdefinierte Klasse darstellt).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="message" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.BinaryMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Instanz der <see cref="T:System.Messaging.BinaryMessageFormatter" />-Klasse, deren Lese-und Schreibeigenschaften (die Formate für Stammobjekt und Typbeschreibung) mit denen des aktuellen <see cref="T:System.Messaging.BinaryMessageFormatter" /> übereinstimmen.</summary>
        <returns>Ein Objekt, dessen Eigenschaften mit denen dieses <see cref="T:System.Messaging.BinaryMessageFormatter" /> übereinstimmen, dessen Metadaten es jedoch nicht als Instanz der Formatierungsprogrammklasse beschreiben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine Kopie des Formatierungsprogramms und initialisiert alle seine Eigenschaften mit den Werten dieses <xref:System.Messaging.BinaryMessageFormatter>. Es dient für Skalierbarkeit, jedoch keine garantieren lesen oder Schreiben Threadsicherheit.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.BinaryMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">Die zu deserialisierende <see cref="T:System.Messaging.Message" /> im binären Format.</param>
        <summary>Liest den Inhalt aus der angegebenen Meldung und erstellt ein Objekt, das die deserialisierte Meldung enthält.</summary>
        <returns>Die deserialisierte Meldung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Beim Aufrufen dieser Methode mit nicht vertrauenswürdigen Daten stellt ein Sicherheitsrisiko dar. Rufen Sie diese Methode nur mit vertrauenswürdigen Daten. Weitere Informationen finden Sie unter [Datenvalidierung](https://www.owasp.org/index.php/Data_Validation).  
  
 Der Text der Nachricht muss im Binärformat sein und muss dasselbe Serialisierungsprogramm Deserialisieren die Nachricht, die anfänglich es serialisiert verwendet werden. Wenn der Text eine benutzerdefinierte Klasse darstellt, muss die Assembly für diese Klasse lokal vorhanden sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Messaging.Message.BodyType" />-Eigenschaft der Meldung gibt kein binäres Objekt an.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="message" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.BinaryMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.BinaryMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TopObjectFormat">
      <MemberSignature Language="C#" Value="public System.Runtime.Serialization.Formatters.FormatterAssemblyStyle TopObjectFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Serialization.Formatters.FormatterAssemblyStyle TopObjectFormat" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.BinaryMessageFormatter.TopObjectFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property TopObjectFormat As FormatterAssemblyStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Serialization::Formatters::FormatterAssemblyStyle TopObjectFormat { System::Runtime::Serialization::Formatters::FormatterAssemblyStyle get(); void set(System::Runtime::Serialization::Formatters::FormatterAssemblyStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTopObjectFormat")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Serialization.Formatters.FormatterAssemblyStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt ihn fest, der definiert, wie das oberste Objekt (Stammobjekt) eines Diagramms bezüglich des Suchens und Ladens seiner Assembly deserialisiert wird.</summary>
        <value>Einer der <see cref="T:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle" />-Werte, der das Deserialisierungsverhalten definiert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurzeit sollten Sie den Standardwert übernehmen `AssemblyStyle`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.BinaryMessageFormatter.TypeFormat" />
      </Docs>
    </Member>
    <Member MemberName="TypeFormat">
      <MemberSignature Language="C#" Value="public System.Runtime.Serialization.Formatters.FormatterTypeStyle TypeFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Serialization.Formatters.FormatterTypeStyle TypeFormat" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.BinaryMessageFormatter.TypeFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property TypeFormat As FormatterTypeStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Serialization::Formatters::FormatterTypeStyle TypeFormat { System::Runtime::Serialization::Formatters::FormatterTypeStyle get(); void set(System::Runtime::Serialization::Formatters::FormatterTypeStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTypeFormat")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Serialization.Formatters.FormatterTypeStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der das Layout von Typbeschreibungen im serialisierten Stream definiert, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Runtime.Serialization.Formatters.FormatterTypeStyle" />, der das Format der Typbeschreibungen definiert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurzeit sollten Sie den Standardwert übernehmen `TypesWhenNeeded`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.BinaryMessageFormatter.TopObjectFormat" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.BinaryMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Body" />-Eigenschaft das serialisierte Objekt aufnimmt.</param>
        <param name="obj">Das in den Meldungstext zu serialisierende Objekt.</param>
        <summary>Serialisiert ein Objekt in den Textkörper der Meldung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das oberste Objekt-Format und das Typformat müssen nicht angegeben werden, zum Schreiben in die Warteschlange, wie es beim Lesen von sein muss. Die <xref:System.Messaging.BinaryMessageFormatter.TopObjectFormat%2A> und <xref:System.Messaging.BinaryMessageFormatter.TypeFormat%2A> Eigenschaften wird vom Formatierungsprogramm nur, wenn eine Nachricht zu deserialisieren.  
  
 Die <xref:System.Messaging.BinaryMessageFormatter> können die meisten Objekte serialisieren, das Ergebnis ist jedoch nicht lose verknüpft. Allerdings ist es compact, damit der Formatierer für große Objekte effizient ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="message" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.BinaryMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>