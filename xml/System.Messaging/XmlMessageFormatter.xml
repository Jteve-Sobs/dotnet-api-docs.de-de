<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="XmlMessageFormatter.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5563e678b40760a20036da2630095cb8b05f461de.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">563e678b40760a20036da2630095cb8b05f461de</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Messaging.XmlMessageFormatter">
          <source>Serializes and deserializes objects to or from the body of a message, using the XML format based on the XSD schema definition.</source>
          
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> is the default formatter that an instance of <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> uses to serialize messages written to the queue.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> der Standardformatierer ist, eine Instanz von <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> verwendet, um in die Warteschlange geschriebenen Nachrichten zu serialisieren.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>When you create an instance of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>, an instance of <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> is created for you and associated with the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</source>
          <target state="translated">Beim Erstellen einer Instanz von <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>, eine Instanz von <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> für Sie erstellt und zugeordnet wird die <ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>You can specify a different formatter by creating it in your code and assigning it to the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph> property of your <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</source>
          <target state="translated">Sie können ein anderes Formatierungsprogramm angeben, indem es in Ihrem Code erstellen und Zuweisen der <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph> Eigenschaft Ihrer <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>A queue's default <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> instance can be used to write to the queue, but it cannot be used to read from the queue until you set either the <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> property on the formatter.</source>
          <target state="translated">Eine Warteschlange Standard <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> Instanz kann zum Schreiben in die Warteschlange verwendet werden, aber es kann nicht verwendet werden, um aus der Warteschlange zu lesen, bis Sie festlegen, die <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> Eigenschaft für den Formatierer.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>You can either set one or both of these values on the default formatter instance, or you can create a new instance of the formatter and set the values automatically by passing them as arguments into the appropriate <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">Sie können entweder eine oder beide der folgenden Werte auf der Standardinstanz für den Formatierer festlegen oder Sie erstellen eine neue Instanz des Formatierungsprogramms und die Werte automatisch festlegen, indem sie in die entsprechenden als Argumente übergeben können <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.%23ctor%2A&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>When specifying <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> rather than <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph>, type existence is checked at compile time rather than read time, reducing possibility for error.</source>
          <target state="translated">Beim Angeben von <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> statt <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph>, Typ vorhanden ist wird zur Kompilierzeit statt Lesezeit, reduzieren die Möglichkeit, dass Fehler überprüft.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> requires every entry to be fully qualified, specifying its assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> erfordert, dass jeder Eintrag angeben des Assemblynamens vollständig qualifiziert werden.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.</source>
          <target state="translated">Darüber hinaus muss bei der Arbeit mit mehrere parallele Versionen die Versionsnummer auch zieltypnamen sowie angefügt werden.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties tell the formatter what schemas to attempt to match when deserializing a message.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> Eigenschaften der Formatierungsprogramm mitgeteilt, welche Schemas versucht, eine Übereinstimmung, wenn eine Nachricht zu deserialisieren.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>This allows the formatter to interpret the message body.</source>
          <target state="translated">Dadurch wird das Formatierungsprogramm der Nachrichtentext interpretiert.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The instance serialized in the message body must comply with one of the schemas represented in the type array.</source>
          <target state="translated">In dem Textkörper der serialisierten Instanz muss eines der Schemas dargestellt, die in den Typarray entsprechen.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>When you read the message using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</source>
          <target state="translated">Beim Lesen der Nachricht mit der <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> -Methode, die Methode erstellt ein Objekt des Typs, der dem bezeichneten Schema entspricht, und liest den Nachrichtentext hinein.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>Only one of the two properties needs to be set when reading from the queue, but you can set both.</source>
          <target state="translated">Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The set of types is the combined set from the two properties.</source>
          <target state="translated">Der Satz von Typen wird der kombinierte Satz aus zwei Eigenschaften.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The decision of which property to use is specific to your application.</source>
          <target state="translated">Die Entscheidung, welche Eigenschaft zu verwenden, bezieht sich auf Ihre Anwendung.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.</source>
          <target state="translated">Wenn der Nachrichtentext ein Typs enthält, deren Schema nicht mit den Typen im Array für beide Eigenschaften übereinstimmt, wird eine Ausnahme ausgelöst werden, wenn die Nachricht gelesen wird.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> is a crucial component of loosely coupled XML-based messaging.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> ist eine wichtige Komponente von lose verbundenen XML-basiertem messaging.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The XSD.exe utility uses the XML format is used to generate XML schema, such as when you use the utility to serialize a class used by your application.</source>
          <target state="translated">Das Dienstprogramm XSD.exe verwendet, die das XML-Format, zum Generieren von XML-Schema verwendet wird, z. B. bei Verwendung des Hilfsprogramms zur Serialisierung einer Klasse, die von Ihrer Anwendung verwendet.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The class must have a default constructor.</source>
          <target state="translated">Die Klasse muss über einen Standardkonstruktor verfügen.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The format is used again in the reverse process when the utility generates a class based on the schema you distribute to describe your class data.</source>
          <target state="translated">Das Format wird verwendet, wieder in dieser Prozess umgekehrt, wenn das Hilfsprogramm eine Klasse, die basierend auf dem Schema generiert Sie verteilen, um die Klassendaten beschreiben.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The use of the utility and the XML schema it generates enables you to avoid redistributing.dll files every time you recompile a class after the implementation of your class has changed.</source>
          <target state="translated">Die Verwendung des Hilfsprogramms und das XML-Schema generierten können Sie redistributing.dll Dateien zu vermeiden, jedes Mal, wenn Sie eine Klasse erneut kompilieren, nachdem die Implementierung der Klasse geändert wurde.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>As long as the schema does not change on the client or the server, other changes on either side do not affect the other.</source>
          <target state="translated">Solange das Schema nicht auf dem Client oder Server ändern, wirken andere Änderungen auf beiden Seiten der anderen sich nicht.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The following code example includes three pieces of code: a server component, an order class, and client code.</source>
          <target state="translated">Das folgende Codebeispiel enthält drei Arten von Code: eine Serverkomponente, eine Order-Klasse, und Clientcode.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The order class can be used by the XSD.exe utility to generate schema that the server recognizes within incoming messages.</source>
          <target state="translated">Die Order-Klasse kann zum Generieren von Schemas, die die Server in eingehenden Nachrichten erkennt vom Dienstprogramm XSD.exe verwendet werden.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The schema is an XML formatted file that describes the "shape" of the class.</source>
          <target state="translated">Das Schema ist eine XML-formatierte Datei, die "Shape" der Klasse beschreibt.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>This schema can then be used on the client side to generate a client-specific order class that shares the same schema as the server class.</source>
          <target state="translated">Dieses Schema kann dann auf der Clientseite verwendet werden, um eine clientspezifische Order-Klasse zu generieren, die gemeinsam das gleiche Schema wie die Server-Klasse.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The following code example represents a server component that receives orders through a message queue.</source>
          <target state="translated">Das folgende Codebeispiel stellt eine Serverkomponente, die Bestellungen über eine Warteschlange empfängt.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The body of the message should be an order object whose schema matches the Order.cs class below.</source>
          <target state="translated">Der Text der Nachricht sollte ein Order-Objekt, dessen Schema der Klasse Order.cs übereinstimmt.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The server process or application deserializes the order.</source>
          <target state="translated">Der Serverprozess bzw. welche Anwendung deserialisiert die Reihenfolge.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The following code example represents the order class that provides a schema for the order objects that the application on the server receives and deserializes.</source>
          <target state="translated">Das folgende Codebeispiel stellt die Order-Klasse, die ein Schema für die Order-Objekte bereitstellt, die die Anwendung auf dem Server empfangen und deserialisiert.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>Any client application that interacts with the application on the server must send messages to the server by serializing information in a locally defined order class into the message body.</source>
          <target state="translated">Jede Clientanwendung, die Interaktion mit der Anwendung auf dem Server muss Nachrichten durch serialisieren Informationen in eine lokal definierte Order-Klasse in den Nachrichtentext an den Server senden.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The locally defined order class must have the same schema as the server-defined order class into which the application on the server will attempt to deserialize the message body.</source>
          <target state="translated">Die lokal definierte Order-Klasse muss das gleiche Schema wie die Server definierte Order-Klasse haben, in dem die Anwendung auf dem Server versucht, den Nachrichtentext deserialisiert.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The XSD.exe utility lets the manager of the application on the server create and distribute the schema the client must use to serialize messages going to the server.</source>
          <target state="translated">Das Dienstprogramm XSD.exe kann die Manager der Anwendung auf dem Server erstellen und Verteilen des Schemas, die der Client verwenden muss, um an den Server gesendete Nachrichten zu serialisieren.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>When the manager of the client application receives the schema for the order class, the XSD.exe utility is used again to generate a client-specific order class from the schema.</source>
          <target state="translated">Erhalt der Manager der Clientanwendung das Schema für die Order-Klasse, wird das Dienstprogramm XSD.exe erneut verwendet, um eine clientspezifische Order-Klasse aus dem Schema zu generieren.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>It is this class that is used in the client code example below, not the server's order class (the XSD.exe utility causes the schema-generated class to have the same name as the original class).</source>
          <target state="translated">Es wird diese Klasse, die im Client-Codebeispiel unten nicht Order-Klasse mit dem Server verwendet wird (das Dienstprogramm XSD.exe bewirkt, dass die schemagenerierter-Klasse, um den gleichen Namen wie die ursprüngliche Klasse haben).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>This new order class is used to serialize the order into the message body.</source>
          <target state="translated">Diese neue Order-Klasse wird verwendet, um die Reihenfolge in den Nachrichtentext zu serialisieren.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The following code example is the client-side processing, used to serialize an order and send the information associated with the order to a queue.</source>
          <target state="translated">Im folgenden Codebeispiel wird die clientseitige Verarbeitung, die zum Serialisieren einer Bestellung und senden Sie die Informationen, die die Reihenfolge an eine Warteschlange zugeordnet.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The code associates Item, Quantity, and Address information with elements of the schema that were generated for the Order.cs class by the XSD.exe utility.</source>
          <target state="translated">Der Code ordnet Element, Menge und Adressinformationen Elemente des Schemas, die vom Dienstprogramm XSD.exe für die Klasse Order.cs generiert wurden.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>An order is sent to the Orders queue on the local computer.</source>
          <target state="translated">Eine Bestellung wird an die Warteschlange "Orders" auf dem lokalen Computer gesendet.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>After the schema is generated from the order class on the server, you can modify the class.</source>
          <target state="translated">Nachdem das Schema aus der Order-Klasse, auf dem Server generiert wird, können Sie die Klasse ändern.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>Unless the schema changes, you do not need to redistribute the schema.</source>
          <target state="translated">Wenn das Schema ändert, müssen Sie nicht das Schema zu verteilen.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>After you have distributed the schema and generated a client-side order class, that client class can also be modified independently of the server's order class, as long as the schema itself is not modified.</source>
          <target state="translated">Nach der das Schema und generiert eine clientseitige Order-Klasse, kann dieser Clientklasse unabhängig von dem Server Order-Klasse auch geändert werden, solange das Schema selbst nicht geändert wird.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.XmlMessageFormatter">
          <source>The two classes have become loosely coupled.</source>
          <target state="translated">Die beiden Klassen sind lose miteinander verbunden werden.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="T:System.Messaging.XmlMessageFormatter">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> class.</source>
          
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> class, without target types set.</source>
          
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor">
          <source>This overload of the constructor is used most frequently when writing to the queue, as target types are not required when writing.</source>
          <target state="translated">Diese Überladung des Konstruktors wird am häufigsten verwendet beim Schreiben in die Warteschlange, da Zieltypen nicht erforderlich, beim Schreiben von sind.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor">
          <source>To read a message from a queue using an instance of <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> created using this constructor, you must set the <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties so the formatter knows what types to attempt to deserialize.</source>
          <target state="translated">Lesen eine Nachricht aus einer Warteschlange mit einer Instanz von <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> mit diesem Konstruktor erstellt, müssen Sie festlegen, die <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> Eigenschaften, damit der Formatierer weiß, welche Typen zu deserialisierenden.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor">
          <source>When you create a new <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>, a default <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> instance is created, without the target types set.</source>
          <target state="translated">Beim Erstellen einer neuen <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>, den Standardwert <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> Instanz erstellt werden, ohne den Zielsatz für Typen.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor">
          <source>As with a formatter created using this constructor, you must set target types for that formatter instance if you want to read from the queue.</source>
          <target state="translated">Wie bei der ein Formatierungsprogramm, die Verwendung dieses Konstruktors erstellt wird, müssen Sie Zieltypen für diese Instanz des Formatierungsprogramms festlegen, wenn Sie aus der Warteschlange lesen möchten.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that specifies the set of possible types that will be deserialized by the formatter from the message provided.</source>
          
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>These values must be fully qualified, for example, "MyNamespace.MyOrders, MyOrdersAssemblyName".</source>
          
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> class, setting target types passed in as an array of (fully qualified) string values.</source>
          
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>The constructors with target type parameters are most frequently used when reading from the queue.</source>
          <target state="translated">Die Konstruktoren mit Parametern für den Ziel werden am häufigsten verwendet werden, beim Lesen aus der Warteschlange.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>When writing, it is not necessary to specify target types.</source>
          <target state="translated">Beim Schreiben von ist es nicht notwendig, dass Zieltypen angeben.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>This overload of the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.%23ctor%2A&gt;</ph> constructor sets the <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> property to the array values passed in through the <ph id="ph3">`targetTypeNames`</ph> parameter.</source>
          <target state="translated">Diese Überladung von der <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.%23ctor%2A&gt;</ph> Konstruktor legt die <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> Eigenschaft, um auf die Arraywerte durch Übergeben der <ph id="ph3">`targetTypeNames`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>Setting this property enables a <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> using this <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> instance to read messages containing objects of given types.</source>
          <target state="translated">Einstellung, die diese Eigenschaft ermöglicht eine <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> mit diesem <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> Instanz zum Lesen von Nachrichten, die mit Objekten des angegebenen Typen.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>Both the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties tell the formatter what schemas to attempt to match when deserializing a message.</source>
          <target state="translated">Sowohl die <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> Eigenschaften der Formatierungsprogramm mitgeteilt, welche Schemas versucht, eine Übereinstimmung, wenn eine Nachricht zu deserialisieren.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>This allows the formatter to interpret the message body.</source>
          <target state="translated">Dadurch wird das Formatierungsprogramm der Nachrichtentext interpretiert.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>The instance serialized in the message body must comply with one of the schemas represented in the type array.</source>
          <target state="translated">In dem Textkörper der serialisierten Instanz muss eines der Schemas dargestellt, die in den Typarray entsprechen.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>When you read the message using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</source>
          <target state="translated">Beim Lesen der Nachricht mit der <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> -Methode, die Methode erstellt ein Objekt des Typs, der dem bezeichneten Schema entspricht, und liest den Nachrichtentext hinein.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>Only one of the two properties needs to be set when reading from the queue, but you can set both.</source>
          <target state="translated">Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>The set of types is the combined set from the two properties.</source>
          <target state="translated">Der Satz von Typen wird der kombinierte Satz aus zwei Eigenschaften.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>The decision of which one to use is specific to your application.</source>
          <target state="translated">Die Entscheidung zu verwenden ist spezifisch für Ihre Anwendung.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown at read time.</source>
          <target state="translated">Wenn der Nachrichtentext ein Typs enthält, deren Schema nicht mit den Typen im Array für beide Eigenschaften übereinstimmt, wird eine Ausnahme am Lesezeit ausgelöst werden.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])">
          <source>The <ph id="ph1">&lt;paramref name="targetTypeNames" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> that specifies the set of possible types that will be deserialized by the formatter from the message provided.</source>
          
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> class, setting target types passed in as an array of object types.</source>
          
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>The constructors with target type parameters are most frequently used when reading from the queue.</source>
          <target state="translated">Die Konstruktoren mit Parametern für den Ziel werden am häufigsten verwendet werden, beim Lesen aus der Warteschlange.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>When writing, it is not necessary to specify target types.</source>
          <target state="translated">Beim Schreiben von ist es nicht notwendig, dass Zieltypen angeben.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>This overload of the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.%23ctor%2A&gt;</ph> constructor sets the <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> property to the array values passed in through the <ph id="ph3">`targetTypes`</ph> parameter.</source>
          <target state="translated">Diese Überladung von der <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.%23ctor%2A&gt;</ph> Konstruktor legt die <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> Eigenschaft, um auf die Arraywerte durch Übergeben der <ph id="ph3">`targetTypes`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>Setting this property enables a <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> using this <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> instance to read messages containing objects of the given types.</source>
          <target state="translated">Die Einstellung dieser Eigenschaft können eine <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> mit diesem <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> Instanz zum Lesen von Nachrichten, die Objekte des angegebenen Typs enthält.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>Both the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties tell the formatter what schemas to attempt to match when deserializing a message.</source>
          <target state="translated">Sowohl die <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> Eigenschaften der Formatierungsprogramm mitgeteilt, welche Schemas versucht, eine Übereinstimmung, wenn eine Nachricht zu deserialisieren.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>This allows the formatter to interpret the message body.</source>
          <target state="translated">Dadurch wird das Formatierungsprogramm der Nachrichtentext interpretiert.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>The instance serialized in the message body must comply with one of the schemas represented in the type array.</source>
          <target state="translated">In dem Textkörper der serialisierten Instanz muss eines der Schemas dargestellt, die in den Typarray entsprechen.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>When you read the message using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</source>
          <target state="translated">Beim Lesen der Nachricht mit der <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> -Methode, die Methode erstellt ein Objekt des Typs, der dem bezeichneten Schema entspricht, und liest den Nachrichtentext hinein.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>Only one of the two properties needs to be set when reading from the queue, but you can set both.</source>
          <target state="translated">Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>The set of types is the combined set from the two properties.</source>
          <target state="translated">Der Satz von Typen wird der kombinierte Satz aus zwei Eigenschaften.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>The decision of which one to use is specific to your application.</source>
          <target state="translated">Die Entscheidung zu verwenden ist spezifisch für Ihre Anwendung.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown at read time.</source>
          <target state="translated">Wenn der Nachrichtentext ein Typs enthält, deren Schema nicht mit den Typen im Array für beide Eigenschaften übereinstimmt, wird eine Ausnahme am Lesezeit ausgelöst werden.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>When specifying <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> rather than <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph>, type existence is checked at compile time rather than read time, reducing possibility for error.</source>
          <target state="translated">Beim Angeben von <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> statt <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph>, Typ vorhanden ist wird zur Kompilierzeit statt Lesezeit, reduzieren die Möglichkeit, dass Fehler überprüft.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> requires every entry to be fully qualified, specifying its assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> erfordert, dass jeder Eintrag angeben des Assemblynamens vollständig qualifiziert werden.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.</source>
          <target state="translated">Darüber hinaus muss bei der Arbeit mit mehrere parallele Versionen die Versionsnummer auch zieltypnamen sowie angefügt werden.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>When using <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph>, you can add each object (for example, <ph id="ph2">`MyClass`</ph>) to the list in a way demonstrated by the following C# code.</source>
          <target state="translated">Bei Verwendung <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph>, Sie können jedes Objekt hinzufügen (z. B. <ph id="ph2">`MyClass`</ph>) zur Liste auf eine Weise, die im folgenden C#-Code veranschaulicht.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])">
          <source>The <ph id="ph1">&lt;paramref name="targetTypes" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> to inspect.</source>
          
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>Determines whether the formatter can deserialize the message.</source>
          
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the XML formatter can deserialize the message; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>When <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.CanRead%2A&gt;</ph> is called, the formatter attempts to determine if the contents of the message are something it can deserialize.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.CanRead%2A&gt;</ph> aufgerufen wird, wird der Formatierer versucht zu bestimmen, ob der Inhalt der Nachricht werden deserialisieren kann.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>The formatter can only deserialize the message if the type in the message body has the same schema as one of the types in the array represented by the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties.</source>
          <target state="translated">Das Formatierungsprogramm kann nur die Nachricht deserialisieren, wenn der Typ im Nachrichtentext das gleiche Schema wie einer der Typen im Array dargestellte besitzt die <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> Eigenschaften.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.CanRead%2A&gt;</ph> returns <ph id="ph2">`false`</ph> under the following two circumstances:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.CanRead%2A&gt;</ph> Gibt <ph id="ph2">`false`</ph> in den folgenden zwei Situationen:</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>The message was not formatted using the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>.</source>
          <target state="translated">Die Nachricht wurde nicht mit formatiert die <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>The schema of the message body is not among those listed in either the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> property.</source>
          <target state="translated">Das Schema des Nachrichtentexts ist nicht in den aufgelisteten entweder in der <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties tell the formatter what types of objects it must be able to deserialize.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> -Eigenschaft geben das Formatierungsprogramm welche Arten von Objekten zum Deserialisieren können muss.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>If any type is missing from the list, yet is found within the message, <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.CanRead%2A&gt;</ph> returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn beliebiger Typ aus der Liste fehlt noch sich innerhalb der Nachricht befindet <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.CanRead%2A&gt;</ph> gibt <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>Neither the <ph id="ph1">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /&gt;</ph> nor <ph id="ph2">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /&gt;</ph> property has been set.</source>
          
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)">
          <source>The <ph id="ph1">&lt;paramref name="message" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Clone">
          <source>Creates an instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> class whose read/write properties (the sets of target types) are the same as the current <ph id="ph2">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> instance.</source>
          
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Clone">
          <source>An object whose properties are identical to those of this <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph> instance, but whose metadata does not specify it to be a formatter class instance.</source>
          
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Clone">
          <source>This method creates a copy of the formatter and initializes all its properties to the values of this <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> object.</source>
          <target state="translated">Diese Methode erstellt eine Kopie des Formatierungsprogramms und initialisiert alle seine Eigenschaften mit den Werten dieses <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>, in XML format, to deserialize.</source>
          
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>Reads the contents from the given message and creates an object that contains the deserialized message.</source>
          
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>The deserialized message.</source>
          
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>Both the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties tell the formatter what schemas to attempt to match when deserializing a message.</source>
          <target state="translated">Sowohl die <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> Eigenschaften der Formatierungsprogramm mitgeteilt, welche Schemas versucht, eine Übereinstimmung, wenn eine Nachricht zu deserialisieren.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>One of these properties must be set before the message can be deserialized.</source>
          <target state="translated">Eine dieser Eigenschaften muss festgelegt werden, bevor die Nachricht deserialisiert werden kann.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>The instance serialized in the message body must comply with one of the schemas represented in the type array.</source>
          <target state="translated">In dem Textkörper der serialisierten Instanz muss eines der Schemas dargestellt, die in den Typarray entsprechen.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>When you read the message using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</source>
          <target state="translated">Beim Lesen der Nachricht mit der <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> -Methode, die Methode erstellt ein Objekt des Typs, der dem bezeichneten Schema entspricht, und liest den Nachrichtentext hinein.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>The target types do not have to be specified in order to write to the queue.</source>
          <target state="translated">Zieltypen müssen nicht angegeben werden, um in die Warteschlange geschrieben.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>Neither the <ph id="ph1">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /&gt;</ph> nor <ph id="ph2">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /&gt;</ph> property has been set.</source>
          
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>The instance serialized in the message body does not comply with any of the schemas represented by the types in the <ph id="ph1">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /&gt;</ph> properties.</source>
          
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)">
          <source>The <ph id="ph1">&lt;paramref name="message" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>Specifies the set of possible types that will be deserialized by the formatter from the message provided.</source>
          
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that specifies the types of objects to deserialize from the message body when reading the message.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> , die die Typen von Objekten aus dem Nachrichtentext deserialisiert, beim Lesen der Nachricht angibt.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>Both the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties tell the formatter what schemas to attempt to match when deserializing a message.</source>
          <target state="translated">Sowohl die <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> Eigenschaften der Formatierungsprogramm mitgeteilt, welche Schemas versucht, eine Übereinstimmung, wenn eine Nachricht zu deserialisieren.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>This allows the formatter to interpret the message body.</source>
          <target state="translated">Dadurch wird das Formatierungsprogramm der Nachrichtentext interpretiert.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>The instance serialized in the message body must comply with one of the schemas represented in the type array.</source>
          <target state="translated">In dem Textkörper der serialisierten Instanz muss eines der Schemas dargestellt, die in den Typarray entsprechen.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>When you read the message using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</source>
          <target state="translated">Beim Lesen der Nachricht mit der <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> -Methode, die Methode erstellt ein Objekt des Typs, der dem bezeichneten Schema entspricht, und liest den Nachrichtentext hinein.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>Only one of the two properties needs to be set when reading from the queue, but you can set both.</source>
          <target state="translated">Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>The set of types is the combined set from the two properties.</source>
          <target state="translated">Der Satz von Typen wird der kombinierte Satz aus zwei Eigenschaften.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>The decision of which property to use is specific to your application.</source>
          <target state="translated">Die Entscheidung, welche Eigenschaft zu verwenden, bezieht sich auf Ihre Anwendung.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.</source>
          <target state="translated">Wenn der Nachrichtentext ein Typs enthält, deren Schema nicht mit den Typen im Array für beide Eigenschaften übereinstimmt, wird eine Ausnahme ausgelöst werden, wenn die Nachricht gelesen wird.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> requires every entry to be fully qualified, specifying its assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> erfordert, dass jeder Eintrag angeben des Assemblynamens vollständig qualifiziert werden.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.</source>
          <target state="translated">Darüber hinaus muss bei der Arbeit mit mehrere parallele Versionen die Versionsnummer auch zieltypnamen sowie angefügt werden.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>The target types are only required when reading from the queue.</source>
          <target state="translated">Die Zieltypen sind nur erforderlich, wenn aus der Warteschlange zu lesen.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties do not need to be set to write to the queue.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> Eigenschaften müssen nicht zum Schreiben in die Warteschlange festgelegt werden.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="P:System.Messaging.XmlMessageFormatter.TargetTypeNames">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /&gt;</ph> property is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>Specifies the set of possible types that will be deserialized by the formatter from the message provided.</source>
          
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> that specifies the types of objects to deserialize from the message body when reading the message.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> , die die Typen von Objekten aus dem Nachrichtentext deserialisiert, beim Lesen der Nachricht angibt.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>Both the <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties tell the formatter what schemas to attempt to match when deserializing a message.</source>
          <target state="translated">Sowohl die <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> Eigenschaften der Formatierungsprogramm mitgeteilt, welche Schemas versucht, eine Übereinstimmung, wenn eine Nachricht zu deserialisieren.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>This allows the formatter to interpret the message body.</source>
          <target state="translated">Dadurch wird das Formatierungsprogramm der Nachrichtentext interpretiert.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>The instance serialized in the message body must comply with one of the schemas represented in the type array.</source>
          <target state="translated">In dem Textkörper der serialisierten Instanz muss eines der Schemas dargestellt, die in den Typarray entsprechen.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>When you read the message using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.</source>
          <target state="translated">Beim Lesen der Nachricht mit der <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> -Methode, die Methode erstellt ein Objekt des Typs, der dem bezeichneten Schema entspricht, und liest den Nachrichtentext hinein.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>Only one of the two properties needs to be set when reading from the queue, but you can set both.</source>
          <target state="translated">Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>The set of types is the combined set from the two properties.</source>
          <target state="translated">Der Satz von Typen wird der kombinierte Satz aus zwei Eigenschaften.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>The decision of which property to use is specific to your application.</source>
          <target state="translated">Die Entscheidung, welche Eigenschaft zu verwenden, bezieht sich auf Ihre Anwendung.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.</source>
          <target state="translated">Wenn der Nachrichtentext ein Typs enthält, deren Schema nicht mit den Typen im Array für beide Eigenschaften übereinstimmt, wird eine Ausnahme ausgelöst werden, wenn die Nachricht gelesen wird.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>The target types are only required when reading from the queue.</source>
          <target state="translated">Die Zieltypen sind nur erforderlich, wenn aus der Warteschlange zu lesen.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> properties do not need to be set to write to the queue.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> Eigenschaften müssen nicht zum Schreiben in die Warteschlange festgelegt werden.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>When specifying <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> rather than <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph>, type existence is checked at compile time rather than read time, reducing possibility for error.</source>
          <target state="translated">Beim Angeben von <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> statt <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph>, Typ vorhanden ist wird zur Kompilierzeit statt Lesezeit, reduzieren die Möglichkeit, dass Fehler überprüft.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>When using <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph>, you can add each object (for example, <ph id="ph2">`MyClass`</ph>) to the list in a way demonstrated by the C# code <ph id="ph3">`TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`</ph>.</source>
          <target state="translated">Bei Verwendung <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph>, Sie können jedes Objekt hinzufügen (z. B. <ph id="ph2">`MyClass`</ph>) zur Liste auf eine Weise, die vom C#-Code veranschaulicht <ph id="ph3">`TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>The following code example sends and receives a message that contains an order to and from a queue.</source>
          <target state="translated">Im folgenden Codebeispiel sendet und empfängt eine Nachricht, die eine Bestellung in und aus einer Warteschlange enthält.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="P:System.Messaging.XmlMessageFormatter.TargetTypes">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /&gt;</ph> property is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Body" /&gt;</ph> property will contain the serialized object.</source>
          
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to be serialized into the message body.</source>
          
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>Serializes an object into the body of the message.</source>
          
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>The target types need not be specified to write to the queue as they must be when reading.</source>
          <target state="translated">Zieltypen müssen nicht angegeben werden, an die Warteschlange geschrieben werden soll, wie es beim Lesen von sein muss.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> property is used by the formatter only when deserializing a message.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;</ph> Eigenschaft wird vom Formatierungsprogramm verwendet, nur, wenn eine Nachricht zu deserialisieren.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> makes use of the <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class, which defines what can be serialized.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> nutzt die <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> Klasse, die definiert, was serialisiert werden kann.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>Only public fields and public properties can be serialized.</source>
          <target state="translated">Nur können öffentliche Felder und öffentliche Eigenschaften serialisiert werden.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>Structures, structures with arrays, and arrays of structures are all serializable, as long as they do not use the encoded style with the SOAP protocol.</source>
          <target state="translated">Strukturen, Strukturen mit Arrays und Arrays von Strukturen sind alle serialisierbaren, solange das Codierungsformat keine mit dem SOAP-Protokoll verwendet wird.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="message" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>