<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ebd69e389a8e772381b0a3f87e7c323d91525d51" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55346875" /></Metadata><TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <TypeSignature Language="F#" Value="type XmlMessageFormatter = class&#xA;    interface IMessageFormatter&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Serialisiert und deserialisiert mithilfe des auf XSD (XML Schema Definition) beruhenden XML-Formats Objekte in den oder aus dem Textkörper einer Meldung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.XmlMessageFormatter> ist der Standardformatierer, die eine Instanz von <xref:System.Messaging.MessageQueue> verwendet, um in die Warteschlange geschriebenen Nachrichten zu serialisieren. Beim Erstellen einer Instanz von <xref:System.Messaging.MessageQueue>, eine Instanz von <xref:System.Messaging.XmlMessageFormatter> für Sie erstellt und zugeordnet ist die <xref:System.Messaging.MessageQueue>. Sie können ein anderes Formatierungsprogramm angeben, indem es in Ihrem Code zu erstellen und zuweisen, damit die <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft Ihre <xref:System.Messaging.MessageQueue>.  
  
 Standardwert von einer Warteschlange <xref:System.Messaging.XmlMessageFormatter> Instanz kann zum Schreiben in die Warteschlange verwendet werden, aber es kann nicht verwendet werden, um aus der Warteschlange gelesen werden soll, bis Sie entweder Festlegen der <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> oder <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Eigenschaft für den Formatierer. Sie können entweder eine oder beide der folgenden Werte auf der Standardinstanz für den Formatierer festlegen oder Sie können eine neue Instanz des Formatierungsprogramms erstellen und die Werte automatisch festlegen, indem sie als Argumente übergeben, in die entsprechenden <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> Konstruktor.  
  
 Beim Angeben von <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> statt <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, Typ vorhanden ist wird zur Kompilierzeit statt Lesezeit, reduzieren die Möglichkeit für Fehler überprüft. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> muss jeder Eintrag angeben des Assemblynamens vollständig qualifiziert werden. Darüber hinaus muss bei der Arbeit mit mehrere parallele Versionen die Versionsnummer auch an den Namen des Zieltyps auch angehängt werden.  
  
 Die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> -Eigenschaft geben das Formatierungsprogramm welche Schemas übereinstimmen, wenn Sie eine Nachricht zu deserialisieren. Dadurch wird den Formatierer, der Nachrichtentext interpretiert.  
  
 Im Meldungstext serialisierte Instanz muss eines der Schemas im Typarray dargestellt entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der das Schema identifiziert entspricht, und liest den Nachrichtentext in dieses.  
  
 Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen. Der Satz von Typen ist der kombinierten Gruppe von zwei Eigenschaften. Die Entscheidung, welche Eigenschaft zu verwenden, ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext ein Typs enthält, deren Schema keine Typen im Array für die Eigenschaft übereinstimmt, wird eine Ausnahme ausgelöst werden, wenn die Nachricht gelesen wird.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> ist eine wesentliche Komponente von lose gekoppelten XML-basiertes messaging. Das XSD.exe-Hilfsprogramm verwendet, die das XML-Format, zum Generieren von XML-Schema verwendet wird, z. B. beim Verwenden des Dienstprogramms zum Serialisieren einer Klasse, die von der Anwendung verwendet. Die Klasse muss über einen Standardkonstruktor verfügen.  
  
 Das Format wird verwendet, wieder in der umgekehrte Vorgang, wenn das Hilfsprogramm eine Klasse, die basierend auf dem Schema generiert Sie verteilen, um Ihre Daten zu beschreiben. Die Verwendung des Hilfsprogramms und das XML-Schema generierten können Sie redistributing.dll Dateien zu vermeiden, jedes Mal, wenn Sie eine Klasse erneut kompilieren, nachdem die Implementierung der Klasse geändert wurde. Solange das Schema nicht auf dem Client oder dem Server geändert wird, wirken andere Änderungen auf beiden Seiten der anderen sich nicht.  
  
   
  
## Examples  
 Das folgende Codebeispiel enthält drei Teile des Codes: eine Serverkomponente, eine Order-Klasse, und Clientcode. Die Order-Klasse kann durch das Hilfsprogramm XSD.exe verwendet werden, zum Generieren eines Schemas, die in eingehenden Nachrichten vom Server erkannt wird. Das Schema ist eine XML-formatierte Datei, die beschreibt, die "Form" der Klasse. Klicken Sie dann kann dieses Schema auf dem Client verwendet werden, zum Generieren einer Client-spezifische Reihenfolge-Klasse, die gemeinsam das gleiche Schema wie die Server-Klasse.  
  
 Das folgende Codebeispiel stellt eine Serverkomponente, die Bestellungen über eine Meldungswarteschlange empfängt dar. Der Text der Nachricht sollte ein Order-Objekt, dessen Schema der Klasse Order.cs übereinstimmt. Serverprozesses oder der Anwendung deserialisiert die Reihenfolge.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 Das folgende Codebeispiel stellt die Order-Klasse, die ein Schema für die Order-Objekte bereitstellt, die die Anwendung auf dem Server empfängt und deserialisiert dar.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Jede Clientanwendung, die Interaktion mit der Anwendung auf dem Server muss Nachrichten durch Serialisierung Informationen in einer lokal definierten Reihenfolge-Klasse in den Nachrichtentext an den Server senden. Die lokal definierte Order-Klasse müssen das gleiche Schema wie die Server definierter Order-Klasse, in dem die Anwendung auf dem Server versucht, auf den Nachrichtentext deserialisieren. Das Hilfsprogramm XSD.exe kann die Manager der Anwendung auf dem Server erstellen und verteilen das Schema, das der Client verwenden muss, um Nachrichten an den Server zu serialisieren.  
  
 Wenn die Manager der Client-Anwendung das Schema für die Order-Klasse erhält, wird das Hilfsprogramm XSD.exe erneut verwendet, um eine Client-spezifische Order-Klasse aus dem Schema zu generieren. Diese Klasse, die im Client Codebeispiel unten nicht Order-Klasse mit dem Server verwendet wird (das Hilfsprogramm XSD.exe bewirkt, dass die Schema generierte Klasse haben den gleichen Namen wie die ursprüngliche Klasse). Diese neue Order-Klasse wird verwendet, um die Reihenfolge in den Nachrichtentext zu serialisieren.  
  
 Im folgenden Codebeispiel wird die clientseitige Verarbeitung, die zum Serialisieren einer Bestellung und senden Sie die Informationen, die die Reihenfolge an eine Warteschlange zugeordnet. Der Code ordnet Element, Menge und die Adresse mit Elementen des Schemas, die für die Order.cs-Klasse, die durch das Hilfsprogramm XSD.exe generiert wurden. Eine Bestellung wird an die Warteschlange "Orders" auf dem lokalen Computer gesendet.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 Nachdem das Schema aus der Order-Klasse, auf dem Server generiert wurde, können Sie die Klasse ändern. Wenn das Schema ändert, müssen Sie nicht das Schema neu zu verteilen. Nachdem Sie das Schema und generiert eine Client-Side-Order-Klasse, kann diese Clientklasse unabhängig von der Order-Klasse des Servers, auch geändert werden, solange das Schema selbst nicht geändert werden. Die beiden Klassen sind lose gekoppelt werden.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.XmlMessageFormatter" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.XmlMessageFormatter" />-Klasse ohne Angabe einer Gruppe von Zieltypen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung des Konstruktors wird beim Schreiben in die Warteschlange, am häufigsten verwendet, da Zieltypen nicht erforderlich, beim Schreiben sind.  
  
 Lesen eine Nachricht aus einer Warteschlange mithilfe einer Instanz von <xref:System.Messaging.XmlMessageFormatter> mit diesem Konstruktor erstellt, müssen Sie festlegen, die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> oder <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften, damit der Formatierer weiß, welche Typen zu deserialisierenden.  
  
 Beim Erstellen einer neuen <xref:System.Messaging.MessageQueue>, den Standardwert <xref:System.Messaging.XmlMessageFormatter> Instanz erstellt werden, ohne die Zieltypen. Wie bei der ein Formatierungsprogramm, die mit diesem Konstruktor erstellt wird, müssen Sie Zieltypen für diese Instanz des Formatierungsprogramms festlegen, wenn aus der Warteschlange gelesen werden sollen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : string[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypeNames" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">Ein Array vom Typ <see cref="T:System.String" />, das die Gruppe der möglichen Typen angibt, die vom Formatierungsprogramm aus der jeweiligen Meldung deserialisiert werden können. Diese Werte müssen voll gekennzeichnet sein, z. B. "MyNamespace.MyOrders, MyOrdersAssemblyName".</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.XmlMessageFormatter" />-Klasse und legt die übergebenen Zieltypen als ein Array von (voll gekennzeichneten) Zeichenfolgenwerten fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Konstruktoren mit Zieltypparametern werden am häufigsten verwendet werden, beim Lesen aus der Warteschlange. Wenn schreiben, ist es nicht notwendig, Zieltypen anzugeben.  
  
 Diese Überladung von der <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> Konstruktor legt die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Eigenschaft, um die Arraywerte durch Übergeben der `targetTypeNames` Parameter. Einstellung, die diese Eigenschaft ermöglicht eine <xref:System.Messaging.MessageQueue> mit diesem <xref:System.Messaging.XmlMessageFormatter> -Instanz zum Lesen von Nachrichten, die Objekte des angegebenen Typen.  
  
 Sowohl die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> -Eigenschaft geben das Formatierungsprogramm welche Schemas übereinstimmen, wenn Sie eine Nachricht zu deserialisieren. Dadurch wird den Formatierer, der Nachrichtentext interpretiert.  
  
 Im Meldungstext serialisierte Instanz muss eines der Schemas im Typarray dargestellt entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der das Schema identifiziert entspricht, und liest den Nachrichtentext in dieses.  
  
 Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen. Der Satz von Typen ist der kombinierten Gruppe von zwei Eigenschaften. Die Entscheidung hierüber zu verwenden ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext ein Typs enthält, deren Schema keine Typen im Array für die Eigenschaft übereinstimmt, wird eine Ausnahme zur Lesezeit ausgelöst werden.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="targetTypeNames" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : Type[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypes" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">Ein Array vom Typ <see cref="T:System.Type" />, das die Gruppe der möglichen Typen angibt, die vom Formatierungsprogramm aus der jeweiligen Meldung deserialisiert werden können.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.XmlMessageFormatter" />-Klasse und legt die übergebenen Zieltypen als ein Array von Objekttypen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Konstruktoren mit Zieltypparametern werden am häufigsten verwendet werden, beim Lesen aus der Warteschlange. Wenn schreiben, ist es nicht notwendig, Zieltypen anzugeben.  
  
 Diese Überladung von der <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> Konstruktor legt die <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaft, um die Arraywerte durch Übergeben der `targetTypes` Parameter. Diese Eigenschaft ermöglicht die Einstellung ein <xref:System.Messaging.MessageQueue> mit diesem <xref:System.Messaging.XmlMessageFormatter> -Instanz zum Lesen von Nachrichten, die Objekte des angegebenen Typs.  
  
 Sowohl die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> -Eigenschaft geben das Formatierungsprogramm welche Schemas übereinstimmen, wenn Sie eine Nachricht zu deserialisieren. Dadurch wird den Formatierer, der Nachrichtentext interpretiert.  
  
 Im Meldungstext serialisierte Instanz muss eines der Schemas im Typarray dargestellt entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der das Schema identifiziert entspricht, und liest den Nachrichtentext in dieses.  
  
 Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen. Der Satz von Typen ist der kombinierten Gruppe von zwei Eigenschaften. Die Entscheidung hierüber zu verwenden ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext ein Typs enthält, deren Schema keine Typen im Array für die Eigenschaft übereinstimmt, wird eine Ausnahme zur Lesezeit ausgelöst werden.  
  
 Beim Angeben von <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> statt <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, Typ vorhanden ist wird zur Kompilierzeit statt Lesezeit, reduzieren die Möglichkeit für Fehler überprüft. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> muss jeder Eintrag angeben des Assemblynamens vollständig qualifiziert werden. Darüber hinaus muss bei der Arbeit mit mehrere parallele Versionen die Versionsnummer auch an den Namen des Zieltyps auch angehängt werden.  
  
 Bei Verwendung <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, Sie können jedes Objekt hinzufügen (z. B. `MyClass`) der Liste auf eine Weise, die durch den folgenden C#-Code veranschaulicht.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="targetTypes" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member CanRead : System.Messaging.Message -&gt; bool&#xA;override this.CanRead : System.Messaging.Message -&gt; bool" Usage="xmlMessageFormatter.CanRead message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">Die zu untersuchende <see cref="T:System.Messaging.Message" />.</param>
        <summary>Ermittelt, ob das Formatierprogramm die Meldung deserialisieren kann.</summary>
        <returns><see langword="true" />, wenn das XML-Formatierungsprogramm die Meldung deserialisieren kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> aufgerufen wurde, versucht das Formatierungsprogramm zu ermitteln, ob der Inhalt der Meldung deserialisieren kann. Der Formatierer kann nur dann die Nachricht deserialisieren, wenn der Typ im Textkörper Nachricht das gleiche Schema wie einer der Typen im Array durch dargestellt hat die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften. <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> Gibt `false` unter den folgenden Fällen:  
  
-   Die Nachricht wurde nicht mit formatiert die <xref:System.Messaging.XmlMessageFormatter>.  
  
-   Das Schema des Nachrichtentexts ist nicht in den aufgelisteten entweder in der <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> oder <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaft.  
  
 Die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> -Eigenschaft geben das Formatierungsprogramm welche Arten von Objekten zum Deserialisieren können muss. Wenn einen beliebigen Typ aus der Liste fehlt, aber es sich in einer Nachricht befindet <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> gibt `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde weder die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />-Eigenschaft noch die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />-Eigenschaft festgelegt.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="message" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="xmlMessageFormatter.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Instanz der <see cref="T:System.Messaging.XmlMessageFormatter" />-Klasse, das dieselben Lese-/Schreibeigenschaften (die Gruppe von Zieltypen) besitzt wie die aktuelle <see cref="T:System.Messaging.XmlMessageFormatter" />-Instanz.</summary>
        <returns>Ein Objekt, dessen Eigenschaften mit denen dieser <see cref="T:System.Messaging.XmlMessageFormatter" />-Instanz übereinstimmen, dessen Metadaten es jedoch nicht als Instanz der Formatierungsprogrammklasse beschreiben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine Kopie des Formatierers und initialisiert alle seine Eigenschaften, die Werte dieser <xref:System.Messaging.XmlMessageFormatter> Objekt.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member Read : System.Messaging.Message -&gt; obj&#xA;override this.Read : System.Messaging.Message -&gt; obj" Usage="xmlMessageFormatter.Read message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">Die zu deserialisierende <see cref="T:System.Messaging.Message" /> im XML-Format.</param>
        <summary>Liest den Inhalt aus der angegebenen Meldung und erstellt ein Objekt, das die deserialisierte Meldung enthält.</summary>
        <returns>Die deserialisierte Meldung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sowohl die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> -Eigenschaft geben das Formatierungsprogramm welche Schemas übereinstimmen, wenn Sie eine Nachricht zu deserialisieren. Eine dieser Eigenschaften muss festgelegt werden, bevor die Nachricht deserialisiert werden kann.  
  
 Im Meldungstext serialisierte Instanz muss eines der Schemas im Typarray dargestellt entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der das Schema identifiziert entspricht, und liest den Nachrichtentext in dieses.  
  
 Die Zieltypen müssen nicht angegeben werden, um das Schreiben in die Warteschlange.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde weder die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />-Eigenschaft noch die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />-Eigenschaft festgelegt.  
  
- oder - 
Die im Meldungstext serialisierte Instanz entspricht keinem der Schemas, die von den Typen in der <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />-Eigenschaft und der <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />-Eigenschaft dargestellt werden.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="message" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypeNames : string[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Gruppe der möglichen Typen an, die vom Formatierungsprogramm aus der bereitgestellten Meldung deserialisiert werden können.</summary>
        <value>Ein Array vom Typ <see cref="T:System.String" />, das die Objekttypen angibt, die beim Lesen der Meldung aus dem Meldungstext deserialisiert werden sollen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sowohl die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> -Eigenschaft geben das Formatierungsprogramm welche Schemas übereinstimmen, wenn Sie eine Nachricht zu deserialisieren. Dadurch wird den Formatierer, der Nachrichtentext interpretiert.  
  
 Im Meldungstext serialisierte Instanz muss eines der Schemas im Typarray dargestellt entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der das Schema identifiziert entspricht, und liest den Nachrichtentext in dieses.  
  
 Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen. Der Satz von Typen ist der kombinierten Gruppe von zwei Eigenschaften. Die Entscheidung, welche Eigenschaft zu verwenden, ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext ein Typs enthält, deren Schema keine Typen im Array für die Eigenschaft übereinstimmt, wird eine Ausnahme ausgelöst werden, wenn die Nachricht gelesen wird.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> muss jeder Eintrag angeben des Assemblynamens vollständig qualifiziert werden. Darüber hinaus muss bei der Arbeit mit mehrere parallele Versionen die Versionsnummer auch an den Namen des Zieltyps auch angehängt werden.  
  
 Die Zieltypen sind nur erforderlich, wenn aus der Warteschlange zu lesen. Die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften müssen nicht auf das Schreiben in die Warteschlange festgelegt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />-Eigenschaft ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypes : Type[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Gruppe der möglichen Typen an, die vom Formatierungsprogramm aus der bereitgestellten Meldung deserialisiert werden können.</summary>
        <value>Ein Array vom Typ <see cref="T:System.Type" />, das die Objekttypen angibt, die beim Lesen der Meldung aus dem Meldungstext deserialisiert werden sollen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sowohl die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> -Eigenschaft geben das Formatierungsprogramm welche Schemas übereinstimmen, wenn Sie eine Nachricht zu deserialisieren. Dadurch wird den Formatierer, der Nachrichtentext interpretiert.  
  
 Im Meldungstext serialisierte Instanz muss eines der Schemas im Typarray dargestellt entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der das Schema identifiziert entspricht, und liest den Nachrichtentext in dieses.  
  
 Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen. Der Satz von Typen ist der kombinierten Gruppe von zwei Eigenschaften. Die Entscheidung, welche Eigenschaft zu verwenden, ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext ein Typs enthält, deren Schema keine Typen im Array für die Eigenschaft übereinstimmt, wird eine Ausnahme ausgelöst werden, wenn die Nachricht gelesen wird.  
  
 Die Zieltypen sind nur erforderlich, wenn aus der Warteschlange zu lesen. Die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften müssen nicht auf das Schreiben in die Warteschlange festgelegt werden.  
  
 Beim Angeben von <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> statt <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, Typ vorhanden ist wird zur Kompilierzeit statt Lesezeit, reduzieren die Möglichkeit für Fehler überprüft.  
  
 Bei Verwendung <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, Sie können jedes Objekt hinzufügen (z. B. `MyClass`) der Liste auf eine Weise, die durch C#-Code veranschaulicht `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht, die eine Bestellung in und aus einer Warteschlange enthält.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />-Eigenschaft ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Write : System.Messaging.Message * obj -&gt; unit&#xA;override this.Write : System.Messaging.Message * obj -&gt; unit" Usage="xmlMessageFormatter.Write (message, obj)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Body" />-Eigenschaft das serialisierte Objekt aufnimmt.</param>
        <param name="obj">Das <see cref="T:System.Object" />, das in den Meldungstext serialisiert werden soll.</param>
        <summary>Serialisiert ein Objekt in den Textkörper der Meldung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zieltypen müssen nicht angegeben werden, an die Warteschlange zu schreiben, müssen sie beim Lesen werden. Die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> oder <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaft wird vom Formatierungsprogramm verwendet, nur, wenn eine Nachricht zu deserialisieren.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> nutzt die <xref:System.Xml.Serialization.XmlSerializer> Klasse, die definiert, was serialisiert werden kann. Nur können öffentliche Felder und die öffentlichen Eigenschaften serialisiert werden. Strukturen, die Strukturen mit Arrays und Arrays von Strukturen sind alle serialisierbaren, solange sie nicht das codierte Format mit dem SOAP-Protokoll verwenden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="message" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>