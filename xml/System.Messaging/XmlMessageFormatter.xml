<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="563e678b40760a20036da2630095cb8b05f461de" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30460734" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Serialisiert und deserialisiert mithilfe des auf XSD (XML Schema Definition) beruhenden XML-Formats Objekte in den oder aus dem Textkörper einer Meldung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.XmlMessageFormatter> der Standardformatierer ist, eine Instanz von <xref:System.Messaging.MessageQueue> verwendet, um in die Warteschlange geschriebenen Nachrichten zu serialisieren. Beim Erstellen einer Instanz von <xref:System.Messaging.MessageQueue>, eine Instanz von <xref:System.Messaging.XmlMessageFormatter> für Sie erstellt und zugeordnet wird die <xref:System.Messaging.MessageQueue>. Sie können ein anderes Formatierungsprogramm angeben, indem es in Ihrem Code erstellen und Zuweisen der <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft Ihrer <xref:System.Messaging.MessageQueue>.  
  
 Eine Warteschlange Standard <xref:System.Messaging.XmlMessageFormatter> Instanz kann zum Schreiben in die Warteschlange verwendet werden, aber es kann nicht verwendet werden, um aus der Warteschlange zu lesen, bis Sie festlegen, die <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> oder <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Eigenschaft für den Formatierer. Sie können entweder eine oder beide der folgenden Werte auf der Standardinstanz für den Formatierer festlegen oder Sie erstellen eine neue Instanz des Formatierungsprogramms und die Werte automatisch festlegen, indem sie in die entsprechenden als Argumente übergeben können <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> Konstruktor.  
  
 Beim Angeben von <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> statt <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, Typ vorhanden ist wird zur Kompilierzeit statt Lesezeit, reduzieren die Möglichkeit, dass Fehler überprüft. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> erfordert, dass jeder Eintrag angeben des Assemblynamens vollständig qualifiziert werden. Darüber hinaus muss bei der Arbeit mit mehrere parallele Versionen die Versionsnummer auch zieltypnamen sowie angefügt werden.  
  
 Die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften der Formatierungsprogramm mitgeteilt, welche Schemas versucht, eine Übereinstimmung, wenn eine Nachricht zu deserialisieren. Dadurch wird das Formatierungsprogramm der Nachrichtentext interpretiert.  
  
 In dem Textkörper der serialisierten Instanz muss eines der Schemas dargestellt, die in den Typarray entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der dem bezeichneten Schema entspricht, und liest den Nachrichtentext hinein.  
  
 Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen. Der Satz von Typen wird der kombinierte Satz aus zwei Eigenschaften. Die Entscheidung, welche Eigenschaft zu verwenden, bezieht sich auf Ihre Anwendung. Wenn der Nachrichtentext ein Typs enthält, deren Schema nicht mit den Typen im Array für beide Eigenschaften übereinstimmt, wird eine Ausnahme ausgelöst werden, wenn die Nachricht gelesen wird.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> ist eine wichtige Komponente von lose verbundenen XML-basiertem messaging. Das Dienstprogramm XSD.exe verwendet, die das XML-Format, zum Generieren von XML-Schema verwendet wird, z. B. bei Verwendung des Hilfsprogramms zur Serialisierung einer Klasse, die von Ihrer Anwendung verwendet. Die Klasse muss über einen Standardkonstruktor verfügen.  
  
 Das Format wird verwendet, wieder in dieser Prozess umgekehrt, wenn das Hilfsprogramm eine Klasse, die basierend auf dem Schema generiert Sie verteilen, um die Klassendaten beschreiben. Die Verwendung des Hilfsprogramms und das XML-Schema generierten können Sie redistributing.dll Dateien zu vermeiden, jedes Mal, wenn Sie eine Klasse erneut kompilieren, nachdem die Implementierung der Klasse geändert wurde. Solange das Schema nicht auf dem Client oder Server ändern, wirken andere Änderungen auf beiden Seiten der anderen sich nicht.  
  
   
  
## Examples  
 Das folgende Codebeispiel enthält drei Arten von Code: eine Serverkomponente, eine Order-Klasse, und Clientcode. Die Order-Klasse kann zum Generieren von Schemas, die die Server in eingehenden Nachrichten erkennt vom Dienstprogramm XSD.exe verwendet werden. Das Schema ist eine XML-formatierte Datei, die "Shape" der Klasse beschreibt. Dieses Schema kann dann auf der Clientseite verwendet werden, um eine clientspezifische Order-Klasse zu generieren, die gemeinsam das gleiche Schema wie die Server-Klasse.  
  
 Das folgende Codebeispiel stellt eine Serverkomponente, die Bestellungen über eine Warteschlange empfängt. Der Text der Nachricht sollte ein Order-Objekt, dessen Schema der Klasse Order.cs übereinstimmt. Der Serverprozess bzw. welche Anwendung deserialisiert die Reihenfolge.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 Das folgende Codebeispiel stellt die Order-Klasse, die ein Schema für die Order-Objekte bereitstellt, die die Anwendung auf dem Server empfangen und deserialisiert.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Jede Clientanwendung, die Interaktion mit der Anwendung auf dem Server muss Nachrichten durch serialisieren Informationen in eine lokal definierte Order-Klasse in den Nachrichtentext an den Server senden. Die lokal definierte Order-Klasse muss das gleiche Schema wie die Server definierte Order-Klasse haben, in dem die Anwendung auf dem Server versucht, den Nachrichtentext deserialisiert. Das Dienstprogramm XSD.exe kann die Manager der Anwendung auf dem Server erstellen und Verteilen des Schemas, die der Client verwenden muss, um an den Server gesendete Nachrichten zu serialisieren.  
  
 Erhalt der Manager der Clientanwendung das Schema für die Order-Klasse, wird das Dienstprogramm XSD.exe erneut verwendet, um eine clientspezifische Order-Klasse aus dem Schema zu generieren. Es wird diese Klasse, die im Client-Codebeispiel unten nicht Order-Klasse mit dem Server verwendet wird (das Dienstprogramm XSD.exe bewirkt, dass die schemagenerierter-Klasse, um den gleichen Namen wie die ursprüngliche Klasse haben). Diese neue Order-Klasse wird verwendet, um die Reihenfolge in den Nachrichtentext zu serialisieren.  
  
 Im folgenden Codebeispiel wird die clientseitige Verarbeitung, die zum Serialisieren einer Bestellung und senden Sie die Informationen, die die Reihenfolge an eine Warteschlange zugeordnet. Der Code ordnet Element, Menge und Adressinformationen Elemente des Schemas, die vom Dienstprogramm XSD.exe für die Klasse Order.cs generiert wurden. Eine Bestellung wird an die Warteschlange "Orders" auf dem lokalen Computer gesendet.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 Nachdem das Schema aus der Order-Klasse, auf dem Server generiert wird, können Sie die Klasse ändern. Wenn das Schema ändert, müssen Sie nicht das Schema zu verteilen. Nach der das Schema und generiert eine clientseitige Order-Klasse, kann dieser Clientklasse unabhängig von dem Server Order-Klasse auch geändert werden, solange das Schema selbst nicht geändert wird. Die beiden Klassen sind lose miteinander verbunden werden.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.XmlMessageFormatter" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.XmlMessageFormatter" />-Klasse ohne Angabe einer Gruppe von Zieltypen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung des Konstruktors wird am häufigsten verwendet beim Schreiben in die Warteschlange, da Zieltypen nicht erforderlich, beim Schreiben von sind.  
  
 Lesen eine Nachricht aus einer Warteschlange mit einer Instanz von <xref:System.Messaging.XmlMessageFormatter> mit diesem Konstruktor erstellt, müssen Sie festlegen, die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> oder <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften, damit der Formatierer weiß, welche Typen zu deserialisierenden.  
  
 Beim Erstellen einer neuen <xref:System.Messaging.MessageQueue>, den Standardwert <xref:System.Messaging.XmlMessageFormatter> Instanz erstellt werden, ohne den Zielsatz für Typen. Wie bei der ein Formatierungsprogramm, die Verwendung dieses Konstruktors erstellt wird, müssen Sie Zieltypen für diese Instanz des Formatierungsprogramms festlegen, wenn Sie aus der Warteschlange lesen möchten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">Ein Array vom Typ <see cref="T:System.String" />, das die Gruppe der möglichen Typen angibt, die vom Formatierungsprogramm aus der jeweiligen Meldung deserialisiert werden können. Diese Werte müssen voll gekennzeichnet sein, z. B. "MyNamespace.MyOrders, MyOrdersAssemblyName".</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.XmlMessageFormatter" />-Klasse und legt die übergebenen Zieltypen als ein Array von (voll gekennzeichneten) Zeichenfolgenwerten fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Konstruktoren mit Parametern für den Ziel werden am häufigsten verwendet werden, beim Lesen aus der Warteschlange. Beim Schreiben von ist es nicht notwendig, dass Zieltypen angeben.  
  
 Diese Überladung von der <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> Konstruktor legt die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Eigenschaft, um auf die Arraywerte durch Übergeben der `targetTypeNames` Parameter. Einstellung, die diese Eigenschaft ermöglicht eine <xref:System.Messaging.MessageQueue> mit diesem <xref:System.Messaging.XmlMessageFormatter> Instanz zum Lesen von Nachrichten, die mit Objekten des angegebenen Typen.  
  
 Sowohl die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften der Formatierungsprogramm mitgeteilt, welche Schemas versucht, eine Übereinstimmung, wenn eine Nachricht zu deserialisieren. Dadurch wird das Formatierungsprogramm der Nachrichtentext interpretiert.  
  
 In dem Textkörper der serialisierten Instanz muss eines der Schemas dargestellt, die in den Typarray entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der dem bezeichneten Schema entspricht, und liest den Nachrichtentext hinein.  
  
 Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen. Der Satz von Typen wird der kombinierte Satz aus zwei Eigenschaften. Die Entscheidung zu verwenden ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext ein Typs enthält, deren Schema nicht mit den Typen im Array für beide Eigenschaften übereinstimmt, wird eine Ausnahme am Lesezeit ausgelöst werden.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="targetTypeNames" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">Ein Array vom Typ <see cref="T:System.Type" />, das die Gruppe der möglichen Typen angibt, die vom Formatierungsprogramm aus der jeweiligen Meldung deserialisiert werden können.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.XmlMessageFormatter" />-Klasse und legt die übergebenen Zieltypen als ein Array von Objekttypen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Konstruktoren mit Parametern für den Ziel werden am häufigsten verwendet werden, beim Lesen aus der Warteschlange. Beim Schreiben von ist es nicht notwendig, dass Zieltypen angeben.  
  
 Diese Überladung von der <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> Konstruktor legt die <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaft, um auf die Arraywerte durch Übergeben der `targetTypes` Parameter. Die Einstellung dieser Eigenschaft können eine <xref:System.Messaging.MessageQueue> mit diesem <xref:System.Messaging.XmlMessageFormatter> Instanz zum Lesen von Nachrichten, die Objekte des angegebenen Typs enthält.  
  
 Sowohl die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften der Formatierungsprogramm mitgeteilt, welche Schemas versucht, eine Übereinstimmung, wenn eine Nachricht zu deserialisieren. Dadurch wird das Formatierungsprogramm der Nachrichtentext interpretiert.  
  
 In dem Textkörper der serialisierten Instanz muss eines der Schemas dargestellt, die in den Typarray entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der dem bezeichneten Schema entspricht, und liest den Nachrichtentext hinein.  
  
 Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen. Der Satz von Typen wird der kombinierte Satz aus zwei Eigenschaften. Die Entscheidung zu verwenden ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext ein Typs enthält, deren Schema nicht mit den Typen im Array für beide Eigenschaften übereinstimmt, wird eine Ausnahme am Lesezeit ausgelöst werden.  
  
 Beim Angeben von <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> statt <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, Typ vorhanden ist wird zur Kompilierzeit statt Lesezeit, reduzieren die Möglichkeit, dass Fehler überprüft. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> erfordert, dass jeder Eintrag angeben des Assemblynamens vollständig qualifiziert werden. Darüber hinaus muss bei der Arbeit mit mehrere parallele Versionen die Versionsnummer auch zieltypnamen sowie angefügt werden.  
  
 Bei Verwendung <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, Sie können jedes Objekt hinzufügen (z. B. `MyClass`) zur Liste auf eine Weise, die im folgenden C#-Code veranschaulicht.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="targetTypes" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">Die zu untersuchende <see cref="T:System.Messaging.Message" />.</param>
        <summary>Ermittelt, ob das Formatierprogramm die Meldung deserialisieren kann.</summary>
        <returns>
          <see langword="true" />, wenn das XML-Formatierungsprogramm die Meldung deserialisieren kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> aufgerufen wird, wird der Formatierer versucht zu bestimmen, ob der Inhalt der Nachricht werden deserialisieren kann. Das Formatierungsprogramm kann nur die Nachricht deserialisieren, wenn der Typ im Nachrichtentext das gleiche Schema wie einer der Typen im Array dargestellte besitzt die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften. <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> Gibt `false` in den folgenden zwei Situationen:  
  
-   Die Nachricht wurde nicht mit formatiert die <xref:System.Messaging.XmlMessageFormatter>.  
  
-   Das Schema des Nachrichtentexts ist nicht in den aufgelisteten entweder in der <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> oder <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaft.  
  
 Die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> -Eigenschaft geben das Formatierungsprogramm welche Arten von Objekten zum Deserialisieren können muss. Wenn beliebiger Typ aus der Liste fehlt noch sich innerhalb der Nachricht befindet <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> gibt `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde weder die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />-Eigenschaft noch die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />-Eigenschaft festgelegt.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="message" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Instanz der <see cref="T:System.Messaging.XmlMessageFormatter" />-Klasse, das dieselben Lese-/Schreibeigenschaften (die Gruppe von Zieltypen) besitzt wie die aktuelle <see cref="T:System.Messaging.XmlMessageFormatter" />-Instanz.</summary>
        <returns>Ein Objekt, dessen Eigenschaften mit denen dieser <see cref="T:System.Messaging.XmlMessageFormatter" />-Instanz übereinstimmen, dessen Metadaten es jedoch nicht als Instanz der Formatierungsprogrammklasse beschreiben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine Kopie des Formatierungsprogramms und initialisiert alle seine Eigenschaften mit den Werten dieses <xref:System.Messaging.XmlMessageFormatter> Objekt.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">Die zu deserialisierende <see cref="T:System.Messaging.Message" /> im XML-Format.</param>
        <summary>Liest den Inhalt aus der angegebenen Meldung und erstellt ein Objekt, das die deserialisierte Meldung enthält.</summary>
        <returns>Die deserialisierte Meldung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sowohl die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften der Formatierungsprogramm mitgeteilt, welche Schemas versucht, eine Übereinstimmung, wenn eine Nachricht zu deserialisieren. Eine dieser Eigenschaften muss festgelegt werden, bevor die Nachricht deserialisiert werden kann.  
  
 In dem Textkörper der serialisierten Instanz muss eines der Schemas dargestellt, die in den Typarray entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der dem bezeichneten Schema entspricht, und liest den Nachrichtentext hinein.  
  
 Zieltypen müssen nicht angegeben werden, um in die Warteschlange geschrieben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde weder die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />-Eigenschaft noch die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />-Eigenschaft festgelegt.  
  
 - oder -   
  
 Die im Meldungstext serialisierte Instanz entspricht keinem der Schemas, die von den Typen in der <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />-Eigenschaft und der <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />-Eigenschaft dargestellt werden.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="message" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Gruppe der möglichen Typen an, die vom Formatierungsprogramm aus der bereitgestellten Meldung deserialisiert werden können.</summary>
        <value>Ein Array vom Typ <see cref="T:System.String" />, das die Objekttypen angibt, die beim Lesen der Meldung aus dem Meldungstext deserialisiert werden sollen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sowohl die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften der Formatierungsprogramm mitgeteilt, welche Schemas versucht, eine Übereinstimmung, wenn eine Nachricht zu deserialisieren. Dadurch wird das Formatierungsprogramm der Nachrichtentext interpretiert.  
  
 In dem Textkörper der serialisierten Instanz muss eines der Schemas dargestellt, die in den Typarray entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der dem bezeichneten Schema entspricht, und liest den Nachrichtentext hinein.  
  
 Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen. Der Satz von Typen wird der kombinierte Satz aus zwei Eigenschaften. Die Entscheidung, welche Eigenschaft zu verwenden, bezieht sich auf Ihre Anwendung. Wenn der Nachrichtentext ein Typs enthält, deren Schema nicht mit den Typen im Array für beide Eigenschaften übereinstimmt, wird eine Ausnahme ausgelöst werden, wenn die Nachricht gelesen wird.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> erfordert, dass jeder Eintrag angeben des Assemblynamens vollständig qualifiziert werden. Darüber hinaus muss bei der Arbeit mit mehrere parallele Versionen die Versionsnummer auch zieltypnamen sowie angefügt werden.  
  
 Die Zieltypen sind nur erforderlich, wenn aus der Warteschlange zu lesen. Die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften müssen nicht zum Schreiben in die Warteschlange festgelegt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />-Eigenschaft ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Gruppe der möglichen Typen an, die vom Formatierungsprogramm aus der bereitgestellten Meldung deserialisiert werden können.</summary>
        <value>Ein Array vom Typ <see cref="T:System.Type" />, das die Objekttypen angibt, die beim Lesen der Meldung aus dem Meldungstext deserialisiert werden sollen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sowohl die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften der Formatierungsprogramm mitgeteilt, welche Schemas versucht, eine Übereinstimmung, wenn eine Nachricht zu deserialisieren. Dadurch wird das Formatierungsprogramm der Nachrichtentext interpretiert.  
  
 In dem Textkörper der serialisierten Instanz muss eines der Schemas dargestellt, die in den Typarray entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der dem bezeichneten Schema entspricht, und liest den Nachrichtentext hinein.  
  
 Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen. Der Satz von Typen wird der kombinierte Satz aus zwei Eigenschaften. Die Entscheidung, welche Eigenschaft zu verwenden, bezieht sich auf Ihre Anwendung. Wenn der Nachrichtentext ein Typs enthält, deren Schema nicht mit den Typen im Array für beide Eigenschaften übereinstimmt, wird eine Ausnahme ausgelöst werden, wenn die Nachricht gelesen wird.  
  
 Die Zieltypen sind nur erforderlich, wenn aus der Warteschlange zu lesen. Die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften müssen nicht zum Schreiben in die Warteschlange festgelegt werden.  
  
 Beim Angeben von <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> statt <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, Typ vorhanden ist wird zur Kompilierzeit statt Lesezeit, reduzieren die Möglichkeit, dass Fehler überprüft.  
  
 Bei Verwendung <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, Sie können jedes Objekt hinzufügen (z. B. `MyClass`) zur Liste auf eine Weise, die vom C#-Code veranschaulicht `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht, die eine Bestellung in und aus einer Warteschlange enthält.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />-Eigenschaft ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Body" />-Eigenschaft das serialisierte Objekt aufnimmt.</param>
        <param name="obj">Das <see cref="T:System.Object" />, das in den Meldungstext serialisiert werden soll.</param>
        <summary>Serialisiert ein Objekt in den Textkörper der Meldung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zieltypen müssen nicht angegeben werden, an die Warteschlange geschrieben werden soll, wie es beim Lesen von sein muss. Die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> oder <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaft wird vom Formatierungsprogramm verwendet, nur, wenn eine Nachricht zu deserialisieren.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> nutzt die <xref:System.Xml.Serialization.XmlSerializer> Klasse, die definiert, was serialisiert werden kann. Nur können öffentliche Felder und öffentliche Eigenschaften serialisiert werden. Strukturen, Strukturen mit Arrays und Arrays von Strukturen sind alle serialisierbaren, solange das Codierungsformat keine mit dem SOAP-Protokoll verwendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="message" />-Parameter ist <see langword="null" />.  
  
 - oder -   
  
 Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>