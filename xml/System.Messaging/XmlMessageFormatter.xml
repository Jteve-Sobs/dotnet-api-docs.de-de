<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e9b5b367df928ff6d7a99dc28208e2d881b64249" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37478894" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <TypeSignature Language="F#" Value="type XmlMessageFormatter = class&#xA;    interface IMessageFormatter&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Serializes and deserializes objects to or from the body of a message, using the XML format based on the XSD schema definition.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Messaging.XmlMessageFormatter> ist der Standardformatierer, die eine Instanz von <xref:System.Messaging.MessageQueue> verwendet, um in die Warteschlange geschriebenen Nachrichten zu serialisieren. Beim Erstellen einer Instanz von <xref:System.Messaging.MessageQueue>, eine Instanz von <xref:System.Messaging.XmlMessageFormatter> für Sie erstellt und zugeordnet ist die <xref:System.Messaging.MessageQueue>. Sie können ein anderes Formatierungsprogramm angeben, indem es in Ihrem Code zu erstellen und zuweisen, damit die <xref:System.Messaging.MessageQueue.Formatter%2A> Eigenschaft Ihre <xref:System.Messaging.MessageQueue>.  
  
 Standardwert von einer Warteschlange <xref:System.Messaging.XmlMessageFormatter> Instanz kann zum Schreiben in die Warteschlange verwendet werden, aber es kann nicht verwendet werden, um aus der Warteschlange gelesen werden soll, bis Sie entweder Festlegen der <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> oder <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Eigenschaft für den Formatierer. Sie können entweder eine oder beide der folgenden Werte auf der Standardinstanz für den Formatierer festlegen oder Sie können eine neue Instanz des Formatierungsprogramms erstellen und die Werte automatisch festlegen, indem sie als Argumente übergeben, in die entsprechenden <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> Konstruktor.  
  
 Beim Angeben von <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> statt <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, Typ vorhanden ist wird zur Kompilierzeit statt Lesezeit, reduzieren die Möglichkeit für Fehler überprüft. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> muss jeder Eintrag angeben des Assemblynamens vollständig qualifiziert werden. Darüber hinaus muss bei der Arbeit mit mehrere parallele Versionen die Versionsnummer auch an den Namen des Zieltyps auch angehängt werden.  
  
 Die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> -Eigenschaft geben das Formatierungsprogramm welche Schemas übereinstimmen, wenn Sie eine Nachricht zu deserialisieren. Dadurch wird den Formatierer, der Nachrichtentext interpretiert.  
  
 Im Meldungstext serialisierte Instanz muss eines der Schemas im Typarray dargestellt entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der das Schema identifiziert entspricht, und liest den Nachrichtentext in dieses.  
  
 Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen. Der Satz von Typen ist der kombinierten Gruppe von zwei Eigenschaften. Die Entscheidung, welche Eigenschaft zu verwenden, ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext ein Typs enthält, deren Schema keine Typen im Array für die Eigenschaft übereinstimmt, wird eine Ausnahme ausgelöst werden, wenn die Nachricht gelesen wird.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> ist eine wesentliche Komponente von lose gekoppelten XML-basiertes messaging. Das XSD.exe-Hilfsprogramm verwendet, die das XML-Format, zum Generieren von XML-Schema verwendet wird, z. B. beim Verwenden des Dienstprogramms zum Serialisieren einer Klasse, die von der Anwendung verwendet. Die Klasse muss über einen Standardkonstruktor verfügen.  
  
 Das Format wird verwendet, wieder in der umgekehrte Vorgang, wenn das Hilfsprogramm eine Klasse, die basierend auf dem Schema generiert Sie verteilen, um Ihre Daten zu beschreiben. Die Verwendung des Hilfsprogramms und das XML-Schema generierten können Sie redistributing.dll Dateien zu vermeiden, jedes Mal, wenn Sie eine Klasse erneut kompilieren, nachdem die Implementierung der Klasse geändert wurde. Solange das Schema nicht auf dem Client oder dem Server geändert wird, wirken andere Änderungen auf beiden Seiten der anderen sich nicht.  
  
   
  
## Examples  
 Das folgende Codebeispiel enthält drei Teile des Codes: eine Serverkomponente, eine Order-Klasse, und Clientcode. Die Order-Klasse kann durch das Hilfsprogramm XSD.exe verwendet werden, zum Generieren eines Schemas, die in eingehenden Nachrichten vom Server erkannt wird. Das Schema ist eine XML-formatierte Datei, die beschreibt, die "Form" der Klasse. Klicken Sie dann kann dieses Schema auf dem Client verwendet werden, zum Generieren einer Client-spezifische Reihenfolge-Klasse, die gemeinsam das gleiche Schema wie die Server-Klasse.  
  
 Das folgende Codebeispiel stellt eine Serverkomponente, die Bestellungen über eine Meldungswarteschlange empfängt dar. Der Text der Nachricht sollte ein Order-Objekt, dessen Schema der Klasse Order.cs übereinstimmt. Serverprozesses oder der Anwendung deserialisiert die Reihenfolge.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 Das folgende Codebeispiel stellt die Order-Klasse, die ein Schema für die Order-Objekte bereitstellt, die die Anwendung auf dem Server empfängt und deserialisiert dar.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Jede Clientanwendung, die Interaktion mit der Anwendung auf dem Server muss Nachrichten durch Serialisierung Informationen in einer lokal definierten Reihenfolge-Klasse in den Nachrichtentext an den Server senden. Die lokal definierte Order-Klasse müssen das gleiche Schema wie die Server definierter Order-Klasse, in dem die Anwendung auf dem Server versucht, auf den Nachrichtentext deserialisieren. Das Hilfsprogramm XSD.exe kann die Manager der Anwendung auf dem Server erstellen und verteilen das Schema, das der Client verwenden muss, um Nachrichten an den Server zu serialisieren.  
  
 Wenn die Manager der Client-Anwendung das Schema für die Order-Klasse erhält, wird das Hilfsprogramm XSD.exe erneut verwendet, um eine Client-spezifische Order-Klasse aus dem Schema zu generieren. Diese Klasse, die im Client Codebeispiel unten nicht Order-Klasse mit dem Server verwendet wird (das Hilfsprogramm XSD.exe bewirkt, dass die Schema generierte Klasse haben den gleichen Namen wie die ursprüngliche Klasse). Diese neue Order-Klasse wird verwendet, um die Reihenfolge in den Nachrichtentext zu serialisieren.  
  
 Im folgenden Codebeispiel wird die clientseitige Verarbeitung, die zum Serialisieren einer Bestellung und senden Sie die Informationen, die die Reihenfolge an eine Warteschlange zugeordnet. Der Code ordnet Element, Menge und die Adresse mit Elementen des Schemas, die für die Order.cs-Klasse, die durch das Hilfsprogramm XSD.exe generiert wurden. Eine Bestellung wird an die Warteschlange "Orders" auf dem lokalen Computer gesendet.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 Nachdem das Schema aus der Order-Klasse, auf dem Server generiert wurde, können Sie die Klasse ändern. Wenn das Schema ändert, müssen Sie nicht das Schema neu zu verteilen. Nachdem Sie das Schema und generiert eine Client-Side-Order-Klasse, kann diese Clientklasse unabhängig von der Order-Klasse des Servers, auch geändert werden, solange das Schema selbst nicht geändert werden. Die beiden Klassen sind lose gekoppelt werden.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class, without target types set.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung des Konstruktors wird beim Schreiben in die Warteschlange, am häufigsten verwendet, da Zieltypen nicht erforderlich, beim Schreiben sind.  
  
 Lesen eine Nachricht aus einer Warteschlange mithilfe einer Instanz von <xref:System.Messaging.XmlMessageFormatter> mit diesem Konstruktor erstellt, müssen Sie festlegen, die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> oder <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften, damit der Formatierer weiß, welche Typen zu deserialisierenden.  
  
 Beim Erstellen einer neuen <xref:System.Messaging.MessageQueue>, den Standardwert <xref:System.Messaging.XmlMessageFormatter> Instanz erstellt werden, ohne die Zieltypen. Wie bei der ein Formatierungsprogramm, die mit diesem Konstruktor erstellt wird, müssen Sie Zieltypen für diese Instanz des Formatierungsprogramms festlegen, wenn aus der Warteschlange gelesen werden sollen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : string[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypeNames" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">An array of type <see cref="T:System.String" /> that specifies the set of possible types that will be deserialized by the formatter from the message provided. These values must be fully qualified, for example, "MyNamespace.MyOrders, MyOrdersAssemblyName".</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class, setting target types passed in as an array of (fully qualified) string values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Konstruktoren mit Zieltypparametern werden am häufigsten verwendet werden, beim Lesen aus der Warteschlange. Wenn schreiben, ist es nicht notwendig, Zieltypen anzugeben.  
  
 Diese Überladung von der <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> Konstruktor legt die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Eigenschaft, um die Arraywerte durch Übergeben der `targetTypeNames` Parameter. Einstellung, die diese Eigenschaft ermöglicht eine <xref:System.Messaging.MessageQueue> mit diesem <xref:System.Messaging.XmlMessageFormatter> -Instanz zum Lesen von Nachrichten, die Objekte des angegebenen Typen.  
  
 Sowohl die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> -Eigenschaft geben das Formatierungsprogramm welche Schemas übereinstimmen, wenn Sie eine Nachricht zu deserialisieren. Dadurch wird den Formatierer, der Nachrichtentext interpretiert.  
  
 Im Meldungstext serialisierte Instanz muss eines der Schemas im Typarray dargestellt entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der das Schema identifiziert entspricht, und liest den Nachrichtentext in dieses.  
  
 Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen. Der Satz von Typen ist der kombinierten Gruppe von zwei Eigenschaften. Die Entscheidung hierüber zu verwenden ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext ein Typs enthält, deren Schema keine Typen im Array für die Eigenschaft übereinstimmt, wird eine Ausnahme zur Lesezeit ausgelöst werden.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="targetTypeNames" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : Type[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypes" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">An array of type <see cref="T:System.Type" /> that specifies the set of possible types that will be deserialized by the formatter from the message provided.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class, setting target types passed in as an array of object types.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Konstruktoren mit Zieltypparametern werden am häufigsten verwendet werden, beim Lesen aus der Warteschlange. Wenn schreiben, ist es nicht notwendig, Zieltypen anzugeben.  
  
 Diese Überladung von der <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> Konstruktor legt die <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaft, um die Arraywerte durch Übergeben der `targetTypes` Parameter. Diese Eigenschaft ermöglicht die Einstellung ein <xref:System.Messaging.MessageQueue> mit diesem <xref:System.Messaging.XmlMessageFormatter> -Instanz zum Lesen von Nachrichten, die Objekte des angegebenen Typs.  
  
 Sowohl die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> -Eigenschaft geben das Formatierungsprogramm welche Schemas übereinstimmen, wenn Sie eine Nachricht zu deserialisieren. Dadurch wird den Formatierer, der Nachrichtentext interpretiert.  
  
 Im Meldungstext serialisierte Instanz muss eines der Schemas im Typarray dargestellt entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der das Schema identifiziert entspricht, und liest den Nachrichtentext in dieses.  
  
 Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen. Der Satz von Typen ist der kombinierten Gruppe von zwei Eigenschaften. Die Entscheidung hierüber zu verwenden ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext ein Typs enthält, deren Schema keine Typen im Array für die Eigenschaft übereinstimmt, wird eine Ausnahme zur Lesezeit ausgelöst werden.  
  
 Beim Angeben von <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> statt <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, Typ vorhanden ist wird zur Kompilierzeit statt Lesezeit, reduzieren die Möglichkeit für Fehler überprüft. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> muss jeder Eintrag angeben des Assemblynamens vollständig qualifiziert werden. Darüber hinaus muss bei der Arbeit mit mehrere parallele Versionen die Versionsnummer auch an den Namen des Zieltyps auch angehängt werden.  
  
 Bei Verwendung <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, Sie können jedes Objekt hinzufügen (z. B. `MyClass`) der Liste auf eine Weise, die durch den folgenden C#-Code veranschaulicht.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="targetTypes" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member CanRead : System.Messaging.Message -&gt; bool&#xA;override this.CanRead : System.Messaging.Message -&gt; bool" Usage="xmlMessageFormatter.CanRead message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">The <see cref="T:System.Messaging.Message" /> to inspect.</param>
        <summary>Determines whether the formatter can deserialize the message.</summary>
        <returns>
          <see langword="true" /> if the XML formatter can deserialize the message; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> aufgerufen wurde, versucht das Formatierungsprogramm zu ermitteln, ob der Inhalt der Meldung deserialisieren kann. Der Formatierer kann nur dann die Nachricht deserialisieren, wenn der Typ im Textkörper Nachricht das gleiche Schema wie einer der Typen im Array durch dargestellt hat die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften. <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> Gibt `false` unter den folgenden Fällen:  
  
-   Die Nachricht wurde nicht mit formatiert die <xref:System.Messaging.XmlMessageFormatter>.  
  
-   Das Schema des Nachrichtentexts ist nicht in den aufgelisteten entweder in der <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> oder <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaft.  
  
 Die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> -Eigenschaft geben das Formatierungsprogramm welche Arten von Objekten zum Deserialisieren können muss. Wenn einen beliebigen Typ aus der Liste fehlt, aber es sich in einer Nachricht befindet <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> gibt `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Neither the <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> nor <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> property has been set.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="message" /> parameter is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="xmlMessageFormatter.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class whose read/write properties (the sets of target types) are the same as the current <see cref="T:System.Messaging.XmlMessageFormatter" /> instance.</summary>
        <returns>An object whose properties are identical to those of this <see cref="T:System.Messaging.XmlMessageFormatter" /> instance, but whose metadata does not specify it to be a formatter class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine Kopie des Formatierers und initialisiert alle seine Eigenschaften, die Werte dieser <xref:System.Messaging.XmlMessageFormatter> Objekt.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member Read : System.Messaging.Message -&gt; obj&#xA;override this.Read : System.Messaging.Message -&gt; obj" Usage="xmlMessageFormatter.Read message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">The <see cref="T:System.Messaging.Message" />, in XML format, to deserialize.</param>
        <summary>Reads the contents from the given message and creates an object that contains the deserialized message.</summary>
        <returns>The deserialized message.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sowohl die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> -Eigenschaft geben das Formatierungsprogramm welche Schemas übereinstimmen, wenn Sie eine Nachricht zu deserialisieren. Eine dieser Eigenschaften muss festgelegt werden, bevor die Nachricht deserialisiert werden kann.  
  
 Im Meldungstext serialisierte Instanz muss eines der Schemas im Typarray dargestellt entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der das Schema identifiziert entspricht, und liest den Nachrichtentext in dieses.  
  
 Die Zieltypen müssen nicht angegeben werden, um das Schreiben in die Warteschlange.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Neither the <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> nor <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> property has been set.  -or-  The instance serialized in the message body does not comply with any of the schemas represented by the types in the <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> and <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> properties.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="message" /> parameter is <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypeNames : string[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies the set of possible types that will be deserialized by the formatter from the message provided.</summary>
        <value>Ein Array vom Typ <see cref="T:System.String" /> , die die Typen von Objekten aus dem Nachrichtentext deserialisiert werden soll, beim Lesen der Nachricht angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sowohl die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> -Eigenschaft geben das Formatierungsprogramm welche Schemas übereinstimmen, wenn Sie eine Nachricht zu deserialisieren. Dadurch wird den Formatierer, der Nachrichtentext interpretiert.  
  
 Im Meldungstext serialisierte Instanz muss eines der Schemas im Typarray dargestellt entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der das Schema identifiziert entspricht, und liest den Nachrichtentext in dieses.  
  
 Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen. Der Satz von Typen ist der kombinierten Gruppe von zwei Eigenschaften. Die Entscheidung, welche Eigenschaft zu verwenden, ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext ein Typs enthält, deren Schema keine Typen im Array für die Eigenschaft übereinstimmt, wird eine Ausnahme ausgelöst werden, wenn die Nachricht gelesen wird.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> muss jeder Eintrag angeben des Assemblynamens vollständig qualifiziert werden. Darüber hinaus muss bei der Arbeit mit mehrere parallele Versionen die Versionsnummer auch an den Namen des Zieltyps auch angehängt werden.  
  
 Die Zieltypen sind nur erforderlich, wenn aus der Warteschlange zu lesen. Die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften müssen nicht auf das Schreiben in die Warteschlange festgelegt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> property is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypes : Type[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies the set of possible types that will be deserialized by the formatter from the message provided.</summary>
        <value>Ein Array vom Typ <see cref="T:System.Type" /> , die die Typen von Objekten aus dem Nachrichtentext deserialisiert werden soll, beim Lesen der Nachricht angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sowohl die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> -Eigenschaft geben das Formatierungsprogramm welche Schemas übereinstimmen, wenn Sie eine Nachricht zu deserialisieren. Dadurch wird den Formatierer, der Nachrichtentext interpretiert.  
  
 Im Meldungstext serialisierte Instanz muss eines der Schemas im Typarray dargestellt entsprechen. Beim Lesen der Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A> -Methode, die Methode erstellt ein Objekt des Typs, der das Schema identifiziert entspricht, und liest den Nachrichtentext in dieses.  
  
 Muss nur eine der beiden Eigenschaften festgelegt werden, beim Lesen aus der Warteschlange, aber Sie können beide festlegen. Der Satz von Typen ist der kombinierten Gruppe von zwei Eigenschaften. Die Entscheidung, welche Eigenschaft zu verwenden, ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext ein Typs enthält, deren Schema keine Typen im Array für die Eigenschaft übereinstimmt, wird eine Ausnahme ausgelöst werden, wenn die Nachricht gelesen wird.  
  
 Die Zieltypen sind nur erforderlich, wenn aus der Warteschlange zu lesen. Die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaften müssen nicht auf das Schreiben in die Warteschlange festgelegt werden.  
  
 Beim Angeben von <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> statt <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, Typ vorhanden ist wird zur Kompilierzeit statt Lesezeit, reduzieren die Möglichkeit für Fehler überprüft.  
  
 Bei Verwendung <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, Sie können jedes Objekt hinzufügen (z. B. `MyClass`) der Liste auf eine Weise, die durch c#-Code veranschaulicht `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet und empfängt eine Nachricht, die eine Bestellung in und aus einer Warteschlange enthält.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> property is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Write : System.Messaging.Message * obj -&gt; unit&#xA;override this.Write : System.Messaging.Message * obj -&gt; unit" Usage="xmlMessageFormatter.Write (message, obj)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Body" /> property will contain the serialized object.</param>
        <param name="obj">The <see cref="T:System.Object" /> to be serialized into the message body.</param>
        <summary>Serializes an object into the body of the message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zieltypen müssen nicht angegeben werden, an die Warteschlange zu schreiben, müssen sie beim Lesen werden. Die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> oder <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Eigenschaft wird vom Formatierungsprogramm verwendet, nur, wenn eine Nachricht zu deserialisieren.  
  
 Die <xref:System.Messaging.XmlMessageFormatter> nutzt die <xref:System.Xml.Serialization.XmlSerializer> Klasse, die definiert, was serialisiert werden kann. Nur können öffentliche Felder und die öffentlichen Eigenschaften serialisiert werden. Strukturen, die Strukturen mit Arrays und Arrays von Strukturen sind alle serialisierbaren, solange sie nicht das codierte Format mit dem SOAP-Protokoll verwenden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="message" /> parameter is <see langword="null" />.  -or-  The <paramref name="obj" /> parameter is <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>