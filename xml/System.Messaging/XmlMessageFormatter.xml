<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ac2fbcd17f34ca9b08ffbb60e2705c9b3b24a9b7" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78822610" /></Metadata><TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <TypeSignature Language="F#" Value="type XmlMessageFormatter = class&#xA;    interface IMessageFormatter&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Serialisiert und deserialisiert mithilfe des auf XSD (XML Schema Definition) beruhenden XML-Formats Objekte in den oder aus dem Textkörper einer Meldung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der-<xref:System.Messaging.XmlMessageFormatter> ist das Standardformatierer, das eine Instanz von <xref:System.Messaging.MessageQueue> verwendet, um in die Warteschlange geschriebene Nachrichten zu serialisieren. Wenn Sie eine Instanz von <xref:System.Messaging.MessageQueue>erstellen, wird eine Instanz von <xref:System.Messaging.XmlMessageFormatter> für Sie erstellt und dem <xref:System.Messaging.MessageQueue>zugeordnet. Sie können einen anderen Formatierer angeben, indem Sie ihn in Ihrem Code erstellen und der <xref:System.Messaging.MessageQueue.Formatter%2A>-Eigenschaft ihrer <xref:System.Messaging.MessageQueue>zuweisen.  
  
 Die standardmäßige <xref:System.Messaging.XmlMessageFormatter> Instanz einer Warteschlange kann zum Schreiben in die Warteschlange verwendet werden. Sie kann jedoch erst verwendet werden, um die Warteschlange zu lesen, wenn Sie die <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>-Eigenschaft oder die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>-Eigenschaft für den Formatierer festgelegt haben. Sie können entweder einen oder beide dieser Werte für die Standard-formatiererinstanz festlegen, oder Sie können eine neue Instanz des Formatierers erstellen und die Werte automatisch festlegen, indem Sie Sie als Argumente an den entsprechenden <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A>-Konstruktor übergeben.  
  
 Wenn Sie <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> anstelle von <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>angeben, wird die typexistenz zur Kompilierzeit anstelle der Lesezeit überprüft, wodurch die Fehlerwahrscheinlichkeit verringert wird. für <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> muss jeder Eintrag voll qualifiziert sein, wobei der Assemblyname angegeben wird. Außerdem muss die Versionsnummer beim Arbeiten mit mehreren gleichzeitigen Versionen ebenfalls an den Zieltyp Namen angehängt werden.  
  
 Die Eigenschaften <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> teilen dem Formatierer mit, welche Schemas beim Deserialisieren einer Nachricht zu vergleichen sind. Dadurch kann der Formatierer den Nachrichtentext interpretieren.  
  
 Die im Nachrichtentext serialisierte-Instanz muss einem der im typanray dargestellten Schemas entsprechen. Wenn Sie die Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A>-Methode lesen, erstellt die-Methode ein Objekt vom Typ, das dem identifizierten Schema entspricht, und liest den Nachrichtentext darin.  
  
 Beim Lesen aus der Warteschlange muss nur eine der beiden Eigenschaften festgelegt werden, aber Sie können beides festlegen. Der Satz von Typen ist die kombinierte Menge aus den beiden Eigenschaften. Die Entscheidung, welche Eigenschaft verwendet werden soll, ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext einen Typ enthält, dessen Schema keinem der Typen im Array für eine der Eigenschaften entspricht, wird eine Ausnahme ausgelöst, wenn die Nachricht gelesen wird.  
  
 Der <xref:System.Messaging.XmlMessageFormatter> ist eine wichtige Komponente des lose verknüpften XML-basierten Messaging. Das Hilfsprogramm XSD. exe verwendet das XML-Format, das zum Generieren eines XML-Schemas verwendet wird, z. b. Wenn Sie das Hilfsprogramm verwenden, um eine von Ihrer Anwendung verwendete Klasse zu serialisieren Die Klasse muss einen parameterlosen Konstruktor haben.  
  
 Das Format wird im umgekehrten Prozess wieder verwendet, wenn das Hilfsprogramm eine Klasse basierend auf dem Schema generiert, das Sie zur Beschreibung der Klassen Daten verteilen. Durch die Verwendung des-Hilfsprogramms und des generierten XML-Schemas können Sie das erneute Verteilen von DLL-Dateien vermeiden, wenn Sie eine Klasse neu kompilieren, nachdem sich die Implementierung der Klasse geändert hat. Solange das Schema auf dem Client oder dem Server nicht geändert wird, wirken sich andere Änderungen auf beiden Seiten nicht auf das andere aus.  
  
   
  
## Examples  
 Das folgende Codebeispiel enthält drei Code Elemente: eine Serverkomponente, eine Order-Klasse und Client Code. Die Order-Klasse kann vom Hilfsprogramm "XSD. exe" verwendet werden, um ein Schema zu generieren, das der Server innerhalb eingehender Nachrichten erkennt. Das Schema ist eine XML-formatierte Datei, die die Form der-Klasse beschreibt. Dieses Schema kann dann auf der Clientseite verwendet werden, um eine Client spezifische Order-Klasse zu generieren, die das gleiche Schema wie die Serverklasse verwendet.  
  
 Das folgende Codebeispiel stellt eine Serverkomponente dar, die Aufträge über eine Nachrichten Warteschlange empfängt. Der Nachrichtentext muss ein Order-Objekt sein, dessen Schema mit der Order.cs-Klasse unten übereinstimmt. Der Server Prozess oder die Anwendung deserialisiert die Reihenfolge.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 Das folgende Codebeispiel stellt die Order-Klasse dar, die ein Schema für die Order-Objekte bereitstellt, die von der Anwendung auf dem Server empfangen und deserialisiert werden.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Jede Client Anwendung, die mit der Anwendung auf dem Server interagiert, muss Nachrichten an den Server senden, indem Informationen in einer lokal definierten Order-Klasse in den Nachrichtentext serialisiert werden. Die lokal definierte Order-Klasse muss das gleiche Schema wie die Server definierte Order-Klasse aufweisen, in der die Anwendung auf dem Server versucht, den Nachrichtentext zu deserialisieren. Mit dem Hilfsprogramm "XSD. exe" kann der Manager der Anwendung auf dem Server das Schema erstellen und verteilen, das der Client zum Serialisieren von Nachrichten an den Server verwenden muss.  
  
 Wenn der Manager der Client Anwendung das Schema für die Order-Klasse empfängt, wird das Dienstprogramm "XSD. exe" erneut verwendet, um eine Client spezifische Order-Klasse aus dem Schema zu generieren. Diese Klasse wird im folgenden Client Codebeispiel verwendet, nicht die Order-Klasse des Servers (das Hilfsprogramm "XSD. exe" bewirkt, dass die Schema generierte Klasse denselben Namen wie die ursprüngliche Klasse hat). Diese neue Order-Klasse wird verwendet, um die Reihenfolge in den Nachrichtentext zu serialisieren.  
  
 Das folgende Codebeispiel ist die Client seitige Verarbeitung, die zum Serialisieren einer Bestellung und zum Senden der der Bestellung zugeordneten Informationen an eine Warteschlange verwendet wird. Der Code ordnet Element-, Mengen-und Adressinformationen Elementen des Schemas zu, die durch das Hilfsprogramm "XSD. exe" für die Order.cs-Klasse generiert wurden. Eine Bestellung wird an die Auftrags Warteschlange auf dem lokalen Computer gesendet.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 Nachdem das Schema aus der Order-Klasse auf dem Server generiert wurde, können Sie die-Klasse ändern. Wenn das Schema nicht geändert wird, müssen Sie das Schema nicht neu verteilen. Nachdem Sie das Schema verteilt und eine Client seitige Order-Klasse generiert haben, kann diese Client Klasse auch unabhängig von der Order-Klasse des Servers geändert werden, solange das Schema selbst nicht geändert wird. Die beiden Klassen sind lose gekoppelt.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.XmlMessageFormatter" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.XmlMessageFormatter" />-Klasse ohne Angabe einer Gruppe von Zieltypen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung des Konstruktors wird am häufigsten beim Schreiben in die Warteschlange verwendet, da Zieltypen beim Schreiben nicht erforderlich sind.  
  
 Zum Lesen einer Nachricht aus einer Warteschlange mithilfe einer Instanz von, die mit diesem Konstruktor erstellt <xref:System.Messaging.XmlMessageFormatter>, müssen Sie die Eigenschaften <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> oder <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> festlegen, damit der Formatierer weiß, welche Typen versucht werden zu deserialisieren.  
  
 Wenn Sie einen neuen <xref:System.Messaging.MessageQueue>erstellen, wird eine standardmäßige <xref:System.Messaging.XmlMessageFormatter> Instanz erstellt, ohne dass die Zieltypen festgelegt sind. Wie bei einem Formatierer, der mit diesem Konstruktor erstellt wurde, müssen Sie Zieltypen für diese formatiererinstanz festlegen, wenn Sie aus der Warteschlange lesen möchten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : string[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypeNames" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">Ein Array vom Typ <see cref="T:System.String" />, das die Gruppe der möglichen Typen angibt, die vom Formatierungsprogramm aus der jeweiligen Meldung deserialisiert werden können. Diese Werte müssen voll gekennzeichnet sein, z. B. "MyNamespace.MyOrders, MyOrdersAssemblyName".</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.XmlMessageFormatter" />-Klasse und legt die übergebenen Zieltypen als ein Array von (voll gekennzeichneten) Zeichenfolgenwerten fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Konstruktoren mit Zieltyp Parametern werden am häufigsten beim Lesen aus der Warteschlange verwendet. Beim Schreiben ist es nicht notwendig, Zieltypen anzugeben.  
  
 Diese Überladung des <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> Konstruktors legt die <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>-Eigenschaft auf die Array Werte fest, die über den `targetTypeNames`-Parameter übergeben werden. Wenn diese Eigenschaft festgelegt wird, kann ein <xref:System.Messaging.MessageQueue> diese <xref:System.Messaging.XmlMessageFormatter> Instanz verwenden, um Nachrichten zu lesen, die Objekte eines bestimmten Typs enthalten  
  
 Die Eigenschaften <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> teilen dem Formatierer mit, welche Schemas beim Deserialisieren einer Nachricht zu vergleichen sind. Dadurch kann der Formatierer den Nachrichtentext interpretieren.  
  
 Die im Nachrichtentext serialisierte-Instanz muss einem der im typanray dargestellten Schemas entsprechen. Wenn Sie die Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A>-Methode lesen, erstellt die-Methode ein Objekt vom Typ, das dem identifizierten Schema entspricht, und liest den Nachrichtentext darin.  
  
 Beim Lesen aus der Warteschlange muss nur eine der beiden Eigenschaften festgelegt werden, aber Sie können beides festlegen. Der Satz von Typen ist die kombinierte Menge aus den beiden Eigenschaften. Die Entscheidung, welche verwendet werden soll, ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext einen Typ enthält, dessen Schema keinem der Typen im Array für eine der Eigenschaften entspricht, wird eine Ausnahme zur Lesezeit ausgelöst.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="targetTypeNames" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : Type[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypes" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">Ein Array vom Typ <see cref="T:System.Type" />, das die Gruppe der möglichen Typen angibt, die vom Formatierungsprogramm aus der jeweiligen Meldung deserialisiert werden können.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Messaging.XmlMessageFormatter" />-Klasse und legt die übergebenen Zieltypen als ein Array von Objekttypen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Konstruktoren mit Zieltyp Parametern werden am häufigsten beim Lesen aus der Warteschlange verwendet. Beim Schreiben ist es nicht notwendig, Zieltypen anzugeben.  
  
 Diese Überladung des <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> Konstruktors legt die <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>-Eigenschaft auf die Array Werte fest, die über den `targetTypes`-Parameter übergeben werden. Wenn diese Eigenschaft festgelegt wird, kann ein <xref:System.Messaging.MessageQueue> diese <xref:System.Messaging.XmlMessageFormatter> Instanz verwenden, um Nachrichten zu lesen, die Objekte der angegebenen Typen enthalten.  
  
 Die Eigenschaften <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> teilen dem Formatierer mit, welche Schemas beim Deserialisieren einer Nachricht zu vergleichen sind. Dadurch kann der Formatierer den Nachrichtentext interpretieren.  
  
 Die im Nachrichtentext serialisierte-Instanz muss einem der im typanray dargestellten Schemas entsprechen. Wenn Sie die Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A>-Methode lesen, erstellt die-Methode ein Objekt vom Typ, das dem identifizierten Schema entspricht, und liest den Nachrichtentext darin.  
  
 Beim Lesen aus der Warteschlange muss nur eine der beiden Eigenschaften festgelegt werden, aber Sie können beides festlegen. Der Satz von Typen ist die kombinierte Menge aus den beiden Eigenschaften. Die Entscheidung, welche verwendet werden soll, ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext einen Typ enthält, dessen Schema keinem der Typen im Array für eine der Eigenschaften entspricht, wird eine Ausnahme zur Lesezeit ausgelöst.  
  
 Wenn Sie <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> anstelle von <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>angeben, wird die typexistenz zur Kompilierzeit anstelle der Lesezeit überprüft, wodurch die Fehlerwahrscheinlichkeit verringert wird. für <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> muss jeder Eintrag voll qualifiziert sein, wobei der Assemblyname angegeben wird. Außerdem muss die Versionsnummer beim Arbeiten mit mehreren gleichzeitigen Versionen ebenfalls an den Zieltyp Namen angehängt werden.  
  
 Wenn Sie <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>verwenden, können Sie jedes Objekt (z. b. `MyClass`) der Liste auf eine Weise hinzufügen, die C# im folgenden Code veranschaulicht wird.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="targetTypes" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanRead (message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member CanRead : System.Messaging.Message -&gt; bool&#xA;override this.CanRead : System.Messaging.Message -&gt; bool" Usage="xmlMessageFormatter.CanRead message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">Die zu untersuchende <see cref="T:System.Messaging.Message" />.</param>
        <summary>Ermittelt, ob das Formatierprogramm die Meldung deserialisieren kann.</summary>
        <returns><see langword="true" />, wenn das XML-Formatierungsprogramm die Meldung deserialisieren kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> aufgerufen wird, versucht der Formatierer festzustellen, ob der Inhalt der Nachricht deserialisiert werden kann. Der Formatierer kann die Nachricht nur deserialisieren, wenn der Typ im Nachrichtentext das gleiche Schema hat wie einer der Typen im Array, der durch die Eigenschaften <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> dargestellt wird. <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> gibt `false` in den folgenden zwei Fällen zurück:  
  
-   Die Nachricht wurde nicht mit dem <xref:System.Messaging.XmlMessageFormatter>formatiert.  
  
-   Das Schema des Nachrichten Texts gehört nicht zu den Angaben, die in der <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>-oder <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>-Eigenschaft aufgeführt sind.  
  
 Die Eigenschaften <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> teilen dem Formatierer mit, welche Typen von Objekten er Deserialisieren muss. Wenn ein beliebiger Typ in der Liste fehlt, aber in der Nachricht gefunden wird, gibt <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> `false`zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde weder die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />-Eigenschaft noch die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />-Eigenschaft festgelegt.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="message" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="xmlMessageFormatter.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Instanz der <see cref="T:System.Messaging.XmlMessageFormatter" />-Klasse, das dieselben Lese-/Schreibeigenschaften (die Gruppe von Zieltypen) besitzt wie die aktuelle <see cref="T:System.Messaging.XmlMessageFormatter" />-Instanz.</summary>
        <returns>Ein Objekt, dessen Eigenschaften mit denen dieser <see cref="T:System.Messaging.XmlMessageFormatter" />-Instanz übereinstimmen, dessen Metadaten es jedoch nicht als Instanz der Formatierungsprogrammklasse beschreiben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine Kopie des Formatierers und initialisiert alle zugehörigen Eigenschaften mit den Werten dieses <xref:System.Messaging.XmlMessageFormatter> Objekts.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (message As Message) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member Read : System.Messaging.Message -&gt; obj&#xA;override this.Read : System.Messaging.Message -&gt; obj" Usage="xmlMessageFormatter.Read message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">Die zu deserialisierende <see cref="T:System.Messaging.Message" /> im XML-Format.</param>
        <summary>Liest den Inhalt aus der angegebenen Meldung und erstellt ein Objekt, das die deserialisierte Meldung enthält.</summary>
        <returns>Die deserialisierte Meldung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eigenschaften <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> teilen dem Formatierer mit, welche Schemas beim Deserialisieren einer Nachricht zu vergleichen sind. Eine dieser Eigenschaften muss festgelegt werden, bevor die Nachricht deserialisiert werden kann.  
  
 Die im Nachrichtentext serialisierte-Instanz muss einem der im typanray dargestellten Schemas entsprechen. Wenn Sie die Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A>-Methode lesen, erstellt die-Methode ein Objekt vom Typ, das dem identifizierten Schema entspricht, und liest den Nachrichtentext darin.  
  
 Die Zieltypen müssen nicht angegeben werden, um in die Warteschlange zu schreiben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde weder die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />-Eigenschaft noch die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />-Eigenschaft festgelegt.  
  
- oder - 
Die im Meldungstext serialisierte Instanz entspricht keinem der Schemas, die von den Typen in der <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />-Eigenschaft und der <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />-Eigenschaft dargestellt werden.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="message" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypeNames : string[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Gruppe der möglichen Typen an, die vom Formatierungsprogramm aus der bereitgestellten Meldung deserialisiert werden können.</summary>
        <value>Ein Array vom Typ <see cref="T:System.String" />, das die Objekttypen angibt, die beim Lesen der Meldung aus dem Meldungstext deserialisiert werden sollen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eigenschaften <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> teilen dem Formatierer mit, welche Schemas beim Deserialisieren einer Nachricht zu vergleichen sind. Dadurch kann der Formatierer den Nachrichtentext interpretieren.  
  
 Die im Nachrichtentext serialisierte-Instanz muss einem der im typanray dargestellten Schemas entsprechen. Wenn Sie die Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A>-Methode lesen, erstellt die-Methode ein Objekt vom Typ, das dem identifizierten Schema entspricht, und liest den Nachrichtentext darin.  
  
 Beim Lesen aus der Warteschlange muss nur eine der beiden Eigenschaften festgelegt werden, aber Sie können beides festlegen. Der Satz von Typen ist die kombinierte Menge aus den beiden Eigenschaften. Die Entscheidung, welche Eigenschaft verwendet werden soll, ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext einen Typ enthält, dessen Schema keinem der Typen im Array für eine der Eigenschaften entspricht, wird eine Ausnahme ausgelöst, wenn die Nachricht gelesen wird.  
  
 für <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> muss jeder Eintrag voll qualifiziert sein, wobei der Assemblyname angegeben wird. Außerdem muss die Versionsnummer beim Arbeiten mit mehreren gleichzeitigen Versionen ebenfalls an den Zieltyp Namen angehängt werden.  
  
 Die Zieltypen sind nur beim Lesen aus der Warteschlange erforderlich. Die Eigenschaften "<xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>" und "<xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>" müssen nicht so festgelegt werden, dass Sie in die Warteschlange schreiben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />-Eigenschaft ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypes : Type[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Gruppe der möglichen Typen an, die vom Formatierungsprogramm aus der bereitgestellten Meldung deserialisiert werden können.</summary>
        <value>Ein Array vom Typ <see cref="T:System.Type" />, das die Objekttypen angibt, die beim Lesen der Meldung aus dem Meldungstext deserialisiert werden sollen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eigenschaften <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> und <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> teilen dem Formatierer mit, welche Schemas beim Deserialisieren einer Nachricht zu vergleichen sind. Dadurch kann der Formatierer den Nachrichtentext interpretieren.  
  
 Die im Nachrichtentext serialisierte-Instanz muss einem der im typanray dargestellten Schemas entsprechen. Wenn Sie die Nachricht mit der <xref:System.Messaging.MessageQueue.Receive%2A>-Methode lesen, erstellt die-Methode ein Objekt vom Typ, das dem identifizierten Schema entspricht, und liest den Nachrichtentext darin.  
  
 Beim Lesen aus der Warteschlange muss nur eine der beiden Eigenschaften festgelegt werden, aber Sie können beides festlegen. Der Satz von Typen ist die kombinierte Menge aus den beiden Eigenschaften. Die Entscheidung, welche Eigenschaft verwendet werden soll, ist spezifisch für Ihre Anwendung. Wenn der Nachrichtentext einen Typ enthält, dessen Schema keinem der Typen im Array für eine der Eigenschaften entspricht, wird eine Ausnahme ausgelöst, wenn die Nachricht gelesen wird.  
  
 Die Zieltypen sind nur beim Lesen aus der Warteschlange erforderlich. Die Eigenschaften "<xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>" und "<xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>" müssen nicht so festgelegt werden, dass Sie in die Warteschlange schreiben.  
  
 Wenn Sie <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> anstelle von <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>angeben, wird die typexistenz zur Kompilierzeit anstelle der Lesezeit überprüft, wodurch die Fehlerwahrscheinlichkeit verringert wird.  
  
 Wenn Sie <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>verwenden, können Sie jedes Objekt (z. b. `MyClass`) der Liste auf eine Weise hinzufügen, C# die durch den Code `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`veranschaulicht wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Nachricht gesendet und empfangen, die eine Bestellung zu und aus einer Warteschlange enthält.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />-Eigenschaft ist <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (message As Message, obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Write : System.Messaging.Message * obj -&gt; unit&#xA;override this.Write : System.Messaging.Message * obj -&gt; unit" Usage="xmlMessageFormatter.Write (message, obj)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">Die <see cref="T:System.Messaging.Message" />, deren <see cref="P:System.Messaging.Message.Body" />-Eigenschaft das serialisierte Objekt aufnimmt.</param>
        <param name="obj">Das <see cref="T:System.Object" />, das in den Meldungstext serialisiert werden soll.</param>
        <summary>Serialisiert ein Objekt in den Textkörper der Meldung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zieltypen müssen nicht so angegeben werden, dass Sie in die Warteschlange geschrieben werden, da Sie beim Lesen vorliegen müssen. Die Eigenschaft <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> oder <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> wird vom Formatierer nur beim Deserialisieren einer Nachricht verwendet.  
  
 Der <xref:System.Messaging.XmlMessageFormatter> verwendet die <xref:System.Xml.Serialization.XmlSerializer>-Klasse, die definiert, was serialisiert werden kann. Es können nur öffentliche Felder und öffentliche Eigenschaften serialisiert werden. Strukturen, Strukturen mit Arrays und Arrays von Strukturen sind alle serialisierbar, sofern Sie nicht den codierten Stil mit dem SOAP-Protokoll verwenden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="message" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>
