<Type Name="AceEnumerator" FullName="System.Security.AccessControl.AceEnumerator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e243cb564071bf81517ddfffdd03c3b5e986c43c" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70657342" /></Metadata><TypeSignature Language="C#" Value="public sealed class AceEnumerator : System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit AceEnumerator extends System.Object implements class System.Collections.IEnumerator" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.AceEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AceEnumerator&#xA;Implements IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class AceEnumerator sealed : System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type AceEnumerator = class&#xA;    interface IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>System.Security.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Bietet die Möglichkeit, die Zugriffssteuerungseinträge (ACEs) in einer Zugriffssteuerungsliste (ACL) zu durchlaufen.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.GenericAce Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.AccessControl.GenericAce Current" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.AceEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As GenericAce" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::AccessControl::GenericAce ^ Current { System::Security::AccessControl::GenericAce ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Security.AccessControl.GenericAce" Usage="System.Security.AccessControl.AceEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.GenericAce</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das aktuelle Element in der <see cref="T:System.Security.AccessControl.GenericAce" />-Auflistung ab. Diese Eigenschaft ruft die typfreundliche Version des Objekts ab.</summary>
        <value>Das aktuelle Element in der <see cref="T:System.Security.AccessControl.GenericAce" />-Auflistung.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.AceEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="aceEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den Enumerator auf das nächste Element der <see cref="T:System.Security.AccessControl.GenericAce" />-Auflistung.</summary>
        <returns><see langword="true" />, wenn der Enumerator erfolgreich auf das nächste Element gesetzt wurde, <see langword="false" />, wenn der Enumerator das Ende der Auflistung überschritten hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem Erstellen eines Enumerators oder nach dem Abrufen der <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> -Methode wird ein Enumerator vor dem ersten Element der-Auflistung positioniert, und der erste-aufrufungs <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> -Enumerator für das erste Element der Auflistung.  
  
 Nachdem das Ende der Auflistung überschritten wurde, werden nachfolgende <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> Aufrufe `false` von <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> zurückgegeben, bis aufgerufen wird.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn Änderungen, z. b. das Hinzufügen, ändern oder Löschen von Elementen, an der Auflistung vorgenommen werden, wird der Enumerator unwiederbringlich ungültig, <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> und <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> der nächste <xref:System.InvalidOperationException>Rückruf von oder löst eine aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Sammlung wurde nach der Erstellung des Enumerators geändert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.AceEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="aceEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt den Enumerator auf seine anfängliche Position vor dem ersten Element in der <see cref="T:System.Security.AccessControl.GenericAce" />-Auflistung fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn, z. b. das Hinzufügen, ändern oder Löschen von Elementen, an der Auflistung vorgenommen werden, wird der Enumerator unwiederbringlich ungültig, und <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> der nächste Rückruf <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> der-Methode oder der-Methode löst eine<xref:System.InvalidOperationException>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Sammlung wurde nach der Erstellung des Enumerators geändert.</exception>
        <block subset="none" type="overrides"><para>Alle Aufrufe von <see cref="M:System.Security.AccessControl.AceEnumerator.Reset" /> müssen für den Enumerator denselben Status aufweisen. Die bevorzugte Implementierung besteht darin, den Enumerator vor dem ersten Element an den Anfang der Auflistung zu verschieben. Dadurch wird der Enumerator ungültig, wenn die Auflistung seit der Erstellung des Enumerators geändert wurde, was mit <see cref="M:System.Security.AccessControl.AceEnumerator.MoveNext" /> und <see cref="P:System.Security.AccessControl.AceEnumerator.Current" />konsistent ist.</para></block>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.AceEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das aktuelle Element in der Auflistung ab.</summary>
        <value>Das aktuelle Element in der Auflistung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem Erstellen eines Enumerators oder <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> nach dem Abrufen der-Methode muss die <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> -Methode aufgerufen werden, um den Enumerator vor dem Lesen des <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A> Werts von <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A>auf das erste Element der Auflistung zu setzen. andernfalls ist nicht definiert. .  
  
 <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A>löst auch eine Ausnahme aus, wenn der letzte <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> Rückruf `false`von zurückgegeben wurde, der das Ende der Auflistung angibt.  
  
 <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A>Verschiebt die Position des Enumerators nicht, und aufeinanderfolgende Aufrufe <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A> von geben das gleiche Objekt zurück, bis entweder <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> oder <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> aufgerufen wird.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn Änderungen, z. b. das Hinzufügen, ändern oder Löschen von Elementen, an der Auflistung vorgenommen werden, ist der Enumerator unwiederbringlich ungültig, und <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> der <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> nächste Rückruf <xref:System.InvalidOperationException>von oder löst eine aus. Wenn die Auflistung zwischen <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> und geändert wird, <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A> gibt das- <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A>Element zurück, auf das Sie festgelegt ist, auch wenn der Enumerator bereits für ungültig erklärt wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Sammlung wurde nach der Erstellung des Enumerators geändert.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
