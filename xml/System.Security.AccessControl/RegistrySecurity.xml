<Type Name="RegistrySecurity" FullName="System.Security.AccessControl.RegistrySecurity">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a1e573054d899d9ece24be60d9cd1af96043f0b2" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69085987" /></Metadata><TypeSignature Language="C#" Value="public sealed class RegistrySecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RegistrySecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.RegistrySecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistrySecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistrySecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type RegistrySecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt die Windows-Zugriffssteuerungssicherheit für einen Registrierungsschlüssel dar. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Security.AccessControl.RegistrySecurity> -Objekt gibt Zugriffsrechte für einen Registrierungsschlüssel an und gibt außerdem an, wie Zugriffsversuche überwacht werden. Zugriffsrechte für den Registrierungsschlüssel werden als Regeln ausgedrückt, wobei jede Zugriffs Regel durch ein <xref:System.Security.AccessControl.RegistryAccessRule> -Objekt dargestellt wird. Jede Überwachungs Regel wird durch ein <xref:System.Security.AccessControl.RegistryAuditRule> -Objekt dargestellt.  
  
 Dies spiegelt das zugrunde liegende Windows-Sicherheitssystem wider, in dem jedes Sicherungs fähige Objekt höchstens eine freigegebene Zugriffs Steuerungs Liste (DACL) aufweist, die den Zugriff auf das gesicherte Objekt steuert, und höchstens eine System Zugriffs Steuerungs Liste (SACL), die den Zugriff angibt. Versuche werden überwacht. DACL und SACL sind geordnete Listen mit Zugriffs Steuerungs Einträgen (ACE), die den Zugriff und die Überwachung für Benutzer und Gruppen angeben. Ein <xref:System.Security.AccessControl.RegistryAccessRule> - <xref:System.Security.AccessControl.RegistryAuditRule> oder-Objekt kann mehr als einen ACE darstellen.  
  
> [!NOTE]
>  Die Windows-Zugriffs Steuerungs Sicherheit kann nur auf Registrierungsschlüssel angewendet werden. Sie kann nicht auf einzelne Schlüssel-Wert-Paare angewendet werden, die in einem Schlüssel gespeichert sind.  
  
 Die <xref:System.Security.AccessControl.RegistrySecurity>Klassen <xref:System.Security.AccessControl.RegistryAccessRule>, und<xref:System.Security.AccessControl.RegistryAuditRule> verbergen die Implementierungsdetails von ACLs und ACEs. Sie ermöglichen es Ihnen, die 17 verschiedenen ACE-Typen und die Komplexität der ordnungsgemäßen Beibehaltung der Vererbung und der Propagierung von Zugriffsrechten zu ignorieren. Diese Objekte sind ebenfalls so konzipiert, dass die folgenden allgemeinen Zugriffs Steuerungs Fehler vermieden werden:  
  
-   Erstellen einer Sicherheits Beschreibung mit einer NULL-DACL. Ein NULL-Verweis auf eine DACL ermöglicht jedem Benutzer das Hinzufügen von Zugriffsregeln zu einem Objekt, was potenziell zu einem Denial-of-Service-Angriff führt. Ein neues <xref:System.Security.AccessControl.RegistrySecurity> -Objekt beginnt immer mit einer leeren DACL, die allen Benutzern den Zugriff verweigert.  
  
-   Verstoß gegen die kanonische Reihenfolge von ACEs. Wenn die ACE-Liste in der DACL nicht in der kanonischen Reihenfolge beibehalten wird, erhalten Benutzer möglicherweise versehentlich Zugriff auf das gesicherte Objekt. Beispielsweise müssen verweigerte Zugriffsrechte immer vor zulässigen Zugriffsrechten angezeigt werden. <xref:System.Security.AccessControl.RegistrySecurity>-Objekte behalten die korrekte Reihenfolge intern bei.  
  
-   Manipulieren von Sicherheitsbeschreibungsflags, die nur unter dem Resource Manager-Steuerelement vorliegen sollten.  
  
-   Erstellen Ungültiger Kombinationen von ACE-Flags.  
  
-   Manipulieren von geerbten ACEs. Vererbung und Weitergabe werden vom Ressourcen-Manager als Reaktion auf Änderungen, die Sie an Zugriffs-und Überwachungsregeln vornehmen, verarbeitet.  
  
-   Einfügen von bedeutungslosen ACEs in ACLs.  
  
 Die einzigen Funktionen, die nicht von den .net-Sicherheits Objekten unterstützt werden, sind gefährliche Aktivitäten, die von den meisten Anwendungsentwicklern vermieden werden sollten, wie z. b. die folgenden:  
  
-   Aufgaben auf niedriger Ebene, die normalerweise vom Ressourcen-Manager ausgeführt werden.  
  
-   Hinzufügen oder Entfernen von Zugriffs Steuerungs Einträgen auf eine Weise, die die kanonische Reihenfolge nicht beibehält.  
  
 Um die Windows-Zugriffs Steuerungs Sicherheit für einen Registrierungsschlüssel zu ändern <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> , verwenden Sie die <xref:System.Security.AccessControl.RegistrySecurity> -Methode, um das-Objekt zu erhalten. Ändern Sie das Sicherheits Objekt durch Hinzufügen und Entfernen von Regeln, und <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> verwenden Sie dann die-Methode, um es erneut anzufügen.  
  
> [!IMPORTANT]
>  Änderungen, die Sie an <xref:System.Security.AccessControl.RegistrySecurity> einem-Objekt vornehmen, wirken sich nicht auf die Zugriffsebenen des Registrierungsschlüssels <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> aus, bis Sie die-Methode aufrufen, um das geänderte Sicherheits Objekt dem Registrierungsschlüssel zuzuweisen.  
  
 Um die Zugriffs Steuerungs Sicherheit von einem Registrierungsschlüssel in einen anderen zu kopieren <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> , verwenden Sie die <xref:System.Security.AccessControl.RegistrySecurity> -Methode, um ein-Objekt zu erhalten, das die Zugriffs-und Überwachungsregeln <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> für den ersten Registrierungsschlüssel darstellt, und verwenden Sie dann die-Methode, um diese Regeln der zweiter Registrierungsschlüssel. Sie können die Regeln auch einem zweiten Registrierungsschlüssel mit einer <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=nameWithType> -oder <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=nameWithType> -Methode zuweisen, die <xref:System.Security.AccessControl.RegistrySecurity> einen-Objekt Parameter annimmt.  
  
 Benutzer mit einer Investition in die Security Deskriptor Definition Language (SDDL) können die <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> -Methode verwenden, um Zugriffsregeln für einen Registrierungsschlüssel festzulegen, und die <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> -Methode, um eine Zeichenfolge abzurufen, die die Zugriffsregeln im SDDL-Format darstellt. Dies wird nicht für die neue Entwicklung empfohlen.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im ersten Beispiel wird gezeigt, wie kompatible Regeln beim Hinzufügen und entfernen zusammengeführt werden, und der zweite zeigt, wie Vererbungs-und Weitergabeflags das Hinzufügen und Löschen von Regeln beeinflussen  
  
 Beispiel 1  
  
 Das folgende Codebeispiel zeigt, wie <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> die-Methode Rechte aus einer kompatiblen Regel entfernt und wie <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> die-Methode Rechte mit kompatiblen Regeln zusammenfasst.  
  
 Im Beispiel wird ein <xref:System.Security.AccessControl.RegistrySecurity> -Objekt erstellt, und es wird eine Regel hinzu <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> gefügt, die die aktuellen Benutzerrechte zulässt. Im Beispiel wird dann eine Regel erstellt, die dem <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>Benutzer die gleichen Vererbungs-und Weitergaberechte wie die erste Regel gewährt <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> und die-Methode verwendet, um diese <xref:System.Security.AccessControl.RegistrySecurity> neue Regel aus dem-Objekt zu entfernen. <xref:System.Security.AccessControl.RegistryRights.SetValue>ist ein Bestand von <xref:System.Security.AccessControl.RegistryRights.ReadKey>, sodass es aus der kompatiblen Regel entfernt wird. Die Regeln im <xref:System.Security.AccessControl.RegistrySecurity> -Objekt werden angezeigt und zeigen die verbleibenden bestand <xref:System.Security.AccessControl.RegistryRights.ReadKey>Teile von an.  
  
 Der Beispielcode ruft dann die <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> -Methode auf, <xref:System.Security.AccessControl.RegistryRights.SetValue> um das direkt mit der Regel im <xref:System.Security.AccessControl.RegistrySecurity> -Objekt zusammenzuführen.  
  
> [!NOTE]
>  In diesem Beispiel wird das Sicherheits Objekt nicht an ein <xref:Microsoft.Win32.RegistryKey> -Objekt angefügt. Das zweite Beispiel in diesem Abschnitt fügt ein Sicherheits Objekt an. führen Sie die Beispiele in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> und <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>aus.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 Beispiel 2  
  
 Im folgenden Codebeispiel werden Zugriffsregeln mit Vererbung und Propagierung veranschaulicht. Im Beispiel wird ein <xref:System.Security.AccessControl.RegistrySecurity> -Objekt erstellt, dann werden zwei Regeln erstellt und hinzu <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> gefügt, die über das-Flag verfügen. Die erste Regel weist keine Weitergabeflags auf, während <xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit> die <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>zweite Regel über und verfügt.  
  
 Das Programm zeigt die Regeln im <xref:System.Security.AccessControl.RegistrySecurity> -Objekt an und verwendet dann das <xref:System.Security.AccessControl.RegistrySecurity> -Objekt, um einen Unterschlüssel zu erstellen. Das Programm erstellt einen untergeordneten Unterschlüssel und einen untergeordneten Unterschlüssel mit zwei untergeordneten Schlüsseln und zeigt dann die Sicherheit für jeden Unterschlüssel an. Schließlich löscht das Programm die Testschlüssel.  
  
 [!code-csharp[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistrySecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistrySecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.AccessControl.RegistrySecurity" />-Klasse mit Standardwerten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein neues <xref:System.Security.AccessControl.RegistrySecurity> -Objekt beginnt immer mit einer leeren DACL (freigegebene Zugriffsliste), die allen Benutzern den Zugriff verweigert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Enumerationstyp ab, mit dessen Hilfe die <see cref="T:System.Security.AccessControl.RegistrySecurity" />-Klasse Zugriffsrechte darstellt.</summary>
        <value>Ein <see cref="T:System.Type" />-Objekt, das die <see cref="T:System.Security.AccessControl.RegistryRights" />-Enumeration darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klassen, die von der <xref:System.Security.AccessControl.ObjectSecurity> -Klasse abgeleitet <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> werden, überschreiben die-Eigenschaft und geben den Typ zurück, den Sie zum Darstellen von Zugriffsrechten Wenn Sie mit Arrays oder Auflistungen arbeiten, die mehrere Typen von Sicherheits Objekten enthalten, verwenden Sie diese Eigenschaft, um den korrekten Enumerationstyp zu bestimmen, der für jedes Sicherheits Objekt verwendet werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="registrySecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">Eine <see cref="T:System.Security.Principal.IdentityReference" />, mit deren Hilfe der Benutzer oder die Gruppe angegeben wird, für den bzw. die die Regel gilt.</param>
        <param name="accessMask">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.RegistryRights" />-Werten, die die zu verweigernden oder zu gewährenden Zugriffsrechte angibt (in eine ganze Zahl umgewandelt).</param>
        <param name="isInherited">Ein boolescher Wert, der angibt, ob die Regel geerbt ist.</param>
        <param name="inheritanceFlags">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.InheritanceFlags" />-Werten, die angibt, wie die Regel von Unterschlüsseln geerbt wird.</param>
        <param name="propagationFlags">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.PropagationFlags" />-Werten, die die Art der Vererbung der Regel für die Unterschlüssel ändert. Irrelevant, wenn der Wert von <paramref name="inheritanceFlags" /><see cref="F:System.Security.AccessControl.InheritanceFlags.None" /> ist.</param>
        <param name="type">Einer der <see cref="T:System.Security.AccessControl.AccessControlType" />-Werte, mit denen angegeben wird, ob die Rechte gewährt oder verweigert werden.</param>
        <summary>Erstellt eine neue Zugriffssteuerungsregel für den angegebenen Benutzer mit den angegebenen Zugriffsrechten und Flags sowie der angegebenen Zugriffssteuerung.</summary>
        <returns>Ein <see cref="T:System.Security.AccessControl.RegistryAccessRule" />-Objekt, das die angegebenen Rechte für den angegebenen Benutzer darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die empfohlene Vorgehensweise zum Erstellen von Zugriffs Steuerungs Regeln ist die Verwendung der Konstruktoren <xref:System.Security.AccessControl.RegistryAccessRule> der-Klasse.  
  
> [!NOTE]
>  Obwohl Sie das <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> -Flag angeben können, gibt es keine Möglichkeit, dies zu tun. Für den Zweck der Zugriffs Steuerung sind die Name-Wert-Paare in einem Unterschlüssel keine separaten Objekte. Die Zugriffsrechte für Name/Wert-Paare werden durch die Rechte des unter Schlüssels gesteuert. Da alle Unterschlüssel Container sind (d. h., Sie können andere Unterschlüssel enthalten), wird das <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> -Flag nicht beeinträchtigt. Schließlich wird durch die <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> Angabe des Flags unnötig die Wartung von Regeln erschwert, da dies die normale Kombination von kompatiblen Regeln beeinträchtigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> oder <paramref name="type" /> ist ein ungültiger Wert angegeben.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="identityReference" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="accessMask" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identityReference" /> ist weder vom Typ <see cref="T:System.Security.Principal.SecurityIdentifier" /> noch von einem Typ wie etwa <see cref="T:System.Security.Principal.NTAccount" />, der in den <see cref="T:System.Security.Principal.SecurityIdentifier" />-Typ konvertiert werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, mit dessen Hilfe die <see cref="T:System.Security.AccessControl.RegistrySecurity" />-Klasse die Zugriffsregeln darstellt.</summary>
        <value>Ein <see cref="T:System.Type" />-Objekt, das die <see cref="T:System.Security.AccessControl.RegistryAccessRule" />-Klasse darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klassen, die von der <xref:System.Security.AccessControl.ObjectSecurity> -Klasse abgeleitet <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> werden, überschreiben die-Eigenschaft und geben den Typ zurück, den Sie verwenden, um Zugriffsregeln Wenn Sie mit Arrays oder Auflistungen arbeiten, die mehrere Typen von Sicherheits Objekten enthalten, verwenden Sie diese Eigenschaft, um den korrekten Zugriffs Regeltyp zu bestimmen, der für jedes Sicherheits Objekt verwendet werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Die hinzuzufügende Zugriffssteuerungsregel.</param>
        <summary>Sucht nach einer übereinstimmenden Zugriffssteuerung, mit der die neue Regel zusammengeführt werden kann. Wenn keine Regel gefunden wurde, wird die neue Regel hinzugefügt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> -Methode sucht nach Regeln mit dem gleichen Benutzer oder der gleichen Gruppe <xref:System.Security.AccessControl.AccessControlType> und `rule`mit dem gleichen. Wenn keine gefunden werden, `rule` wird hinzugefügt. Wenn eine abgleichsregel gefunden wird, werden `rule` die Rechte in mit der vorhandenen Regel zusammengeführt.  
  
 Regeln können nicht zusammengeführt werden, wenn Sie unterschiedliche Vererbungs Flags aufweisen. Wenn einem Benutzer z. b. Lesezugriff ohne Vererbungs Flags gestattet wird und <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> eine Regel hinzugefügt wird, die dem Benutzer Schreibzugriff auf die Vererbung von unter<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>Schlüsseln () gewährt, können die beiden Regeln nicht zusammengeführt werden.  
  
 Regeln mit unter <xref:System.Security.AccessControl.AccessControlType> schiedlichen Werten werden nie zusammengeführt.  
  
 Regeln werden auf die wirtschaftlichste Weise mit rechten ausgedrückt. Wenn ein Benutzer beispielsweise über die <xref:System.Security.AccessControl.RegistryRights.QueryValues>Rechte <xref:System.Security.AccessControl.RegistryRights.Notify> , <xref:System.Security.AccessControl.RegistryRights.ReadPermissions> und verfügt und Sie eine Regel hinzufügen <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> , die Rechte zulässt, verfügt der Benutzer über alle <xref:System.Security.AccessControl.RegistryRights.ReadKey> Bestandteile der Rechte. Wenn Sie die Rechte des Benutzers Abfragen, wird eine Regel mit <xref:System.Security.AccessControl.RegistryRights.ReadKey> rechten angezeigt. Wenn Sie Rechte entfernen <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> , werden auch die anderen Rechte Bestandteile der <xref:System.Security.AccessControl.RegistryRights.ReadKey> Rechte angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Registrierungs Zugriffsregeln erstellt und einem-Objekt <xref:System.Security.AccessControl.RegistrySecurity> hinzugefügt. Dadurch wird gezeigt, wie Regeln, die die Rechte zulassen und verweigern, getrennt bleiben, während kompatible Regeln derselben Art zusammengeführt werden.  
  
> [!NOTE]
>  In diesem Beispiel wird das Sicherheits Objekt nicht an ein <xref:Microsoft.Win32.RegistryKey> -Objekt angefügt. Beispiele zum Anfügen von Sicherheits Objekten finden Sie <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> unter <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>und.  
  
 Ein Codebeispiel, das Vererbungs-und Weitergabeflags veranschaulicht <xref:System.Security.AccessControl.RegistryAccessRule> , finden Sie in der-Klasse.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Die hinzuzufügende Überwachungsregel. Der von dieser Regel angegebene Benutzer bestimmt die Suche.</param>
        <summary>Sucht nach einer Überwachungsregel, mit der die neue Regel zusammengeführt werden kann. Wenn keine Regel gefunden wurde, wird die neue Regel hinzugefügt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> -Methode sucht nach Regeln mit dem gleichen Benutzer oder der `rule`gleichen Gruppe wie. Wenn keine gefunden werden, `rule` wird hinzugefügt. Wenn eine übereinstimmende Regel gefunden wird, werden `rule` die Flags in mit der vorhandenen Regel zusammengeführt.  
  
 Regeln können nicht zusammengeführt werden, wenn Sie unterschiedliche Vererbungs Flags aufweisen. Wenn z. b. fehlerhafte Versuche, in einen Schlüssel zu schreiben, für einen bestimmten Benutzer ohne Vererbungs Flags <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> überwacht werden, wird zum Hinzufügen einer Regel verwendet, um anzugeben, dass fehlgeschlagene Versuche, Berechtigungen zu ändern, für denselben Benutzer überwacht werden sollen, aber mit Vererbung für Unterschlüssel (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>), die beiden Regeln können nicht zusammengeführt werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="registrySecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">Eine <see cref="T:System.Security.Principal.IdentityReference" />, mit deren Hilfe der Benutzer oder die Gruppe angegeben wird, für den bzw. die die Regel gilt.</param>
        <param name="accessMask">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.RegistryRights" />-Werten, die die zu überwachenden Zugriffsrechte angibt (in eine ganze Zahl umgewandelt).</param>
        <param name="isInherited">Ein boolescher Wert, der angibt, ob die Regel geerbt ist.</param>
        <param name="inheritanceFlags">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.InheritanceFlags" />-Werten, die angibt, wie die Regel von Unterschlüsseln geerbt wird.</param>
        <param name="propagationFlags">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.PropagationFlags" />-Werten, die die Art der Vererbung der Regel für die Unterschlüssel ändert. Irrelevant, wenn der Wert von <paramref name="inheritanceFlags" /><see cref="F:System.Security.AccessControl.InheritanceFlags.None" /> ist.</param>
        <param name="flags">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.AuditFlags" />-Werten, die angibt, ob erfolgreiche Zugriffsversuche und/oder fehlgeschlagene Zugriffsversuche überwacht werden sollen.</param>
        <summary>Erstellt eine neue Überwachungsregel, die den Benutzer angibt, auf den diese Regel angewendet wird, sowie die zu überwachenden Zugriffsrechte, die Vererbung und Weitergabe der Regel und das Ergebnis, das die Überwachungsregel auslöst.</summary>
        <returns>Ein <see cref="T:System.Security.AccessControl.RegistryAuditRule" />-Objekt, das die angegebene Überwachungsregel für den angegebenen Benutzer mit den angegebenen Flags darstellt. Der Rückgabetyp der Methode entspricht der Basisklasse <see cref="T:System.Security.AccessControl.AuditRule" />, er kann jedoch problemlos in die abgeleitete Klasse umgewandelt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die empfohlene Vorgehensweise zum Erstellen von Überwachungsregeln ist die Verwendung der Konstruktoren <xref:System.Security.AccessControl.RegistryAuditRule> der-Klasse.  
  
> [!NOTE]
>  Obwohl Sie das <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> -Flag angeben können, gibt es keine Möglichkeit, dies zu tun. Zum Zweck der Überwachungs Steuerung sind die Name-Wert-Paare in einem Unterschlüssel keine separaten Objekte. Die Überwachungsrechte für Name/Wert-Paare werden durch die Rechte des unter Schlüssels gesteuert. Da alle Unterschlüssel Container sind (d. h., Sie können andere Unterschlüssel enthalten), wird das <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> -Flag nicht beeinträchtigt. Schließlich wird durch die <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> Angabe des Flags unnötig die Wartung von Regeln erschwert, da dies die normale Kombination von kompatiblen Regeln beeinträchtigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> oder <paramref name="flags" /> ist ein ungültiger Wert angegeben.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="identityReference" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="accessMask" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identityReference" /> ist weder vom Typ <see cref="T:System.Security.Principal.SecurityIdentifier" /> noch von einem Typ wie etwa <see cref="T:System.Security.Principal.NTAccount" />, der in den <see cref="T:System.Security.Principal.SecurityIdentifier" />-Typ konvertiert werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, mit dessen Hilfe die <see cref="T:System.Security.AccessControl.RegistrySecurity" />-Klasse Überwachungsregeln darstellt.</summary>
        <value>Ein <see cref="T:System.Type" />-Objekt, das die <see cref="T:System.Security.AccessControl.RegistryAuditRule" />-Klasse darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klassen, die von der <xref:System.Security.AccessControl.ObjectSecurity> -Klasse abgeleitet <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> werden, überschreiben die-Eigenschaft und geben den Typ zurück, den Sie zum Darstellen von Überwachungs rechten Wenn Sie mit Arrays oder Auflistungen arbeiten, die mehrere Typen von Sicherheits Objekten enthalten, verwenden Sie diese Eigenschaft, um den richtigen Überwachungs Regeltyp zu bestimmen, der für jedes Sicherheits Objekt verwendet werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As RegistryAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; bool" Usage="registrySecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Eine <see cref="T:System.Security.AccessControl.RegistryAccessRule" />, die den Benutzer und den <see cref="T:System.Security.AccessControl.AccessControlType" /> angibt, nach denen gesucht werden soll, sowie eine Reihe von Vererbungs- und Weitergabeflags, mit denen eine übereinstimmende Regel (falls vorhanden) kompatibel sein muss. Gibt die Rechte an, die aus der kompatiblen Regel entfernt werden sollen (falls vorhanden).</param>
        <summary>Sucht nach einer Zugriffssteuerungsregel mit demselben Benutzer und demselben <see cref="T:System.Security.AccessControl.AccessControlType" /> (gewähren oder verweigern) wie die angegebene Zugriffsregel sowie mit kompatiblen Vererbungs- und Weitergabeflags. Wenn eine solche Regel gefunden wird, werden die in der angegebenen Zugriffsregel enthaltenen Rechte daraus entfernt.</summary>
        <returns><see langword="true" />, wenn eine kompatible Regel gefunden wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Security.AccessControl.RegistrySecurity> wird nach einer Regel durchsucht, die denselben Benutzer und denselben <xref:System.Security.AccessControl.AccessControlType> Wert wie `rule`hat. Wenn keine solche Regel gefunden wird, wird keine Aktion durchgeführt, und die Methode `false`gibt zurück. Wenn übereinstimmende Regeln gefunden werden, werden deren Vererbungs-und Kompatibilitäts Flags auf Kompatibilität mit `rule`den in angegebenen Flags geprüft. Wenn keine kompatible Regel gefunden wird, wird keine Aktion durchgeführt, und die Methode `false`gibt zurück. Wenn eine Regel mit kompatiblen Flags gefunden wird, werden die in `rule` angegebenen Rechte aus der kompatiblen Regel entfernt, und die Methode gibt zurück. `true` Wenn `rule` Rechte angibt, die nicht in der kompatiblen Regel enthalten sind, wird in Bezug auf diese Rechte keine Aktion ausgeführt. Wenn alle Rechte aus der kompatiblen Regel entfernt werden, wird die gesamte Regel aus dem aktuellen <xref:System.Security.AccessControl.RegistrySecurity> -Objekt entfernt.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> die-Methode Rechte aus einer kompatiblen Regel entfernt und wie <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> die-Methode Rechte mit kompatiblen Regeln zusammenfasst.  
  
 Im Beispiel wird ein <xref:System.Security.AccessControl.RegistrySecurity> -Objekt erstellt, und es wird eine Regel hinzu <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> gefügt, die die aktuellen Benutzerrechte zulässt. Im Beispiel wird dann eine Regel erstellt, die dem <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>Benutzer die gleichen Vererbungs-und Weitergaberechte wie die erste Regel gewährt <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> und die-Methode verwendet, um diese <xref:System.Security.AccessControl.RegistrySecurity> neue Regel aus dem-Objekt zu entfernen. <xref:System.Security.AccessControl.RegistryRights.SetValue>ist ein Bestand von <xref:System.Security.AccessControl.RegistryRights.ReadKey>, sodass es aus der kompatiblen Regel entfernt wird. Die Regeln im <xref:System.Security.AccessControl.RegistrySecurity> -Objekt werden angezeigt und zeigen die verbleibenden bestand <xref:System.Security.AccessControl.RegistryRights.ReadKey>Teile von an.  
  
 Der Beispielcode ruft dann die <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> -Methode auf, <xref:System.Security.AccessControl.RegistryRights.SetValue> um das direkt mit der Regel im <xref:System.Security.AccessControl.RegistrySecurity> -Objekt zusammenzuführen.  
  
> [!NOTE]
>  In diesem Beispiel wird das Sicherheits Objekt nicht an ein <xref:Microsoft.Win32.RegistryKey> -Objekt angefügt. Das zweite Beispiel in diesem Abschnitt fügt ein Sicherheits Objekt an. führen Sie die Beispiele in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>aus <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleAll : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.RemoveAccessRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Eine <see cref="T:System.Security.AccessControl.RegistryAccessRule" />, die den Benutzer und den <see cref="T:System.Security.AccessControl.AccessControlType" /> angibt, nach denen gesucht werden soll. Alle in dieser Regel angegebenen Rechte, Vererbungsflags oder Weitergabeflags werden ignoriert.</param>
        <summary>Sucht nach allen Zugriffssteuerungsregeln mit demselben Benutzer und demselben <see cref="T:System.Security.AccessControl.AccessControlType" /> (gewähren oder verweigern) wie die angegebene Regel und entfernt diese (falls vorhanden).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Security.AccessControl.RegistrySecurity> wird nach Regeln gesucht, die denselben Benutzer und denselben <xref:System.Security.AccessControl.AccessControlType> Wert wie `rule`haben. Alle Rechte, Vererbungs Flags oder propagierungs Flags, `rule` die von angegeben werden, werden beim Ausführen dieser Suche ignoriert. Wenn keine übereinstimmenden Regeln gefunden werden, wird keine Aktion ausgeführt.  
  
 Wenn ein Benutzer beispielsweise über mehrere Regeln verfügt, die verschiedene Rechte mit unterschiedlichen Vererbungs-und Weitergabeflags zulassen, können Sie alle <xref:System.Security.AccessControl.RegistryAccessRule> diese Regeln entfernen, indem Sie <xref:System.Security.AccessControl.AccessControlType.Allow?displayProperty=nameWithType>ein-Objekt erstellen, das den Benutzer angibt, und mit beliebigen rechten und Flags. und übergeben diese Regel an die <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> -Methode.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, dass <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> die-Methode alle Regeln entfernt, die <xref:System.Security.AccessControl.AccessControlType>Benutzer und unterliegen, wobei Rechte und Flags ignoriert werden.  
  
 Im Beispiel wird ein <xref:System.Security.AccessControl.RegistrySecurity> -Objekt erstellt und Regeln hinzugefügt, die verschiedene Rechte für den aktuellen Benutzer mit unterschiedlichen Vererbungs-und Weitergabeflags zulassen und verweigern. Im Beispiel wird dann eine neue Regel erstellt, die es dem aktuellen Benutzer ermöglicht, den Besitz zu übernehmen, <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> und diese Regel an die-Methode übergibt, um die beiden Regeln zu entfernen, die den Zugriff erlauben.  
  
> [!NOTE]
>  In diesem Beispiel wird das Sicherheits Objekt nicht an ein <xref:Microsoft.Win32.RegistryKey> -Objekt angefügt. Siehe die <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> -Methode und <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> die-Methode.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleSpecific : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Das zu entfernende <see cref="T:System.Security.AccessControl.RegistryAccessRule" />-Element.</param>
        <summary>Sucht nach einer Zugriffssteuerungsregel, die genau mit der angegebenen Regel übereinstimmt, und entfernt diese (falls vorhanden).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Regel wird nur entfernt, wenn Sie in `rule` allen Details genau übereinstimmt, einschließlich Flags. Andere Regeln mit demselben Benutzer und <xref:System.Security.AccessControl.AccessControlType> sind nicht betroffen.  
  
> [!IMPORTANT]
>  Eine Regel stellt einen oder mehrere zugrunde liegende Zugriffs Steuerungs Einträge (Access Control Entries, ACE) dar, und diese Einträge werden nach Bedarf aufgeteilt oder kombiniert, wenn Sie die Zugriffs Sicherheitsregeln für einen Benutzer ändern. Folglich ist eine Regel möglicherweise nicht mehr in der spezifischen Form vorhanden, die Sie beim Hinzufügen hatte, und in diesem <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> Fall kann Sie von der Methode nicht entfernt werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, dass <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> die-Methode eine Regel nur dann entfernt, wenn Sie genau übereinstimmt.  
  
 Im Beispiel werden zwei Regeln erstellt, die unterschiedliche Rechte zulassen. Die Regeln verfügen über kompatible Vererbungs-und Weitergabeflags. wenn die zweite Regel hinzugefügt wird, wird Sie mit der ersten zusammengeführt. Das Beispiel ruft die <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> -Methode auf und gibt die erste Regel an, aber da die Regeln zusammengeführt werden, gibt es keine Regel, die mit übereinstimmt. Im Beispiel wird dann die <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> -Methode aufgerufen, um die zweite Regel aus der zusammengeführten Regel zu entfernen, <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> und schließlich wird die-Methode aufgerufen, um die erste Regel zu entfernen.  
  
> [!NOTE]
>  In diesem Beispiel wird das Sicherheits Objekt nicht an ein <xref:Microsoft.Win32.RegistryKey> -Objekt angefügt. Siehe die <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> -Methode und <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> die-Methode.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As RegistryAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; bool" Usage="registrySecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Eine <see cref="T:System.Security.AccessControl.RegistryAuditRule" />, die den zu suchenden Benutzer angibt, sowie eine Reihe von Vererbungs- und Weitergabeflags, mit denen eine übereinstimmende Regel (falls vorhanden) kompatibel sein muss. Gibt die Rechte an, die aus der kompatiblen Regel entfernt werden sollen (falls vorhanden).</param>
        <summary>Sucht nach einer Überwachungssteuerungsregel mit demselben Benutzer wie die angegebene Regel und mit kompatiblen Vererbungs- und Weitergabeflags; wenn eine solche Regel gefunden wird, werden die in der angegebenen Regel enthaltenen Rechte daraus entfernt.</summary>
        <returns><see langword="true" />, wenn eine kompatible Regel gefunden wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Security.AccessControl.RegistrySecurity> wird nach einer Überwachungs Regel durchsucht, die denselben Benutzer wie `rule`hat. Wenn keine solche Regel gefunden wird, wird keine Aktion durchgeführt, und die Methode `false`gibt zurück. Wenn übereinstimmende Regeln gefunden werden, werden deren Vererbungs-und Kompatibilitäts Flags auf Kompatibilität mit `rule`den in angegebenen Flags geprüft. Wenn keine kompatible Regel gefunden wird, wird keine Aktion durchgeführt, und die Methode `false`gibt zurück. Wenn eine Regel mit kompatiblen Flags gefunden wird, werden die in `rule` angegebenen Rechte aus der kompatiblen Regel entfernt, und die Methode gibt zurück. `true` Wenn `rule` Rechte angibt, die nicht in der kompatiblen Regel enthalten sind, wird in Bezug auf diese Rechte keine Aktion ausgeführt. Wenn alle Rechte aus der kompatiblen Regel entfernt werden, wird die gesamte Regel aus dem aktuellen <xref:System.Security.AccessControl.RegistrySecurity> -Objekt entfernt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleAll : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Eine <see cref="T:System.Security.AccessControl.RegistryAuditRule" />, die den zu suchenden Benutzer angibt. Alle in dieser Regel angegebenen Rechte, Vererbungsflags oder Weitergabeflags werden ignoriert.</param>
        <summary>Sucht alle Überwachungsregeln, die denselben Benutzer wie die angegebene Regel aufweisen, und entfernt sie, sofern sie gefunden wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Security.AccessControl.RegistrySecurity> wird nach Überwachungsregeln durchsucht, die denselben Benutzer wie `rule`haben. Alle Rechte, Vererbungs Flags oder propagierungs Flags, `rule` die von angegeben werden, werden beim Ausführen dieser Suche ignoriert. Wenn keine übereinstimmenden Regeln gefunden werden, wird keine Aktion ausgeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleSpecific : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Die <see cref="T:System.Security.AccessControl.RegistryAuditRule" />, die entfernt werden soll.</param>
        <summary>Sucht nach einer Überwachungsregel, die genau mit der angegebenen Regel übereinstimmt, und entfernt diese (falls vorhanden).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Regel wird nur entfernt, wenn Sie in `rule` allen Details genau übereinstimmt, einschließlich Flags. Andere Überwachungsregeln für denselben Benutzer sind nicht betroffen.  
  
> [!IMPORTANT]
>  Eine Regel stellt einen oder mehrere zugrunde liegende Zugriffs Steuerungs Einträge (Access Control Entries, ACE) dar, und diese Einträge werden nach Bedarf aufgeteilt oder kombiniert, wenn Sie die Überwachungs Sicherheitsregeln für einen Benutzer ändern. Folglich ist eine Regel möglicherweise nicht mehr in der spezifischen Form vorhanden, die Sie beim Hinzufügen hatte, und in diesem <xref:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific%2A> Fall kann Sie von der Methode nicht entfernt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.ResetAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Das hinzuzufügende <see cref="T:System.Security.AccessControl.RegistryAccessRule" />. Der von dieser Regel angegebene Benutzer bestimmt die Regeln, die vor dem Hinzufügen dieser Regel entfernt werden sollen.</param>
        <summary>Entfernt alle Zugriffssteuerungsregeln mit demselben Benutzer wie in der angegebenen Regel, unabhängig von <see cref="T:System.Security.AccessControl.AccessControlType" />, und fügt anschließend die angegebene Regel hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine Zugriffsregeln vorhanden sind, deren Benutzer der angegebenen Regel entsprechen `rule` , wird hinzugefügt.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> die-Methode alle Regeln für den übereinstimmenden Benutzer durch die für die Übereinstimmung angegebene Regel ersetzt.  
  
 Im Beispiel wird ein <xref:System.Security.AccessControl.RegistrySecurity> -Objekt erstellt und Regeln hinzugefügt, die verschiedene Rechte für den aktuellen Benutzer mit unterschiedlichen Vererbungs-und Weitergabeflags zulassen und verweigern. Im Beispiel wird dann eine neue Regel erstellt, die es dem aktuellen Benutzer gestattet, den Schlüssel zu lesen, <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> und die-Methode verwendet, um alle Regeln für den Benutzer zu entfernen und Sie durch die neue Regel zu ersetzen.  
  
> [!NOTE]
>  In diesem Beispiel wird das Sicherheits Objekt nicht an ein <xref:Microsoft.Win32.RegistryKey> -Objekt angefügt. Siehe die <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> -Methode und <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> die-Methode.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Das hinzuzufügende <see cref="T:System.Security.AccessControl.RegistryAccessRule" />. Der Benutzer und der <see cref="T:System.Security.AccessControl.AccessControlType" /> dieser Regel bestimmen die Regeln, die vor dem Hinzufügen dieser Regel entfernt werden sollen.</param>
        <summary>Entfernt alle Zugriffssteuerungsregeln mit demselben Benutzer und demselben <see cref="T:System.Security.AccessControl.AccessControlType" /> (gewähren oder verweigern) wie die angegebene Regel und fügt anschließend die angegebene Regel hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die angegebene Regel <xref:System.Security.AccessControl.AccessControlType.Allow>ist, besteht die Auswirkung dieser Methode darauf, alle <xref:System.Security.AccessControl.AccessControlType.Allow> Regeln für den angegebenen Benutzer zu entfernen und Sie durch die angegebene Regel zu ersetzen. Wenn die angegebene Regel aufweist <xref:System.Security.AccessControl.AccessControlType.Deny>, werden <xref:System.Security.AccessControl.AccessControlType.Deny> alle Regeln für den angegebenen Benutzer durch die angegebene Regel ersetzt.  
  
 Wenn keine Regeln vorhanden sind, deren Benutzer <xref:System.Security.AccessControl.AccessControlType> der angegebenen Regel entsprechen, `rule` wird hinzugefügt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> dass die-Methode alle Regeln entfernt, die sowohl dem <xref:System.Security.AccessControl.AccessControlType> Benutzer `rule`als auch der von entsprechen. dabei werden die Rechte `rule`und Flags ignoriert und durch ersetzt.  
  
 Im Beispiel wird ein <xref:System.Security.AccessControl.RegistrySecurity> -Objekt erstellt und Regeln hinzugefügt, die verschiedene Rechte für den aktuellen Benutzer mit unterschiedlichen Vererbungs-und Weitergabeflags zulassen und verweigern. Im Beispiel wird dann eine neue Regel erstellt, die es dem aktuellen Benutzer gestattet, den Schlüssel zu lesen, <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> und die-Methode verwendet, um die beiden Regeln zu entfernen, die den Zugriff erlauben, und diese durch die neue Regel zu ersetzen. Die Regel, die den Zugriff verweigert, ist nicht betroffen.  
  
> [!NOTE]
>  In diesem Beispiel wird das Sicherheits Objekt nicht an ein <xref:Microsoft.Win32.RegistryKey> -Objekt angefügt. Siehe die <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> -Methode und <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> die-Methode.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Das hinzuzufügende <see cref="T:System.Security.AccessControl.RegistryAuditRule" />. Der von dieser Regel angegebene Benutzer bestimmt die Regeln, die vor dem Hinzufügen dieser Regel entfernt werden sollen.</param>
        <summary>Entfernt alle Überwachungsregeln mit demselben Benutzer wie in der angegebenen Regel, unabhängig vom <see cref="T:System.Security.AccessControl.AuditFlags" />-Wert, und fügt danach die angegebene Regel hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine Überwachungsregeln vorhanden sind, deren Benutzer der angegebenen Regel entsprechen `rule` , wird hinzugefügt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
