<Type Name="RegistryAccessRule" FullName="System.Security.AccessControl.RegistryAccessRule">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4a8e468f28367bb3c624af10f77dff896707100d" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86582044" /></Metadata><TypeSignature Language="C#" Value="public sealed class RegistryAccessRule : System.Security.AccessControl.AccessRule" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RegistryAccessRule extends System.Security.AccessControl.AccessRule" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.RegistryAccessRule" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistryAccessRule&#xA;Inherits AccessRule" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistryAccessRule sealed : System::Security::AccessControl::AccessRule" />
  <TypeSignature Language="F#" Value="type RegistryAccessRule = class&#xA;    inherit AccessRule" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>4.1.3.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="Microsoft.Win32.Registry.AccessControl" FromVersion="4.0.3.0" To="Microsoft.Win32.Registry" ToVersion="4.1.1.0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2" />
    <TypeForwarding From="Microsoft.Win32.Registry.AccessControl" FromVersion="4.0.4.0" To="Microsoft.Win32.Registry" ToVersion="4.1.2.0" FrameworkAlternate="dotnet-plat-ext-3.0;net-5.0;netcore-3.0" />
    <TypeForwarding From="Microsoft.Win32.Registry.AccessControl" FromVersion="4.0.5.0" To="Microsoft.Win32.Registry" ToVersion="4.1.3.0" FrameworkAlternate="dotnet-plat-ext-3.1;netcore-3.1" />
    <TypeForwarding From="Microsoft.Win32.Registry.AccessControl" FromVersion="5.0.0.0" To="Microsoft.Win32.Registry" ToVersion="5.0.0.0" FrameworkAlternate="dotnet-plat-ext-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Security.AccessControl.AccessRule</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Gruppe von Zugriffsrechten dar, die einem Benutzer oder einer Gruppe gewährt oder verweigert werden. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der- <xref:System.Security.AccessControl.RegistryAccessRule> Klasse handelt es sich um einen Satz von Klassen, die der .NET Framework für die Verwaltung der Windows-Zugriffs Steuerungs Sicherheit für Registrierungsschlüssel bereitstellt. Eine Übersicht über diese Klassen und deren Beziehung zu den zugrunde liegenden Windows-Zugriffs Steuerungsstrukturen finden Sie unter <xref:System.Security.AccessControl.RegistrySecurity> .  
  
> [!NOTE]
>  Die Windows-Zugriffs Steuerungs Sicherheit kann nur auf Registrierungsschlüssel angewendet werden. Sie kann nicht auf einzelne Schlüssel-Wert-Paare angewendet werden, die in einem Schlüssel gespeichert sind.  
  
 Zum Abrufen einer Liste der zurzeit auf einen Registrierungsschlüssel angewendeten Regeln verwenden Sie die <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> -Methode, um ein <xref:System.Security.AccessControl.RegistrySecurity> -Objekt abzurufen, und verwenden Sie dann die- <xref:System.Security.AccessControl.CommonObjectSecurity.GetAccessRules%2A> Methode, um eine Auflistung von- <xref:System.Security.AccessControl.RegistryAccessRule> Objekten abzurufen.  
  
 <xref:System.Security.AccessControl.RegistryAccessRule> -Objekte ordnen keine eins-zu-eins-Elemente mit Zugriffs Steuerungs Einträgen in der zugrunde liegenden DACL (diskretioncontrol Access List) zu. Wenn Sie den Satz aller Zugriffsregeln für einen Registrierungsschlüssel erhalten, enthält die Gruppe die Mindestanzahl von Regeln, die derzeit zum Ausdrücken aller Zugriffs Steuerungs Einträge erforderlich sind.  
  
> [!NOTE]
>  Die zugrunde liegenden Zugriffs Steuerungs Einträge ändern sich, wenn Sie Regeln anwenden und entfernen. Die Informationen in den Regeln werden nach Möglichkeit zusammengeführt, um die kleinste Anzahl von Zugriffs Steuerungs Einträgen beizubehalten. Wenn Sie also die aktuelle Liste der Regeln lesen, sieht Sie möglicherweise nicht genau wie die Liste aller von Ihnen hinzugefügten Regeln aus.  
  
 Verwenden <xref:System.Security.AccessControl.RegistryAccessRule> Sie-Objekte, um die Zugriffsrechte anzugeben, die einem Benutzer oder einer Gruppe gestattet oder verweigert werden. Ein- <xref:System.Security.AccessControl.RegistryAccessRule> Objekt stellt immer entweder den zulässigen Zugriff oder verweigerten Zugriff dar, nie beides.  
  
 Zum Anwenden einer Regel auf einen Registrierungsschlüssel verwenden Sie die- <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> Methode, um das-Objekt zu erhalten <xref:System.Security.AccessControl.RegistrySecurity> . Ändern Sie das <xref:System.Security.AccessControl.RegistrySecurity> Objekt, indem Sie die zugehörigen Methoden zum Hinzufügen der Regel verwenden, und verwenden Sie dann die- <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> Methode, um das Sicherheits Objekt erneut anzufügen.  
  
> [!IMPORTANT]
>  Änderungen, die Sie an einem-Objekt vornehmen, <xref:System.Security.AccessControl.RegistrySecurity> wirken sich nicht auf die Zugriffsebenen des Registrierungsschlüssels aus, bis Sie die- <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> Methode aufrufen, um das geänderte Sicherheits Objekt dem Registrierungsschlüssel zuzuweisen.  
  
 <xref:System.Security.AccessControl.RegistryAccessRule> Objekte sind unveränderlich. Die Sicherheit für einen Registrierungsschlüssel wird mithilfe der Methoden der- <xref:System.Security.AccessControl.RegistrySecurity> Klasse geändert, um Regeln hinzuzufügen oder zu entfernen. in diesem Fall werden die zugrunde liegenden Zugriffs Steuerungs Einträge geändert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Zugriffsregeln mit Vererbung und Propagierung veranschaulicht. Im Beispiel wird ein- <xref:System.Security.AccessControl.RegistrySecurity> Objekt erstellt, dann werden zwei Regeln erstellt und hinzugefügt, die über das- <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> Flag verfügen. Die erste Regel weist keine Weitergabeflags auf, während die zweite Regel über <xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit> und verfügt <xref:System.Security.AccessControl.PropagationFlags.InheritOnly> .  
  
 Das Programm zeigt die Regeln im <xref:System.Security.AccessControl.RegistrySecurity> -Objekt an und verwendet dann das-Objekt, um einen Unterschlüssel zu erstellen. Das Programm erstellt einen untergeordneten Unterschlüssel und einen untergeordneten Unterschlüssel mit zwei untergeordneten Schlüsseln und zeigt dann die Sicherheit für jeden Unterschlüssel an. Schließlich löscht das Programm die Testschlüssel.  
  
 [!code-csharp[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.AccessControl.RegistryAccessRule" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistryAccessRule (System.Security.Principal.IdentityReference identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Principal.IdentityReference identity, valuetype System.Security.AccessControl.RegistryRights registryRights, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (identity As IdentityReference, registryRights As RegistryRights, type As AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistryAccessRule(System::Security::Principal::IdentityReference ^ identity, System::Security::AccessControl::RegistryRights registryRights, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="new System.Security.AccessControl.RegistryAccessRule : System.Security.Principal.IdentityReference * System.Security.AccessControl.RegistryRights * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.RegistryAccessRule" Usage="new System.Security.AccessControl.RegistryAccessRule (identity, registryRights, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="identity" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="registryRights" Type="System.Security.AccessControl.RegistryRights" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identity">Der Benutzer oder die Gruppe, für den bzw. die die Regel gilt. Muss vom Typ <see cref="T:System.Security.Principal.SecurityIdentifier" /> oder einem Typ wie etwa<see cref="T:System.Security.Principal.NTAccount" /> sein, der in den <see cref="T:System.Security.Principal.SecurityIdentifier" />-Typ konvertiert werden kann.</param>
        <param name="registryRights">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.RegistryRights" />-Werten, die die gewährten oder verweigerten Rechte angibt.</param>
        <param name="type">Einer der <see cref="T:System.Security.AccessControl.AccessControlType" />-Werte, der angibt, ob die Rechte gewährt oder verweigert werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.AccessControl.RegistryAccessRule" />-Klasse und gibt den Benutzer oder die Gruppe an, für den bzw. die die Regel gilt. Außerdem werden die Zugriffsrechte angegeben und ob diese gewährt oder verweigert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor gibt die Standard Propagierung und-Vererbung an. Das heißt, <xref:System.Security.AccessControl.InheritanceFlags.None?displayProperty=nameWithType> und <xref:System.Security.AccessControl.PropagationFlags.None?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="registryRights" /> gibt einen ungültigen Wert an.  
  
- oder - 
 <paramref name="type" /> gibt einen ungültigen Wert an.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="identity" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="eventRights" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identity" /> ist weder vom Typ <see cref="T:System.Security.Principal.SecurityIdentifier" /> noch von einem Typ wie etwa <see cref="T:System.Security.Principal.NTAccount" />, der in den Typ <see cref="T:System.Security.Principal.SecurityIdentifier" /> konvertiert werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistryAccessRule (string identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string identity, valuetype System.Security.AccessControl.RegistryRights registryRights, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (identity As String, registryRights As RegistryRights, type As AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistryAccessRule(System::String ^ identity, System::Security::AccessControl::RegistryRights registryRights, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="new System.Security.AccessControl.RegistryAccessRule : string * System.Security.AccessControl.RegistryRights * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.RegistryAccessRule" Usage="new System.Security.AccessControl.RegistryAccessRule (identity, registryRights, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="identity" Type="System.String" />
        <Parameter Name="registryRights" Type="System.Security.AccessControl.RegistryRights" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identity">Der Name des Benutzers oder der Gruppe, für den bzw. die die Regel gilt.</param>
        <param name="registryRights">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.RegistryRights" />-Werten, die die gewährten oder verweigerten Rechte angibt.</param>
        <param name="type">Einer der <see cref="T:System.Security.AccessControl.AccessControlType" />-Werte, der angibt, ob die Rechte gewährt oder verweigert werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.AccessControl.RegistryAccessRule" />-Klasse und gibt den Namen des Benutzers oder der Gruppe an, für den bzw. die die Regel gilt. Außerdem werden die Zugriffsrechte angegeben und ob diese gewährt oder verweigert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor gibt die Standard Propagierung und-Vererbung an. Das heißt, <xref:System.Security.AccessControl.InheritanceFlags.None?displayProperty=nameWithType> und <xref:System.Security.AccessControl.PropagationFlags.None?displayProperty=nameWithType> .  
  
 Dieser Konstruktor entspricht dem Erstellen eines <xref:System.Security.Principal.NTAccount> -Objekts, indem `identity` an den <xref:System.Security.Principal.NTAccount.%23ctor%28System.String%29?displayProperty=nameWithType> -Konstruktor übergeben und das neu erstellte- <xref:System.Security.Principal.NTAccount> Objekt an den- <xref:System.Security.AccessControl.RegistryAccessRule.%23ctor%28System.Security.Principal.IdentityReference%2CSystem.Security.AccessControl.RegistryRights%2CSystem.Security.AccessControl.AccessControlType%29> Konstruktor übergeben wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Registrierungs Zugriffsregeln erstellt und einem-Objekt hinzugefügt <xref:System.Security.AccessControl.RegistrySecurity> . Dadurch wird gezeigt, wie Regeln, die die Rechte zulassen und verweigern, getrennt bleiben, während kompatible Regeln derselben Art zusammengeführt werden.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="registryRights" /> gibt einen ungültigen Wert an.  
  
- oder - 
 <paramref name="type" /> gibt einen ungültigen Wert an.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="registryRights" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identity" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="identity" /> ist eine Zeichenfolge der Länge 0 (null).  
  
- oder - 
 <paramref name="identity" /> ist länger als 512 Zeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistryAccessRule (System.Security.Principal.IdentityReference identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Principal.IdentityReference identity, valuetype System.Security.AccessControl.RegistryRights registryRights, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (identity As IdentityReference, registryRights As RegistryRights, inheritanceFlags As InheritanceFlags, propagationFlags As PropagationFlags, type As AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistryAccessRule(System::Security::Principal::IdentityReference ^ identity, System::Security::AccessControl::RegistryRights registryRights, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="new System.Security.AccessControl.RegistryAccessRule : System.Security.Principal.IdentityReference * System.Security.AccessControl.RegistryRights * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.RegistryAccessRule" Usage="new System.Security.AccessControl.RegistryAccessRule (identity, registryRights, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="identity" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="registryRights" Type="System.Security.AccessControl.RegistryRights" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identity">Der Benutzer oder die Gruppe, für den bzw. die die Regel gilt. Muss vom Typ <see cref="T:System.Security.Principal.SecurityIdentifier" /> oder einem Typ wie etwa<see cref="T:System.Security.Principal.NTAccount" /> sein, der in den <see cref="T:System.Security.Principal.SecurityIdentifier" />-Typ konvertiert werden kann.</param>
        <param name="registryRights">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.RegistryRights" />-Werten, mit denen angegeben wird, ob die Rechte gewährt oder verweigert werden.</param>
        <param name="inheritanceFlags">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.InheritanceFlags" />-Flags, die angibt, auf welche Weise Zugriffsrechte von anderen Objekten geerbt werden.</param>
        <param name="propagationFlags">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.PropagationFlags" />-Flags, die angibt, wie Zugriffsrechte an andere Objekte weitergegeben werden.</param>
        <param name="type">Einer der <see cref="T:System.Security.AccessControl.AccessControlType" />-Werte, mit denen angegeben wird, ob die Rechte gewährt oder verweigert werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.AccessControl.RegistryAccessRule" />-Klasse und gibt den Benutzer oder die Gruppe an, für den bzw. die die Regel gilt, sowie die Zugriffsrechte, die Vererbungsflags und die Weitergabeflags. Außerdem wird angegeben, ob die angegebenen Zugriffsrechte gewährt oder verweigert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Registrierungsschlüssel sind Container, sodass das einzige Vererbungs Flag, das für Registrierungsschlüssel sinnvoll ist, das- <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType> Flag ist. Wenn dieses Flag nicht angegeben wird, werden die Weitergabeflags ignoriert, und nur die unmittelbare Taste ist betroffen. Wenn das-Flag vorhanden ist, wird die Regel weitergegeben, wie in der folgenden Tabelle dargestellt. In der Tabelle wird davon ausgegangen, dass es sich um untergeordnete Unterschlüssel und untergeordnete Unterschlüssel-GS handelt. Das heißt, der Pfad für den Unterschlüssel für den untergeordneten untergeordneten Schlüssel lautet S\CS\GS.  
  
|Propagierungs Flags|E|CS|GS|  
|-----------------------|-------|--------|--------|  
|<xref:System.Security.AccessControl.PropagationFlags.None>|X|X|X|  
|<xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit>|X|X||  
|<xref:System.Security.AccessControl.PropagationFlags.InheritOnly>||X|X|  
|<xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit>, <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>||X||  
  
 Das Muster für den Unterschlüssel für den zweiten untergeordneten Schlüssel regelt alle Unterschlüssel, die im Unterschlüssel für den untergeordneten untergeordneten Schlüssel  
  
 Wenn z. b. das <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> -Flag für angegeben ist `inheritanceFlags` und das <xref:System.Security.AccessControl.PropagationFlags.InheritOnly> propagierungs Kennzeichen für angegeben ist `propagationFlags` , gilt diese Regel nicht für den unmittelbaren Unterschlüssel, sondern für alle unmittelbaren untergeordneten Unterschlüssel und für alle darin enthaltenen Unterschlüssel.  
  
> [!NOTE]
>  Obwohl Sie das- <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> Flag für angeben können `inheritanceFlags` , gibt es keine Möglichkeit, dies zu tun. Für den Zweck der Zugriffs Steuerung sind die Name-Wert-Paare in einem Unterschlüssel keine separaten Objekte. Die Zugriffsrechte für Name/Wert-Paare werden durch die Rechte des unter Schlüssels gesteuert. Da alle Unterschlüssel Container sind (d. h., Sie können andere Unterschlüssel enthalten), wird das-Flag nicht beeinträchtigt <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> . Schließlich wird durch die Angabe des <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> Flags unnötig die Wartung von Regeln erschwert, da dies die Kombination von anderweitig kompatiblen Regeln beeinträchtigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="registryRights" /> gibt einen ungültigen Wert an.  
  
- oder - 
 <paramref name="type" /> gibt einen ungültigen Wert an.  
  
- oder - 
 <paramref name="inheritanceFlags" /> gibt einen ungültigen Wert an.  
  
- oder - 
 <paramref name="propagationFlags" /> gibt einen ungültigen Wert an.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="identity" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="registryRights" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identity" /> ist weder vom Typ <see cref="T:System.Security.Principal.SecurityIdentifier" /> noch von einem Typ wie etwa <see cref="T:System.Security.Principal.NTAccount" />, der in den <see cref="T:System.Security.Principal.SecurityIdentifier" />-Typ konvertiert werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistryAccessRule (string identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string identity, valuetype System.Security.AccessControl.RegistryRights registryRights, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (identity As String, registryRights As RegistryRights, inheritanceFlags As InheritanceFlags, propagationFlags As PropagationFlags, type As AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistryAccessRule(System::String ^ identity, System::Security::AccessControl::RegistryRights registryRights, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="new System.Security.AccessControl.RegistryAccessRule : string * System.Security.AccessControl.RegistryRights * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.RegistryAccessRule" Usage="new System.Security.AccessControl.RegistryAccessRule (identity, registryRights, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="identity" Type="System.String" />
        <Parameter Name="registryRights" Type="System.Security.AccessControl.RegistryRights" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identity">Der Name des Benutzers oder der Gruppe, für den bzw. die die Regel gilt.</param>
        <param name="registryRights">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.RegistryRights" />-Werten, die die gewährten oder verweigerten Rechte angibt.</param>
        <param name="inheritanceFlags">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.InheritanceFlags" />-Flags, die angibt, auf welche Weise Zugriffsrechte von anderen Objekten geerbt werden.</param>
        <param name="propagationFlags">Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.PropagationFlags" />-Flags, die angibt, wie Zugriffsrechte an andere Objekte weitergegeben werden.</param>
        <param name="type">Einer der <see cref="T:System.Security.AccessControl.AccessControlType" />-Werte, mit denen angegeben wird, ob die Rechte gewährt oder verweigert werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.AccessControl.RegistryAccessRule" />-Klasse und gibt den Namen des Benutzers oder der Gruppe an, für den bzw. die die Regel gilt, sowie die Zugriffsrechte, die Vererbungsflags und die Weitergabeflags. Außerdem wird angegeben, ob die angegebenen Zugriffsrechte gewährt oder verweigert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Registrierungsschlüssel sind Container, sodass das einzige Vererbungs Flag, das für Registrierungsschlüssel sinnvoll ist, das- <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType> Flag ist. Wenn dieses Flag nicht angegeben wird, werden die Weitergabeflags ignoriert, und nur die unmittelbare Taste ist betroffen. Wenn das-Flag vorhanden ist, wird die Regel weitergegeben, wie in der folgenden Tabelle dargestellt. In der Tabelle wird davon ausgegangen, dass es sich um untergeordnete Unterschlüssel und untergeordnete Unterschlüssel-GS handelt. Das heißt, der Pfad für den Unterschlüssel für den untergeordneten untergeordneten Schlüssel lautet S\CS\GS.  
  
|Propagierungs Flags|E|CS|GS|  
|-----------------------|-------|--------|--------|  
|<xref:System.Security.AccessControl.PropagationFlags.None>|X|X|X|  
|<xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit>|X|X||  
|<xref:System.Security.AccessControl.PropagationFlags.InheritOnly>||X|X|  
|<xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit>, <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>||X||  
  
 Das Muster für den Unterschlüssel für den zweiten untergeordneten Schlüssel regelt alle Unterschlüssel, die im Unterschlüssel für den untergeordneten untergeordneten Schlüssel  
  
 Wenn z. b. das <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> -Flag für angegeben ist `inheritanceFlags` und das <xref:System.Security.AccessControl.PropagationFlags.InheritOnly> propagierungs Kennzeichen für angegeben ist `propagationFlags` , gilt diese Regel nicht für den unmittelbaren Unterschlüssel, sondern für alle unmittelbaren untergeordneten Unterschlüssel und für alle darin enthaltenen Unterschlüssel.  
  
> [!NOTE]
>  Obwohl Sie das- <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> Flag für angeben können `inheritanceFlags` , gibt es keine Möglichkeit, dies zu tun. Für den Zweck der Zugriffs Steuerung sind die Name-Wert-Paare in einem Unterschlüssel keine separaten Objekte. Die Zugriffsrechte für Name/Wert-Paare werden durch die Rechte des unter Schlüssels gesteuert. Da alle Unterschlüssel Container sind (d. h., Sie können andere Unterschlüssel enthalten), wird das-Flag nicht beeinträchtigt <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> . Schließlich wird durch die Angabe des <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> Flags unnötig die Wartung von Regeln erschwert, da dies die Kombination von anderweitig kompatiblen Regeln beeinträchtigt.  
  
 Dieser Konstruktor entspricht dem Erstellen eines <xref:System.Security.Principal.NTAccount> -Objekts, indem `identity` an den <xref:System.Security.Principal.NTAccount.%23ctor%28System.String%29?displayProperty=nameWithType> -Konstruktor übergeben und das neu erstellte- <xref:System.Security.Principal.NTAccount> Objekt an den- <xref:System.Security.AccessControl.RegistryAccessRule.%23ctor%28System.Security.Principal.IdentityReference%2CSystem.Security.AccessControl.RegistryRights%2CSystem.Security.AccessControl.InheritanceFlags%2CSystem.Security.AccessControl.PropagationFlags%2CSystem.Security.AccessControl.AccessControlType%29> Konstruktor übergeben wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Zugriffsregeln mit Vererbung und Propagierung veranschaulicht. Im Beispiel wird ein <xref:System.Security.AccessControl.RegistrySecurity> -Objekt erstellt, und anschließend werden zwei Regeln erstellt und hinzugefügt, die über das- <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> Flag verfügen. Die erste Regel weist keine Weitergabeflags auf, während die zweite Regel über <xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit> und verfügt <xref:System.Security.AccessControl.PropagationFlags.InheritOnly> .  
  
 Das Programm zeigt die Regeln im <xref:System.Security.AccessControl.RegistrySecurity> -Objekt an und verwendet dann das- <xref:System.Security.AccessControl.RegistrySecurity> Objekt, um einen Unterschlüssel zu erstellen. Das Programm erstellt einen untergeordneten Unterschlüssel und einen untergeordneten Unterschlüssel mit zwei untergeordneten Schlüsseln und zeigt dann die Regeln für jeden Unterschlüssel an. Schließlich löscht das Programm die Testschlüssel.  
  
 [!code-csharp[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="registryRights" /> gibt einen ungültigen Wert an.  
  
- oder - 
 <paramref name="type" /> gibt einen ungültigen Wert an.  
  
- oder - 
 <paramref name="inheritanceFlags" /> gibt einen ungültigen Wert an.  
  
- oder - 
 <paramref name="propagationFlags" /> gibt einen ungültigen Wert an.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="eventRights" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identity" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="identity" /> ist eine Zeichenfolge der Länge 0 (null).  
  
- oder - 
 <paramref name="identity" /> ist länger als 512 Zeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegistryRights">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistryRights RegistryRights { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.AccessControl.RegistryRights RegistryRights" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistryAccessRule.RegistryRights" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RegistryRights As RegistryRights" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::AccessControl::RegistryRights RegistryRights { System::Security::AccessControl::RegistryRights get(); };" />
      <MemberSignature Language="F#" Value="member this.RegistryRights : System.Security.AccessControl.RegistryRights" Usage="System.Security.AccessControl.RegistryAccessRule.RegistryRights" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistryRights</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die von der Zugriffsregel gewährten oder verweigerten Rechte ab.</summary>
        <value>Eine bitweise Kombination von <see cref="T:System.Security.AccessControl.RegistryRights" />-Werten, mit denen die in der Zugriffsregel gewährten oder verweigerten Rechte angegeben werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AccessControl.RegistryAccessRule> Objekte sind unveränderlich. Sie können eine neue Zugriffs Regel erstellen, die einen anderen Benutzer, andere Rechte oder ein anderes darstellt <xref:System.Security.AccessControl.AccessControlType> , aber Sie können eine vorhandene Zugriffs Regel nicht ändern.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
