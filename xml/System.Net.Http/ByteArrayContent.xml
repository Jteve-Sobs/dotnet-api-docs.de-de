<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ByteArrayContent.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5d06b98425feeb50a3962c2d861064a3e184394fc.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d06b98425feeb50a3962c2d861064a3e184394fc</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Net.Http.ByteArrayContent">
          <source>Provides HTTP content based on a byte array.</source>
          <target state="translated">Stellt HTTP-Inhalt auf der Grundlage eines Bytearrays bereit.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Net.Http.ByteArrayContent">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Http.ByteArrayContent" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Net.Http.ByteArrayContent" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[])">
          <source>The content used to initialize the <ph id="ph1">&lt;see cref="T:System.Net.Http.ByteArrayContent" /&gt;</ph>.</source>
          <target state="translated">Der Inhalt, der zum Initialisieren der <ph id="ph1">&lt;see cref="T:System.Net.Http.ByteArrayContent" /&gt;</ph> verwendet wird.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Http.ByteArrayContent" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Net.Http.ByteArrayContent" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[])">
          <source>The <ph id="ph1">&lt;paramref name="content" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="content" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The content used to initialize the <ph id="ph1">&lt;see cref="T:System.Net.Http.ByteArrayContent" /&gt;</ph>.</source>
          <target state="translated">Der Inhalt, der zum Initialisieren der <ph id="ph1">&lt;see cref="T:System.Net.Http.ByteArrayContent" /&gt;</ph> verwendet wird.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The offset, in bytes, in the <bpt id="p1">&lt;c&gt;</bpt>content<ept id="p1">&lt;/c&gt;</ept> parameter used to initialize the <ph id="ph1">&lt;see cref="T:System.Net.Http.ByteArrayContent" /&gt;</ph>.</source>
          <target state="translated">Der Offset in Bytes im <bpt id="p1">&lt;c&gt;</bpt>content<ept id="p1">&lt;/c&gt;</ept>-Parameter, der verwendet wird, um den <ph id="ph1">&lt;see cref="T:System.Net.Http.ByteArrayContent" /&gt;</ph> zu initialisieren.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes in the <bpt id="p1">&lt;c&gt;</bpt>content<ept id="p1">&lt;/c&gt;</ept> starting from the <bpt id="p2">&lt;c&gt;</bpt>offset<ept id="p2">&lt;/c&gt;</ept> parameter used to initialize the <ph id="ph1">&lt;see cref="T:System.Net.Http.ByteArrayContent" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der Bytes in <bpt id="p1">&lt;c&gt;</bpt>content<ept id="p1">&lt;/c&gt;</ept> ab dem <bpt id="p2">&lt;c&gt;</bpt>offset<ept id="p2">&lt;/c&gt;</ept>-Parameter, die zum Initialisieren von <ph id="ph1">&lt;see cref="T:System.Net.Http.ByteArrayContent" /&gt;</ph> benutzt werden.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Http.ByteArrayContent" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Net.Http.ByteArrayContent" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>Only the range specified by the <ph id="ph1">`offset`</ph> parameter and the <ph id="ph2">`count`</ph>  parameter is used as content.</source>
          <target state="translated">Nur der Bereich, die gemäß der <ph id="ph1">`offset`</ph> Parameter und der <ph id="ph2">`count`</ph> Parameter als Inhalt dient.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>Syntax</source>
          <target state="translated">Syntax</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="content" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="content" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> parameter is less than zero.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="offset" /&gt;</ph>-Parameter ist kleiner als 0 (null).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> parameter is greater than the length of content specified by the <ph id="ph2">&lt;paramref name="content" /&gt;</ph> parameter.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="offset" /&gt;</ph>-Parameter größer als die Länge des Inhalts, der durch den <ph id="ph2">&lt;paramref name="content" /&gt;</ph>-Parameters angegeben wird.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="count" /&gt;</ph> parameter is less than zero.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="count" /&gt;</ph>-Parameter ist kleiner als 0 (null).</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="count" /&gt;</ph> parameter is greater than the length of content specified by the <ph id="ph2">&lt;paramref name="content" /&gt;</ph> parameter - minus the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="count" /&gt;</ph>-Parameter größer als die Länge des Inhalts, der durch den <ph id="ph2">&lt;paramref name="content" /&gt;</ph>-Parameters - minus dem <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>-Parameter angegeben wird.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.CreateContentReadStreamAsync">
          <source>Creates an HTTP content stream as an asynchronous operation for reading whose backing store is memory from the <ph id="ph1">&lt;see cref="T:System.Net.Http.ByteArrayContent" /&gt;</ph>.</source>
          <target state="translated">Erstellt einen HTTP-Inhaltsdatenstrom als asynchronen Vorgang zum Lesen, dessen Sicherungsspeicher Speicher aus dem <ph id="ph1">&lt;see cref="T:System.Net.Http.ByteArrayContent" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.CreateContentReadStreamAsync">
          <source>The task object representing the asynchronous operation.</source>
          <target state="translated">Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Http.ByteArrayContent.CreateContentReadStreamAsync">
          <source>This operation will not block.</source>
          <target state="translated">Dieser Vorgang wird nicht blockiert.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Http.ByteArrayContent.CreateContentReadStreamAsync">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object will complete after all of the content stream has been created.</source>
          <target state="translated">Das zurückgegebene <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> Objekt wird abgeschlossen, nachdem alle des inhaltsdatenstroms erstellt wurde.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.SerializeToStreamAsync(System.IO.Stream,System.Net.TransportContext)">
          <source>The target stream.</source>
          <target state="translated">Der Zieldatenstrom.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.SerializeToStreamAsync(System.IO.Stream,System.Net.TransportContext)">
          <source>Information about the transport, like channel binding token.</source>
          <target state="translated">Informationen über den Transport, z.B. Kanalbindungstoken.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.SerializeToStreamAsync(System.IO.Stream,System.Net.TransportContext)">
          <source>This parameter may be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Dieser Parameter kann <ph id="ph1">&lt;see langword="null" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.SerializeToStreamAsync(System.IO.Stream,System.Net.TransportContext)">
          <source>Serialize and write the byte array provided in the constructor to an HTTP content stream as an asynchronous operation.</source>
          <target state="translated">Serialisiert und schreibt das im Konstruktor bereitgestellte Bytearray als asynchronen Vorgang in einen HTTP-Inhaltedatenstrom.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.SerializeToStreamAsync(System.IO.Stream,System.Net.TransportContext)">
          <source>The task object representing the asynchronous operation.</source>
          <target state="translated">Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Http.ByteArrayContent.SerializeToStreamAsync(System.IO.Stream,System.Net.TransportContext)">
          <source>This operation does not block.</source>
          <target state="translated">Dieser Vorgang wird nicht blockiert.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Http.ByteArrayContent.SerializeToStreamAsync(System.IO.Stream,System.Net.TransportContext)">
          <source>When the returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object completes, the whole byte array has been written to the <ph id="ph2">`stream`</ph> parameter.</source>
          <target state="translated">Wenn das zurückgegebene <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> Objekt abgeschlossen ist, das gesamte Bytearray %medialocationinfo;) wurde die <ph id="ph2">`stream`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.TryComputeLength(System.Int64@)">
          <source>The length in bytes of the byte array.</source>
          <target state="translated">Die Länge des Bytearrays in Bytes.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.TryComputeLength(System.Int64@)">
          <source>Determines whether a byte array has a valid length in bytes.</source>
          <target state="translated">Bestimmt, ob ein Bytearray eine gültige Länge in Bytes hat.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Net.Http.ByteArrayContent.TryComputeLength(System.Int64@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is a valid length; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="length" /&gt;</ph> eine gültige Länge ist; andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Http.ByteArrayContent.TryComputeLength(System.Int64@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Http.ByteArrayContent.TryComputeLength%2A&gt;</ph> method gives a derived content type the ability to calculate the content length.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Http.ByteArrayContent.TryComputeLength%2A&gt;</ph> -Methode einem abgeleiteten Inhaltstyp erhalten die Möglichkeit, die Länge des Inhalte zu berechnen.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Http.ByteArrayContent.TryComputeLength(System.Int64@)">
          <source>This is useful for content types which are able to easily calculate the content length.</source>
          <target state="translated">Dies ist hilfreich für Inhaltstypen, die die Inhaltslänge leicht berechnen können.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Http.ByteArrayContent.TryComputeLength(System.Int64@)">
          <source>If computing the content length is not possible or expensive (would require the system to buffer the whole content where the serialization would be expensive or require the system to allocate a lot of memory), this method can return <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Wenn berechnen den Content-Length ist nicht möglich oder teure (, müsste das System den gesamten Inhalt gepuffert werden sollen, in denen die Serialisierung teuer sein oder muss das System zu viel Arbeitsspeicher belegen würde), kann diese Methode zurückgeben <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Http.ByteArrayContent.TryComputeLength(System.Int64@)">
          <source>If this method returns <ph id="ph1">`false`</ph>, this implies that either chunked transfer is needed or the content must get buffered before being sent to the server.</source>
          <target state="translated">Wenn diese Methode zurückgibt <ph id="ph1">`false`</ph>, dies bedeutet, dass entweder aufgeteilte Übertragung erforderlich ist, oder der Inhalt muss vor dem Senden an den Server gepuffert.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Http.ByteArrayContent.TryComputeLength(System.Int64@)">
          <source>This method always returned <ph id="ph1">`true`</ph> for <ph id="ph2">&lt;xref:System.Net.Http.ByteArrayContent&gt;</ph>.</source>
          <target state="translated">Diese Methode immer zurückgegeben <ph id="ph1">`true`</ph> für <ph id="ph2">&lt;xref:System.Net.Http.ByteArrayContent&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>