<Type Name="WebRequestHandler" FullName="System.Net.Http.WebRequestHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e6a34b0853e14f0bea39560273a938c63512434f" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53230558" /></Metadata><TypeSignature Language="C#" Value="public class WebRequestHandler : System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebRequestHandler extends System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="DocId" Value="T:System.Net.Http.WebRequestHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class WebRequestHandler&#xA;Inherits HttpClientHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebRequestHandler : System::Net::Http::HttpClientHandler" />
  <TypeSignature Language="F#" Value="type WebRequestHandler = class&#xA;    inherit HttpClientHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Http.HttpClientHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt desktop-spezifische Funktionen bereit, die für Windows Store-Apps oder andere Umgebungen nicht verfügbar sind.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse implementiert eine Transport Handler mit <xref:System.Net.HttpWebRequest> -Instanzen, die HTTP-Anforderungen an Server senden.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebRequestHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.WebRequestHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebRequestHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Http.WebRequestHandler" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowPipelining">
      <MemberSignature Language="C#" Value="public bool AllowPipelining { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowPipelining" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.AllowPipelining" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowPipelining As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowPipelining { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowPipelining : bool with get, set" Usage="System.Net.Http.WebRequestHandler.AllowPipelining" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Anforderung über Pipelineverbindungen zur Internetressource gesendet werden soll, oder legt diesen fest.</summary>
        <value>Gibt <see cref="T:System.Boolean" />zurück.  
  
 <see langword="true" />, wenn die Anforderung über Pipelineverbindungen gesendet werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung verwendet die <xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A> Eigenschaft, die eine Vorliebe für pipelineverbindungen angibt. Wenn <xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A> ist `true`, eine Anwendung macht pipelineverbindungen mit den Servern, die sie unterstützen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.AuthenticationLevel AuthenticationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.AuthenticationLevel AuthenticationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.AuthenticationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationLevel As AuthenticationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::AuthenticationLevel AuthenticationLevel { System::Net::Security::AuthenticationLevel get(); void set(System::Net::Security::AuthenticationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationLevel : System.Net.Security.AuthenticationLevel with get, set" Usage="System.Net.Http.WebRequestHandler.AuthenticationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.AuthenticationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab bzw. legt diesen fest, der die für diese Anforderung verwendete Ebene von Authentifizierung und Identitätswechsel angibt.</summary>
        <value>Eine bitweise Kombination der <see cref="T:System.Net.Security.AuthenticationLevel" />-Werte. Der Standardwert ist <see cref="F:System.Net.Security.AuthenticationLevel.MutualAuthRequested" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei gegenseitiger Authentifizierung stellen sowohl Client als auch Server Anmeldeinformationen bereit, um ihre Identität anzugeben. Der <xref:System.Net.Security.AuthenticationLevel.MutualAuthRequired>-Wert und der <xref:System.Net.Security.AuthenticationLevel.MutualAuthRequested>-Wert sind für die Kerberos-Authentifizierung relevant. Kerberos-Authentifizierung kann direkt unterstützt oder verwendet werden, wenn das tatsächliche Sicherheitsprotokoll mithilfe des Negotiate-Sicherheitsprotokolls ausgewählt wird. Weitere Informationen über Authentifizierungsprotokolle finden Sie unter [Internetauthentifizierung](~/docs/framework/network-programming/internet-authentication.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CachePolicy">
      <MemberSignature Language="C#" Value="public System.Net.Cache.RequestCachePolicy CachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Cache.RequestCachePolicy CachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.CachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Cache::RequestCachePolicy ^ CachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.Http.WebRequestHandler.CachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Cacherichtlinie für diese Anforderung ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Net.Cache.RequestCachePolicy" />-Objekt, das eine Cacherichtlinie definiert. Die Standardeinstellung ist <see cref="P:System.Net.WebRequest.DefaultCachePolicy" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle Cacherichtlinie und das Vorhandensein der angeforderten Ressource im Cache bestimmen, ob eine Antwort aus dem Cache abgerufen werden kann. In der Regel mithilfe von zwischengespeicherten Antworten verbessert die Anwendungsleistung, aber es besteht ein Risiko, dass die Antwort im Cache nicht die Antwort auf dem Server übereinstimmt.  
  
 Die Standardcacherichtlinie kann angegeben werden, in der Datei "Machine.config" oder durch Festlegen der <xref:System.Net.HttpWebRequest.DefaultCachePolicy%2A> Eigenschaft.  
  
 Eine Kopie einer Ressource wird nur mit dem Cache hinzugefügt, wenn der Antwortstream für die Ressource abgerufen und bis zum Ende des Streams gelesen wird. Damit eine andere Anforderung für dieselbe Ressource eine zwischengespeicherte Kopie, abhängig von der Ebene des Caches-Richtlinie für diese Anforderung verwenden kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection" Usage="System.Net.Http.WebRequestHandler.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dieser Anforderung zugeordnete Auflistung von Sicherheitszertifikaten ab oder legt diese fest.</summary>
        <value>Die Auflistung von Sicherheitszertifikaten, die dieser Anforderung zugeordnet sind.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan ContinueTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : TimeSpan with get, set" Usage="System.Net.Http.WebRequestHandler.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeitdauer in Millisekunden ab, die die Anwendung auf 100-Continue vom Server wartet, ehe Daten hochgeladen werden, oder legt diese fest.</summary>
        <value>Die Zeitdauer in Millisekunden, die die Anwendung auf 100-Continue vom Server wartet, ehe Daten hochgeladen werden. Der Standardwert beträgt 350 Millisekunden.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::TokenImpersonationLevel ImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); void set(System::Security::Principal::TokenImpersonationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ImpersonationLevel : System.Security.Principal.TokenImpersonationLevel with get, set" Usage="System.Net.Http.WebRequestHandler.ImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Ebene des Identitätswechsels für die aktuelle Anforderung ab oder legt diese fest.</summary>
        <value>Die Identitätswechselebene dieser Anforderung. Der Standardwert ist <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Identitätswechselebene bestimmt, wie der Server die Anmeldeinformationen des Clients verwenden kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaxResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxResponseHeadersLength : int with get, set" Usage="System.Net.Http.WebRequestHandler.MaxResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximal zulässige Länge der Antwortheader ab oder legt diese fest.</summary>
        <value>Die Länge der Antwortheader in KB (1024 Bytes).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Länge des Antwortheaders enthält die Antwort-Statuszeile und alle zusätzlichen Steuerzeichen, die als Teil des HTTP-Protokoll empfangen werden. Ein Wert-1 bedeutet, dass, die keine Obergrenze für die Header der Antwort festgelegt wird. ein Wert von 0 bedeutet, bei denen alle Anforderungen.  
  
 Wenn die <xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A> Eigenschaft nicht explizit festgelegt ist, wird standardmäßig des Werts des der <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> Eigenschaft.  
  
 Überschreitet die Länge des Antwortheaders empfangen den Wert des der <xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A> -Eigenschaft eine Ausnahme wird ausgelöst, wenn die Antwort erfolgt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.Http.WebRequestHandler.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Timeout in Millisekunden für das Schreiben einer Anforderung an oder das Lesen einer Antwort von einem Server ab oder legt dieses fest.</summary>
        <value>Die Anzahl von Millisekunden vor dem Timeout für das Schreiben oder Lesen. Der Standardwert ist 300.000 Millisekunden (5 Minuten).</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Rückrufmethode zur Überprüfung des Serverzertifikats ab oder legt diese fest.</summary>
        <value>Eine Rückrufmethode zur Überprüfung des Serverzertifikats.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback%2A> ist `null`, das Serverzertifikat wird mit der standardmäßigen bekannten Zertifizierungsstellen überprüft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.Http.WebRequestHandler.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Freigabe NTLM-authentifizierter Hochgeschwindigkeitsverbindungen zulässig ist, oder legt diesen fest.</summary>
        <value>Gibt <see cref="T:System.Boolean" />zurück.  
  
 <see langword="true" />, um die authentifizierte Verbindung geöffnet zu halten, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für diese Eigenschaft ist `false`, die bewirkt, dass der aktuellen Verbindungs geschlossen wird, nachdem eine Anforderung abgeschlossen wurde. Die Authentifizierungsfolge muss Ihre Anwendung durchlaufen, jedes Mal, wenn sie eine neue Anforderung ausgibt. Wenn diese Eigenschaft, um festgelegt wird `true`, die zum Abrufen der Antwort verwendete Verbindung bleibt geöffnet, nachdem die Authentifizierung durchgeführt wurde. In diesem Fall andere Anforderungen, die diese Eigenschaft auf festgelegt haben `true` möglicherweise verwenden Sie die Verbindung, ohne Sie erneut zu authentifizieren. Das heißt, wenn eine Verbindung für Benutzer A authentifiziert wurde, Benutzer B kann wiederverwenden, A-Verbindung. Benutzer B die Anforderung erfüllt ist, basierend auf den Anmeldeinformationen von Benutzer A.  
  
> [!CAUTION]
>  Da es für eine Anwendung die Verbindung zu verwenden, ohne Authentifizierung möglich ist, müssen Sie darauf achten, keine administrativen Sicherheitslücken in Ihrem System vorhanden ist, beim Festlegen dieser Eigenschaft auf `true`. Wenn Ihre Anwendung die Anforderungen für mehrere Benutzer sendet (nimmt mehrere Benutzerkonten) und stützt sich auf die Authentifizierung beim Schützen von Ressourcen, legen Sie nicht diese Eigenschaft auf `true` , wenn Sie das Verbindungsgruppen verwenden, wie unten beschrieben.  
  
 Sie sollten erwägen die Aktivierung dieser Mechanismus aus, wenn Ihre Leistung Probleme und Ihre Anwendung auf einem Webserver mit integrierter Windows-Authentifizierung ausgeführt wird.  
  
 Diese Einstellung aktivieren, wird das System von Sicherheitsrisiken. Setzen Sie die <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> Eigenschaft `true` Achten Sie darauf, dass Sie die folgenden Vorsichtsmaßnahmen getroffen werden:  
  
-   Führen Sie die Anwendung in einer geschützten Umgebung aus, um zu verhindern, dass Exploits der Verbindung.  
  
 Wenn Sie den Back-End-Server zu steuern, als Alternative sollten Sie authentifizierungspersistenz deaktivieren. Dies verbessert die Leistung in geringerem Maße, aber es ist sicherer. Weitere Informationen zu suchen, in der MSDN Library unter nach AuthPersistence [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>