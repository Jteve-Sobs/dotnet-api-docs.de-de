<Type Name="HttpContent" FullName="System.Net.Http.HttpContent">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3ea0bd117154431b899b26f84c7713b150c4b064" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69092297" /></Metadata><TypeSignature Language="C#" Value="public abstract class HttpContent : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit HttpContent extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Http.HttpContent" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class HttpContent&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContent abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type HttpContent = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Http</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Eine Basisklasse, die einen HTTP-Entitätstext und Inhaltsheader darstellt.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpContent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpContent.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpContent();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Http.HttpContent" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyToAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Serialisiert den HTTP-Inhalt in einen Bytedatenstrom und kopiert ihn in das als <paramref name="stream" />-Parameter bereitgestellte Datenstromobjekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpContent.CopyToAsync(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream -&gt; System.Threading.Tasks.Task" Usage="httpContent.CopyToAsync stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Der Zieldatenstrom.</param>
        <summary>Serialisiert den HTTP-Inhalt in einen Bytedatenstrom und kopiert ihn in das als <paramref name="stream" />-Parameter bereitgestellte Datenstromobjekt.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurück <xref:System.Threading.Tasks.Task> gegebene Objekt wird abgeschlossen, nachdem der gesamte Inhalt in das `stream` als-Parameter übergebenen Stream-Objekt geschrieben wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream stream, System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream stream, class System.Net.TransportContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpContent.CopyToAsync(System.IO.Stream,System.Net.TransportContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ stream, System::Net::TransportContext ^ context);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream * System.Net.TransportContext -&gt; System.Threading.Tasks.Task" Usage="httpContent.CopyToAsync (stream, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="context" Type="System.Net.TransportContext" />
      </Parameters>
      <Docs>
        <param name="stream">Der Zieldatenstrom.</param>
        <param name="context">Informationen über den Transport (z.B. Kanalbindungstoken). Dieser Parameter kann <see langword="null" /> sein.</param>
        <summary>Serialisiert den HTTP-Inhalt in einen Bytedatenstrom und kopiert ihn in das als <paramref name="stream" />-Parameter bereitgestellte Datenstromobjekt.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurück <xref:System.Threading.Tasks.Task> gegebene Objekt wird abgeschlossen, nachdem der gesamte Inhalt in das `stream` als-Parameter übergebenen Stream-Objekt geschrieben wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateContentReadStreamAsync">
      <MemberSignature Language="C#" Value="protected virtual System.Threading.Tasks.Task&lt;System.IO.Stream&gt; CreateContentReadStreamAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class System.IO.Stream&gt; CreateContentReadStreamAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpContent.CreateContentReadStreamAsync" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateContentReadStreamAsync () As Task(Of Stream)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Threading::Tasks::Task&lt;System::IO::Stream ^&gt; ^ CreateContentReadStreamAsync();" />
      <MemberSignature Language="F#" Value="abstract member CreateContentReadStreamAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.IO.Stream&gt;&#xA;override this.CreateContentReadStreamAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.IO.Stream&gt;" Usage="httpContent.CreateContentReadStreamAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.IO.Stream&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serialisiert den HTTP-Inhalt in einen Speicherdatenstrom als asynchroner Vorgang.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurück <xref:System.Threading.Tasks.Task%601> gegebene Objekt wird abgeschlossen, nachdem der gesamte Inhalt in den Speicherstream geschrieben wurde.  
  
 Sobald der Vorgang abgeschlossen ist, <xref:System.Threading.Tasks.Task%601.Result%2A> enthält die-Eigenschaft des zurückgegebenen Task-Objekts den Arbeitsspeicherstream, der den HTTP-Inhalt darstellt. Der zurückgegebene Stream kann dann zum Lesen des Inhalts mithilfe verschiedener Stream-APIs verwendet werden.  
  
 Die <xref:System.Net.Http.HttpContent.CreateContentReadStreamAsync%2A> -Methode puffert den Inhalt in einen Speicherdaten Strom. Abgeleitete Klassen können dieses Verhalten überschreiben, wenn die Inhalte besser als Stream abgerufen werden können. Beispielsweise kann ein Bytearray oder eine Zeichenfolge eine effizientere Methode verwenden, z. b. das <xref:System.IO.MemoryStream> umschließen eines schreibgeschützten um die Bytes oder Zeichenfolge.)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die vom <see cref="T:System.Net.Http.HttpContent" /> verwendeten, nicht verwalteten Ressourcen frei und verwirft optional auch die verwalteten Ressourcen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpContent.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="httpContent.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die vom <see cref="T:System.Net.Http.HttpContent" /> verwendeten, nicht verwalteten Ressourcen frei und verwirft die verwalteten Ressourcen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpContent.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="httpContent.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben. <see langword="false" />, wenn ausschließlich nicht verwaltete Ressourcen freigegeben werden sollen.</param>
        <summary>Gibt die vom <see cref="T:System.Net.Http.HttpContent" /> verwendeten, nicht verwalteten Ressourcen frei und verwirft optional auch die verwalteten Ressourcen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der öffentlichen `Dispose()` -Methode und der <xref:System.Object.Finalize%2A> -Methode aufgerufen. `Dispose()`Ruft die geschützte `Dispose(Boolean)` Methode auf, `disposing` wobei der- `true`Parameter auf festgelegt ist. <xref:System.Object.Finalize%2A>Ruft `Dispose` auf `disposing` , wobei `false`auf gesetzt ist. Wenn der `disposing` -Parameter `true`ist, gibt diese Methode alle Ressourcen frei, die von allen verwalteten <xref:System.Net.Http.HttpContent> Objekten gehalten werden, auf die dieser verweist. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Net.Http.Headers.HttpContentHeaders Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Http.Headers.HttpContentHeaders Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpContent.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As HttpContentHeaders" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Http::Headers::HttpContentHeaders ^ Headers { System::Net::Http::Headers::HttpContentHeaders ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.Http.Headers.HttpContentHeaders" Usage="System.Net.Http.HttpContent.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Http.Headers.HttpContentHeaders</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die HTTP-Inhaltsheader gemäß Definition in RFC 2616 ab.</summary>
        <value>Die Inhaltsheader gemäß Definition in RFC 2616.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadIntoBufferAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Serialisiert den HTTP-Inhalt in einen Arbeitsspeicherpuffer als asynchroner Vorgang.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadIntoBufferAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task LoadIntoBufferAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task LoadIntoBufferAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpContent.LoadIntoBufferAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadIntoBufferAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ LoadIntoBufferAsync();" />
      <MemberSignature Language="F#" Value="member this.LoadIntoBufferAsync : unit -&gt; System.Threading.Tasks.Task" Usage="httpContent.LoadIntoBufferAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serialisiert den HTTP-Inhalt in einen Arbeitsspeicherpuffer als asynchroner Vorgang.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurück <xref:System.Threading.Tasks.Task> gegebene Objekt wird abgeschlossen, nachdem der gesamte Inhalt in den Speicherpuffer serialisiert wurde.  
  
 Nachdem der Inhalt in einen Arbeitsspeicher Puffer serialisiert wurde, kopieren Aufrufe einer <xref:System.Net.Http.HttpContent.CopyToAsync%2A> der-Methoden den Inhalt des Speicherpuffers in den Zielstream.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadIntoBufferAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task LoadIntoBufferAsync (long maxBufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task LoadIntoBufferAsync(int64 maxBufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpContent.LoadIntoBufferAsync(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadIntoBufferAsync (maxBufferSize As Long) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ LoadIntoBufferAsync(long maxBufferSize);" />
      <MemberSignature Language="F#" Value="member this.LoadIntoBufferAsync : int64 -&gt; System.Threading.Tasks.Task" Usage="httpContent.LoadIntoBufferAsync maxBufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxBufferSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="maxBufferSize">Die maximale Größe des zu verwendenden Puffers in Bytes.</param>
        <summary>Serialisiert den HTTP-Inhalt in einen Arbeitsspeicherpuffer als asynchroner Vorgang.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurück <xref:System.Threading.Tasks.Task> gegebene Objekt wird abgeschlossen, nachdem der gesamte Inhalt in den Speicherpuffer serialisiert wurde.  
  
 Nachdem der Inhalt in einen Arbeitsspeicher Puffer serialisiert wurde, kopieren Aufrufe einer <xref:System.Net.Http.HttpContent.CopyToAsync%2A> der-Methoden den Inhalt des Speicherpuffers in den Zielstream.  
  
 Wenn der Inhalt den im `maxBufferSize` -Parameter übergebenen Wert überschreitet, wird eine-Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsByteArrayAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;byte[]&gt; ReadAsByteArrayAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;unsigned int8[]&gt; ReadAsByteArrayAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpContent.ReadAsByteArrayAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAsByteArrayAsync () As Task(Of Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;cli::array &lt;System::Byte&gt; ^&gt; ^ ReadAsByteArrayAsync();" />
      <MemberSignature Language="F#" Value="member this.ReadAsByteArrayAsync : unit -&gt; System.Threading.Tasks.Task&lt;byte[]&gt;" Usage="httpContent.ReadAsByteArrayAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Byte[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serialisiert den HTTP-Inhalt in ein Bytearray als asynchroner Vorgang.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurück <xref:System.Threading.Tasks.Task%601> gegebene Objekt wird abgeschlossen, nachdem der gesamte Inhalt als Bytearray geschrieben wurde.  
  
 Sobald der Vorgang abgeschlossen ist, <xref:System.Threading.Tasks.Task%601.Result%2A> enthält die-Eigenschaft des zurückgegebenen Task-Objekts das Bytearray mit dem HTTP-Inhalt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsStreamAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.IO.Stream&gt; ReadAsStreamAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.IO.Stream&gt; ReadAsStreamAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpContent.ReadAsStreamAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAsStreamAsync () As Task(Of Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::IO::Stream ^&gt; ^ ReadAsStreamAsync();" />
      <MemberSignature Language="F#" Value="member this.ReadAsStreamAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.IO.Stream&gt;" Usage="httpContent.ReadAsStreamAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.IO.Stream&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serialisieren des HTTP-Inhalts und Zurückgeben eines Datenstroms, der den Inhalt darstellt, als asynchroner Vorgang.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurück <xref:System.Threading.Tasks.Task%601> gegebene Objekt wird abgeschlossen, nachdem der gesamte Stream, der den Inhalt darstellt, gelesen wurde.  
  
 Sobald der Vorgang abgeschlossen ist, <xref:System.Threading.Tasks.Task%601.Result%2A> enthält die-Eigenschaft des zurückgegebenen Task-Objekts den Datenstrom, der den HTTP-Inhalt darstellt. Der zurückgegebene Stream kann dann zum Lesen des Inhalts mithilfe verschiedener Stream-APIs verwendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsStringAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;string&gt; ReadAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpContent.ReadAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadAsStringAsync();" />
      <MemberSignature Language="F#" Value="member this.ReadAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="httpContent.ReadAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serialisiert den HTTP-Inhalt in eine Zeichenfolge als asynchroner Vorgang.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurück <xref:System.Threading.Tasks.Task%601> gegebene Objekt wird abgeschlossen, nachdem der gesamte Inhalt als Zeichenfolge geschrieben wurde.  
  
 Sobald der Vorgang abgeschlossen ist, <xref:System.Threading.Tasks.Task%601.Result%2A> enthält die-Eigenschaft des zurückgegebenen Task-Objekts die Zeichenfolge mit dem HTTP-Inhalt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializeToStreamAsync">
      <MemberSignature Language="C#" Value="protected internal abstract System.Threading.Tasks.Task SerializeToStreamAsync (System.IO.Stream stream, System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Threading.Tasks.Task SerializeToStreamAsync(class System.IO.Stream stream, class System.Net.TransportContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpContent.SerializeToStreamAsync(System.IO.Stream,System.Net.TransportContext)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract System::Threading::Tasks::Task ^ SerializeToStreamAsync(System::IO::Stream ^ stream, System::Net::TransportContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member SerializeToStreamAsync : System.IO.Stream * System.Net.TransportContext -&gt; System.Threading.Tasks.Task" Usage="httpContent.SerializeToStreamAsync (stream, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="context" Type="System.Net.TransportContext" />
      </Parameters>
      <Docs>
        <param name="stream">Der Zieldatenstrom.</param>
        <param name="context">Informationen über den Transport (z.B. Kanalbindungstoken). Dieser Parameter kann <see langword="null" /> sein.</param>
        <summary>Serialisiert den HTTP-Inhalt in einen Datenstrom als asynchroner Vorgang.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurück <xref:System.Threading.Tasks.Task%601> gegebene Objekt wird abgeschlossen, nachdem der gesamte Inhalt in das `stream` im-Parameter übergebenen Stream-Objekt serialisiert wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryComputeLength">
      <MemberSignature Language="C#" Value="protected internal abstract bool TryComputeLength (out long length);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryComputeLength([out] int64&amp; length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpContent.TryComputeLength(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function TryComputeLength (ByRef length As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract bool TryComputeLength([Runtime::InteropServices::Out] long % length);" />
      <MemberSignature Language="F#" Value="abstract member TryComputeLength :  -&gt; bool" Usage="httpContent.TryComputeLength length" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="length" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="length">Die Länge des HTTP-Inhalts in Bytes.</param>
        <summary>Bestimmt, ob der HTTP-Inhalt eine gültige Länge in Bytes hat.</summary>
        <returns><see langword="true" />, wenn <paramref name="length" /> eine gültige Länge ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Http.HttpContent.TryComputeLength%2A> -Methode gibt einem HTTP-Inhalt die Möglichkeit, die Inhalts Länge zu berechnen. Dies ist nützlich für Inhaltstypen, die die Inhalts Länge problemlos berechnen können. Wenn das Berechnen der Inhalts Länge nicht möglich oder teuer ist (wäre es erforderlich, dass das System den gesamten Inhalt puffert, wenn die Serialisierung aufwendig wäre oder das System viel Arbeitsspeicher zuordnen muss), kann diese `false`Methode zurückgeben. Wenn diese Methode zurück `false`gegeben wird, bedeutet dies, dass entweder eine segmentierte Übertragung erforderlich ist oder der Inhalt gepuffert werden muss, bevor er an den Server gesendet wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
