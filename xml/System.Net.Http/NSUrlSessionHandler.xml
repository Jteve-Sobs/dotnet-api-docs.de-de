<Type Name="NSUrlSessionHandler" FullName="System.Net.Http.NSUrlSessionHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="211fedf6059f2c9a8d20f83e85d6d38bad4499f2" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86801457" /></Metadata><TypeSignature Language="C#" Value="public class NSUrlSessionHandler : System.Net.Http.HttpMessageHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NSUrlSessionHandler extends System.Net.Http.HttpMessageHandler" />
  <TypeSignature Language="DocId" Value="T:System.Net.Http.NSUrlSessionHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class NSUrlSessionHandler&#xA;Inherits HttpMessageHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class NSUrlSessionHandler : System::Net::Http::HttpMessageHandler" />
  <TypeSignature Language="F#" Value="type NSUrlSessionHandler = class&#xA;    inherit HttpMessageHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Http</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Http.HttpMessageHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="a02a4-101">Der Standardmeldungshandler, der von <see cref="T:System.Net.Http.HttpClient" /> auf Apple-Plattformen unter Verwendung des Xamarin-Stapels verwendet wird (iOS, macOS, watchOS, tvOS)</span><span class="sxs-lookup"><span data-stu-id="a02a4-101">The default message handler used by <see cref="T:System.Net.Http.HttpClient" /> on Apple platforms using the Xamarin stack (iOS, macOS, watchOS, tvOS)</span></span></summary>
    <remarks><para><span data-ttu-id="a02a4-102">Der nsurlsessionhandler ist ein HTTP-Client Handler, der seine Arbeit an das integrierte Apple-Gerät delegiert  <see cref="T:Foundation.NSUrlSession" /> .</span><span class="sxs-lookup"><span data-stu-id="a02a4-102">The NSUrlSessionHandler is an HTTP client handler that delegates its work to Apple’s built-in <see cref="T:Foundation.NSUrlSession" />.</span></span> <span data-ttu-id="a02a4-103">Dies ist die Standardeinstellung, wenn Sie die Anwendung kompilieren, Sie können Sie jedoch manuell in Ihrer Anwendung deaktivieren, indem Sie einen anderen Handler auswählen.</span><span class="sxs-lookup"><span data-stu-id="a02a4-103">  This is the default when you compile your application, but you can opt-out of it manually in your application by selecting a different handler.</span></span>  </para>
      <para> </para>
      <para><span data-ttu-id="a02a4-104">Die Verwendung von Apple nsurlsession bietet einige Vorteile gegenüber der Verwendung von socketbasierten Implementierungen, der Hauptbenutzer, der auf einem mobilen Gerät ist, das Radio automatisch in Ihrem Namen aktiviert wird, und Sie vermeiden ein mögliches Timeout oder einen Fehler, wenn das Radio nicht verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="a02a4-104">Using the Apple NSUrlSession has some advantages over using any socket-based implementation, the chief one being that on a mobile device, it will automatically turn on the radio on your behalf and you will avoid a potential timeout or an error if the radio is down.</span></span></para>
      <para> </para>
      <para><span data-ttu-id="a02a4-105">Darüber hinaus können Sie den Handler so konfigurieren, dass der Download fortgesetzt wird, auch wenn die Anwendung angehalten wurde oder nicht mehr ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="a02a4-105">Additionally, you can configure the handler to continue your downloads even if your application is suspended or has stopped running.</span></span></para></remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NSUrlSessionHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.NSUrlSessionHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NSUrlSessionHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a02a4-106">Der Standardkonstruktor für NSUrlSessionHandler konfiguriert den Handler mit einem auf den Standardwert festgelegten <see cref="T:Foundation.NSUrlSessionConfiguration" />-Element und passt das Ressourcentimeout an, sodass es 24 Stunden beträgt. (Unendliche Timeouts werden von eigenen Apple-Transportelementen nicht unterstützt.)</span><span class="sxs-lookup"><span data-stu-id="a02a4-106">The default constructor for NSUrlSessionHandler configures the handler with a <see cref="T:Foundation.NSUrlSessionConfiguration" /> set to the default value, and customizes the resources time out to be 24 hours (as infinite timeouts are not supported by Apple’s own transport).</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.NSUrlSessionHandler.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.Http.NSUrlSessionHandler.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a02a4-107">Ruft einen Wert ab, der automatische Umleitung zulässt, oder legt ihn fest.</span><span class="sxs-lookup"><span data-stu-id="a02a4-107">Gets or sets a value that allows automatic redirection.</span></span> <span data-ttu-id="a02a4-108">Der Standardwert lautet <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="a02a4-108">Its default value is <see langword="true" />.</span></span></summary>
        <value><span data-ttu-id="a02a4-109"><see langword="true" /> So lassen Sie die automatische Umleitung zu andernfalls <see langword="false" /> .</span><span class="sxs-lookup"><span data-stu-id="a02a4-109"><see langword="true" /> to allow automatic redirection; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.NSUrlSessionHandler.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.Http.NSUrlSessionHandler.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a02a4-110">Ruft von diesem Handler verwendete Authentifizierungsinformationen ab oder legt diese fest.</span><span class="sxs-lookup"><span data-stu-id="a02a4-110">Gets or sets authentication information used by this handler.</span></span></summary>
        <value><span data-ttu-id="a02a4-111">Die dem Handler zugeordneten Authentifizierungsanmeldeinformationen.</span><span class="sxs-lookup"><span data-stu-id="a02a4-111">The authentication credentials associated with the handler.</span></span> <span data-ttu-id="a02a4-112">Der Standardwert lautet <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a02a4-112">The default is <see langword="null" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableCaching">
      <MemberSignature Language="C#" Value="public bool DisableCaching { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisableCaching" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.NSUrlSessionHandler.DisableCaching" />
      <MemberSignature Language="VB.NET" Value="Public Property DisableCaching As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisableCaching { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisableCaching : bool with get, set" Usage="System.Net.Http.NSUrlSessionHandler.DisableCaching" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.NSUrlSessionHandler.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="nSUrlSessionHandler.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="protected internal override System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; SendAsync(class System.Net.Http.HttpRequestMessage request, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.NSUrlSessionHandler.SendAsync(System.Net.Http.HttpRequestMessage,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SendAsync (request As HttpRequestMessage, cancellationToken As CancellationToken) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ SendAsync(System::Net::Http::HttpRequestMessage ^ request, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.SendAsync : System.Net.Http.HttpRequestMessage * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="nSUrlSessionHandler.SendAsync (request, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Net.Http.HttpRequestMessage" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="a02a4-113">Die zu sendende HTTP-Anforderungsmeldung.</span><span class="sxs-lookup"><span data-stu-id="a02a4-113">The HTTP request message to send.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="a02a4-114">Das Abbruchtoken, um den Vorgang abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="a02a4-114">The cancellation token to cancel the operation.</span></span></param>
        <summary><span data-ttu-id="a02a4-115">Sendet eine HTTP-Anforderung als asynchronen Vorgang.</span><span class="sxs-lookup"><span data-stu-id="a02a4-115">Sends an HTTP request as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="a02a4-116">Das Aufgabenobjekt, das den asynchronen Vorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="a02a4-116">The task object representing the asynchronous operation.</span></span></returns>
        <remarks><span data-ttu-id="a02a4-117">Dieser Vorgang ist nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="a02a4-117">This operation is does not block.</span></span> <span data-ttu-id="a02a4-118">Es gibt eine Instanz von zurück <see cref="T:System.Threading.Tasks.Task`1" />   , die den asynchronen Vorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="a02a4-118">It returns an instance of <see cref="T:System.Threading.Tasks.Task`1" /> to represent the asynchronous operation.</span></span> <span data-ttu-id="a02a4-119">Wenn der Vorgang abgeschlossen ist, <see cref="P:System.Threading.Tasks.Task`1.Result" /> enthält die Antwortnachricht.</span><span class="sxs-lookup"><span data-stu-id="a02a4-119">When the operation completes, <see cref="P:System.Threading.Tasks.Task`1.Result" /> contains the response message.</span></span></remarks>
      </Docs>
    </Member>
  </Members>
</Type>
