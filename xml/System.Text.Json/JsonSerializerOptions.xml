<Type Name="JsonSerializerOptions" FullName="System.Text.Json.JsonSerializerOptions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b881f9fc052d051240dbbbf5ce20b765480c2f88" /><Meta Name="ms.sourcegitcommit" Value="2f78d0752398ee2d15afbf06143cb62a01dc6d71" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/14/2020" /><Meta Name="ms.locfileid" Value="88242414" /></Metadata><TypeSignature Language="C#" Value="public sealed class JsonSerializerOptions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit JsonSerializerOptions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Json.JsonSerializerOptions" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class JsonSerializerOptions" />
  <TypeSignature Language="C++ CLI" Value="public ref class JsonSerializerOptions sealed" />
  <TypeSignature Language="F#" Value="type JsonSerializerOptions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Json</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Optionen bereit, die mit der <see cref="T:System.Text.Json.JsonSerializer" />-Klasse verwendet werden sollen</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

Weitere Informationen finden Sie unter Gewusst [wie: Serialisieren und Deserialisieren von JSON](/dotnet/standard/serialization/system-text-json-how-to).

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JsonSerializerOptions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JsonSerializerOptions();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Json.JsonSerializerOptions" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JsonSerializerOptions (System.Text.Json.JsonSerializerDefaults defaults);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Text.Json.JsonSerializerDefaults defaults) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.#ctor(System.Text.Json.JsonSerializerDefaults)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaults As JsonSerializerDefaults)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JsonSerializerOptions(System::Text::Json::JsonSerializerDefaults defaults);" />
      <MemberSignature Language="F#" Value="new System.Text.Json.JsonSerializerOptions : System.Text.Json.JsonSerializerDefaults -&gt; System.Text.Json.JsonSerializerOptions" Usage="new System.Text.Json.JsonSerializerOptions defaults" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaults" Type="System.Text.Json.JsonSerializerDefaults" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="defaults">Der zu diskutierende <see cref="T:System.Text.Json.JsonSerializerDefaults" />.</param>
        <summary>Konstruiert eine neue <see cref="T:System.Text.Json.JsonSerializerOptions" />-Instanz mit einer vordefinierten Menge von Optionen, die durch die angegebenen <see cref="T:System.Text.Json.JsonSerializerDefaults" /> bestimmt wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JsonSerializerOptions (System.Text.Json.JsonSerializerOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.#ctor(System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (options As JsonSerializerOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JsonSerializerOptions(System::Text::Json::JsonSerializerOptions ^ options);" />
      <MemberSignature Language="F#" Value="new System.Text.Json.JsonSerializerOptions : System.Text.Json.JsonSerializerOptions -&gt; System.Text.Json.JsonSerializerOptions" Usage="new System.Text.Json.JsonSerializerOptions options" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="options">Die Optionsinstanz, aus der Optionen kopiert werden sollen.</param>
        <summary>Kopiert die Optionen aus einer <see cref="T:System.Text.Json.JsonSerializerOptions" />-Instanz in eine neue Instanz.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="options" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowTrailingCommas">
      <MemberSignature Language="C#" Value="public bool AllowTrailingCommas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowTrailingCommas" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.AllowTrailingCommas" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowTrailingCommas As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowTrailingCommas { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowTrailingCommas : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.AllowTrailingCommas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob ein zusätzliches Komma am Ende einer Liste von JSON-Werten in einem Objekt oder Array in der deserialisierten JSON-Nutzlast zulässig ist (und ignoriert wird)</summary>
        <value><see langword="true" /> , wenn ein zusätzliches Komma am Ende einer Liste von JSON-Werten in einem Objekt oder Array zulässig ist (und ignoriert wird); <see langword="false" /> andernfalls.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Standardmäßig `AllowTrailingCommas` ist auf festgelegt `false` , und <xref:System.Text.Json.JsonException> während der Deserialisierung wird eine ausgelöst, wenn ein nach gestelltes Komma auftritt.

Weitere Informationen finden Sie unter Gewusst [wie: Serialisieren und Deserialisieren von JSON](/dotnet/standard/serialization/system-text-json-how-to#allow-comments-and-trailing-commas).

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft wurde festgelegt, nachdem die Serialisierung oder Deserialisierung stattgefunden hat.</exception>
      </Docs>
    </Member>
    <Member MemberName="Converters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt;? Converters { get; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Text.Json.Serialization.JsonConverter&gt; Converters" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.Converters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Converters As IList(Of JsonConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Text::Json::Serialization::JsonConverter ^&gt; ^ Converters { System::Collections::Generic::IList&lt;System::Text::Json::Serialization::JsonConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Converters : System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt;" Usage="System.Text.Json.JsonSerializerOptions.Converters" />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt; Converters { get; }" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Liste der registrierten benutzerdefinierten Konverter ab</summary>
        <value>Die Liste der benutzerdefinierten Konverter.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Nach der Serialisierung oder Deserialisierung kann die Liste nicht geändert werden.

Weitere Informationen finden Sie unter [Vorgehensweise: Schreiben benutzerdefinierter Konverter](/dotnet/standard/serialization/system-text-json-converters-how-to#registration-sample---converters-collection).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultBufferSize">
      <MemberSignature Language="C#" Value="public int DefaultBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DefaultBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.DefaultBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DefaultBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBufferSize : int with get, set" Usage="System.Text.Json.JsonSerializerOptions.DefaultBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardpuffergröße in Byte ab, die beim Erstellen temporärer Puffer verwendet werden soll, oder legt diese fest.</summary>
        <value>Die Standardpuffergröße in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die Standardpuffergröße in Bytes ist 16.384.
Bei den meisten Arbeits Auslastungen ist die Standardgröße eine angemessene Menge an JSON, die beim Lesen aus einem Stream oder beim Schreiben in einen Stream gepuffert werden kann.
Das heißt, Sie führt eine gute Leistung aus, ohne Objekte auf dem Large Object Heap für den Garbage Collector (GC) zu erstellen, der nachverfolgt werden soll. In Szenarien ohne Streaming könnte das Erhöhen der Standardpuffergröße die Leistung für große JSON-Zeichen folgen oder UTF-8-Byte Arrays verbessern.
Es wird empfohlen, diesen Wert unverändert zu lassen, wenn er nicht geändert werden kann.


          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Puffergröße ist kleiner als 1.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft wurde festgelegt, nachdem die Serialisierung oder Deserialisierung stattgefunden hat.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIgnoreCondition">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.JsonIgnoreCondition DefaultIgnoreCondition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.Serialization.JsonIgnoreCondition DefaultIgnoreCondition" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.DefaultIgnoreCondition" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultIgnoreCondition As JsonIgnoreCondition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::Serialization::JsonIgnoreCondition DefaultIgnoreCondition { System::Text::Json::Serialization::JsonIgnoreCondition get(); void set(System::Text::Json::Serialization::JsonIgnoreCondition value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultIgnoreCondition : System.Text.Json.Serialization.JsonIgnoreCondition with get, set" Usage="System.Text.Json.JsonSerializerOptions.DefaultIgnoreCondition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonIgnoreCondition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt eine Bedingung an, um festzulegen, wann Eigenschaften mit Standardwerten bei der Serialisierung oder Deserialisierung ignoriert werden.
Der Standardwert ist <see cref="F:System.Text.Json.Serialization.JsonIgnoreCondition.Never" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Die Eigenschaft ist auf <see cref="F:System.Text.Json.Serialization.JsonIgnoreCondition.Always" /> festgelegt.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft wird festgelegt, nachdem die Serialisierung oder Deserialisierung stattgefunden hat.

- oder -

<see cref="P:System.Text.Json.JsonSerializerOptions.IgnoreNullValues" /> wurde auf <see langword="true" /> festgelegt. Diese Eigenschaften können nicht gleichzeitig verwendet werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="DictionaryKeyPolicy">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonNamingPolicy DictionaryKeyPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Json.JsonNamingPolicy DictionaryKeyPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.DictionaryKeyPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DictionaryKeyPolicy As JsonNamingPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonNamingPolicy ^ DictionaryKeyPolicy { System::Text::Json::JsonNamingPolicy ^ get(); void set(System::Text::Json::JsonNamingPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DictionaryKeyPolicy : System.Text.Json.JsonNamingPolicy with get, set" Usage="System.Text.Json.JsonSerializerOptions.DictionaryKeyPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonNamingPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Richtlinie ab, die zum Konvertieren des Namens eines <see cref="T:System.Collections.IDictionary" />-Schlüssels in ein anderes Format (z. B. die Camel-Case-Schreibweise) verwendet wird, oder legt sie fest.</summary>
        <value>Die Richtlinie, die verwendet wird, um einen <see cref="T:System.Collections.IDictionary" /> Schlüsselnamen in ein anderes Format zu konvertieren.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Eigenschaft kann auf festgelegt werden <xref:System.Text.Json.JsonNamingPolicy.CamelCase?displayProperty=nameWithType> , um eine Richtlinie für die Kamel-Schreibweise anzugeben.

Diese Eigenschaft kann auf festgelegt werden <xref:System.Text.Json.JsonNamingPolicy.CamelCase> , um eine Richtlinie für die Kamel-Schreibweise anzugeben.

Sie wird bei der Deserialisierung nicht verwendet.

Weitere Informationen finden Sie unter Gewusst [wie: Serialisieren und Deserialisieren von JSON](/dotnet/standard/serialization/system-text-json-how-to#camel-case-dictionary-keys).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Encoder">
      <MemberSignature Language="C#" Value="public System.Text.Encodings.Web.JavaScriptEncoder Encoder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encodings.Web.JavaScriptEncoder Encoder" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.Encoder" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoder As JavaScriptEncoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encodings::Web::JavaScriptEncoder ^ Encoder { System::Text::Encodings::Web::JavaScriptEncoder ^ get(); void set(System::Text::Encodings::Web::JavaScriptEncoder ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Encoder : System.Text.Encodings.Web.JavaScriptEncoder with get, set" Usage="System.Text.Json.JsonSerializerOptions.Encoder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encodings.Web.JavaScriptEncoder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Encoder ab oder legt den Encoder fest, der beim Versehen von Zeichenfolgen mit Escapezeichen verwendet wird, oder <see langword="null" />, um den Standardencoder zu verwenden.</summary>
        <value>Die JavaScript-Zeichencodierung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Weitere Informationen finden Sie unter Gewusst [wie: Serialisieren und Deserialisieren von JSON](/dotnet/standard/serialization/system-text-json-how-to#customize-character-encoding).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.JsonConverter GetConverter (Type typeToConvert);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.Json.Serialization.JsonConverter GetConverter(class System.Type typeToConvert) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.GetConverter(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConverter (typeToConvert As Type) As JsonConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::Json::Serialization::JsonConverter ^ GetConverter(Type ^ typeToConvert);" />
      <MemberSignature Language="F#" Value="member this.GetConverter : Type -&gt; System.Text.Json.Serialization.JsonConverter" Usage="jsonSerializerOptions.GetConverter typeToConvert" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeToConvert" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="typeToConvert">Der Typ, für den ein Konverter zurückgegeben wird</param>
        <summary>Gibt den Konverter für den angegebenen Typ zurück</summary>
        <returns>Der erste Konverter, der den angegebenen Typ unterstützt, oder <see langword="null" />, wenn kein Konverter vorhanden ist</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Weitere Informationen finden Sie unter Gewusst [wie: Serialisieren und Deserialisieren von JSON](/dotnet/standard/serialization/system-text-json-how-to#sample-factory-pattern-converter).

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der konfigurierte <see cref="System.Text.Json.Serialization.JsonConverter" /> für <paramref name="typeToConvert" /> gab einen ungültigen Konverter zurück.</exception>
        <exception cref="T:System.NotSupportedException">Es ist kein kompatibler <see cref="System.Text.Json.Serialization.JsonConverter" /> für <paramref name="typeToConvert" /> oder seine serialisierbaren Member vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="IgnoreNullValues">
      <MemberSignature Language="C#" Value="public bool IgnoreNullValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreNullValues" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.IgnoreNullValues" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreNullValues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreNullValues { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreNullValues : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.IgnoreNullValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der bestimmt, ob <see langword="null" />-Werte während der Serialisierung und Deserialisierung ignoriert werden, oder legt ihn fest. Der Standardwert ist <see langword="false" />.</summary>
        <value><see langword="true" /> So ignorieren Sie NULL-Werte während der Serialisierung und Deserialisierung andernfalls Siehe langword = "false"/ &gt; .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Weitere Informationen finden Sie unter [ausschließen aller NULL-Wert Eigenschaften](/dotnet/standard/serialization/system-text-json-how-to#exclude-all-null-value-properties) und [Ignorieren von NULL bei der Deserialisierung](/dotnet/standard/serialization/system-text-json-how-to#ignore-null-when-deserializing).

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft wurde festgelegt, nachdem die Serialisierung oder Deserialisierung stattgefunden hat.

- oder -

<see cref="P:System.Text.Json.JsonSerializerOptions.DefaultIgnoreCondition" /> wurde auf nicht auf einen Standardwert festgelegt. Diese Eigenschaften können nicht gleichzeitig verwendet werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="IgnoreReadOnlyProperties">
      <MemberSignature Language="C#" Value="public bool IgnoreReadOnlyProperties { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreReadOnlyProperties" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyProperties" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreReadOnlyProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreReadOnlyProperties { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreReadOnlyProperties : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der bestimmt, ob schreibgeschützte Eigenschaften während der Serialisierung ignoriert werden Der Standardwert ist <see langword="false" />.</summary>
        <value><see langword="true" /> So ignorieren Sie schreibgeschützte Eigenschaften während der Serialisierung andernfalls <see langword="false" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Eine Eigenschaft ist schreibgeschützt, wenn sie einen öffentlichen Getter, aber keinen öffentlichen Setter enthält. 

Schreibgeschützte Eigenschaften werden unabhängig von dieser Einstellung nicht deserialisiert.

Weitere Informationen finden Sie unter Gewusst [wie: Serialisieren und Deserialisieren von JSON](/dotnet/standard/serialization/system-text-json-how-to#exclude-all-read-only-properties).

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft wurde festgelegt, nachdem die Serialisierung oder Deserialisierung stattgefunden hat.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxDepth">
      <MemberSignature Language="C#" Value="public int MaxDepth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxDepth" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.MaxDepth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxDepth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxDepth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxDepth : int with get, set" Usage="System.Text.Json.JsonSerializerOptions.MaxDepth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die bei der Serialisierung oder Deserialisierung von JSON maximal zulässige Tiefe ab oder legt sie auf den Standardwert 0 (null) fest, wobei eine maximale Tiefe von 64 angegeben wird.</summary>
        <value>Die maximal zulässige Tiefe bei der Serialisierung oder Deserialisierung von JSON.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Wenn Sie diese Tiefe überschreiten, wird eine ausgelöst <xref:System.Text.Json.JsonException> .

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft wurde festgelegt, nachdem die Serialisierung oder Deserialisierung stattgefunden hat.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die maximale Tiefe wird auf einen negativen Wert festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="PropertyNameCaseInsensitive">
      <MemberSignature Language="C#" Value="public bool PropertyNameCaseInsensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PropertyNameCaseInsensitive" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.PropertyNameCaseInsensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyNameCaseInsensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PropertyNameCaseInsensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyNameCaseInsensitive : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.PropertyNameCaseInsensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der bestimmt, ob der Name einer Eigenschaft bei der Deserialisierung einen Vergleich ohne Beachtung der Groß-/Kleinschreibung verwendet. Der Standardwert ist <see langword="false" />.</summary>
        <value><see langword="true" /> So vergleichen Sie Eigenschaftsnamen unter Berücksichtigung der Groß-/Kleinschreibung andernfalls <see langword="false" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Der Vergleich ohne Berücksichtigung der Groß-/Kleinschreibung ist mit Leistungseinbußen verbunden (d. h., wenn `PropertyNameCaseInsensitive` ist `true` ).

Weitere Informationen finden Sie unter Gewusst [wie: Serialisieren und Deserialisieren von JSON](/dotnet/standard/serialization/system-text-json-how-to#case-insensitive-property-matching).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyNamingPolicy">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonNamingPolicy PropertyNamingPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Json.JsonNamingPolicy PropertyNamingPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.PropertyNamingPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyNamingPolicy As JsonNamingPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonNamingPolicy ^ PropertyNamingPolicy { System::Text::Json::JsonNamingPolicy ^ get(); void set(System::Text::Json::JsonNamingPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyNamingPolicy : System.Text.Json.JsonNamingPolicy with get, set" Usage="System.Text.Json.JsonSerializerOptions.PropertyNamingPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonNamingPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der die Richtlinie angibt, mit der der Name einer Eigenschaft in einem Objekt in ein anderes Format konvertiert wird (z. B. Camel-Case), oder <see langword="null" />, um die Eigenschaftsnamen unverändert zu lassen</summary>
        <value>Eine Benennungs Richtlinie für Eigenschaften oder, <see langword="null" /> um Eigenschaftsnamen unverändert zu lassen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Es wird erwartet, dass der resultierende Eigenschaftsname bei der Deserialisierung mit der JSON-Nutzlast übereinstimmt und beim Schreiben des Eigenschafts namens während der Serialisierung verwendet wird.

Die Richtlinie wird nicht für Eigenschaften verwendet, auf die ein <xref:System.Text.Json.Serialization.JsonPropertyNameAttribute> angewendet wird.

Diese Eigenschaft kann auf festgelegt werden <xref:System.Text.Json.JsonNamingPolicy.CamelCase?displayProperty=nameWithType> , um eine Richtlinie für die Kamel-Schreibweise anzugeben.

Weitere Informationen finden Sie unter Gewusst [wie: Serialisieren und Deserialisieren von JSON](/dotnet/standard/serialization/system-text-json-how-to#customize-json-names-and-values).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadCommentHandling">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonCommentHandling ReadCommentHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonCommentHandling ReadCommentHandling" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.ReadCommentHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadCommentHandling As JsonCommentHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonCommentHandling ReadCommentHandling { System::Text::Json::JsonCommentHandling get(); void set(System::Text::Json::JsonCommentHandling value); };" />
      <MemberSignature Language="F#" Value="member this.ReadCommentHandling : System.Text.Json.JsonCommentHandling with get, set" Usage="System.Text.Json.JsonSerializerOptions.ReadCommentHandling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonCommentHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der definiert, wie Kommentare während der Deserialisierung behandelt werden</summary>
        <value>Ein Wert, der angibt, ob Kommentare zulässig, unzulässig oder übersprungen werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Standardmäßig wird eine <xref:System.Text.Json.JsonException> während der Deserialisierung ausgelöst, wenn ein Kommentar auftritt.

Weitere Informationen finden Sie unter Gewusst [wie: Serialisieren und Deserialisieren von JSON](/dotnet/standard/serialization/system-text-json-how-to#allow-comments-and-trailing-commas).

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft wurde festgelegt, nachdem die Serialisierung oder Deserialisierung stattgefunden hat.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Enumeration für die Kommentarbehandlung wird auf einen Wert festgelegt, der nicht unterstützt wird (oder nicht innerhalb des <see cref="T:System.Text.Json.JsonCommentHandling" />-Enumeratiosbereichs liegt).</exception>
      </Docs>
    </Member>
    <Member MemberName="ReferenceHandler">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.ReferenceHandler ReferenceHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Json.Serialization.ReferenceHandler ReferenceHandler" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.ReferenceHandler" />
      <MemberSignature Language="VB.NET" Value="Public Property ReferenceHandler As ReferenceHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::Serialization::ReferenceHandler ^ ReferenceHandler { System::Text::Json::Serialization::ReferenceHandler ^ get(); void set(System::Text::Json::Serialization::ReferenceHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReferenceHandler : System.Text.Json.Serialization.ReferenceHandler with get, set" Usage="System.Text.Json.JsonSerializerOptions.ReferenceHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.ReferenceHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konfiguriert, wie Objektverweise beim Lesen und Schreiben von JSON behandelt werden sollen.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Standardmäßig werden Objekte mit Zyklen von der Serialisierung nicht unterstützt, und doppelte Verweise werden nicht beibehalten. Beim Serialisieren von Verweis Typen werden keine Metadateneigenschaften geschrieben und werden bei der Deserialisierung als reguläre Eigenschaften behandelt.
 
* Beim Serialisieren:

  * Behandelt doppelte Objekt Verweise so, als wären Sie eindeutig und schreibt alle zugehörigen Eigenschaften.
  * Das Serialisierungsprogramm löst eine aus, <xref:System.Text.Json.JsonException> Wenn ein-Objekt einen-Durchlauf enthält.

* Beim Deserialisieren:

  * Metadateneigenschaften ( `$id` , `$values` und `$ref` ) werden nicht verbraucht und werden daher als reguläre JSON-Eigenschaften behandelt.
  * Die Metadateneigenschaften können einer echten Eigenschaft für das zurückgegebene Objekt zugeordnet werden, wenn die Eigenschaftsnamen entsprechen, oder dem <xref:System.Text.Json.Serialization.JsonExtensionDataAttribute> Überlauf Wörterbuch hinzugefügt werden, sofern vorhanden. andernfalls werden Sie ignoriert.

Verwenden Sie <xref:System.Text.Json.Serialization.ReferenceHandler.Preserve> , um eine eindeutige Objekt Verweis Beibehaltung für die Serialisierung und den metadatenverbrauch zu aktivieren

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteIndented">
      <MemberSignature Language="C#" Value="public bool WriteIndented { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WriteIndented" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.WriteIndented" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteIndented As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WriteIndented { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WriteIndented : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.WriteIndented" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der definiert, ob JSON eine automatische Strukturierung und Einrückung verwenden soll. Standardmäßig wird JSON ohne zusätzlichen Leerraum serialisiert.</summary>
        <value><see langword="true" /> , wenn JSON bei der Serialisierung Recht gedruckt werden soll. andernfalls <see langword="false" /> . Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Ein hübsches Drucken umfasst Folgendes: 

- Geschaltete JSON-Token werden eingefügt.
- Neue Zeilen werden hinzugefügt
- Leerzeichen zwischen Eigenschaftsnamen und-Werten werden hinzugefügt. 

Weitere Informationen finden Sie unter Gewusst [wie: Serialisieren und Deserialisieren von JSON](/dotnet/standard/serialization/system-text-json-how-to#serialize-to-formatted-json).

         ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft wurde festgelegt, nachdem die Serialisierung oder Deserialisierung stattgefunden hat.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
