<Type Name="Utf8JsonReader" FullName="System.Text.Json.Utf8JsonReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7e3de822fc6bc069344292addd24eba53fba3652" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70528851" /></Metadata><TypeSignature Language="C#" Value="public struct Utf8JsonReader" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Utf8JsonReader extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Text.Json.Utf8JsonReader" />
  <TypeSignature Language="VB.NET" Value="Public Structure Utf8JsonReader" />
  <TypeSignature Language="C++ CLI" Value="public value class Utf8JsonReader" />
  <TypeSignature Language="F#" Value="type Utf8JsonReader = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Json</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine leistungsstarke API für schreibgeschützten Zugriff auf UTF-8-codierten JSON-Text in Vorwärtsrichtung bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

`Utf8JsonReader`verarbeitet den Text sequenziell ohne Zwischenspeichern und entspricht standardmäßig strikt der [JSON-RFC](https://tools.ietf.org/html/rfc8259).

Wenn `Utf8JsonReader` ein ungültiges JSON-Zeichen gefunden <xref:System.Text.Json.JsonException> wird, löst es eine mit grundlegenden Fehlerinformationen wie Zeilennummer und Byte Position in der Zeile aus.

Da dieser Typ eine Ref-Struktur ist, wird Async nicht direkt unterstützt. Es bietet jedoch Unterstützung für den erneuten eintreten zum Lesen unvollständiger Daten und zum weiteren lesen, wenn weitere Daten angezeigt werden.

Um die maximale Tiefe beim Lesen oder Zulassen von Kommentaren festlegen zu können, erstellen Sie eine Instanz von <xref:System.Text.Json.JsonReaderState> , und übergeben Sie Sie an den Reader.

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (System.Buffers.ReadOnlySequence&lt;byte&gt; jsonData, System.Text.Json.JsonReaderOptions options = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Buffers.ReadOnlySequence`1&lt;unsigned int8&gt; jsonData, valuetype System.Text.Json.JsonReaderOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte},System.Text.Json.JsonReaderOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySequence(Of Byte), Optional options As JsonReaderOptions = null)" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : System.Buffers.ReadOnlySequence&lt;byte&gt; * System.Text.Json.JsonReaderOptions -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.Buffers.ReadOnlySequence&lt;System.Byte&gt;" />
        <Parameter Name="options" Type="System.Text.Json.JsonReaderOptions" />
      </Parameters>
      <Docs>
        <param name="jsonData">Der zu verarbeitende UTF-8 codierte JSON-Text.</param>
        <param name="options">Ein Objekt, mit dem das benutzerdefinierte Verhalten für das <see cref="T:System.Text.Json.Utf8JsonReader" />-Element definiert wird, das sich vom JSON RFC unterscheidet (z. B. die Handhabung von Kommentaren oder die maximal zulässige Tiefe beim Lesen). In der Standardeinstellung folgt <see cref="T:System.Text.Json.Utf8JsonReader" /> streng dem JSON RFC. Kommentare im JSON-Code sind ungültig, und die maximale Tiefe beträgt 64.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Json.Utf8JsonReader" />-Struktur, mit der eine schreibgeschützte Sequenz mit UTF-8-codiertem Text verarbeitet wird, indem die angegebenen Optionen verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Da dieser Typ eine Ref-Struktur ist, handelt es sich um einen reinen Stapel Datentyp, und alle Einschränkungen von Verweis Strukturen gelten für ihn.

Dieser Konstruktor geht davon aus, dass die gesamte JSON- `jsonData`Nutzlast in enthalten ist, <xref:System.Text.Json.Utf8JsonReader.IsFinalBlock?displayProperty=nameWithType>und  =  `true`entspricht.
              
          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (ReadOnlySpan&lt;byte&gt; jsonData, System.Text.Json.JsonReaderOptions options = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; jsonData, valuetype System.Text.Json.JsonReaderOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.ReadOnlySpan{System.Byte},System.Text.Json.JsonReaderOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySpan(Of Byte), Optional options As JsonReaderOptions = null)" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : ReadOnlySpan&lt;byte&gt; * System.Text.Json.JsonReaderOptions -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="options" Type="System.Text.Json.JsonReaderOptions" />
      </Parameters>
      <Docs>
        <param name="jsonData">Der zu verarbeitende UTF-8 codierte JSON-Text.</param>
        <param name="options">Ein Objekt, mit dem das benutzerdefinierte Verhalten für das <see cref="T:System.Text.Json.Utf8JsonReader" />-Element definiert wird, das sich vom JSON RFC unterscheidet (z. B. die Handhabung von Kommentaren oder die maximal zulässige Tiefe beim Lesen). In der Standardeinstellung folgt <see cref="T:System.Text.Json.Utf8JsonReader" /> streng dem JSON RFC. Kommentare im JSON-Code sind ungültig, und die maximale Tiefe beträgt 64.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Json.Utf8JsonReader" />-Struktur, mit der ein schreibgeschützter Bereich mit UTF-8-codiertem Text verarbeitet wird, indem die angegebenen Optionen verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Da dieser Typ eine Ref-Struktur ist, handelt es sich um einen reinen Stapel Datentyp, und alle Einschränkungen von Verweis Strukturen gelten für ihn.

Dieser Konstruktor geht davon aus, dass die gesamte JSON- `jsonData`Nutzlast in enthalten ist, <xref:System.Text.Json.Utf8JsonReader.IsFinalBlock?displayProperty=nameWithType>und  =  `true`entspricht.
              
          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (System.Buffers.ReadOnlySequence&lt;byte&gt; jsonData, bool isFinalBlock, System.Text.Json.JsonReaderState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Buffers.ReadOnlySequence`1&lt;unsigned int8&gt; jsonData, bool isFinalBlock, valuetype System.Text.Json.JsonReaderState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte},System.Boolean,System.Text.Json.JsonReaderState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySequence(Of Byte), isFinalBlock As Boolean, state As JsonReaderState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Utf8JsonReader(System::Buffers::ReadOnlySequence&lt;System::Byte&gt; jsonData, bool isFinalBlock, System::Text::Json::JsonReaderState state);" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : System.Buffers.ReadOnlySequence&lt;byte&gt; * bool * System.Text.Json.JsonReaderState -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, isFinalBlock, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.Buffers.ReadOnlySequence&lt;System.Byte&gt;" />
        <Parameter Name="isFinalBlock" Type="System.Boolean" />
        <Parameter Name="state" Type="System.Text.Json.JsonReaderState" />
      </Parameters>
      <Docs>
        <param name="jsonData">Der zu verarbeitende UTF-8 codierte JSON-Text.</param>
        <param name="isFinalBlock"><see langword="true" />, wenn die Eingabesequenz die gesamten zu verarbeitenden Daten enthält. <see langword="false" />, wenn der Eingabebereich nur einen Teil der Daten enthält und weitere Daten später folgen.</param>
        <param name="state">Ein Objekt, das den Readerzustand enthält. Wenn dies der erste Aufruf des Konstruktors ist, übergeben Sie einen Standardzustand. Andernfalls erfassen Sie den Zustand aus der vorherigen Instanz von <see cref="T:System.Text.Json.Utf8JsonReader" />, und geben Sie diesen zurück.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Json.Utf8JsonReader" />-Struktur, mit der eine schreibgeschützte Sequenz mit UTF-8-codiertem Text verarbeitet und angegeben wird, ob die Eingabe den gesamten zu verarbeitenden Text enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Da dieser Typ eine Ref-Struktur ist, handelt es sich um einen reinen Stapel Datentyp, und alle Einschränkungen von Verweis Strukturen gelten für ihn.
Dies ist der Grund, warum der Konstruktor eine <xref:System.Text.Json.JsonReaderState>akzeptiert.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonReader (ReadOnlySpan&lt;byte&gt; jsonData, bool isFinalBlock, System.Text.Json.JsonReaderState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; jsonData, bool isFinalBlock, valuetype System.Text.Json.JsonReaderState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Text.Json.JsonReaderState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (jsonData As ReadOnlySpan(Of Byte), isFinalBlock As Boolean, state As JsonReaderState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Utf8JsonReader(ReadOnlySpan&lt;System::Byte&gt; jsonData, bool isFinalBlock, System::Text::Json::JsonReaderState state);" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonReader : ReadOnlySpan&lt;byte&gt; * bool * System.Text.Json.JsonReaderState -&gt; System.Text.Json.Utf8JsonReader" Usage="new System.Text.Json.Utf8JsonReader (jsonData, isFinalBlock, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="jsonData" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isFinalBlock" Type="System.Boolean" />
        <Parameter Name="state" Type="System.Text.Json.JsonReaderState" />
      </Parameters>
      <Docs>
        <param name="jsonData">Der zu verarbeitende UTF-8 codierte JSON-Text.</param>
        <param name="isFinalBlock"><see langword="true" />, wenn die Eingabesequenz die gesamten zu verarbeitenden Daten enthält. <see langword="false" />, wenn der Eingabebereich nur einen Teil der Daten enthält und weitere Daten später folgen.</param>
        <param name="state">Ein Objekt, das den Readerzustand enthält. Wenn es sich um den ersten Aufruf des Konstruktors handelt, sollte ein Standardzustand widergespiegelt werden. Andernfalls sollte der Zustand aus der vorherigen Instanz von <see cref="T:System.Text.Json.Utf8JsonReader" /> erfasst und zurückgegeben werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.Json.Utf8JsonReader" />-Struktur, mit der ein schreibgeschützter Bereich mit UTF-8-codiertem Text verarbeitet und angegeben wird, ob die Eingabe den gesamten zu verarbeitenden Text enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Da dieser Typ eine Ref-Struktur ist, handelt es sich um einen reinen Stapel Datentyp, und alle Einschränkungen von Verweis Strukturen gelten für ihn.
Dies ist der Grund, warum der Konstruktor eine <xref:System.Text.Json.JsonReaderState>akzeptiert.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BytesConsumed">
      <MemberSignature Language="C#" Value="public long BytesConsumed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 BytesConsumed" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.BytesConsumed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesConsumed As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long BytesConsumed { long get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesConsumed : int64" Usage="System.Text.Json.Utf8JsonReader.BytesConsumed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gesamte Anzahl von Bytes ab, die von dieser Instanz von <see cref="T:System.Text.Json.Utf8JsonReader" /> bisher verbraucht wurden.</summary>
        <value>Die bisher verbrauchte Gesamtanzahl von Bytes.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentDepth">
      <MemberSignature Language="C#" Value="public int CurrentDepth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentDepth" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.CurrentDepth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentDepth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentDepth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDepth : int" Usage="System.Text.Json.Utf8JsonReader.CurrentDepth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Tiefe des aktuellen Tokens ab.</summary>
        <value>Die Tiefe des aktuellen Tokens.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die `CurrentDepth` -Eigenschaft verfolgt die rekursive Tiefe der geschachtelten Objekte oder Arrays im bisher verarbeiteten JSON-Text.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentState">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonReaderState CurrentState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonReaderState CurrentState" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.CurrentState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentState As JsonReaderState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonReaderState CurrentState { System::Text::Json::JsonReaderState get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentState : System.Text.Json.JsonReaderState" Usage="System.Text.Json.Utf8JsonReader.CurrentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonReaderState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den aktuellen <see cref="T:System.Text.Json.Utf8JsonReader" />-Zustand ab, um ihn an einen <see cref="T:System.Text.Json.Utf8JsonReader" />-Konstruktor mit weiteren Daten zu übergeben.</summary>
        <value>Der aktuelle Reader-Zustand.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Im Gegensatz <xref:System.Text.Json.Utf8JsonReader>zum, bei dem es sich um eine Ref-Struktur handelt, kann der Zustand über die asynchrone/warte weite Grenzen hinweg Dieser Typ ist erforderlich, um Unterstützung für das asynchrone Lesen von Daten vor dem <xref:System.Text.Json.Utf8JsonReader>fortsetzen einer neuen Instanz von zu bieten.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBoolean">
      <MemberSignature Language="C#" Value="public bool GetBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetBoolean();" />
      <MemberSignature Language="F#" Value="member this.GetBoolean : unit -&gt; bool" Usage="utf8JsonReader.GetBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den nächsten JSON-Tokenwert aus der Quelle als einen <see cref="T:System.Boolean" />-Wert.</summary>
        <returns><see langword="true" />, wenn <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> den Wert <see cref="F:System.Text.Json.JsonTokenType.True" /> hat. <see langword="false" />, wenn <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> den Wert <see cref="F:System.Text.Json.JsonTokenType.False" /> hat.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der Wert des JSON-Tokens ist kein boolescher Wert (d.h. <see cref="F:System.Text.Json.JsonTokenType.True" /> oder <see cref="F:System.Text.Json.JsonTokenType.False" />).</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetByte">
      <MemberSignature Language="C#" Value="public byte GetByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8 GetByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetByte" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByte () As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Byte GetByte();" />
      <MemberSignature Language="F#" Value="member this.GetByte : unit -&gt; byte" Usage="utf8JsonReader.GetByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analysiert den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.Byte" />.</summary>
        <returns>Der Wert des UTF-8-codierten Tokens.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der Wert des JSON-Tokens ist keine <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <exception cref="T:System.FormatException">Das numerische Format des JSON-Tokenwerts ist falsch (enthält beispielsweise einen Bruch oder ist in wissenschaftlicher Notation geschrieben).
          
- oder -

Der JSON-Tokenwert stellt eine Zahl dar, die kleiner als <see cref="F:System.Byte.MinValue" /> oder größer als <see cref="F:System.Byte.MaxValue" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytesFromBase64">
      <MemberSignature Language="C#" Value="public byte[] GetBytesFromBase64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytesFromBase64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetBytesFromBase64" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytesFromBase64 () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytesFromBase64();" />
      <MemberSignature Language="F#" Value="member this.GetBytesFromBase64 : unit -&gt; byte[]" Usage="utf8JsonReader.GetBytesFromBase64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analysiert den Wert des aktuellen JSON-Tokens aus der Quelle und decodiert die Base64-codierte JSON-Zeichenfolge als Bytearray.</summary>
        <returns>Das Bytearray, das den Wert des aktuellen JSON-Tokens darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der Typ des JSON-Tokens ist kein <see cref="F:System.Text.Json.JsonTokenType.String" />.</exception>
        <exception cref="T:System.FormatException">Der Wert wird nicht als Base64-Text codiert und kann daher nicht in Bytes decodiert werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComment">
      <MemberSignature Language="C#" Value="public string GetComment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetComment" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComment () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComment();" />
      <MemberSignature Language="F#" Value="member this.GetComment : unit -&gt; string" Usage="utf8JsonReader.GetComment " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analysiert den Wert des aktuellen JSON-Tokens aus der Quelle als Kommentar, in einen <see cref="T:System.String" /> transcodiert.</summary>
        <returns>Der Kommentar, der den Wert des aktuellen JSON-Tokens darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Das JSON-Token ist kein Kommentar.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTime">
      <MemberSignature Language="C#" Value="public DateTime GetDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime GetDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime GetDateTime();" />
      <MemberSignature Language="F#" Value="member this.GetDateTime : unit -&gt; DateTime" Usage="utf8JsonReader.GetDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den nächsten JSON-Tokenwert aus der Quelle und analysiert ihn in einen <see cref="T:System.DateTime" />-Wert.</summary>
        <returns>Datum und Uhrzeit, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich analysiert werden kann.</returns>
        <remarks>Diese Methode erstellt nur eine DateTime-Darstellung von JSON-Zeichen folgen, die dem erweiterten ISO 8601-1-Format entsprechen (Weitere Informationen finden Sie [unter DateTime-und DateTimeOffset-Unterstützung in System. Text. JSON](~/docs/standard/datetime/system-text-json-support.md)).</remarks>
        <exception cref="T:System.InvalidOperationException">Der Wert des JSON-Tokens ist kein <see cref="F:System.Text.Json.JsonTokenType.String" />.</exception>
        <exception cref="T:System.FormatException">Der Wert des JSON-Tokens darf nicht als <see cref="T:System.DateTime" /> gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeOffset">
      <MemberSignature Language="C#" Value="public DateTimeOffset GetDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset GetDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeOffset () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset GetDateTimeOffset();" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeOffset : unit -&gt; DateTimeOffset" Usage="utf8JsonReader.GetDateTimeOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den nächsten JSON-Tokenwert aus der Quelle und analysiert ihn in einen <see cref="T:System.DateTimeOffset" />-Wert.</summary>
        <returns>Datum und Uhrzeit, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich analysiert werden kann.</returns>
        <remarks>Diese Methode erstellt nur eine DateTimeOffset-Darstellung von JSON-Zeichen folgen, die dem erweiterten ISO 8601-1-Format entsprechen (Weitere Informationen finden Sie [unter DateTime-und DateTimeOffset-Unterstützung in System. Text. JSON](~/docs/standard/datetime/system-text-json-support.md)).</remarks>
        <exception cref="T:System.InvalidOperationException">Der Wert des JSON-Tokens ist kein <see cref="F:System.Text.Json.JsonTokenType.String" />.</exception>
        <exception cref="T:System.FormatException">Der Wert des JSON-Tokens darf nicht als <see cref="T:System.DateTimeOffset" /> gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDecimal">
      <MemberSignature Language="C#" Value="public decimal GetDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Decimal GetDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Decimal GetDecimal();" />
      <MemberSignature Language="F#" Value="member this.GetDecimal : unit -&gt; decimal" Usage="utf8JsonReader.GetDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den nächsten JSON-Tokenwert aus der Quelle und analysiert ihn in einen <see cref="T:System.Decimal" />-Wert.</summary>
        <returns>Der in einen <see cref="T:System.Decimal" />-Wert analysierte UTF-8 codierte Tokenwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die `GetDecimal` -Methode löst eine Ausnahme aus, wenn der gesamte UTF-8-codierte Tokenwert nicht <xref:System.Decimal> in einen-Wert analysiert werden soll.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
        <exception cref="T:System.FormatException">Der JSON-Tokenwert stellt eine Zahl dar, die kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" /> ist.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetDouble">
      <MemberSignature Language="C#" Value="public double GetDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetDouble" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetDouble();" />
      <MemberSignature Language="F#" Value="member this.GetDouble : unit -&gt; double" Usage="utf8JsonReader.GetDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den nächsten JSON-Tokenwert aus der Quelle und analysiert ihn in einen <see cref="T:System.Double" />-Wert.</summary>
        <returns>Der in einen <see cref="T:System.Double" />-Wert analysierte UTF-8 codierte Tokenwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die `GetDouble` -Methode löst eine Ausnahme aus, wenn der gesamte UTF-8-codierte Tokenwert nicht <xref:System.Double> in einen-Wert analysiert werden soll.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
        <exception cref="T:System.FormatException">Der JSON-Tokenwert stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetGuid">
      <MemberSignature Language="C#" Value="public Guid GetGuid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Guid GetGuid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetGuid" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGuid () As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid GetGuid();" />
      <MemberSignature Language="F#" Value="member this.GetGuid : unit -&gt; Guid" Usage="utf8JsonReader.GetGuid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den nächsten JSON-Tokenwert aus der Quelle und analysiert ihn in einen <see cref="T:System.Guid" />-Wert.</summary>
        <returns>Der GUID-Wert, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich analysiert werden kann.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der Wert des JSON-Tokens ist kein <see cref="F:System.Text.Json.JsonTokenType.String" />.</exception>
        <exception cref="T:System.FormatException">Der Wert des JSON-Tokens liegt in einem für eine GUID nicht unterstützten Format vor.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt16">
      <MemberSignature Language="C#" Value="public short GetInt16 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int16 GetInt16() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetInt16" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInt16 () As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; short GetInt16();" />
      <MemberSignature Language="F#" Value="member this.GetInt16 : unit -&gt; int16" Usage="utf8JsonReader.GetInt16 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analysiert den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.Int16" />.</summary>
        <returns>Der in einen <see cref="T:System.Int16" />-Wert analysierte UTF-8 codierte Tokenwert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der Wert des JSON-Tokens ist keine <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <exception cref="T:System.FormatException">Das numerische Format des JSON-Tokenwerts ist falsch (enthält beispielsweise einen Bruch oder ist in wissenschaftlicher Notation geschrieben).
          
- oder -

Der JSON-Tokenwert stellt eine Zahl dar, die kleiner als <see cref="F:System.Int16.MinValue" /> oder größer als <see cref="F:System.Int16.MaxValue" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt32">
      <MemberSignature Language="C#" Value="public int GetInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInt32 () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetInt32();" />
      <MemberSignature Language="F#" Value="member this.GetInt32 : unit -&gt; int" Usage="utf8JsonReader.GetInt32 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den nächsten JSON-Tokenwert aus der Quelle und analysiert ihn in einen <see cref="T:System.Int32" />-Wert.</summary>
        <returns>Der in einen <see cref="T:System.Int32" />-Wert analysierte UTF-8 codierte Tokenwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die `GetInt32` -Methode löst eine Ausnahme aus, wenn der gesamte UTF-8-codierte Tokenwert nicht <xref:System.Int32> in einen-Wert analysiert werden soll.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
        <exception cref="T:System.FormatException">Der JSON-Tokenwert hat das falsche numerische Format. Er enthält z.B. eine Dezimalzahl oder ist in wissenschaftlicher Schreibweise geschrieben.
            
- oder -

Der JSON-Tokenwert stellt eine Zahl dar, die kleiner als <see cref="F:System.Int32.MinValue" /> oder größer als <see cref="F:System.Int32.MaxValue" /> ist.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetInt64">
      <MemberSignature Language="C#" Value="public long GetInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInt64 () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetInt64();" />
      <MemberSignature Language="F#" Value="member this.GetInt64 : unit -&gt; int64" Usage="utf8JsonReader.GetInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den nächsten JSON-Tokenwert aus der Quelle und analysiert ihn in einen <see cref="T:System.Int64" />-Wert.</summary>
        <returns>Der in einen <see cref="T:System.Int64" />-Wert analysierte UTF-8 codierte Tokenwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die `GetInt64` -Methode löst eine Ausnahme aus, wenn der gesamte UTF-8-codierte Tokenwert nicht <xref:System.Int64> in einen-Wert analysiert werden soll.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
        <exception cref="T:System.FormatException">Der JSON-Tokenwert hat das falsche numerische Format. Er enthält z.B. eine Dezimalzahl oder ist in wissenschaftlicher Schreibweise geschrieben.
            
- oder -

Der JSON-Tokenwert stellt eine Zahl dar, die kleiner als <see cref="F:System.Int64.MinValue" /> oder größer als <see cref="F:System.Int64.MaxValue" /> ist.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetSByte">
      <MemberSignature Language="C#" Value="public sbyte GetSByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int8 GetSByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetSByte" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSByte () As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::SByte GetSByte();" />
      <MemberSignature Language="F#" Value="member this.GetSByte : unit -&gt; sbyte" Usage="utf8JsonReader.GetSByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analysiert den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.SByte" />.</summary>
        <returns>Der in einen <see cref="T:System.SByte" />-Wert analysierte UTF-8 codierte Tokenwert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der Wert des JSON-Tokens ist keine <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <exception cref="T:System.FormatException">Das numerische Format des JSON-Tokenwerts ist falsch (enthält beispielsweise einen Bruch oder ist in wissenschaftlicher Notation geschrieben).
          
- oder -

Der JSON-Tokenwert stellt eine Zahl dar, die kleiner als <see cref="F:System.SByte.MinValue" /> oder größer als <see cref="F:System.SByte.MaxValue" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSingle">
      <MemberSignature Language="C#" Value="public float GetSingle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float32 GetSingle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetSingle" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSingle () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float GetSingle();" />
      <MemberSignature Language="F#" Value="member this.GetSingle : unit -&gt; single" Usage="utf8JsonReader.GetSingle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den nächsten JSON-Tokenwert aus der Quelle und analysiert ihn in einen <see cref="T:System.Single" />-Wert.</summary>
        <returns>Der in einen <see cref="T:System.Single" />-Wert analysierte UTF-8 codierte Tokenwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die `GetSingle` -Methode löst eine Ausnahme aus, wenn der gesamte UTF-8-codierte Tokenwert nicht <xref:System.Single> in einen-Wert analysiert werden soll.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
        <exception cref="T:System.FormatException">Der JSON-Tokenwert stellt eine Zahl dar, die kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" /> ist.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetString" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString();" />
      <MemberSignature Language="F#" Value="member this.GetString : unit -&gt; string" Usage="utf8JsonReader.GetString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den nächsten JSON-Tokenwert aus der Quelle (ohne Escapezeichen und als Zeichenfolge transcodiert).</summary>
        <returns>Der in eine Zeichenfolge analysierte Tokenwert oder <see langword="null" />, wenn <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> auf <see cref="F:System.Text.Json.JsonTokenType.Null" /> festgelegt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Gibt `null` zurück <xref:System.Text.Json.Utf8JsonReader.TokenType> , <xref:System.Text.Json.JsonTokenType.Null?displayProperty=nameWithType>wenn ist.

          ]]></format>
        </remarks>
         <exception cref="T:System.InvalidOperationException">Der Wert des JSON-Tokens ist keine Zeichenfolge (d. h. keine <see cref="F:System.Text.Json.JsonTokenType.String" />-, <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />- oder <see cref="F:System.Text.Json.JsonTokenType.Null" />-Enumeration).

- oder -

Die JSON-Zeichenfolge enthält ungültige UTF-8-Bytes oder ungültige UTF-16-Ersatzzeichen.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetUInt16">
      <MemberSignature Language="C#" Value="public ushort GetUInt16 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int16 GetUInt16() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetUInt16" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUInt16 () As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt16 GetUInt16();" />
      <MemberSignature Language="F#" Value="member this.GetUInt16 : unit -&gt; uint16" Usage="utf8JsonReader.GetUInt16 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analysiert den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.UInt16" />.</summary>
        <returns>Der in einen <see cref="T:System.UInt16" />-Wert analysierte UTF-8 codierte Tokenwert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der Wert des JSON-Tokens ist keine <see cref="F:System.Text.Json.JsonTokenType.Number" />.</exception>
        <exception cref="T:System.FormatException">Das numerische Format des JSON-Tokenwerts ist falsch (enthält beispielsweise einen Bruch oder ist in wissenschaftlicher Notation geschrieben).
          
- oder -

Der JSON-Tokenwert stellt eine Zahl dar, die kleiner als <see cref="F:System.UInt16.MinValue" /> oder größer als <see cref="F:System.UInt16.MaxValue" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetUInt32">
      <MemberSignature Language="C#" Value="public uint GetUInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int32 GetUInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetUInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUInt32 () As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt32 GetUInt32();" />
      <MemberSignature Language="F#" Value="member this.GetUInt32 : unit -&gt; uint32" Usage="utf8JsonReader.GetUInt32 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den nächsten JSON-Tokenwert aus der Quelle und analysiert ihn in einen <see cref="T:System.UInt32" />-Wert.</summary>
        <returns>Der in einen <see cref="T:System.UInt32" />-Wert analysierte UTF-8 codierte Tokenwert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
        <exception cref="T:System.FormatException">Der JSON-Tokenwert hat das falsche numerische Format. Er enthält z.B. eine Dezimalzahl oder ist in wissenschaftlicher Schreibweise geschrieben.

- oder -

Der JSON-Tokenwert stellt eine Zahl dar, die kleiner als <see cref="F:System.UInt32.MinValue" /> oder größer als <see cref="F:System.UInt32.MaxValue" /> ist.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="GetUInt64">
      <MemberSignature Language="C#" Value="public ulong GetUInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int64 GetUInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.GetUInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUInt64 () As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt64 GetUInt64();" />
      <MemberSignature Language="F#" Value="member this.GetUInt64 : unit -&gt; uint64" Usage="utf8JsonReader.GetUInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den nächsten JSON-Tokenwert aus der Quelle und analysiert ihn in einen <see cref="T:System.UInt64" />-Wert.</summary>
        <returns>Der in einen <see cref="T:System.UInt64" />-Wert analysierte UTF-8 codierte Tokenwert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
        <exception cref="T:System.FormatException">Der JSON-Tokenwert hat das falsche numerische Format. Er enthält z.B. eine Dezimalzahl oder ist in wissenschaftlicher Schreibweise geschrieben.
            
- oder -

Der JSON-Tokenwert stellt eine Zahl dar, die kleiner als <see cref="F:System.UInt64.MinValue" /> oder größer als <see cref="F:System.UInt64.MaxValue" /> ist.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="HasValueSequence">
      <MemberSignature Language="C#" Value="public bool HasValueSequence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValueSequence" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.HasValueSequence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValueSequence As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValueSequence { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValueSequence : bool" Usage="System.Text.Json.Utf8JsonReader.HasValueSequence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert an, der angibt, welche <c>Value</c>-Eigenschaft zum Abrufen des Tokenwerts zu verwenden ist.</summary>
        <value><see langword="true" />, <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> wenn verwendet werden soll, um den Tokenwert zu erhalten. <see langword="false" /> Wenn <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" />  stattdessen verwendet werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Wenn `HasValueSequence` ist `false` , <xref:System.Text.Json.Utf8JsonReader.ValueSequence>  ist leer. Lesen Sie daher den Tokenwert mithilfe <xref:System.Text.Json.Utf8JsonReader.ValueSpan> der-Eigenschaft.

Für Eingabedaten in einem `ReadOnlySpan<byte>`gibt dies immer zurück `false`. Bei Eingabedaten in einem `ReadOnlySequence<byte>`gibt dies nur dann `true` zurück, wenn der Tokenwert mehr als ein einzelnes Segment überschreitet und daher nicht als Spanne dargestellt werden kann.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalBlock">
      <MemberSignature Language="C#" Value="public bool IsFinalBlock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinalBlock" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.IsFinalBlock" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFinalBlock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFinalBlock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFinalBlock : bool" Usage="System.Text.Json.Utf8JsonReader.IsFinalBlock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Modus dieser Instanz von <see cref="T:System.Text.Json.Utf8JsonReader" /> ab, der angibt, ob die gesamten JSON-Daten übergeben wurden oder weitere folgen.</summary>
        <value><see langword="true" />, wenn der Reader mit der Eingabe Spanne oder Sequenz erstellt wurde, die die gesamten JSON-Daten enthält, die verarbeitet werden sollen. <see langword="false" /> , wenn der Reader mit einer Eingabe Spanne oder Sequenz erstellt wurde, die möglicherweise partielle JSON-Daten mit weiteren Daten enthält, die befolgt werden sollen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public SequencePosition Position { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.SequencePosition Position" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.Position" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Position As SequencePosition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property SequencePosition Position { SequencePosition get(); };" />
      <MemberSignature Language="F#" Value="member this.Position : SequencePosition" Usage="System.Text.Json.Utf8JsonReader.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SequencePosition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle <see cref="T:System.SequencePosition" /> innerhalb des bereitgestellten UTF-8-codierten ReadOnlySequence&lt;Byte&gt; der Eingabe oder einen <see cref="T:System.SequencePosition" />-Standardwert ab, wenn die <see cref="T:System.Text.Json.Utf8JsonReader" />-Struktur mit einem ReadOnlySpan&lt;Byte&gt; erstellt wurde.</summary>
        <value>Der aktuelle <see cref="T:System.SequencePosition" /> innerhalb des bereitgestellten UTF-8-codierten Eingabe-sequenzbyte <see cref="T:System.SequencePosition" /> &gt;&lt;&gt; oder <see cref="T:System.Text.Json.Utf8JsonReader" /> ein Standardwert, wenn die Struktur mit einem&lt;Read-lyspan-Byte erstellt wurde.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Read();" />
      <MemberSignature Language="F#" Value="member this.Read : unit -&gt; bool" Usage="utf8JsonReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das nächste JSON-Token aus der Eingabequelle.</summary>
        <returns><see langword="false" />, wenn das Token erfolgreich gelesen wurde, andernfalls <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Text.Json.JsonException">Ein gemäß JSON RFC ungültiges JSON-Token wurde festgestellt.
        
- oder -

Die aktuelle Tiefe übersteigt den rekursiven Grenzwert, der durch die maximale Tiefe festgelegt ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Skip();" />
      <MemberSignature Language="F#" Value="member this.Skip : unit -&gt; unit" Usage="utf8JsonReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überspringt die untergeordneten Elemente des aktuellen JSON-Tokens.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Wenn  <xref:System.Text.Json.Utf8JsonReader.TokenType> den Wert hat, wechselt der Reader zuerst in den-Eigenschafts Wert. <xref:System.Text.Json.JsonTokenType.PropertyName?displayProperty=nameWithType>

Wenn <xref:System.Text.Json.Utf8JsonReader.TokenType> (ursprünglich oder nach der Weiterentwicklung) <xref:System.Text.Json.JsonTokenType.StartObject?displayProperty=nameWithtype> oder <xref:System.Text.Json.JsonTokenType.StartArray?displayProperty=nameWithType>ist, wechselt der Reader zum passenden <xref:System.Text.Json.JsonTokenType.EndObject?displayProperty=nameWithType> oder <xref:System.Text.Json.JsonTokenType.EndArray?displayProperty=nameWithType>.
            
Für alle anderen Tokentypen wird der Reader nicht verschoben. Nach dem nächsten <xref:System.Text.Json.Utf8JsonReader.Read>-Vorgang wird der Reader beim nächsten Wert (in einem Array), beim nächsten Eigenschaftsnamen (bei einem-Objekt) oder beim endarray-/Objekttoken verwendet.

            ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Dem Reader wurden Teildaten übergeben, und weitere Daten folgen (d.h., <see cref="P:System.Text.Json.Utf8JsonReader.IsFinalBlock" /> ist <see langword="false" />).</exception>
        <exception cref="T:System.Text.Json.JsonException">Beim Überspringen wurde ein gemäß JSON-RFC ungültiges JSON-Token gefunden.

- oder -

Die aktuelle Tiefe übersteigt den rekursiven Grenzwert, der durch die maximale Tiefe festgelegt ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="TokenStartIndex">
      <MemberSignature Language="C#" Value="public long TokenStartIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 TokenStartIndex" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.TokenStartIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TokenStartIndex As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long TokenStartIndex { long get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenStartIndex : int64" Usage="System.Text.Json.Utf8JsonReader.TokenStartIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Index ab, an dem das zuletzt verarbeitete JSON-Token beginnt (innerhalb des angegebenen UTF-8-codierten Eingabetexts), wobei Leerraum übersprungen wird.</summary>
        <value>Der Start Index des letzten verarbeiteten JSON-Tokens innerhalb des angegebenen UTF-8-codierten Eingabe Texts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Bei JSON-Zeichen folgen (einschließlich Eigenschaftsnamen) verweist dieser Wert auf vor dem Start Anführungszeichen.

Für Kommentare verweist dieser Wert auf vor dem ersten Kommentar Trennzeichen (d. h. "/").

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonTokenType TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonTokenType TokenType" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TokenType As JsonTokenType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonTokenType TokenType { System::Text::Json::JsonTokenType get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : System.Text.Json.JsonTokenType" Usage="System.Text.Json.Utf8JsonReader.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonTokenType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des zuletzt verarbeiteten JSON-Tokens im UTF-8-codierten JSON-Text ab.</summary>
        <value>Der Typ des zuletzt verarbeiteten JSON-Tokens.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetByte">
      <MemberSignature Language="C#" Value="public bool TryGetByte (out byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetByte([out] unsigned int8&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetByte(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetByte (ByRef value As Byte) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetByte([Runtime::InteropServices::Out] System::Byte % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetByte :  -&gt; bool" Usage="utf8JsonReader.TryGetByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wenn diese Methode zurückgegeben wird, enthält sie den analysierten Wert.</param>
        <summary>Es wird versucht, den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.Byte" /> zu analysieren, und es wird ein Wert zurückgegeben, mit dem der Erfolg bzw. Misserfolg des Vorgangs angegeben wird.</summary>
        <returns><see langword="true" />, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich in einen <see cref="T:System.Byte" />-Wert analysiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetBytesFromBase64">
      <MemberSignature Language="C#" Value="public bool TryGetBytesFromBase64 (out byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetBytesFromBase64([out] unsigned int8[]&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetBytesFromBase64(System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetBytesFromBase64 (ByRef value As Byte()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetBytesFromBase64([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetBytesFromBase64 :  -&gt; bool" Usage="utf8JsonReader.TryGetBytesFromBase64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wenn diese Methode zurückgegeben wird, ist die decodierte binäre Darstellung des Base64-Texts enthalten.</param>
        <summary>Es wird versucht, den aktuellen JSON-Tokenwert aus der Quelle zu analysieren. Die Base64-codierte JSON-Zeichenfolge wird als Bytearray decodiert, und es wird ein Wert zurückgegeben, mit dem der Erfolg bzw. Misserfolg des Vorgangs angegeben wird.</summary>
        <returns><see langword="true" />, wenn der gesamte Tokenwert als gültiger Base64-Text codiert ist und erfolgreich in Bytes decodiert werden kann; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Das JSON-Token ist kein <see cref="F:System.Text.Json.JsonTokenType.String" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetDateTime">
      <MemberSignature Language="C#" Value="public bool TryGetDateTime (out DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDateTime([out] valuetype System.DateTime&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDateTime(System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDateTime (ByRef value As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDateTime([Runtime::InteropServices::Out] DateTime % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDateTime :  -&gt; bool" Usage="utf8JsonReader.TryGetDateTime value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wenn diese Methode zurückgegeben wird, enthält sie den analysierten Wert.</param>
        <summary>Es wird versucht, den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.DateTime" /> zu analysieren, und es wird ein Wert zurückgegeben, mit dem der Erfolg bzw. Misserfolg des Vorgangs angegeben wird.</summary>
        <returns><see langword="true" />, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich in einen <see cref="T:System.DateTime" />-Wert analysiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>Diese Methode erstellt nur eine DateTime-Darstellung von JSON-Zeichen folgen, die dem erweiterten ISO 8601-1-Format entsprechen (Weitere Informationen finden Sie [unter DateTime-und DateTimeOffset-Unterstützung in System. Text. JSON](~/docs/standard/datetime/system-text-json-support.md)).</remarks>
        <exception cref="T:System.InvalidOperationException">Der Wert des JSON-Tokens ist kein <see cref="F:System.Text.Json.JsonTokenType.String" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetDateTimeOffset">
      <MemberSignature Language="C#" Value="public bool TryGetDateTimeOffset (out DateTimeOffset value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDateTimeOffset([out] valuetype System.DateTimeOffset&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDateTimeOffset(System.DateTimeOffset@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDateTimeOffset (ByRef value As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDateTimeOffset([Runtime::InteropServices::Out] DateTimeOffset % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDateTimeOffset :  -&gt; bool" Usage="utf8JsonReader.TryGetDateTimeOffset value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTimeOffset" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wenn diese Methode zurückgegeben wird, enthält sie den analysierten Wert.</param>
        <summary>Es wird versucht, den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.DateTimeOffset" /> zu analysieren, und es wird ein Wert zurückgegeben, mit dem der Erfolg bzw. Misserfolg des Vorgangs angegeben wird.</summary>
        <returns><see langword="true" />, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich in einen <see cref="T:System.DateTimeOffset" />-Wert analysiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>Diese Methode erstellt nur eine DateTimeOffset-Darstellung von JSON-Zeichen folgen, die dem erweiterten ISO 8601-1-Format entsprechen (Weitere Informationen finden Sie [unter DateTime-und DateTimeOffset-Unterstützung in System. Text. JSON](~/docs/standard/datetime/system-text-json-support.md)).</remarks>
        <exception cref="T:System.InvalidOperationException">Der Wert des JSON-Tokens ist kein <see cref="F:System.Text.Json.JsonTokenType.String" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetDecimal">
      <MemberSignature Language="C#" Value="public bool TryGetDecimal (out decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDecimal([out] valuetype System.Decimal&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDecimal(System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDecimal (ByRef value As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDecimal([Runtime::InteropServices::Out] System::Decimal % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDecimal :  -&gt; bool" Usage="utf8JsonReader.TryGetDecimal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wenn diese Methode zurückgegeben wird, enthält sie den analysierten Wert.</param>
        <summary>Es wird versucht, den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.Decimal" /> zu analysieren, und es wird ein Wert zurückgegeben, mit dem der Erfolg bzw. Misserfolg des Vorgangs angegeben wird.</summary>
        <returns><see langword="true" />, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich in einen <see cref="T:System.Decimal" />-Wert analysiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetDouble">
      <MemberSignature Language="C#" Value="public bool TryGetDouble (out double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDouble([out] float64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetDouble(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDouble (ByRef value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDouble([Runtime::InteropServices::Out] double % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDouble :  -&gt; bool" Usage="utf8JsonReader.TryGetDouble value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wenn diese Methode zurückgegeben wird, enthält sie den analysierten Wert.</param>
        <summary>Es wird versucht, den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.Double" /> zu analysieren, und es wird ein Wert zurückgegeben, mit dem der Erfolg bzw. Misserfolg des Vorgangs angegeben wird.</summary>
        <returns><see langword="true" />, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich in einen <see cref="T:System.Double" />-Wert analysiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetGuid">
      <MemberSignature Language="C#" Value="public bool TryGetGuid (out Guid value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetGuid([out] valuetype System.Guid&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetGuid(System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetGuid (ByRef value As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetGuid([Runtime::InteropServices::Out] Guid % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetGuid :  -&gt; bool" Usage="utf8JsonReader.TryGetGuid value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Guid" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wenn diese Methode zurückgegeben wird, enthält sie den analysierten Wert.</param>
        <summary>Es wird versucht, den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.Guid" /> zu analysieren, und es wird ein Wert zurückgegeben, mit dem der Erfolg bzw. Misserfolg des Vorgangs angegeben wird.</summary>
        <returns><see langword="true" />, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich in einen <see cref="T:System.Guid" />-Wert analysiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Methode analysiert <xref:System.Guid> nur Werte mit Bindestrichen und ohne umgebende Dekorationen. 

         ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Wert des JSON-Tokens ist kein <see cref="F:System.Text.Json.JsonTokenType.String" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetInt16">
      <MemberSignature Language="C#" Value="public bool TryGetInt16 (out short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetInt16([out] int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetInt16(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetInt16 (ByRef value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetInt16([Runtime::InteropServices::Out] short % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetInt16 :  -&gt; bool" Usage="utf8JsonReader.TryGetInt16 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wenn diese Methode zurückgegeben wird, enthält sie den analysierten Wert.</param>
        <summary>Es wird versucht, den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.Int16" /> zu analysieren, und es wird ein Wert zurückgegeben, mit dem der Erfolg bzw. Misserfolg des Vorgangs angegeben wird.</summary>
        <returns><see langword="true" />, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich in einen <see cref="T:System.Int16" />-Wert analysiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetInt32">
      <MemberSignature Language="C#" Value="public bool TryGetInt32 (out int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetInt32([out] int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetInt32(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetInt32 (ByRef value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetInt32([Runtime::InteropServices::Out] int % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetInt32 :  -&gt; bool" Usage="utf8JsonReader.TryGetInt32 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wenn diese Methode zurückgegeben wird, enthält sie den analysierten Wert.</param>
        <summary>Es wird versucht, den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.Int32" /> zu analysieren, und es wird ein Wert zurückgegeben, mit dem der Erfolg bzw. Misserfolg des Vorgangs angegeben wird.</summary>
        <returns><see langword="true" />, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich in einen <see cref="T:System.Int32" />-Wert analysiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetInt64">
      <MemberSignature Language="C#" Value="public bool TryGetInt64 (out long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetInt64([out] int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetInt64(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetInt64 (ByRef value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetInt64([Runtime::InteropServices::Out] long % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetInt64 :  -&gt; bool" Usage="utf8JsonReader.TryGetInt64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wenn diese Methode zurückgegeben wird, enthält sie den analysierten Wert.</param>
        <summary>Es wird versucht, den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.Int64" /> zu analysieren, und es wird ein Wert zurückgegeben, mit dem der Erfolg bzw. Misserfolg des Vorgangs angegeben wird.</summary>
        <returns><see langword="true" />, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich in einen <see cref="T:System.Int64" />-Wert analysiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetSByte">
      <MemberSignature Language="C#" Value="public bool TryGetSByte (out sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetSByte([out] int8&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetSByte(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetSByte (ByRef value As SByte) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetSByte([Runtime::InteropServices::Out] System::SByte % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetSByte :  -&gt; bool" Usage="utf8JsonReader.TryGetSByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wenn diese Methode zurückgegeben wird, enthält sie den analysierten Wert.</param>
        <summary>Es wird versucht, den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.SByte" /> zu analysieren, und es wird ein Wert zurückgegeben, mit dem der Erfolg bzw. Misserfolg des Vorgangs angegeben wird.</summary>
        <returns><see langword="true" />, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich in einen <see cref="T:System.SByte" />-Wert analysiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetSingle">
      <MemberSignature Language="C#" Value="public bool TryGetSingle (out float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetSingle([out] float32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetSingle(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetSingle (ByRef value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetSingle([Runtime::InteropServices::Out] float % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetSingle :  -&gt; bool" Usage="utf8JsonReader.TryGetSingle value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wenn diese Methode zurückgegeben wird, enthält sie den analysierten Wert.</param>
        <summary>Es wird versucht, den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.Single" /> zu analysieren, und es wird ein Wert zurückgegeben, mit dem der Erfolg bzw. Misserfolg des Vorgangs angegeben wird.</summary>
        <returns><see langword="true" />, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich in einen <see cref="T:System.Single" />-Wert analysiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetUInt16">
      <MemberSignature Language="C#" Value="public bool TryGetUInt16 (out ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetUInt16([out] unsigned int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetUInt16(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetUInt16 (ByRef value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetUInt16([Runtime::InteropServices::Out] System::UInt16 % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetUInt16 :  -&gt; bool" Usage="utf8JsonReader.TryGetUInt16 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wenn diese Methode zurückgegeben wird, enthält sie den analysierten Wert.</param>
        <summary>Es wird versucht, den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.UInt16" /> zu analysieren, und es wird ein Wert zurückgegeben, mit dem der Erfolg bzw. Misserfolg des Vorgangs angegeben wird.</summary>
        <returns><see langword="true" />, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich in einen <see cref="T:System.UInt16" />-Wert analysiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetUInt32">
      <MemberSignature Language="C#" Value="public bool TryGetUInt32 (out uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetUInt32([out] unsigned int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetUInt32(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetUInt32 (ByRef value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetUInt32([Runtime::InteropServices::Out] System::UInt32 % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetUInt32 :  -&gt; bool" Usage="utf8JsonReader.TryGetUInt32 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wenn diese Methode zurückgegeben wird, enthält sie den analysierten Wert.</param>
        <summary>Es wird versucht, den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.UInt32" /> zu analysieren, und es wird ein Wert zurückgegeben, mit dem der Erfolg bzw. Misserfolg des Vorgangs angegeben wird.</summary>
        <returns><see langword="true" />, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich in einen <see cref="T:System.UInt32" />-Wert analysiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TryGetUInt64">
      <MemberSignature Language="C#" Value="public bool TryGetUInt64 (out ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetUInt64([out] unsigned int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TryGetUInt64(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetUInt64 (ByRef value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetUInt64([Runtime::InteropServices::Out] System::UInt64 % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetUInt64 :  -&gt; bool" Usage="utf8JsonReader.TryGetUInt64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wenn diese Methode zurückgegeben wird, enthält sie den analysierten Wert.</param>
        <summary>Es wird versucht, den aktuellen JSON-Tokenwert aus der Quelle als <see cref="T:System.UInt64" /> zu analysieren, und es wird ein Wert zurückgegeben, mit dem der Erfolg bzw. Misserfolg des Vorgangs angegeben wird.</summary>
        <returns><see langword="true" />, wenn der gesamte UTF-8-codierte Tokenwert erfolgreich in einen <see cref="T:System.UInt64" />-Wert analysiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der JSON-Tokenwert ist kein <see cref="F:System.Text.Json.JsonTokenType.Number" />-Wert.</exception>
        <altmember cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
      </Docs>
    </Member>
    <Member MemberName="TrySkip">
      <MemberSignature Language="C#" Value="public bool TrySkip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySkip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.TrySkip" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySkip () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySkip();" />
      <MemberSignature Language="F#" Value="member this.TrySkip : unit -&gt; bool" Usage="utf8JsonReader.TrySkip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versucht, die untergeordneten Elemente des aktuellen JSON-Tokens zu überspringen.</summary>
        <returns><see langword="true" /> wenn genügend Daten vorhanden waren, um die untergeordneten Elemente erfolgreich zu überspringen; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Wenn der Reader nicht über genügend Daten verfügt, um die untergeordneten Elemente des aktuellen Tokens vollständig zu überspringen, wird er auf den Zustand zurückgesetzt, in dem er sich vor dem Aufrufen der-Methode befand.
              
Wenn  <xref:System.Text.Json.Utf8JsonReader.TokenType> den Wert hat, wechselt der Reader zuerst in den-Eigenschafts Wert. <xref:System.Text.Json.JsonTokenType.PropertyName?displayProperty=nameWithType>

Wenn <xref:System.Text.Json.Utf8JsonReader.TokenType> (ursprünglich oder nach der Weiterentwicklung) <xref:System.Text.Json.JsonTokenType.StartObject?displayProperty=nameWithType> oder <xref:System.Text.Json.JsonTokenType.StartArray?displayProperty=nameWithType>ist, wechselt der Reader zum passenden <xref:System.Text.Json.JsonTokenType.EndObject?displayProperty=nameWithType> oder <xref:System.Text.Json.JsonTokenType.EndArray?displayProperty=nameWithType>.
            
Für alle anderen Tokentypen wird der Reader nicht verschoben. Nach dem nächsten <xref:System.Text.Json.Utf8JsonReader.Read>-Vorgang wird der Reader beim nächsten Wert (in einem Array), beim nächsten Eigenschaftsnamen (bei einem-Objekt) oder beim endarray-/Objekttoken verwendet.

          ]]></format>
        </remarks>
        <exception cref="T:System.Text.Json.JsonException">Beim Überspringen wurde ein gemäß JSON-RFC ungültiges JSON-Token gefunden.
          
- oder -

Die aktuelle Tiefe übersteigt den rekursiven Grenzwert, der durch die maximale Tiefe festgelegt ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="ValueSequence">
      <MemberSignature Language="C#" Value="public System.Buffers.ReadOnlySequence&lt;byte&gt; ValueSequence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Buffers.ReadOnlySequence`1&lt;unsigned int8&gt; ValueSequence" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.ValueSequence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSequence As ReadOnlySequence(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Buffers::ReadOnlySequence&lt;System::Byte&gt; ValueSequence { System::Buffers::ReadOnlySequence&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSequence : System.Buffers.ReadOnlySequence&lt;byte&gt;" Usage="System.Text.Json.Utf8JsonReader.ValueSequence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Buffers.ReadOnlySequence&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des zuletzt verarbeiteten Tokens als einen <see cref="T:System.ReadOnlySpan`1" />-Slice der Eingabenutzlast ab. Wenn der JSON-Code innerhalb eines <see cref="T:System.Buffers.ReadOnlySequence`1" /> bereitgestellt wird und der Slice, der den Tokenwert darstellt, in ein einzelnes Segment passt, enthält <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> den Slicewert, weil die Darstellung als Bereich möglich ist. Andernfalls enthält <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> den Tokenwert.</summary>
        <value>Eine schreibgeschützte Byte-Sequenz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks


Wenn <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> ist `false` , `ValueSequence`  ist leer. Daher wird `ValueSequence` <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> nur `true` auf zugegriffen, wenn den Wert hat.
Andernfalls muss auf den Tokenwert von <xref:System.Text.Json.Utf8JsonReader.ValueSpan>zugegriffen werden.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSpan">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;byte&gt; ValueSpan { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; ValueSpan" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonReader.ValueSpan" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSpan As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ReadOnlySpan&lt;System::Byte&gt; ValueSpan { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSpan : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Json.Utf8JsonReader.ValueSpan" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des zuletzt verarbeiteten Tokens als einen ReadOnlySpan&lt;Byte&gt;-Slice der Eingabenutzlast ab. Wenn der JSON-Code innerhalb eines ReadOnlySequence&lt;Byte&gt; bereitgestellt wird und der Slice, der den Tokenwert darstellt, in ein einzelnes Segment passt, enthält <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> den Slicewert, da es als ein Bereich dargestellt werden kann. Andernfalls enthält <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> den Tokenwert.</summary>
        <value>Ein schreibgeschützter Bytes-Span.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Wenn <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> ist `true` , <xref:System.Text.Json.Utf8JsonReader.ValueSpan>  ist leer. Daher wird `ValueSpan` <xref:System.Text.Json.Utf8JsonReader.HasValueSequence> nur `false` auf zugegriffen, wenn den Wert hat.
Andernfalls muss auf den Tokenwert von <xref:System.Text.Json.Utf8JsonReader.ValueSequence>zugegriffen werden.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ValueTextEquals">
      <Docs>
        <summary>Vergleicht den angegebenen Text mit dem JSON-Tokenwert ohne Escapezeichen in der Quelle und gibt einen Wert zurück, der angibt, ob eine Übereinstimmung besteht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Wenn der Suchtext einen ungültigen UTF-8-Text hat, gibt die `false` Methode zurück, da Sie in der JSON-Nutzlast keinen ungültigen UTF-8-Wert haben können.

Der Vergleich des JSON-tokenwerts in der Quelle und dem Suchtext erfolgt durch das erste Escapezeichen des JSON-Werts in der Quelle (falls erforderlich). Der Suchtext wird unverändert abgeglichen.

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValueTextEquals">
      <MemberSignature Language="C#" Value="public bool ValueTextEquals (ReadOnlySpan&lt;byte&gt; utf8Text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValueTextEquals(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.ValueTextEquals(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function ValueTextEquals (utf8Text As ReadOnlySpan(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValueTextEquals(ReadOnlySpan&lt;System::Byte&gt; utf8Text);" />
      <MemberSignature Language="F#" Value="member this.ValueTextEquals : ReadOnlySpan&lt;byte&gt; -&gt; bool" Usage="utf8JsonReader.ValueTextEquals utf8Text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="utf8Text">Der UTF-8-codierte Text für den Vergleich.</param>
        <summary>Vergleicht den UTF-8-codierten Text in einem schreibgeschützten Bytebereich mit dem JSON-Tokenwert ohne Escapezeichen in der Quelle und gibt einen Wert zurück, der angibt, ob eine Übereinstimmung besteht.</summary>
        <returns><see langword="true" />, wenn der JSON-Tokenwert in der Quelle mit dem UTF-8-codierten Suchtext übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Wenn der Suchtext einen ungültigen UTF-8-Text hat, gibt `false` die Methode zurück, da Sie in der JSON-Nutzlast keinen ungültigen UTF-8-Wert haben können.
              
Der Vergleich des JSON-tokenwerts in der Quelle und dem Suchtext erfolgt durch das erste Escapezeichen des JSON-Werts in der Quelle (falls erforderlich). Der Suchtext wird unverändert abgeglichen, ohne dass Änderungen vorgenommen werden.
              
          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das JSON-Token, bei dem es sich nicht um eine Zeichenfolge handelt (also nicht <see cref="F:System.Text.Json.JsonTokenType.String" /> oder <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="ValueTextEquals">
      <MemberSignature Language="C#" Value="public bool ValueTextEquals (ReadOnlySpan&lt;char&gt; text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValueTextEquals(valuetype System.ReadOnlySpan`1&lt;char&gt; text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.ValueTextEquals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function ValueTextEquals (text As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValueTextEquals(ReadOnlySpan&lt;char&gt; text);" />
      <MemberSignature Language="F#" Value="member this.ValueTextEquals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="utf8JsonReader.ValueTextEquals text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="text">Der UTF-8-codierte Text für den Vergleich.</param>
        <summary>Vergleicht den UTF-8-codierten Text in einem schreibgeschützten Zeichenbereich mit dem JSON-Tokenwert ohne Escapezeichen in der Quelle und gibt einen Wert zurück, der angibt, ob eine Übereinstimmung besteht.</summary>
        <returns><see langword="true" />, wenn der JSON-Tokenwert in der Quelle mit dem UTF-8-codierten Suchtext übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Wenn es sich bei dem Suchtext um einen ungültigen oder unvollständigen UTF-16-Text handelt (d. h. nicht `false` zugeordnete Surrogates), gibt die Methode zurück, da Sie in der JSON-Nutzlast kein ungültiges UTF-16-
              
Der Vergleich des JSON-tokenwerts in der Quelle und dem Suchtext erfolgt durch das erste Escapezeichen des JSON-Werts in der Quelle (falls erforderlich). Der Suchtext wird unverändert abgeglichen, ohne dass Änderungen vorgenommen werden.
              
          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das JSON-Token, bei dem es sich nicht um eine Zeichenfolge handelt (also nicht <see cref="F:System.Text.Json.JsonTokenType.String" /> oder <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="ValueTextEquals">
      <MemberSignature Language="C#" Value="public bool ValueTextEquals (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValueTextEquals(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonReader.ValueTextEquals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ValueTextEquals (text As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValueTextEquals(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.ValueTextEquals : string -&gt; bool" Usage="utf8JsonReader.ValueTextEquals text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Der Text, mit dem verglichen werden soll.</param>
        <summary>Vergleicht den Text in einem schreibgeschützten Zeichenbereich mit dem JSON-Tokenwert ohne Escapezeichen in der Quelle und gibt einen Wert zurück, der angibt, ob eine Übereinstimmung besteht.</summary>
        <returns><see langword="true" />, wenn der JSON-Tokenwert in der Quelle mit dem Suchtext übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Wenn der Suchtext einen ungültigen UTF-8-Text hat, gibt `false` die Methode zurück, da Sie in der JSON-Nutzlast keinen ungültigen UTF-8-Wert haben können.
              
Der Vergleich des JSON-tokenwerts in der Quelle und dem Suchtext erfolgt durch das erste Escapezeichen des JSON-Werts in der Quelle (falls erforderlich). Der Suchtext wird unverändert abgeglichen, ohne dass Änderungen vorgenommen werden.
              
          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das JSON-Token, bei dem es sich nicht um eine Zeichenfolge handelt (also nicht <see cref="F:System.Text.Json.JsonTokenType.String" /> oder <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).</exception>
      </Docs>
    </Member>
  </Members>
</Type>
