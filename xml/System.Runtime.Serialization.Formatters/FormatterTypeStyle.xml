<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FormatterTypeStyle.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5e990cc2ba4f28358cd07886e0e7b7aa04f6a7d75.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e990cc2ba4f28358cd07886e0e7b7aa04f6a7d75</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.Serialization.Formatters.FormatterTypeStyle">
          <source>Indicates the format in which type descriptions are laid out in the serialized stream.</source>
          <target state="translated">Gibt das Format für das Layout von Typbeschreibungen im serialisierten Stream an.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.TypesAlways">
          <source>Indicates that types can be given to all object members and <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> object members.</source>
          <target state="translated">Gibt an, dass Typen für alle Objektmember und <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph>-Objektmember festgelegt werden können.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.TypesWhenNeeded">
          <source>Indicates that types can be stated only for arrays of objects, object members of type <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>, and <ph id="ph2">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> non-primitive value types.</source>
          <target state="translated">Gibt an, dass Typen nur für Arrays von Objekten, Objektmember vom Typ <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> und für nicht primitive <ph id="ph2">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph>-Werttypen angegeben werden können.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.XsdString">
          <source>Indicates that strings can be given in the XSD format rather than SOAP.</source>
          <target state="translated">Gibt an, dass Zeichenfolgen statt im SOAP-Format im XSD-Format angegeben werden können.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.XsdString">
          <source>No string IDs are transmitted.</source>
          <target state="translated">Es werden keine Zeichenfolgen-IDs übertragen.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.XsdString">
          <source>The <ph id="ph1">`XsdString`</ph> and <ph id="ph2">`TypesWhenNeeded`</ph> settings are meant for high performance serialization between services built on the same version of the <ph id="ph3">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>.</source>
          <target state="translated">Die <ph id="ph1">`XsdString`</ph> und <ph id="ph2">`TypesWhenNeeded`</ph> Einstellungen beziehen sich auf hohe Leistung Serialisierung zwischen Diensten, die auf die gleiche Version von den <ph id="ph3">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.XsdString">
          <source>These two values do not support VTS (Version Tolerant Serialization) because they intentionally omit type information that VTS uses to skip or add optional fields and properties.</source>
          <target state="translated">Diese beiden Werte unterstützen keine VTS (versionstolerante Serialisierung), da sie absichtlich Typinformationen auszulassen, die VTS überspringen oder Hinzufügen von optionalen Felder und Eigenschaften verwendet.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.XsdString">
          <source>You should not use the <ph id="ph1">`XsdString`</ph> or <ph id="ph2">`TypesWhenNeeded`</ph> type formats when serializing and deserializing types on a computer running a different version of the <ph id="ph3">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> than the computer on which the type was serialized.</source>
          <target state="translated">Verwenden Sie nicht die <ph id="ph1">`XsdString`</ph> oder <ph id="ph2">`TypesWhenNeeded`</ph> geben Formate beim Serialisieren und Deserialisieren von Typen, die auf einem Computer mit einer anderen Version von der <ph id="ph3">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> als dem Computer, auf dem der Typ serialisiert wurde.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.XsdString">
          <source>Serializing and deserializing on computers running different versions of the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> causes the formatter to skip serialization of type information, thus making it impossible for the deserializer to skip optional fields if they are not present in certain types that may exist in the other version of the <ph id="ph2">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>.</source>
          <target state="translated">Serialisieren und Deserialisieren von auf Computern mit verschiedenen Versionen von der <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> bewirkt, dass das Formatierungsprogramm der Serialisierung von Typinformationen, wodurch es unmöglich, für das Deserialisierungsprogramm, optionale Felder zu überspringen, wenn sie nicht in bestimmten vorhanden sind Typen, die in die andere Version der vorhanden sind, können die <ph id="ph2">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.Serialization.Formatters.FormatterTypeStyle.XsdString">
          <source>If you must use <ph id="ph1">`XsdString`</ph> or <ph id="ph2">`TypesWhenNeeded`</ph> in such a scenario, you must provide custom serialization for types that have changed from one version of the <ph id="ph3">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> to the other.</source>
          <target state="translated">Wenn Sie verwenden müssen <ph id="ph1">`XsdString`</ph> oder <ph id="ph2">`TypesWhenNeeded`</ph> in solch einem Szenario müssen Sie angeben, benutzerdefinierte Serialisierung für Typen, die von einer Version von geändert haben die <ph id="ph3">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> in den anderen.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>