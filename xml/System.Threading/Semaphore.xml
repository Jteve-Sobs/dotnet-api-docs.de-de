<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b53add0a4b0be18cda3ae161bbeb088161899ebd" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82289449" /></Metadata><TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Schränkt die Anzahl von Threads ein, die gleichzeitig auf eine Ressource oder einen Pool von Ressourcen zugreifen können.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Threading.Semaphore>-Klasse, um den Zugriff auf einen Ressourcenpool zu steuern. Threads geben das Semaphor ein, indem Sie die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode aufrufen, die von der <xref:System.Threading.WaitHandle>-Klasse geerbt wird, und das Semaphor freigeben, indem Sie die <xref:System.Threading.Semaphore.Release%2A>-Methode aufrufen.  
  
 Die Anzahl in einem Semaphor wird jedes Mal dekrementiert, wenn ein Thread in das Semaphor eintritt, und erhöht sich, wenn ein Thread das Semaphor freigibt. Wenn die Anzahl 0 (null) ist, werden nachfolgende Anforderungen blockiert, bis andere Threads das Semaphor freigeben. Wenn alle Threads das Semaphor freigegeben haben, liegt die Anzahl bei dem maximalen Wert, der beim Erstellen des Semaphors angegeben wurde.  
  
 Es gibt keine garantierte Reihenfolge, z. b. FIFO oder LIFO, bei der blockierte Threads in das Semaphor eintreten.  
  
 Ein Thread kann das Semaphor mehrmals eingeben, indem er die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode wiederholt aufrufen. Um einige oder alle dieser Einträge freizugeben, kann der Thread die parameterlose <xref:System.Threading.Semaphore.Release> Methoden Überladung mehrmals aufrufen, oder er kann die <xref:System.Threading.Semaphore.Release%28System.Int32%29>-Methoden Überladung aufrufen, die die Anzahl der frei zugebende Einträge angibt.  
  
 Die <xref:System.Threading.Semaphore>-Klasse erzwingt keine Thread Identität bei Aufrufen von <xref:System.Threading.WaitHandle.WaitOne%2A> oder <xref:System.Threading.Semaphore.Release%2A>. Es ist Aufgabe des Programmierers, sicherzustellen, dass Threads die Semaphor nicht zu oft freigeben. Angenommen, ein Semaphor hat einen maximalen Zähler von zwei und Thread A sowie Thread B wechseln beide in das Semaphor. Wenn ein Programmierfehler in Thread B bewirkt, dass <xref:System.Threading.Semaphore.Release%2A> zweimal aufruft, sind beide Aufrufe erfolgreich. Der Zähler des Semaphors ist voll, und wenn Thread A schließlich <xref:System.Threading.Semaphore.Release%2A> aufruft, wird eine <xref:System.Threading.SemaphoreFullException> ausgelöst.  
  
 Semaphoren haben zwei Typen: lokale Semaphoren und benannte System Semaphoren. Wenn Sie ein <xref:System.Threading.Semaphore> Objekt mithilfe eines Konstruktors erstellen, der einen Namen akzeptiert, wird er einem Betriebssystem-Semaphor dieses Namens zugeordnet. Benannte System Semaphoren sind im gesamten Betriebssystem sichtbar und können verwendet werden, um die Aktivitäten von Prozessen zu synchronisieren. Sie können mehrere <xref:System.Threading.Semaphore> Objekte erstellen, die das gleiche benannte System Semaphor darstellen, und Sie können die <xref:System.Threading.Semaphore.OpenExisting%2A>-Methode verwenden, um ein vorhandenes benanntes System Semaphore zu öffnen.  
  
 Ein lokales Semaphor ist nur innerhalb des Prozesses vorhanden. Er kann von jedem Thread in einem Prozess verwendet werden, der einen Verweis auf das lokale <xref:System.Threading.Semaphore>-Objekt enthält. Jedes <xref:System.Threading.Semaphore> Objekt ist ein separates lokales Semaphor.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Semaphor mit einer maximalen Anzahl von drei und einer anfänglichen Anzahl von 0 (null) erstellt. Im Beispiel werden fünf Threads gestartet, die blockieren, um auf das Semaphor zu warten. Der Haupt Thread verwendet die <xref:System.Threading.Semaphore.Release%28System.Int32%29>-Methoden Überladung, um die Anzahl der Semaphor auf den maximalen Wert zu erhöhen, sodass drei Threads in das Semaphor gelangen können. Jeder Thread verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>-Methode, um eine Sekunde zu warten, um die Arbeit zu simulieren, und ruft dann die <xref:System.Threading.Semaphore.Release>-Methoden Überladung auf, um das Semaphor freizugeben. Jedes Mal, wenn das Semaphor freigegeben wird, wird die vorherige Semaphor-Anzahl angezeigt. Konsolen Meldungen verfolgen die Verwendung von Semaphor. Das simulierte Arbeitsintervall wird für jeden Thread geringfügig angehoben, damit die Ausgabe leichter lesbar ist.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Threading.Semaphore" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Die anfängliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</param>
        <param name="maximumCount">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Semaphore" />-Klasse und gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert ein unbenanntes Semaphor. Alle Threads, die eine Instanz eines solchen Semaphors verwenden, müssen Verweise auf die Instanz aufweisen.  
  
 Wenn `initialCount` kleiner als `maximumCount`ist, entspricht der Effekt dem, wenn der aktuelle Thread <xref:System.Threading.WaitHandle.WaitOne%2A>-Zeit (`maximumCount` minus `initialCount`) aufgerufen hat. Wenn Sie keine Einträge für den Thread reservieren möchten, der das Semaphor erstellt, verwenden Sie die gleiche Zahl für `maximumCount` und `initialCount`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Semaphor mit einer maximalen Anzahl von drei und einer anfänglichen Anzahl von 0 (null) erstellt. Im Beispiel werden fünf Threads gestartet, die blockieren, um auf das Semaphor zu warten. Der Haupt Thread verwendet die <xref:System.Threading.Semaphore.Release%28System.Int32%29>-Methoden Überladung, um die Anzahl der Semaphor auf den maximalen Wert zu erhöhen, sodass drei Threads in das Semaphor gelangen können. Jeder Thread verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>-Methode, um eine Sekunde zu warten, um die Arbeit zu simulieren, und ruft dann die <xref:System.Threading.Semaphore.Release>-Methoden Überladung auf, um das Semaphor freizugeben. Jedes Mal, wenn das Semaphor freigegeben wird, wird die vorherige Semaphor-Anzahl angezeigt. Konsolen Meldungen verfolgen die Verwendung von Semaphor. Das simulierte Arbeitsintervall wird für jeden Thread geringfügig angehoben, damit die Ausgabe leichter lesbar ist.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="initialCount" /> ist größer als <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumCount" /> ist kleiner als 1.  
  
Oder 
 <paramref name="initialCount" /> ist kleiner als 0.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">Die anfängliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</param>
        <param name="maximumCount">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</param>
        <param name="name">Der Name eines benannten Systemsemaphorobjekts.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Semaphore" />-Klasse, gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen sowie optional den Namen eines Systemsemaphorobjekts an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.Semaphore> Objekt, das ein benanntes System Semaphor darstellt. Sie können mehrere <xref:System.Threading.Semaphore> Objekte erstellen, die dasselbe benannte System Semaphor darstellen.  
  
 Wenn das benannte System Semaphor nicht vorhanden ist, wird es mit der anfänglichen Anzahl und der maximalen Anzahl erstellt, die durch `initialCount` und `maximumCount`angegeben werden. Wenn das benannte System Semaphor bereits vorhanden ist, werden `initialCount` und `maximumCount` nicht verwendet, obwohl ungültige Werte weiterhin Ausnahmen verursachen. Wenn Sie bestimmen müssen, ob ein benanntes System Semaphor erstellt wurde, verwenden Sie stattdessen die <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29>-Konstruktorüberladung.  
  
> [!IMPORTANT]
>  Wenn Sie diese Konstruktorüberladung verwenden, empfiehlt es sich, für `initialCount` und `maximumCount`dieselbe Zahl anzugeben. Wenn `initialCount` kleiner als `maximumCount`ist und ein benanntes System Semaphor erstellt wird, entspricht der Effekt dem, wenn der aktuelle Thread <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`)-Zeiten aufgerufen hätte. Bei dieser Konstruktorüberladung gibt es jedoch keine Möglichkeit, zu bestimmen, ob ein benanntes System Semaphor erstellt wurde.  
  
 Wenn Sie `null` oder eine leere Zeichenfolge für `name`angeben, wird ein lokales Semaphor erstellt, als ob Sie die <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29>-Konstruktorüberladung aufgerufen hätten.  
  
 Da benannte Semaphoren im gesamten Betriebssystem sichtbar sind, können Sie verwendet werden, um die Ressourcenverwendung über Prozess Grenzen hinweg zu koordinieren.  
  
 Wenn Sie herausfinden möchten, ob ein benanntes System Semaphor vorhanden ist, verwenden Sie die <xref:System.Threading.Semaphore.OpenExisting%2A>-Methode. Die <xref:System.Threading.Semaphore.OpenExisting%2A>-Methode versucht, ein vorhandenes benanntes Semaphor zu öffnen, und löst eine Ausnahme aus, wenn das System Semaphor nicht vorhanden ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Semaphors veranschaulicht. Das Beispiel erstellt ein benanntes Semaphor mit einer maximalen Anzahl von fünf und einer anfänglichen Anzahl von fünf. Das Programm führt drei Aufrufe an die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode aus. Wenn Sie also das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, wird die zweite Kopie beim dritten <xref:System.Threading.WaitHandle.WaitOne%2A>-aufrufblock blockiert. Geben Sie mindestens einen Eintrag in der ersten Kopie des Programms frei, um die Blockierung der zweiten aufzuheben.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="initialCount" /> ist größer als <paramref name="maximumCount" />.  
  
Oder 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumCount" /> ist kleiner als 1.  
  
Oder 
 <paramref name="initialCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der benannte Semaphor ist vorhanden und verfügt über Zugriffssteuerungssicherheit, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Der benannte Semaphor kann nicht erstellt werden, möglicherweise, weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string * bool -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">Die ursprüngliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</param>
        <param name="maximumCount">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</param>
        <param name="name">Der Name eines benannten Systemsemaphorobjekts.</param>
        <param name="createdNew">Enthält nach dem Beenden dieser Methode den Wert <see langword="true" />, wenn ein lokales Semaphor erstellt wurde (d. h., wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemsemaphor erstellt wurde. Der Wert ist <see langword="false" />, wenn das angegebene benannte Systemsemaphor bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Semaphore" />-Klasse, gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen sowie optional den Namen eines Systemsemaphorobjekts an, gibt eine Variable an, die einen Wert empfängt, der angibt, ob ein neues Systemsemaphor erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.Semaphore> Objekt, das ein benanntes System Semaphor darstellt. Sie können mehrere <xref:System.Threading.Semaphore> Objekte erstellen, die dasselbe benannte System Semaphor darstellen.  
  
 Wenn das benannte System Semaphor nicht vorhanden ist, wird es mit der anfänglichen Anzahl und der maximalen Anzahl erstellt, die durch `initialCount` und `maximumCount`angegeben werden. Wenn das benannte System Semaphor bereits vorhanden ist, werden `initialCount` und `maximumCount` nicht verwendet, obwohl ungültige Werte weiterhin Ausnahmen verursachen. Verwenden Sie `createdNew`, um zu bestimmen, ob das System Semaphor erstellt wurde.  
  
 Wenn `initialCount` kleiner als `maximumCount`und `createdNew` `true`ist, entspricht der Effekt dem, wenn der aktuelle Thread <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) Mal aufgerufen hätte.  
  
 Wenn Sie `null` oder eine leere Zeichenfolge für `name`angeben, wird ein lokales Semaphor erstellt, als ob Sie die <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29>-Konstruktorüberladung aufgerufen hätten. In diesem Fall wird `createdNew` immer `true`.  
  
 Da benannte Semaphoren im gesamten Betriebssystem sichtbar sind, können Sie verwendet werden, um die Ressourcenverwendung über Prozess Grenzen hinweg zu koordinieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Semaphors veranschaulicht. Das Beispiel erstellt ein benanntes Semaphor mit einer maximalen Anzahl von fünf und einer anfänglichen Anzahl von zwei. Das heißt, es werden drei Einträge für den Thread reserviert, der den Konstruktor aufruft. Wenn `createNew` `false`ist, führt das Programm drei Aufrufe an die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode aus. Wenn Sie also das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, wird die zweite Kopie beim dritten <xref:System.Threading.WaitHandle.WaitOne%2A>-aufrufblock blockiert. Geben Sie mindestens einen Eintrag in der ersten Kopie des Programms frei, um die Blockierung der zweiten aufzuheben.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="initialCount" /> ist größer als <paramref name="maximumCount" />.  
  
Oder 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumCount" /> ist kleiner als 1.  
  
Oder 
 <paramref name="initialCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der benannte Semaphor ist vorhanden und verfügt über Zugriffssteuerungssicherheit, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Der benannte Semaphor kann nicht erstellt werden, möglicherweise, weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean, semaphoreSecurity As SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string * bool * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="maximumCount" Type="System.Int32" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initialCount">Die ursprüngliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</param>
        <param name="maximumCount">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</param>
        <param name="name">Der Name eines benannten Systemsemaphorobjekts.</param>
        <param name="createdNew">Enthält nach dem Beenden dieser Methode den Wert <see langword="true" />, wenn ein lokales Semaphor erstellt wurde (d. h., wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemsemaphor erstellt wurde. Der Wert ist <see langword="false" />, wenn das angegebene benannte Systemsemaphor bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <param name="semaphoreSecurity">Ein <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf das benannte Systemsemaphor angewendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Semaphore" />-Klasse, gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen an, gibt optional den Namen eines Systemsemaphorobjekts an, gibt eine Variable an, die einen Wert empfängt, der angibt, ob ein neues Systemsemaphor erstellt wurde, und gibt die Sicherheitszugriffssteuerung für das Systemsemaphor an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, um die Zugriffs Steuerungs Sicherheit auf ein benanntes System Semaphor anzuwenden, wenn es erstellt wird. Dadurch wird verhindert, dass anderer Code die Kontrolle über die Semaphor übernimmt.  
  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.Semaphore> Objekt, das ein benanntes System Semaphor darstellt. Sie können mehrere <xref:System.Threading.Semaphore> Objekte erstellen, die dasselbe benannte System Semaphor darstellen.  
  
 Wenn das benannte System Semaphor nicht vorhanden ist, wird es mit der angegebenen Zugriffs Steuerungs Sicherheit erstellt. Wenn das benannte Semaphor vorhanden ist, wird die angegebene Zugriffs Steuerungs Sicherheit ignoriert.  
  
> [!NOTE]
>  Der Aufrufer hat die vollständige Kontrolle über das neu erstellte <xref:System.Threading.Semaphore> Objekt, auch wenn `semaphoreSecurity` dem aktuellen Benutzer einige Zugriffsrechte verweigert oder ihm nicht zuweist. Wenn der aktuelle Benutzer jedoch versucht, ein anderes <xref:System.Threading.Semaphore> Objekt zu erhalten, das das gleiche benannte Semaphor repräsentiert, wobei entweder ein Konstruktor oder die <xref:System.Threading.Semaphore.OpenExisting%2A>-Methode verwendet wird, wird die Windows-Zugriffs Steuerungs Sicherheit angewendet.  
  
 Wenn das benannte System Semaphor nicht vorhanden ist, wird es mit der anfänglichen Anzahl und der maximalen Anzahl erstellt, die durch `initialCount` und `maximumCount`angegeben werden. Wenn das benannte System Semaphor bereits vorhanden ist, werden `initialCount` und `maximumCount` nicht verwendet, obwohl ungültige Werte weiterhin Ausnahmen verursachen. Verwenden Sie den `createdNew`-Parameter, um zu bestimmen, ob das System Semaphor von diesem Konstruktor erstellt wurde.  
  
 Wenn `initialCount` kleiner als `maximumCount`und `createdNew` `true`ist, entspricht der Effekt dem, wenn der aktuelle Thread <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) Mal aufgerufen hätte.  
  
 Wenn Sie `null` oder eine leere Zeichenfolge für `name`angeben, wird ein lokales Semaphor erstellt, als ob Sie die <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29>-Konstruktorüberladung aufgerufen hätten. In diesem Fall wird `createdNew` immer `true`.  
  
 Da benannte Semaphoren im gesamten Betriebssystem sichtbar sind, können Sie verwendet werden, um die Ressourcenverwendung über Prozess Grenzen hinweg zu koordinieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Semaphors mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Semaphor vorhanden ist. Wenn das Semaphor nicht vorhanden ist, wird es mit einer maximalen Anzahl von zwei und mit Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Semaphor zu verwenden, aber das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor gewährt. Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie eine Zugriffs Verletzungs Ausnahme beim Aufrufen der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methode aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>-Methoden Überladung, um das Semaphor mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen geändert wurden, wird das Semaphor mit den Rechten geöffnet, die für die Eingabe und Freigabe erforderlich sind. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="initialCount" /> ist größer als <paramref name="maximumCount" />.  
  
Oder 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumCount" /> ist kleiner als 1.  
  
Oder 
 <paramref name="initialCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der benannte Semaphor ist vorhanden und verfügt über Zugriffssteuerungssicherheit, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Der benannte Semaphor kann nicht erstellt werden, möglicherweise, weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Zugriffssteuerungssicherheit für ein benanntes Systemsemaphor ab.</summary>
        <returns>Ein <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />-Objekt, das die Zugriffssteuerungssicherheit für das benannte Systemsemaphor darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Semaphore.GetAccessControl%2A>-Methode verwendet die folgende Kombination von-Flags (kombiniert mithilfe des bitweisen OR-Vorgangs), um nach Berechtigungen zu suchen: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>und <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Der Benutzer muss über <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> Rechte verfügen, um diese Methode aufzurufen, und das Semaphor muss mit <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> Rechten geöffnet worden sein.  
  
 Bei einem lokalen Semaphor ist die Zugriffs Steuerungs Sicherheit irrelevant. Wenn das <xref:System.Threading.Semaphore>-Objekt kein benanntes System Semaphor darstellt, gibt diese Methode ein <xref:System.Security.AccessControl.SemaphoreSecurity>-Objekt zurück, das allen Benutzern alle Rechte gewährt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Semaphors mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Semaphor vorhanden ist.  
  
 Wenn das Semaphor nicht vorhanden ist, wird es mit einer maximalen Anzahl von zwei und mit Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Semaphor zu verwenden, aber das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor gewährt.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie eine Zugriffs Verletzungs Ausnahme beim Aufrufen der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methode aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>-Methoden Überladung, um das Semaphor mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind. Die Zugriffs Steuerungs Sicherheit für das System Semaphor wird mithilfe der <xref:System.Threading.Semaphore.GetAccessControl%2A>-Methode abgerufen.  
  
 Nachdem die Berechtigungen geändert wurden, wird das Semaphor mit den Rechten geöffnet, die für die Eingabe und Freigabe erforderlich sind. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Das aktuelle <see cref="T:System.Threading.Semaphore" />-Objekt stellt einen benannten Systemsemaphor dar, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />-Berechtigung.  
  
Oder 
Das aktuelle <see cref="T:System.Threading.Semaphore" />-Objekt stellt einen benannten Systemsemaphor dar und wurde nicht mit <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />-Berechtigung geöffnet.</exception>
        <exception cref="T:System.NotSupportedException">Wird nicht für Windows 98 oder Windows Millennium Edition unterstützt.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein angegebenes benanntes Semaphor, wenn es bereits vorhanden ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsemaphors.</param>
        <summary>Öffnet das angegebene benannte Semaphor, wenn es bereits vorhanden ist.</summary>
        <returns>Ein Objekt, das das benannte Systemsemaphor darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Semaphore.OpenExisting%2A>-Methode versucht, die angegebene benannte Semaphore zu öffnen. Wenn das System Semaphor nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das System Semaphor zu erstellen. Um das System Semaphor zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie einen der <xref:System.Threading.Semaphore.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.  
  
 Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.Semaphore> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Semaphor darstellen.  
  
 Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.Semaphore.OpenExisting%2A>-Methoden Überladung und der Angabe von <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rechten, kombiniert mithilfe des bitweisen OR-Vorgangs.  
  
 Wenn Sie das <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>-Flag angeben, kann ein Thread in das Semaphor eintreten, und die Angabe des <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Flags ermöglicht einem Thread, die <xref:System.Threading.Semaphore.Release%2A>-Methode aufzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Semaphors mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Semaphor vorhanden ist.  
  
 Wenn das Semaphor nicht vorhanden ist, wird es mit einer maximalen Anzahl von zwei und mit der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Semaphor zu verwenden, das jedoch dem Recht gewährt, Lese-und Änderungs Berechtigungen für das Semaphor zu erteilen.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methoden Überladung eine Zugriffs Verletzungs Ausnahme aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>-Methoden Überladung, um das Semaphor mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen geändert wurden, wird das Semaphor mit den zum eingeben und Freigeben erforderlichen Rechten geöffnet. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
Oder 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Semaphor ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der benannte Semaphor ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsemaphors.</param>
        <param name="rights">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</param>
        <summary>Öffnet das angegebene benannte Semaphor, wenn es bereits vorhanden ist, mit dem gewünschten Sicherheitszugriff.</summary>
        <returns>Ein Objekt, das das benannte Systemsemaphor darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `rights`-Parameter muss das <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>-Flag enthalten, damit Threads in das Semaphor eintreten können, und das <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>-Flag, damit Threads die <xref:System.Threading.Semaphore.Release%2A>-Methode aufrufen können.  
  
 Die <xref:System.Threading.Semaphore.OpenExisting%2A>-Methode versucht, eine vorhandene benannte Semaphore zu öffnen. Wenn das System Semaphor nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das System Semaphor zu erstellen. Um das System Semaphor zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie einen der <xref:System.Threading.Semaphore.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.  
  
 Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.Semaphore> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Semaphor darstellen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Semaphors mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Semaphor vorhanden ist.  
  
 Wenn das Semaphor nicht vorhanden ist, wird es mit einer maximalen Anzahl von zwei und mit Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Semaphor zu verwenden, aber das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor gewährt.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie eine Zugriffs Verletzungs Ausnahme beim Aufrufen der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methode aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>-Methoden Überladung, um das Semaphor mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen geändert wurden, wird das Semaphor mit den zum eingeben und Freigeben erforderlichen Rechten geöffnet. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
Oder 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Semaphor ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Semaphor ist vorhanden, der Benutzer verfügt jedoch nicht über die gewünschten Sicherheitszugriffsrechte.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beendet das Semaphor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet das Semaphor und gibt die vorherige Anzahl zurück.</summary>
        <returns>Die Anzahl für das Semaphor vor dem Aufruf der <see cref="Overload:System.Threading.Semaphore.Release" />-Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Threads verwenden in der Regel die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode, um das Semaphor einzugeben, und verwenden diese Methoden Überladung normalerweise zum Beenden.  
  
 Wenn ein <xref:System.Threading.SemaphoreFullException> von der <xref:System.Threading.Semaphore.Release%2A>-Methode ausgelöst wird, weist dies nicht unbedingt auf ein Problem mit dem aufrufenden Thread hin. Ein Programmierfehler in einem anderen Thread hat möglicherweise bewirkt, dass dieser Thread das Semaphor mehrmals beendet hat, als er eingegeben hat.  
  
 Wenn das aktuelle <xref:System.Threading.Semaphore>-Objekt ein benanntes System Semaphor darstellt, muss der Benutzer über <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechte verfügen, und das Semaphor muss mit <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechten geöffnet worden sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Semaphor mit einer maximalen Anzahl von drei und einer anfänglichen Anzahl von 0 (null) erstellt. Im Beispiel werden fünf Threads gestartet, die blockieren, um auf das Semaphor zu warten. Der Haupt Thread verwendet die <xref:System.Threading.Semaphore.Release%28System.Int32%29>-Methoden Überladung, um die Anzahl der Semaphor auf den maximalen Wert zu erhöhen, sodass drei Threads in das Semaphor gelangen können. Jeder Thread verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>-Methode, um eine Sekunde zu warten, um die Arbeit zu simulieren, und ruft dann die <xref:System.Threading.Semaphore.Release>-Methoden Überladung auf, um das Semaphor freizugeben.  
  
 Jedes Mal, wenn das Semaphor freigegeben wird, wird die vorherige Semaphor-Anzahl angezeigt. Konsolen Meldungen verfolgen die Verwendung von Semaphor. Das simulierte Arbeitsintervall wird für jeden Thread geringfügig angehoben, damit die Ausgabe leichter lesbar ist.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">Die Anzahl für das Semaphor weist bereits den maximalen Wert auf.</exception>
        <exception cref="T:System.IO.IOException">Bei einem benannten Semaphor ist ein Win32-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar. Der Benutzer verfügt jedoch nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
Oder 
Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar, es wurde jedoch nicht mit <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> geöffnet.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">Die Anzahl von Malen, die das Semaphor freigegeben werden soll.</param>
        <summary>Gibt das Semaphor eine festgelegte Anzahl von Malen frei und gibt die vorherige Anzahl zurück.</summary>
        <returns>Die Anzahl für das Semaphor vor dem Aufruf der <see cref="Overload:System.Threading.Semaphore.Release" />-Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Thread mehrmals in das Semaphor gelangt ist, lässt diese Methoden Überladung zu, dass die gesamte Semaphor-Anzahl mit einem-Befehl wieder hergestellt wird.  
  
 Wenn ein <xref:System.Threading.SemaphoreFullException> von der <xref:System.Threading.Semaphore.Release%2A>-Methode ausgelöst wird, weist dies nicht unbedingt auf ein Problem mit dem aufrufenden Thread hin. Ein Programmierfehler in einem anderen Thread hat möglicherweise bewirkt, dass dieser Thread das Semaphor mehrmals beendet hat, als er eingegeben hat.  
  
 Wenn das aktuelle <xref:System.Threading.Semaphore>-Objekt ein benanntes System Semaphor darstellt, muss der Benutzer über <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechte verfügen, und das Semaphor muss mit <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechten geöffnet worden sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Semaphor mit einer maximalen Anzahl von drei und einer anfänglichen Anzahl von 0 (null) erstellt. Im Beispiel werden fünf Threads gestartet, die blockieren, um auf das Semaphor zu warten. Der Haupt Thread verwendet die <xref:System.Threading.Semaphore.Release%28System.Int32%29>-Methoden Überladung, um die Anzahl der Semaphor auf den maximalen Wert zu erhöhen, sodass drei Threads in das Semaphor gelangen können. Jeder Thread verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>-Methode, um eine Sekunde zu warten, um die Arbeit zu simulieren, und ruft dann die <xref:System.Threading.Semaphore.Release>-Methoden Überladung auf, um das Semaphor freizugeben.  
  
 Jedes Mal, wenn das Semaphor freigegeben wird, wird die vorherige Semaphor-Anzahl angezeigt. Konsolen Meldungen verfolgen die Verwendung von Semaphor. Das simulierte Arbeitsintervall wird für jeden Thread geringfügig angehoben, damit die Ausgabe leichter lesbar ist.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="releaseCount" /> ist kleiner als 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">Die Anzahl für das Semaphor weist bereits den maximalen Wert auf.</exception>
        <exception cref="T:System.IO.IOException">Bei einem benannten Semaphor ist ein Win32-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar. Der Benutzer verfügt jedoch nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />-Rechte.  
  
Oder 
Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar, es wurde jedoch nicht mit <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />-Rechten geöffnet.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (semaphoreSecurity As SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">Ein <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf das benannte Systemsemaphor angewendet werden soll.</param>
        <summary>Legt die Zugriffssteuerungssicherheit für ein benanntes Systemsemaphor fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die Zugriffs Steuerungs Sicherheit nur für <xref:System.Threading.Semaphore> Objekte festlegen, die benannte System Semaphoren darstellen.  
  
 Der Benutzer muss über <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> Rechte verfügen, um diese Methode aufzurufen, und das Semaphor muss mit <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> Rechten geöffnet worden sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Semaphors mit Zugriffs Steuerungs Sicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Semaphor vorhanden ist.  
  
 Wenn das Semaphor nicht vorhanden ist, wird es mit einer maximalen Anzahl von zwei und mit Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Semaphor zu verwenden, aber das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor gewährt.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie eine Zugriffs Verletzungs Ausnahme beim Aufrufen der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methode aus. Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>-Methoden Überladung, um das Semaphor mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind.  
  
 Nachdem die Berechtigungen mithilfe der <xref:System.Threading.Semaphore.SetAccessControl%2A>-Methode geändert wurden, wird das Semaphor mit den Rechten geöffnet, die für die Eingabe und Freigabe erforderlich sind. Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="semaphoreSecurity" /> ist <see langword="null" /></exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />-Rechte.  
  
Oder 
Das Semaphor wurde nicht mit <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />-Rechten geöffnet.</exception>
        <exception cref="T:System.NotSupportedException">Das aktuelle <see cref="T:System.Threading.Semaphore" />-Objekt stellt kein benanntes Systemsemaphor dar.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein angegebenes benanntes Semaphor, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * Semaphore -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsemaphors.</param>
        <param name="result">Enthält nach Beenden der Methode ein <see cref="T:System.Threading.Semaphore" />-Objekt, das das benannte Semaphor darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn der Aufruf fehlgeschlagen ist. Dieser Parameter wird als nicht initialisiert behandelt.</param>
        <summary>Öffnet das angegebene benannte Semaphor, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
        <returns><see langword="true" />, wenn das benannte Semaphor erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das benannte Semaphor nicht vorhanden ist, wird es von dieser Methode nicht erstellt. Um das System Semaphor zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie einen der <xref:System.Threading.Semaphore.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.  
  
 Wenn Sie unsicher sind, ob ein benanntes Semaphor vorhanden ist, verwenden Sie diese Methoden Überladung anstelle der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methoden Überladung, die eine Ausnahme auslöst, wenn das Semaphor nicht vorhanden ist.  
  
 Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.Semaphore.TryOpenExisting%2A>-Methoden Überladung und der Angabe von <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rechten, kombiniert mithilfe des bitweisen OR-Vorgangs. Wenn Sie das <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>-Flag angeben, kann ein Thread in das Semaphor eintreten, und die Angabe des <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Flags ermöglicht einem Thread, die <xref:System.Threading.Semaphore.Release%2A>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
Oder 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der benannte Semaphor ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights * Semaphore -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsemaphors.</param>
        <param name="rights">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</param>
        <param name="result">Enthält nach Beenden der Methode ein <see cref="T:System.Threading.Semaphore" />-Objekt, das das benannte Semaphor darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn der Aufruf fehlgeschlagen ist. Dieser Parameter wird als nicht initialisiert behandelt.</param>
        <summary>Öffnet das angegebene benannte Semaphor, wenn es bereits mit dem gewünschten Sicherheitszugriff vorhanden ist und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
        <returns><see langword="true" />, wenn das benannte Semaphor erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das benannte Semaphor nicht vorhanden ist, wird es von dieser Methode nicht erstellt. Um das System Semaphor zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie einen der <xref:System.Threading.Semaphore.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.  
  
 Wenn Sie unsicher sind, ob ein benanntes Semaphor vorhanden ist, verwenden Sie diese Methoden Überladung anstelle der <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>-Methoden Überladung, die eine Ausnahme auslöst, wenn das Semaphor nicht vorhanden ist.  
  
 Der `rights`-Parameter muss das <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>-Flag enthalten, damit Threads in das Semaphor eintreten können, und das <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>-Flag, damit Threads die <xref:System.Threading.Semaphore.Release%2A>-Methode aufrufen können.  
  
 Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.Semaphore> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Semaphor darstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist eine leere Zeichenfolge.  
  
Oder 
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der benannte Semaphor ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
