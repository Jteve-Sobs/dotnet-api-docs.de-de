<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="341a2bbc0c3988004ab57f93d5e715cb713edbe1" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48748922" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Schränkt die Anzahl von Threads ein, die gleichzeitig auf eine Ressource oder einen Pool von Ressourcen zugreifen können.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Threading.Semaphore> Klasse zum Steuern des Zugriffs auf einen Pool von Ressourcen. Threads das Semaphor durch Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%2A> -Methode, die von geerbt wurde die <xref:System.Threading.WaitHandle> Klasse, und geben Sie das Semaphor durch Aufrufen der <xref:System.Threading.Semaphore.Release%2A> Methode.  
  
 Die Anzahl für einen Semaphore wird jedes Mal ein Thread das Semaphor gibt und inkrementiert, wenn ein Thread das Semaphor freigibt verringert. Wenn die Zahl 0 (null) ist, blockiert nachfolgende Anforderungen, bis andere Threads das Semaphor freizugeben. Wenn alle Threads das Semaphor freigegeben haben, wird die Anzahl die den maximalen Wert angegeben, wenn das Semaphor erstellt wurde.  
  
 Es gibt keine festgelegte Reihenfolge, z. B. FIFO oder LIFO, in denen blockierte Threads das Semaphor.  
  
 Ein Thread kann das Semaphor mehrfach durch Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode wiederholt. Um einige oder alle diese Einträge freizugeben, kann der Thread die parameterlose Aufrufen <xref:System.Threading.Semaphore.Release> mehrmals, oder sie rufen Sie kann eine Überladung der <xref:System.Threading.Semaphore.Release%28System.Int32%29> methodenüberladung, der angibt, die Anzahl der freizugebenden Einträge.  
  
 Die <xref:System.Threading.Semaphore> Klasse erzwingt keine Threadidentität für Aufrufe von <xref:System.Threading.WaitHandle.WaitOne%2A> oder <xref:System.Threading.Semaphore.Release%2A>. Es ist der Programmierer dafür verantwortlich, um sicherzustellen, dass Threads das Semaphor nicht zu viele Versuche freigeben. Angenommen, ein Semaphor hat einen maximalen Zähler von zwei und Thread A sowie Thread B wechseln beide in das Semaphor. Wenn ein Programmierfehler in Thread B bewirkt, dass Aufrufen <xref:System.Threading.Semaphore.Release%2A> zweimal beide Aufrufe erfolgreich. Der Zähler des Semaphors ist voll, und wenn Thread A schließlich <xref:System.Threading.Semaphore.Release%2A> aufruft, wird eine <xref:System.Threading.SemaphoreFullException> ausgelöst.  
  
 Gibt zwei Typen von Semaphoren: lokale Semaphore und benanntes Semaphore. Bei der Erstellung einer <xref:System.Threading.Semaphore> -Objekt mithilfe eines Konstruktors, der einen Namen akzeptiert ein Betriebssystem-Semaphor mit diesem Namen zugeordnet ist. Benannte Semaphoren sind im gesamten Betriebssystem sichtbar und können zum Synchronisieren der Aktivitäten von Prozessen verwendet werden. Sie können mehrere erstellen <xref:System.Threading.Semaphore> gleich darstellende – Objekte benannte Systemsemaphor, und Sie können die <xref:System.Threading.Semaphore.OpenExisting%2A> Methode zum Öffnen eine vorhandene benannte Systemsemaphor.  
  
 Ein lokales Semaphor ist vorhanden, nur innerhalb des Prozesses. Er kann von jedem Thread in einem Prozess verwendet werden, der einen Verweis auf das lokale <xref:System.Threading.Semaphore>-Objekt enthält. Jede <xref:System.Threading.Semaphore> Objekt ist ein separates lokales Semaphor.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Semaphor erstellt, mit einer maximalen Anzahl von drei und eine anfängliche Anzahl von 0 (null). Das Beispiel beginnt fünf Threads, die das Semaphor warten zu blockieren. Der Hauptthread verwendet die <xref:System.Threading.Semaphore.Release%28System.Int32%29> -methodenüberladung, um die Semaphorenanzahl ausschöpfen, sodass drei Threads in das Semaphor zu erhöhen. Jeder Thread verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode für eine Sekunde warten, Arbeit, und ruft anschließend simulieren die <xref:System.Threading.Semaphore.Release> -methodenüberladung, um das Semaphor freizugeben. Jedes Mal, wenn das Semaphor freigegeben ist, wird die vorherige Anzahl des Semaphors angezeigt. Konsole Nachrichten nachverfolgen Semaphore verwenden. Das Arbeiten mit simulierten Intervall wird für jeden Thread, um die Ausgabe leichter lesbar zu machen geringfügig erhöht.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Semaphore" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Die anfängliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</param>
        <param name="maximumCount">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Semaphore" />-Klasse und gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert ein unbenanntes Semaphor. Alle Threads, die eine Instanz eines solchen Semaphors zu verwenden, müssen Verweise auf die Instanz.  
  
 Wenn `initialCount` ist kleiner als `maximumCount`, der Effekt ist derselbe, als ob der aktuelle Thread aufgerufen hätten <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) Mal. Wenn Sie nicht möchten, alle Einträge für den Thread zu reservieren, die das Semaphor erstellt, verwenden Sie die gleiche Anzahl für `maximumCount` und `initialCount`.  
  
   
  
## Examples  
 Im folgende Beispiel wird ein Semaphor erstellt, mit einer maximalen Anzahl von drei und eine anfängliche Anzahl von 0 (null). Das Beispiel beginnt fünf Threads, die das Semaphor warten zu blockieren. Der Hauptthread verwendet die <xref:System.Threading.Semaphore.Release%28System.Int32%29> -methodenüberladung, um die Semaphorenanzahl ausschöpfen, sodass drei Threads in das Semaphor zu erhöhen. Jeder Thread verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode für eine Sekunde warten, Arbeit, und ruft anschließend simulieren die <xref:System.Threading.Semaphore.Release> -methodenüberladung, um das Semaphor freizugeben. Jedes Mal, wenn das Semaphor freigegeben ist, wird die vorherige Anzahl des Semaphors angezeigt. Konsole Nachrichten nachverfolgen Semaphore verwenden. Das Arbeiten mit simulierten Intervall wird für jeden Thread, um die Ausgabe leichter lesbar zu machen geringfügig erhöht.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> ist größer als <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> ist kleiner als 1.  
  
- oder -  
 <paramref name="initialCount" /> ist kleiner als 0.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">Die anfängliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</param>
        <param name="maximumCount">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</param>
        <param name="name">Der Name eines benannten Systemsemaphorobjekts.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Semaphore" />-Klasse, gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen sowie optional den Namen eines Systemsemaphorobjekts an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.Semaphore> Objekt, das ein benanntes Systemsemaphor darstellt. Sie können mehrere erstellen <xref:System.Threading.Semaphore> gleich darstellende – Objekte benannte Systemsemaphor.  
  
 Wenn das benannte Systemsemaphor nicht vorhanden ist, wird es mit dem anfänglichen Zähler und die maximale Anzahl von angegeben erstellt `initialCount` und `maximumCount`. Wenn das benannte Systemsemaphor bereits vorhanden ist, `initialCount` und `maximumCount` werden nicht verwendet, obwohl ungültige Werte weiterhin Ausnahmen auslösen. Wenn Sie benötigen, um zu bestimmen, ob ein benanntes Systemsemaphor erstellt wurde, verwenden die <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> Konstruktor stattdessen die Überladung.  
  
> [!IMPORTANT]
>  Wenn Sie diese Konstruktorüberladung verwenden, wird empfohlen, für die gleiche Anzahl an `initialCount` und `maximumCount`. Wenn `initialCount` ist kleiner als `maximumCount`, und es wird ein benanntes Systemsemaphor erstellt, der Effekt ist derselbe, als ob der aktuelle Thread aufgerufen <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) Mal. Mit dieser Überladung des Konstruktors ist jedoch keine Möglichkeit festzustellen, ob ein benanntes Systemsemaphor erstellt wurde.  
  
 Bei Angabe von `null` oder eine leere Zeichenfolge für `name`, ein lokales Semaphor erstellt wird, wie bei einem Aufruf der <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> Überladung des Konstruktors.  
  
 Da benannte Semaphoren im gesamten Betriebssystem sichtbar sind, können sie verwendet werden, um die Ressourcenverwendung über Prozessgrenzen hinweg koordiniert.  
  
 Wenn Sie verwenden möchten, finden Sie heraus, ob ein benanntes Systemsemaphor vorhanden ist, verwenden Sie die <xref:System.Threading.Semaphore.OpenExisting%2A> Methode. Die <xref:System.Threading.Semaphore.OpenExisting%2A> Methode versucht, einen vorhandenen benannten Semaphors zu öffnen, und löst eine Ausnahme aus, wenn das Systemsemaphor nicht vorhanden ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das prozessübergreifende Verhalten eines benannten Semaphors. Das Beispiel erstellt einen benannten Semaphor mit einer maximalen Anzahl von fünf und eine anfängliche Anzahl von fünf. Das Programm sendet drei Aufrufe an die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode. Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird blockiert damit der dritte Aufruf von <xref:System.Threading.WaitHandle.WaitOne%2A>. Veröffentlichen Sie ein oder mehrere Einträge in der ersten Kopie des Programms ein, das zweite zu entsperren.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> ist größer als <paramref name="maximumCount" />.  
  
- oder -  
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> ist kleiner als 1.  
  
- oder -  
 <paramref name="initialCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der benannte Semaphor ist vorhanden und verfügt über Zugriffssteuerungssicherheit, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Der benannte Semaphor kann nicht erstellt werden, möglicherweise, weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code, um ein benanntes Systemsemaphor zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />  
  
Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">Die ursprüngliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</param>
        <param name="maximumCount">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</param>
        <param name="name">Der Name eines benannten Systemsemaphorobjekts.</param>
        <param name="createdNew">Enthält nach dem Beenden dieser Methode den Wert <see langword="true" />, wenn ein lokales Semaphor erstellt wurde (d. h., wenn <c>name</c> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemsemaphor erstellt wurde. Der Wert ist <see langword="false" />, wenn das angegebene benannte Systemsemaphor bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Semaphore" />-Klasse, gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen sowie optional den Namen eines Systemsemaphorobjekts an, gibt eine Variable an, die einen Wert empfängt, der angibt, ob ein neues Systemsemaphor erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.Semaphore> Objekt, das ein benanntes Systemsemaphor darstellt. Sie können mehrere erstellen <xref:System.Threading.Semaphore> gleich darstellende – Objekte benannte Systemsemaphor.  
  
 Wenn das benannte Systemsemaphor nicht vorhanden ist, wird es mit dem anfänglichen Zähler und die maximale Anzahl von angegeben erstellt `initialCount` und `maximumCount`. Wenn das benannte Systemsemaphor bereits vorhanden ist, `initialCount` und `maximumCount` werden nicht verwendet, obwohl ungültige Werte weiterhin Ausnahmen auslösen. Verwendung `createdNew` zu bestimmen, ob das Systemsemaphor erstellt wurde.  
  
 Wenn `initialCount` ist kleiner als `maximumCount`, und `createdNew` ist `true`, der Effekt ist derselbe, als ob der aktuelle Thread aufgerufen hätten <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) Mal.  
  
 Bei Angabe von `null` oder eine leere Zeichenfolge für `name`, ein lokales Semaphor erstellt wird, wie bei einem Aufruf der <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> Überladung des Konstruktors. In diesem Fall `createdNew` ist immer `true`.  
  
 Da benannte Semaphoren im gesamten Betriebssystem sichtbar sind, können sie verwendet werden, um die Ressourcenverwendung über Prozessgrenzen hinweg koordiniert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das prozessübergreifende Verhalten eines benannten Semaphors. Das Beispiel erstellt einen benannten Semaphor mit einer maximalen Anzahl von fünf und eine anfängliche Anzahl von zwei. D. h. er behält sich vor drei Einträge für den Thread, der den Konstruktor aufruft. Wenn `createNew` ist `false`, das Programm sendet drei Aufrufe an die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode. Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird blockiert damit der dritte Aufruf von <xref:System.Threading.WaitHandle.WaitOne%2A>. Veröffentlichen Sie ein oder mehrere Einträge in der ersten Kopie des Programms ein, das zweite zu entsperren.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> ist größer als <paramref name="maximumCount" />.  
  
- oder -  
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> ist kleiner als 1.  
  
- oder -  
 <paramref name="initialCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der benannte Semaphor ist vorhanden und verfügt über Zugriffssteuerungssicherheit, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Der benannte Semaphor kann nicht erstellt werden, möglicherweise, weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code, um ein benanntes Systemsemaphor zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />  
  
Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">Die ursprüngliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</param>
        <param name="maximumCount">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</param>
        <param name="name">Der Name eines benannten Systemsemaphorobjekts.</param>
        <param name="createdNew">Enthält nach dem Beenden dieser Methode den Wert <see langword="true" />, wenn ein lokales Semaphor erstellt wurde (d. h., wenn <c>name</c> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemsemaphor erstellt wurde. Der Wert ist <see langword="false" />, wenn das angegebene benannte Systemsemaphor bereits vorhanden war. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <param name="semaphoreSecurity">Ein <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf das benannte Systemsemaphor angewendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Semaphore" />-Klasse, gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen an, gibt optional den Namen eines Systemsemaphorobjekts an, gibt eine Variable an, die einen Wert empfängt, der angibt, ob ein neues Systemsemaphor erstellt wurde, und gibt die Sicherheitszugriffssteuerung für das Systemsemaphor an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor Steuerung des Zugriffs auf ein benanntes Systemsemaphor angewendet wird, wenn verhindert, dass anderer Code die Übernahme der Kontrolle über das Semaphor erstellt wurde, ein.  
  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.Semaphore> Objekt, das ein benanntes Systemsemaphor darstellt. Sie können mehrere erstellen <xref:System.Threading.Semaphore> gleich darstellende – Objekte benannte Systemsemaphor.  
  
 Wenn das benannte Systemsemaphor nicht vorhanden ist, wird es mit der angegebenen zugriffssteuerungssicherheit erstellt. Wenn der benannte Semaphor ist vorhanden, wird die angegebene zugriffssteuerungssicherheit ignoriert.  
  
> [!NOTE]
>  Der Aufrufer hat vollständige Kontrolle über die neu erstellte <xref:System.Threading.Semaphore> Objekt, selbst wenn `semaphoreSecurity` verweigert, oder ein Fehler auftritt, um einige über die Zugriffsrechte für den aktuellen Benutzer zu gewähren. Allerdings, wenn der aktuelle Benutzer versucht, erhalten einen anderen <xref:System.Threading.Semaphore> Objekt zur Darstellung der gleichen Semaphor, die entweder mit dem Namen eines Konstruktors oder der <xref:System.Threading.Semaphore.OpenExisting%2A> Methode, die Windows-zugriffssteuerungssicherheit angewendet wird.  
  
 Wenn das benannte Systemsemaphor nicht vorhanden ist, wird es mit dem anfänglichen Zähler und die maximale Anzahl von angegeben erstellt `initialCount` und `maximumCount`. Wenn das benannte Systemsemaphor bereits vorhanden ist, `initialCount` und `maximumCount` werden nicht verwendet, obwohl ungültige Werte weiterhin Ausnahmen auslösen. Verwenden der `createdNew` Parameter, um zu bestimmen, ob von diesem Konstruktor die Systemsemaphor erstellt wurde.  
  
 Wenn `initialCount` ist kleiner als `maximumCount`, und `createdNew` ist `true`, der Effekt ist derselbe, als ob der aktuelle Thread aufgerufen hätten <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) Mal.  
  
 Bei Angabe von `null` oder eine leere Zeichenfolge für `name`, ein lokales Semaphor erstellt wird, wie bei einem Aufruf der <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> Überladung des Konstruktors. In diesem Fall `createdNew` ist immer `true`.  
  
 Da benannte Semaphoren im gesamten Betriebssystem sichtbar sind, können sie verwendet werden, um die Ressourcenverwendung über Prozessgrenzen hinweg koordiniert.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das prozessübergreifende Verhalten eines benannten Semaphors mit zugriffssteuerungssicherheit. Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein eines benannten Semaphors zu testen. Wenn das Semaphor nicht vorhanden ist, wird es erstellt, mit einer maximalen Anzahl von zwei und mit zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Semaphor zu verwenden, aber wird nicht das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor. Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird eine Ausnahme Zugriff Verletzung beim Aufruf von der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> Methode. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> -methodenüberladung, um mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen die Semaphore zu öffnen.  
  
 Nachdem die Berechtigungen geändert werden, wird das Semaphor geöffnet, mit den erforderlichen Benutzerrechten zum Eintreten und freigeben. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird es mit der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> ist größer als <paramref name="maximumCount" />.  
  
- oder -  
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> ist kleiner als 1.  
  
- oder -  
 <paramref name="initialCount" /> ist kleiner als 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der benannte Semaphor ist vorhanden und verfügt über Zugriffssteuerungssicherheit, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Der benannte Semaphor kann nicht erstellt werden, möglicherweise, weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code, um ein benanntes Systemsemaphor zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Zugriffssteuerungssicherheit für ein benanntes Systemsemaphor ab.</summary>
        <returns>Ein <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />-Objekt, das die Zugriffssteuerungssicherheit für das benannte Systemsemaphor darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Semaphore.GetAccessControl%2A> -Methode verwendet die folgende Kombination von Flags (bitweise OR-Operation) für Berechtigungen suchen: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, und <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Der Benutzer <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> Rechte für diese Methode aufzurufen, und das Semaphor geöffnet worden sein müssen mit <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> Rechte.  
  
 Klicken Sie auf ein lokales Semaphor ist die zugriffssteuerungssicherheit irrelevant. Wenn die <xref:System.Threading.Semaphore> -Objekt stellt kein benanntes Systemsemaphor dar, die diese Methode gibt eine <xref:System.Security.AccessControl.SemaphoreSecurity> -Objekt, das alle Rechte für jeden Benutzer gewährt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das prozessübergreifende Verhalten eines benannten Semaphors mit zugriffssteuerungssicherheit. Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein eines benannten Semaphors zu testen.  
  
 Wenn das Semaphor nicht vorhanden ist, wird es erstellt, mit einer maximalen Anzahl von zwei und mit zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Semaphor zu verwenden, aber wird nicht das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor.  
  
 Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird eine Ausnahme Zugriff Verletzung beim Aufruf von der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> Methode. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> -methodenüberladung, um mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen die Semaphore zu öffnen. Die zugriffssteuerungssicherheit für das Systemsemaphor abgerufen wird, mit der <xref:System.Threading.Semaphore.GetAccessControl%2A> Methode.  
  
 Nachdem die Berechtigungen geändert werden, wird das Semaphor geöffnet, mit den erforderlichen Benutzerrechten zum Eintreten und freigeben. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird es mit der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Das aktuelle <see cref="T:System.Threading.Semaphore" />-Objekt stellt einen benannten Systemsemaphor dar, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />-Berechtigung.  
  
- oder -  
Das aktuelle <see cref="T:System.Threading.Semaphore" />-Objekt stellt einen benannten Systemsemaphor dar und wurde nicht mit <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />-Berechtigung geöffnet.</exception>
        <exception cref="T:System.NotSupportedException">Wird nicht für Windows 98 oder Windows Millennium Edition unterstützt.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein angegebenes benanntes Semaphor, wenn es bereits vorhanden ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsemaphors.</param>
        <summary>Öffnet das angegebene benannte Semaphor, wenn es bereits vorhanden ist.</summary>
        <returns>Ein Objekt, das das benannte Systemsemaphor darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Semaphore.OpenExisting%2A> Methode versucht, die das angegebene benannte Semaphor zu öffnen. Wenn das Systemsemaphor nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das Systemsemaphor an. Um das Systemsemaphor zu erstellen, wenn es nicht bereits vorhanden ist, gehen die <xref:System.Threading.Semaphore.%23ctor%2A> Konstruktoren, die eine `name` Parameter.  
  
 Mehrere Aufrufe dieser Methode, die den gleichen Wert für `name` ist nicht unbedingt zurück, die gleiche <xref:System.Threading.Semaphore> Objekt, auch wenn die Objekte, die zurückgegeben werden, stellen die gleichen Systemsemaphor mit dem Namen.  
  
 Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.Semaphore.OpenExisting%2A> -methodenüberladung, und geben <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechte, die mithilfe einer bitweise OR-Operation kombiniert.  
  
 Angeben der <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> Flag ermöglicht, dass einen Thread das Semaphor, und geben Sie die <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Flag ermöglicht, dass einen Thread aufrufen, die <xref:System.Threading.Semaphore.Release%2A> Methode.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das prozessübergreifende Verhalten eines benannten Semaphors mit zugriffssteuerungssicherheit. Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein eines benannten Semaphors zu testen.  
  
 Wenn das Semaphor nicht vorhanden ist, wird es erstellt, mit einer maximalen Anzahl von zwei und mit zugriffssteuerungssicherheit verweigert, die dem aktuellen Benutzer das Recht, das Semaphor zu verwenden, aber das wird nicht das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor.  
  
 Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird eine Ausnahme Zugriff Verletzung beim Aufruf von der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> -methodenüberladung. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> -methodenüberladung, um mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen die Semaphore zu öffnen.  
  
 Nachdem die Berechtigungen geändert werden, wird das Semaphor geöffnet, mit den erforderlichen Benutzerrechten zum eingeben und freigegeben werden soll. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird es mit der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder -  
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Semaphor ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der benannte Semaphor ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code, um ein benanntes Systemsemaphor zu öffnen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />  
  
Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsemaphors.</param>
        <param name="rights">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</param>
        <summary>Öffnet das angegebene benannte Semaphor, wenn es bereits vorhanden ist, mit dem gewünschten Sicherheitszugriff.</summary>
        <returns>Ein Objekt, das das benannte Systemsemaphor darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `rights` Parameter enthalten muss die <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> Flag, um Threads das Semaphor zu ermöglichen und die <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Flag, um Threads aufgerufen werden können die <xref:System.Threading.Semaphore.Release%2A> Methode.  
  
 Die <xref:System.Threading.Semaphore.OpenExisting%2A> Methode versucht, einen vorhandenen benannten Semaphors zu öffnen. Wenn das Systemsemaphor nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das Systemsemaphor an. Um das Systemsemaphor zu erstellen, wenn es nicht bereits vorhanden ist, gehen die <xref:System.Threading.Semaphore.%23ctor%2A> Konstruktoren, die eine `name` Parameter.  
  
 Mehrere Aufrufe dieser Methode, die den gleichen Wert für `name` ist nicht unbedingt zurück, die gleiche <xref:System.Threading.Semaphore> Objekt, auch wenn die Objekte, die zurückgegeben werden, stellen die gleichen Systemsemaphor mit dem Namen.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das prozessübergreifende Verhalten eines benannten Semaphors mit zugriffssteuerungssicherheit. Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein eines benannten Semaphors zu testen.  
  
 Wenn das Semaphor nicht vorhanden ist, wird es erstellt, mit einer maximalen Anzahl von zwei und mit zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Semaphor zu verwenden, aber wird nicht das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor.  
  
 Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird eine Ausnahme Zugriff Verletzung beim Aufruf von der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> Methode. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> -methodenüberladung, um mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen die Semaphore zu öffnen.  
  
 Nachdem die Berechtigungen geändert werden, wird das Semaphor geöffnet, mit den erforderlichen Benutzerrechten zum eingeben und freigegeben werden soll. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird es mit der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder -  
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Das benannte Semaphor ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das benannte Semaphor ist vorhanden, der Benutzer verfügt jedoch nicht über die gewünschten Sicherheitszugriffsrechte.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code, um ein benanntes Systemsemaphor zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />  
  
Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beendet das Semaphor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet das Semaphor und gibt die vorherige Anzahl zurück.</summary>
        <returns>Die Anzahl für das Semaphor vor dem Aufruf der <see cref="Overload:System.Threading.Semaphore.Release" />-Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie Threads in der Regel die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode, um in der Regel geben das Semaphor, und sie verwenden eine Überladung dieser Methode um zu beenden.  
  
 Wenn eine <xref:System.Threading.SemaphoreFullException> wird ausgelöst, durch die <xref:System.Threading.Semaphore.Release%2A> -Methode, es bedeutet nicht unbedingt ein Problem mit dem aufrufenden Thread. Ein Programmierfehler in einem anderen Thread kann dieser Thread das Semaphor mehrfach als er verursacht.  
  
 Wenn die aktuelle <xref:System.Threading.Semaphore> -Objekt stellt ein benanntes Systemsemaphor dar, die Benutzer benötigen <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechte und das Semaphor geöffnet worden sein müssen mit <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechte.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Semaphor erstellt, mit einer maximalen Anzahl von drei und eine anfängliche Anzahl von 0 (null). Das Beispiel beginnt fünf Threads, die das Semaphor warten zu blockieren. Der Hauptthread verwendet die <xref:System.Threading.Semaphore.Release%28System.Int32%29> -methodenüberladung, um die Semaphorenanzahl ausschöpfen, sodass drei Threads in das Semaphor zu erhöhen. Jeder Thread verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode für eine Sekunde warten, Arbeit, und ruft anschließend simulieren die <xref:System.Threading.Semaphore.Release> -methodenüberladung, um das Semaphor freizugeben.  
  
 Jedes Mal, wenn das Semaphor freigegeben ist, wird die vorherige Anzahl des Semaphors angezeigt. Konsole Nachrichten nachverfolgen Semaphore verwenden. Das Arbeiten mit simulierten Intervall wird für jeden Thread, um die Ausgabe leichter lesbar zu machen geringfügig erhöht.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">Die Anzahl für das Semaphor weist bereits den maximalen Wert auf.</exception>
        <exception cref="T:System.IO.IOException">Bei einem benannten Semaphor ist ein Win32-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar. Der Benutzer verfügt jedoch nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
- oder -  
Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar, es wurde jedoch nicht mit <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> geöffnet.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">Die Anzahl von Malen, die das Semaphor freigegeben werden soll.</param>
        <summary>Gibt das Semaphor eine festgelegte Anzahl von Malen frei und gibt die vorherige Anzahl zurück.</summary>
        <returns>Die Anzahl für das Semaphor vor dem Aufruf der <see cref="Overload:System.Threading.Semaphore.Release" />-Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Thread das Semaphor mehrfach eingegeben hat, kann die Überladung dieser Methode die gesamte Semaphorenanzahl mit einem einzigen Aufruf wiederhergestellt werden.  
  
 Wenn eine <xref:System.Threading.SemaphoreFullException> wird ausgelöst, durch die <xref:System.Threading.Semaphore.Release%2A> -Methode, es bedeutet nicht unbedingt ein Problem mit dem aufrufenden Thread. Ein Programmierfehler in einem anderen Thread kann dieser Thread das Semaphor mehrfach als er verursacht.  
  
 Wenn die aktuelle <xref:System.Threading.Semaphore> -Objekt stellt ein benanntes Systemsemaphor dar, die Benutzer benötigen <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechte und das Semaphor geöffnet worden sein müssen mit <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechte.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Semaphor erstellt, mit einer maximalen Anzahl von drei und eine anfängliche Anzahl von 0 (null). Das Beispiel beginnt fünf Threads, die das Semaphor warten zu blockieren. Der Hauptthread verwendet die <xref:System.Threading.Semaphore.Release%28System.Int32%29> -methodenüberladung, um die Semaphorenanzahl ausschöpfen, sodass drei Threads in das Semaphor zu erhöhen. Jeder Thread verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode für eine Sekunde warten, Arbeit, und ruft anschließend simulieren die <xref:System.Threading.Semaphore.Release> -methodenüberladung, um das Semaphor freizugeben.  
  
 Jedes Mal, wenn das Semaphor freigegeben ist, wird die vorherige Anzahl des Semaphors angezeigt. Konsole Nachrichten nachverfolgen Semaphore verwenden. Das Arbeiten mit simulierten Intervall wird für jeden Thread, um die Ausgabe leichter lesbar zu machen geringfügig erhöht.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="releaseCount" /> ist kleiner als 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">Die Anzahl für das Semaphor weist bereits den maximalen Wert auf.</exception>
        <exception cref="T:System.IO.IOException">Bei einem benannten Semaphor ist ein Win32-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar. Der Benutzer verfügt jedoch nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />-Rechte.  
  
- oder -  
Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar, es wurde jedoch nicht mit <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />-Rechten geöffnet.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">Ein <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf das benannte Systemsemaphor angewendet werden soll.</param>
        <summary>Legt die Zugriffssteuerungssicherheit für ein benanntes Systemsemaphor fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die zugriffssteuerungssicherheit festlegen, nur auf <xref:System.Threading.Semaphore> benanntes Semaphore darstellende – Objekte.  
  
 Der Benutzer <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> Rechte für diese Methode aufzurufen, und das Semaphor geöffnet worden sein müssen mit <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> Rechte.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das prozessübergreifende Verhalten eines benannten Semaphors mit zugriffssteuerungssicherheit. Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein eines benannten Semaphors zu testen.  
  
 Wenn das Semaphor nicht vorhanden ist, wird es erstellt, mit einer maximalen Anzahl von zwei und mit zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Semaphor zu verwenden, aber wird nicht das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor.  
  
 Wenn Sie das kompilierte Beispiel über zwei Befehlsfenster ausführen, die zweite Kopie wird eine Ausnahme Zugriff Verletzung beim Aufruf von der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> Methode. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> -methodenüberladung, um mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen die Semaphore zu öffnen.  
  
 Nach dem Ändern der Berechtigungen mithilfe der <xref:System.Threading.Semaphore.SetAccessControl%2A> mit den erforderlichen Benutzerrechten zum eingeben und release-Methode, das Semaphor geöffnet wird. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird es mit der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="semaphoreSecurity" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />-Rechte.  
  
- oder -  
Das Semaphor wurde nicht mit <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />-Rechten geöffnet.</exception>
        <exception cref="T:System.NotSupportedException">Das aktuelle <see cref="T:System.Threading.Semaphore" />-Objekt stellt kein benanntes Systemsemaphor dar.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein angegebenes benanntes Semaphor, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsemaphors.</param>
        <param name="result">Enthält nach Beenden der Methode ein <see cref="T:System.Threading.Semaphore" />-Objekt, das das benannte Semaphor darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn der Aufruf fehlgeschlagen ist. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Öffnet das angegebene benannte Semaphor, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
        <returns>
          <see langword="true" />, wenn das benannte Semaphor erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das benannte Semaphor nicht vorhanden ist, wird es von dieser Methode nicht erstellt. Um das Systemsemaphor zu erstellen, wenn es nicht bereits vorhanden ist, gehen die <xref:System.Threading.Semaphore.%23ctor%2A> Konstruktoren, die eine `name` Parameter.  
  
 Wenn Sie unsicher sind, gibt an, ob ein benanntes Semaphor ist vorhanden, verwenden Sie die Überladung dieser Methode nicht die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> methodenüberladung, die eine Ausnahme auslöst, wenn das Semaphor nicht vorhanden ist.  
  
 Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.Semaphore.TryOpenExisting%2A> -methodenüberladung, und geben <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechte, die mithilfe einer bitweise OR-Operation kombiniert. Angeben der <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> Flag ermöglicht, dass einen Thread das Semaphor, und geben Sie die <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Flag ermöglicht, dass einen Thread aufrufen, die <xref:System.Threading.Semaphore.Release%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder -  
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der benannte Semaphor ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu öffnenden Systemsemaphors.</param>
        <param name="rights">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</param>
        <param name="result">Enthält nach Beenden der Methode ein <see cref="T:System.Threading.Semaphore" />-Objekt, das das benannte Semaphor darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn der Aufruf fehlgeschlagen ist. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Öffnet das angegebene benannte Semaphor, wenn es bereits mit dem gewünschten Sicherheitszugriff vorhanden ist und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</summary>
        <returns>
          <see langword="true" />, wenn das benannte Semaphor erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das benannte Semaphor nicht vorhanden ist, wird es von dieser Methode nicht erstellt. Um das Systemsemaphor zu erstellen, wenn es nicht bereits vorhanden ist, gehen die <xref:System.Threading.Semaphore.%23ctor%2A> Konstruktoren, die eine `name` Parameter.  
  
 Wenn Sie unsicher sind, gibt an, ob ein benanntes Semaphor ist vorhanden, verwenden Sie die Überladung dieser Methode nicht die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> methodenüberladung, die eine Ausnahme auslöst, wenn das Semaphor nicht vorhanden ist.  
  
 Die `rights` Parameter enthalten muss die <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> Flag, um Threads das Semaphor zu ermöglichen und die <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Flag, um Threads aufgerufen werden können die <xref:System.Threading.Semaphore.Release%2A> Methode.  
  
 Mehrere Aufrufe dieser Methode, die den gleichen Wert für `name` ist nicht unbedingt zurück, die gleiche <xref:System.Threading.Semaphore> Objekt, auch wenn die Objekte, die zurückgegeben werden, stellen die gleichen Systemsemaphor mit dem Namen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> ist eine leere Zeichenfolge.  
  
- oder -  
 <paramref name="name" /> ist länger als 260 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Win32-Fehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der benannte Semaphor ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</exception>
      </Docs>
    </Member>
  </Members>
</Type>