<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b53add0a4b0be18cda3ae161bbeb088161899ebd" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82289449" /></Metadata><TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="a148b-101">Schränkt die Anzahl von Threads ein, die gleichzeitig auf eine Ressource oder einen Pool von Ressourcen zugreifen können.</span><span class="sxs-lookup"><span data-stu-id="a148b-101">Limits the number of threads that can access a resource or pool of resources concurrently.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a148b-102">Verwenden Sie die <xref:System.Threading.Semaphore>-Klasse, um den Zugriff auf einen Ressourcenpool zu steuern.</span><span class="sxs-lookup"><span data-stu-id="a148b-102">Use the <xref:System.Threading.Semaphore> class to control access to a pool of resources.</span></span> <span data-ttu-id="a148b-103">Threads geben das Semaphor ein, indem Sie die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode aufrufen, die von der <xref:System.Threading.WaitHandle>-Klasse geerbt wird, und das Semaphor freigeben, indem Sie die <xref:System.Threading.Semaphore.Release%2A>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="a148b-103">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, and release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="a148b-104">Die Anzahl in einem Semaphor wird jedes Mal dekrementiert, wenn ein Thread in das Semaphor eintritt, und erhöht sich, wenn ein Thread das Semaphor freigibt.</span><span class="sxs-lookup"><span data-stu-id="a148b-104">The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore.</span></span> <span data-ttu-id="a148b-105">Wenn die Anzahl 0 (null) ist, werden nachfolgende Anforderungen blockiert, bis andere Threads das Semaphor freigeben.</span><span class="sxs-lookup"><span data-stu-id="a148b-105">When the count is zero, subsequent requests block until other threads release the semaphore.</span></span> <span data-ttu-id="a148b-106">Wenn alle Threads das Semaphor freigegeben haben, liegt die Anzahl bei dem maximalen Wert, der beim Erstellen des Semaphors angegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="a148b-106">When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.</span></span>  
  
 <span data-ttu-id="a148b-107">Es gibt keine garantierte Reihenfolge, z. b. FIFO oder LIFO, bei der blockierte Threads in das Semaphor eintreten.</span><span class="sxs-lookup"><span data-stu-id="a148b-107">There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.</span></span>  
  
 <span data-ttu-id="a148b-108">Ein Thread kann das Semaphor mehrmals eingeben, indem er die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode wiederholt aufrufen.</span><span class="sxs-lookup"><span data-stu-id="a148b-108">A thread can enter the semaphore multiple times, by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method repeatedly.</span></span> <span data-ttu-id="a148b-109">Um einige oder alle dieser Einträge freizugeben, kann der Thread die parameterlose <xref:System.Threading.Semaphore.Release> Methoden Überladung mehrmals aufrufen, oder er kann die <xref:System.Threading.Semaphore.Release%28System.Int32%29>-Methoden Überladung aufrufen, die die Anzahl der frei zugebende Einträge angibt.</span><span class="sxs-lookup"><span data-stu-id="a148b-109">To release some or all of these entries, the thread can call the parameterless <xref:System.Threading.Semaphore.Release> method overload multiple times, or it can call the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload that specifies the number of entries to be released.</span></span>  
  
 <span data-ttu-id="a148b-110">Die <xref:System.Threading.Semaphore>-Klasse erzwingt keine Thread Identität bei Aufrufen von <xref:System.Threading.WaitHandle.WaitOne%2A> oder <xref:System.Threading.Semaphore.Release%2A>.</span><span class="sxs-lookup"><span data-stu-id="a148b-110">The <xref:System.Threading.Semaphore> class does not enforce thread identity on calls to <xref:System.Threading.WaitHandle.WaitOne%2A> or <xref:System.Threading.Semaphore.Release%2A>.</span></span> <span data-ttu-id="a148b-111">Es ist Aufgabe des Programmierers, sicherzustellen, dass Threads die Semaphor nicht zu oft freigeben.</span><span class="sxs-lookup"><span data-stu-id="a148b-111">It is the programmer's responsibility to ensure that threads do not release the semaphore too many times.</span></span> <span data-ttu-id="a148b-112">Angenommen, ein Semaphor hat einen maximalen Zähler von zwei und Thread A sowie Thread B wechseln beide in das Semaphor.</span><span class="sxs-lookup"><span data-stu-id="a148b-112">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="a148b-113">Wenn ein Programmierfehler in Thread B bewirkt, dass <xref:System.Threading.Semaphore.Release%2A> zweimal aufruft, sind beide Aufrufe erfolgreich.</span><span class="sxs-lookup"><span data-stu-id="a148b-113">If a programming error in thread B causes it to call <xref:System.Threading.Semaphore.Release%2A> twice, both calls succeed.</span></span> <span data-ttu-id="a148b-114">Der Zähler des Semaphors ist voll, und wenn Thread A schließlich <xref:System.Threading.Semaphore.Release%2A> aufruft, wird eine <xref:System.Threading.SemaphoreFullException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="a148b-114">The count on the semaphore is full, and when thread A eventually calls <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
 <span data-ttu-id="a148b-115">Semaphoren haben zwei Typen: lokale Semaphoren und benannte System Semaphoren.</span><span class="sxs-lookup"><span data-stu-id="a148b-115">Semaphores are of two types: local semaphores and named system semaphores.</span></span> <span data-ttu-id="a148b-116">Wenn Sie ein <xref:System.Threading.Semaphore> Objekt mithilfe eines Konstruktors erstellen, der einen Namen akzeptiert, wird er einem Betriebssystem-Semaphor dieses Namens zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="a148b-116">If you create a <xref:System.Threading.Semaphore> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name.</span></span> <span data-ttu-id="a148b-117">Benannte System Semaphoren sind im gesamten Betriebssystem sichtbar und können verwendet werden, um die Aktivitäten von Prozessen zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="a148b-117">Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="a148b-118">Sie können mehrere <xref:System.Threading.Semaphore> Objekte erstellen, die das gleiche benannte System Semaphor darstellen, und Sie können die <xref:System.Threading.Semaphore.OpenExisting%2A>-Methode verwenden, um ein vorhandenes benanntes System Semaphore zu öffnen.</span><span class="sxs-lookup"><span data-stu-id="a148b-118">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore, and you can use the <xref:System.Threading.Semaphore.OpenExisting%2A> method to open an existing named system semaphore.</span></span>  
  
 <span data-ttu-id="a148b-119">Ein lokales Semaphor ist nur innerhalb des Prozesses vorhanden.</span><span class="sxs-lookup"><span data-stu-id="a148b-119">A local semaphore exists only within your process.</span></span> <span data-ttu-id="a148b-120">Er kann von jedem Thread in einem Prozess verwendet werden, der einen Verweis auf das lokale <xref:System.Threading.Semaphore>-Objekt enthält.</span><span class="sxs-lookup"><span data-stu-id="a148b-120">It can be used by any thread in your process that has a reference to the local <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="a148b-121">Jedes <xref:System.Threading.Semaphore> Objekt ist ein separates lokales Semaphor.</span><span class="sxs-lookup"><span data-stu-id="a148b-121">Each <xref:System.Threading.Semaphore> object is a separate local semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a148b-122">Im folgenden Codebeispiel wird ein Semaphor mit einer maximalen Anzahl von drei und einer anfänglichen Anzahl von 0 (null) erstellt.</span><span class="sxs-lookup"><span data-stu-id="a148b-122">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="a148b-123">Im Beispiel werden fünf Threads gestartet, die blockieren, um auf das Semaphor zu warten.</span><span class="sxs-lookup"><span data-stu-id="a148b-123">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="a148b-124">Der Haupt Thread verwendet die <xref:System.Threading.Semaphore.Release%28System.Int32%29>-Methoden Überladung, um die Anzahl der Semaphor auf den maximalen Wert zu erhöhen, sodass drei Threads in das Semaphor gelangen können.</span><span class="sxs-lookup"><span data-stu-id="a148b-124">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="a148b-125">Jeder Thread verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>-Methode, um eine Sekunde zu warten, um die Arbeit zu simulieren, und ruft dann die <xref:System.Threading.Semaphore.Release>-Methoden Überladung auf, um das Semaphor freizugeben.</span><span class="sxs-lookup"><span data-stu-id="a148b-125">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="a148b-126">Jedes Mal, wenn das Semaphor freigegeben wird, wird die vorherige Semaphor-Anzahl angezeigt.</span><span class="sxs-lookup"><span data-stu-id="a148b-126">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="a148b-127">Konsolen Meldungen verfolgen die Verwendung von Semaphor.</span><span class="sxs-lookup"><span data-stu-id="a148b-127">Console messages track semaphore use.</span></span> <span data-ttu-id="a148b-128">Das simulierte Arbeitsintervall wird für jeden Thread geringfügig angehoben, damit die Ausgabe leichter lesbar ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-128">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="a148b-129">Dieser Typ ist threadsicher.</span><span class="sxs-lookup"><span data-stu-id="a148b-129">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="a148b-130">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="a148b-130">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="a148b-131">Semaphore</span><span class="sxs-lookup"><span data-stu-id="a148b-131">Semaphore</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a148b-132">Initialisiert eine neue Instanz der Klasse <see cref="T:System.Threading.Semaphore" />.</span><span class="sxs-lookup"><span data-stu-id="a148b-132">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount"><span data-ttu-id="a148b-133">Die anfängliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</span><span class="sxs-lookup"><span data-stu-id="a148b-133">The initial number of requests for the semaphore that can be granted concurrently.</span></span></param>
        <param name="maximumCount"><span data-ttu-id="a148b-134">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</span><span class="sxs-lookup"><span data-stu-id="a148b-134">The maximum number of requests for the semaphore that can be granted concurrently.</span></span></param>
        <summary><span data-ttu-id="a148b-135">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Semaphore" />-Klasse und gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen an.</span><span class="sxs-lookup"><span data-stu-id="a148b-135">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a148b-136">Dieser Konstruktor initialisiert ein unbenanntes Semaphor.</span><span class="sxs-lookup"><span data-stu-id="a148b-136">This constructor initializes an unnamed semaphore.</span></span> <span data-ttu-id="a148b-137">Alle Threads, die eine Instanz eines solchen Semaphors verwenden, müssen Verweise auf die Instanz aufweisen.</span><span class="sxs-lookup"><span data-stu-id="a148b-137">All threads that use an instance of such a semaphore must have references to the instance.</span></span>  
  
 <span data-ttu-id="a148b-138">Wenn `initialCount` kleiner als `maximumCount`ist, entspricht der Effekt dem, wenn der aktuelle Thread <xref:System.Threading.WaitHandle.WaitOne%2A>-Zeit (`maximumCount` minus `initialCount`) aufgerufen hat.</span><span class="sxs-lookup"><span data-stu-id="a148b-138">If `initialCount` is less than `maximumCount`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="a148b-139">Wenn Sie keine Einträge für den Thread reservieren möchten, der das Semaphor erstellt, verwenden Sie die gleiche Zahl für `maximumCount` und `initialCount`.</span><span class="sxs-lookup"><span data-stu-id="a148b-139">If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for `maximumCount` and `initialCount`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a148b-140">Im folgenden Beispiel wird ein Semaphor mit einer maximalen Anzahl von drei und einer anfänglichen Anzahl von 0 (null) erstellt.</span><span class="sxs-lookup"><span data-stu-id="a148b-140">The following example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="a148b-141">Im Beispiel werden fünf Threads gestartet, die blockieren, um auf das Semaphor zu warten.</span><span class="sxs-lookup"><span data-stu-id="a148b-141">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="a148b-142">Der Haupt Thread verwendet die <xref:System.Threading.Semaphore.Release%28System.Int32%29>-Methoden Überladung, um die Anzahl der Semaphor auf den maximalen Wert zu erhöhen, sodass drei Threads in das Semaphor gelangen können.</span><span class="sxs-lookup"><span data-stu-id="a148b-142">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="a148b-143">Jeder Thread verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>-Methode, um eine Sekunde zu warten, um die Arbeit zu simulieren, und ruft dann die <xref:System.Threading.Semaphore.Release>-Methoden Überladung auf, um das Semaphor freizugeben.</span><span class="sxs-lookup"><span data-stu-id="a148b-143">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="a148b-144">Jedes Mal, wenn das Semaphor freigegeben wird, wird die vorherige Semaphor-Anzahl angezeigt.</span><span class="sxs-lookup"><span data-stu-id="a148b-144">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="a148b-145">Konsolen Meldungen verfolgen die Verwendung von Semaphor.</span><span class="sxs-lookup"><span data-stu-id="a148b-145">Console messages track semaphore use.</span></span> <span data-ttu-id="a148b-146">Das simulierte Arbeitsintervall wird für jeden Thread geringfügig angehoben, damit die Ausgabe leichter lesbar ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-146">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a148b-147"><paramref name="initialCount" /> ist größer als <paramref name="maximumCount" />.</span><span class="sxs-lookup"><span data-stu-id="a148b-147"><paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a148b-148"><paramref name="maximumCount" /> ist kleiner als 1.</span><span class="sxs-lookup"><span data-stu-id="a148b-148"><paramref name="maximumCount" /> is less than 1.</span></span>  
  
<span data-ttu-id="a148b-149">Oder</span><span class="sxs-lookup"><span data-stu-id="a148b-149">-or-</span></span> 
 <span data-ttu-id="a148b-150"><paramref name="initialCount" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="a148b-150"><paramref name="initialCount" /> is less than 0.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="a148b-151">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="a148b-151">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="a148b-152">Semaphore</span><span class="sxs-lookup"><span data-stu-id="a148b-152">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount"><span data-ttu-id="a148b-153">Die anfängliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</span><span class="sxs-lookup"><span data-stu-id="a148b-153">The initial number of requests for the semaphore that can be granted concurrently.</span></span></param>
        <param name="maximumCount"><span data-ttu-id="a148b-154">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</span><span class="sxs-lookup"><span data-stu-id="a148b-154">The maximum number of requests for the semaphore that can be granted concurrently.</span></span></param>
        <param name="name"><span data-ttu-id="a148b-155">Der Name eines benannten Systemsemaphorobjekts.</span><span class="sxs-lookup"><span data-stu-id="a148b-155">The name of a named system semaphore object.</span></span></param>
        <summary><span data-ttu-id="a148b-156">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Semaphore" />-Klasse, gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen sowie optional den Namen eines Systemsemaphorobjekts an.</span><span class="sxs-lookup"><span data-stu-id="a148b-156">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a148b-157">Dieser Konstruktor initialisiert ein <xref:System.Threading.Semaphore> Objekt, das ein benanntes System Semaphor darstellt.</span><span class="sxs-lookup"><span data-stu-id="a148b-157">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="a148b-158">Sie können mehrere <xref:System.Threading.Semaphore> Objekte erstellen, die dasselbe benannte System Semaphor darstellen.</span><span class="sxs-lookup"><span data-stu-id="a148b-158">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="a148b-159">Wenn das benannte System Semaphor nicht vorhanden ist, wird es mit der anfänglichen Anzahl und der maximalen Anzahl erstellt, die durch `initialCount` und `maximumCount`angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="a148b-159">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="a148b-160">Wenn das benannte System Semaphor bereits vorhanden ist, werden `initialCount` und `maximumCount` nicht verwendet, obwohl ungültige Werte weiterhin Ausnahmen verursachen.</span><span class="sxs-lookup"><span data-stu-id="a148b-160">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="a148b-161">Wenn Sie bestimmen müssen, ob ein benanntes System Semaphor erstellt wurde, verwenden Sie stattdessen die <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29>-Konstruktorüberladung.</span><span class="sxs-lookup"><span data-stu-id="a148b-161">If you need to determine whether or not a named system semaphore was created, use the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> constructor overload instead.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a148b-162">Wenn Sie diese Konstruktorüberladung verwenden, empfiehlt es sich, für `initialCount` und `maximumCount`dieselbe Zahl anzugeben.</span><span class="sxs-lookup"><span data-stu-id="a148b-162">When you use this constructor overload, the recommended practice is to specify the same number for `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="a148b-163">Wenn `initialCount` kleiner als `maximumCount`ist und ein benanntes System Semaphor erstellt wird, entspricht der Effekt dem, wenn der aktuelle Thread <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`)-Zeiten aufgerufen hätte.</span><span class="sxs-lookup"><span data-stu-id="a148b-163">If `initialCount` is less than `maximumCount`, and a named system semaphore is created, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="a148b-164">Bei dieser Konstruktorüberladung gibt es jedoch keine Möglichkeit, zu bestimmen, ob ein benanntes System Semaphor erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="a148b-164">However, with this constructor overload there is no way to determine whether a named system semaphore was created.</span></span>  
  
 <span data-ttu-id="a148b-165">Wenn Sie `null` oder eine leere Zeichenfolge für `name`angeben, wird ein lokales Semaphor erstellt, als ob Sie die <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29>-Konstruktorüberladung aufgerufen hätten.</span><span class="sxs-lookup"><span data-stu-id="a148b-165">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span>  
  
 <span data-ttu-id="a148b-166">Da benannte Semaphoren im gesamten Betriebssystem sichtbar sind, können Sie verwendet werden, um die Ressourcenverwendung über Prozess Grenzen hinweg zu koordinieren.</span><span class="sxs-lookup"><span data-stu-id="a148b-166">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
 <span data-ttu-id="a148b-167">Wenn Sie herausfinden möchten, ob ein benanntes System Semaphor vorhanden ist, verwenden Sie die <xref:System.Threading.Semaphore.OpenExisting%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="a148b-167">If you want to find out whether a named system semaphore exists, use the <xref:System.Threading.Semaphore.OpenExisting%2A> method.</span></span> <span data-ttu-id="a148b-168">Die <xref:System.Threading.Semaphore.OpenExisting%2A>-Methode versucht, ein vorhandenes benanntes Semaphor zu öffnen, und löst eine Ausnahme aus, wenn das System Semaphor nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-168">The <xref:System.Threading.Semaphore.OpenExisting%2A> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a148b-169">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Semaphors veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="a148b-169">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="a148b-170">Das Beispiel erstellt ein benanntes Semaphor mit einer maximalen Anzahl von fünf und einer anfänglichen Anzahl von fünf.</span><span class="sxs-lookup"><span data-stu-id="a148b-170">The example creates a named semaphore with a maximum count of five and an initial count of five.</span></span> <span data-ttu-id="a148b-171">Das Programm führt drei Aufrufe an die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode aus.</span><span class="sxs-lookup"><span data-stu-id="a148b-171">The program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="a148b-172">Wenn Sie also das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, wird die zweite Kopie beim dritten <xref:System.Threading.WaitHandle.WaitOne%2A>-aufrufblock blockiert.</span><span class="sxs-lookup"><span data-stu-id="a148b-172">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="a148b-173">Geben Sie mindestens einen Eintrag in der ersten Kopie des Programms frei, um die Blockierung der zweiten aufzuheben.</span><span class="sxs-lookup"><span data-stu-id="a148b-173">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a148b-174"><paramref name="initialCount" /> ist größer als <paramref name="maximumCount" />.</span><span class="sxs-lookup"><span data-stu-id="a148b-174"><paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span></span>  
  
<span data-ttu-id="a148b-175">Oder</span><span class="sxs-lookup"><span data-stu-id="a148b-175">-or-</span></span> 
 <span data-ttu-id="a148b-176"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="a148b-176"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a148b-177"><paramref name="maximumCount" /> ist kleiner als 1.</span><span class="sxs-lookup"><span data-stu-id="a148b-177"><paramref name="maximumCount" /> is less than 1.</span></span>  
  
<span data-ttu-id="a148b-178">Oder</span><span class="sxs-lookup"><span data-stu-id="a148b-178">-or-</span></span> 
 <span data-ttu-id="a148b-179"><paramref name="initialCount" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="a148b-179"><paramref name="initialCount" /> is less than 0.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a148b-180">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="a148b-180">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a148b-181">Der benannte Semaphor ist vorhanden und verfügt über Zugriffssteuerungssicherheit, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="a148b-181">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="a148b-182">Der benannte Semaphor kann nicht erstellt werden, möglicherweise, weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</span><span class="sxs-lookup"><span data-stu-id="a148b-182">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="a148b-183">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="a148b-183">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="a148b-184">Semaphore</span><span class="sxs-lookup"><span data-stu-id="a148b-184">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string * bool -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount"><span data-ttu-id="a148b-185">Die ursprüngliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</span><span class="sxs-lookup"><span data-stu-id="a148b-185">The initial number of requests for the semaphore that can be satisfied concurrently.</span></span></param>
        <param name="maximumCount"><span data-ttu-id="a148b-186">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</span><span class="sxs-lookup"><span data-stu-id="a148b-186">The maximum number of requests for the semaphore that can be satisfied concurrently.</span></span></param>
        <param name="name"><span data-ttu-id="a148b-187">Der Name eines benannten Systemsemaphorobjekts.</span><span class="sxs-lookup"><span data-stu-id="a148b-187">The name of a named system semaphore object.</span></span></param>
        <param name="createdNew"><span data-ttu-id="a148b-188">Enthält nach dem Beenden dieser Methode den Wert <see langword="true" />, wenn ein lokales Semaphor erstellt wurde (d. h., wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemsemaphor erstellt wurde. Der Wert ist <see langword="false" />, wenn das angegebene benannte Systemsemaphor bereits vorhanden war.</span><span class="sxs-lookup"><span data-stu-id="a148b-188">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span></span> <span data-ttu-id="a148b-189">Dieser Parameter wird nicht initialisiert übergeben.</span><span class="sxs-lookup"><span data-stu-id="a148b-189">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="a148b-190">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Semaphore" />-Klasse, gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen sowie optional den Namen eines Systemsemaphorobjekts an, gibt eine Variable an, die einen Wert empfängt, der angibt, ob ein neues Systemsemaphor erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="a148b-190">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a148b-191">Dieser Konstruktor initialisiert ein <xref:System.Threading.Semaphore> Objekt, das ein benanntes System Semaphor darstellt.</span><span class="sxs-lookup"><span data-stu-id="a148b-191">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="a148b-192">Sie können mehrere <xref:System.Threading.Semaphore> Objekte erstellen, die dasselbe benannte System Semaphor darstellen.</span><span class="sxs-lookup"><span data-stu-id="a148b-192">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="a148b-193">Wenn das benannte System Semaphor nicht vorhanden ist, wird es mit der anfänglichen Anzahl und der maximalen Anzahl erstellt, die durch `initialCount` und `maximumCount`angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="a148b-193">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="a148b-194">Wenn das benannte System Semaphor bereits vorhanden ist, werden `initialCount` und `maximumCount` nicht verwendet, obwohl ungültige Werte weiterhin Ausnahmen verursachen.</span><span class="sxs-lookup"><span data-stu-id="a148b-194">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="a148b-195">Verwenden Sie `createdNew`, um zu bestimmen, ob das System Semaphor erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="a148b-195">Use `createdNew` to determine whether the system semaphore was created.</span></span>  
  
 <span data-ttu-id="a148b-196">Wenn `initialCount` kleiner als `maximumCount`und `createdNew` `true`ist, entspricht der Effekt dem, wenn der aktuelle Thread <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) Mal aufgerufen hätte.</span><span class="sxs-lookup"><span data-stu-id="a148b-196">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="a148b-197">Wenn Sie `null` oder eine leere Zeichenfolge für `name`angeben, wird ein lokales Semaphor erstellt, als ob Sie die <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29>-Konstruktorüberladung aufgerufen hätten.</span><span class="sxs-lookup"><span data-stu-id="a148b-197">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="a148b-198">In diesem Fall wird `createdNew` immer `true`.</span><span class="sxs-lookup"><span data-stu-id="a148b-198">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="a148b-199">Da benannte Semaphoren im gesamten Betriebssystem sichtbar sind, können Sie verwendet werden, um die Ressourcenverwendung über Prozess Grenzen hinweg zu koordinieren.</span><span class="sxs-lookup"><span data-stu-id="a148b-199">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a148b-200">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Semaphors veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="a148b-200">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="a148b-201">Das Beispiel erstellt ein benanntes Semaphor mit einer maximalen Anzahl von fünf und einer anfänglichen Anzahl von zwei.</span><span class="sxs-lookup"><span data-stu-id="a148b-201">The example creates a named semaphore with a maximum count of five and an initial count of two.</span></span> <span data-ttu-id="a148b-202">Das heißt, es werden drei Einträge für den Thread reserviert, der den Konstruktor aufruft.</span><span class="sxs-lookup"><span data-stu-id="a148b-202">That is, it reserves three entries for the thread that calls the constructor.</span></span> <span data-ttu-id="a148b-203">Wenn `createNew` `false`ist, führt das Programm drei Aufrufe an die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode aus.</span><span class="sxs-lookup"><span data-stu-id="a148b-203">If `createNew` is `false`, the program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="a148b-204">Wenn Sie also das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, wird die zweite Kopie beim dritten <xref:System.Threading.WaitHandle.WaitOne%2A>-aufrufblock blockiert.</span><span class="sxs-lookup"><span data-stu-id="a148b-204">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="a148b-205">Geben Sie mindestens einen Eintrag in der ersten Kopie des Programms frei, um die Blockierung der zweiten aufzuheben.</span><span class="sxs-lookup"><span data-stu-id="a148b-205">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a148b-206"><paramref name="initialCount" /> ist größer als <paramref name="maximumCount" />.</span><span class="sxs-lookup"><span data-stu-id="a148b-206"><paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span></span>  
  
<span data-ttu-id="a148b-207">Oder</span><span class="sxs-lookup"><span data-stu-id="a148b-207">-or-</span></span> 
 <span data-ttu-id="a148b-208"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="a148b-208"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a148b-209"><paramref name="maximumCount" /> ist kleiner als 1.</span><span class="sxs-lookup"><span data-stu-id="a148b-209"><paramref name="maximumCount" /> is less than 1.</span></span>  
  
<span data-ttu-id="a148b-210">Oder</span><span class="sxs-lookup"><span data-stu-id="a148b-210">-or-</span></span> 
 <span data-ttu-id="a148b-211"><paramref name="initialCount" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="a148b-211"><paramref name="initialCount" /> is less than 0.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a148b-212">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="a148b-212">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a148b-213">Der benannte Semaphor ist vorhanden und verfügt über Zugriffssteuerungssicherheit, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="a148b-213">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="a148b-214">Der benannte Semaphor kann nicht erstellt werden, möglicherweise, weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</span><span class="sxs-lookup"><span data-stu-id="a148b-214">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="a148b-215">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="a148b-215">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="a148b-216">Semaphore</span><span class="sxs-lookup"><span data-stu-id="a148b-216">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean, semaphoreSecurity As SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string * bool * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="maximumCount" Type="System.Int32" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initialCount"><span data-ttu-id="a148b-217">Die ursprüngliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</span><span class="sxs-lookup"><span data-stu-id="a148b-217">The initial number of requests for the semaphore that can be satisfied concurrently.</span></span></param>
        <param name="maximumCount"><span data-ttu-id="a148b-218">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</span><span class="sxs-lookup"><span data-stu-id="a148b-218">The maximum number of requests for the semaphore that can be satisfied concurrently.</span></span></param>
        <param name="name"><span data-ttu-id="a148b-219">Der Name eines benannten Systemsemaphorobjekts.</span><span class="sxs-lookup"><span data-stu-id="a148b-219">The name of a named system semaphore object.</span></span></param>
        <param name="createdNew"><span data-ttu-id="a148b-220">Enthält nach dem Beenden dieser Methode den Wert <see langword="true" />, wenn ein lokales Semaphor erstellt wurde (d. h., wenn <paramref name="name" /> gleich <see langword="null" /> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemsemaphor erstellt wurde. Der Wert ist <see langword="false" />, wenn das angegebene benannte Systemsemaphor bereits vorhanden war.</span><span class="sxs-lookup"><span data-stu-id="a148b-220">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span></span> <span data-ttu-id="a148b-221">Dieser Parameter wird nicht initialisiert übergeben.</span><span class="sxs-lookup"><span data-stu-id="a148b-221">This parameter is passed uninitialized.</span></span></param>
        <param name="semaphoreSecurity"><span data-ttu-id="a148b-222">Ein <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf das benannte Systemsemaphor angewendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="a148b-222">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span></span></param>
        <summary><span data-ttu-id="a148b-223">Initialisiert eine neue Instanz der <see cref="T:System.Threading.Semaphore" />-Klasse, gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen an, gibt optional den Namen eines Systemsemaphorobjekts an, gibt eine Variable an, die einen Wert empfängt, der angibt, ob ein neues Systemsemaphor erstellt wurde, und gibt die Sicherheitszugriffssteuerung für das Systemsemaphor an.</span><span class="sxs-lookup"><span data-stu-id="a148b-223">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a148b-224">Verwenden Sie diesen Konstruktor, um die Zugriffs Steuerungs Sicherheit auf ein benanntes System Semaphor anzuwenden, wenn es erstellt wird. Dadurch wird verhindert, dass anderer Code die Kontrolle über die Semaphor übernimmt.</span><span class="sxs-lookup"><span data-stu-id="a148b-224">Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.</span></span>  
  
 <span data-ttu-id="a148b-225">Dieser Konstruktor initialisiert ein <xref:System.Threading.Semaphore> Objekt, das ein benanntes System Semaphor darstellt.</span><span class="sxs-lookup"><span data-stu-id="a148b-225">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="a148b-226">Sie können mehrere <xref:System.Threading.Semaphore> Objekte erstellen, die dasselbe benannte System Semaphor darstellen.</span><span class="sxs-lookup"><span data-stu-id="a148b-226">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="a148b-227">Wenn das benannte System Semaphor nicht vorhanden ist, wird es mit der angegebenen Zugriffs Steuerungs Sicherheit erstellt.</span><span class="sxs-lookup"><span data-stu-id="a148b-227">If the named system semaphore does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="a148b-228">Wenn das benannte Semaphor vorhanden ist, wird die angegebene Zugriffs Steuerungs Sicherheit ignoriert.</span><span class="sxs-lookup"><span data-stu-id="a148b-228">If the named semaphore exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a148b-229">Der Aufrufer hat die vollständige Kontrolle über das neu erstellte <xref:System.Threading.Semaphore> Objekt, auch wenn `semaphoreSecurity` dem aktuellen Benutzer einige Zugriffsrechte verweigert oder ihm nicht zuweist.</span><span class="sxs-lookup"><span data-stu-id="a148b-229">The caller has full control over the newly created <xref:System.Threading.Semaphore> object even if `semaphoreSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="a148b-230">Wenn der aktuelle Benutzer jedoch versucht, ein anderes <xref:System.Threading.Semaphore> Objekt zu erhalten, das das gleiche benannte Semaphor repräsentiert, wobei entweder ein Konstruktor oder die <xref:System.Threading.Semaphore.OpenExisting%2A>-Methode verwendet wird, wird die Windows-Zugriffs Steuerungs Sicherheit angewendet.</span><span class="sxs-lookup"><span data-stu-id="a148b-230">However, if the current user attempts to get another <xref:System.Threading.Semaphore> object to represent the same named semaphore, using either a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="a148b-231">Wenn das benannte System Semaphor nicht vorhanden ist, wird es mit der anfänglichen Anzahl und der maximalen Anzahl erstellt, die durch `initialCount` und `maximumCount`angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="a148b-231">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="a148b-232">Wenn das benannte System Semaphor bereits vorhanden ist, werden `initialCount` und `maximumCount` nicht verwendet, obwohl ungültige Werte weiterhin Ausnahmen verursachen.</span><span class="sxs-lookup"><span data-stu-id="a148b-232">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="a148b-233">Verwenden Sie den `createdNew`-Parameter, um zu bestimmen, ob das System Semaphor von diesem Konstruktor erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="a148b-233">Use the `createdNew` parameter to determine whether the system semaphore was created by this constructor.</span></span>  
  
 <span data-ttu-id="a148b-234">Wenn `initialCount` kleiner als `maximumCount`und `createdNew` `true`ist, entspricht der Effekt dem, wenn der aktuelle Thread <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) Mal aufgerufen hätte.</span><span class="sxs-lookup"><span data-stu-id="a148b-234">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="a148b-235">Wenn Sie `null` oder eine leere Zeichenfolge für `name`angeben, wird ein lokales Semaphor erstellt, als ob Sie die <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29>-Konstruktorüberladung aufgerufen hätten.</span><span class="sxs-lookup"><span data-stu-id="a148b-235">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="a148b-236">In diesem Fall wird `createdNew` immer `true`.</span><span class="sxs-lookup"><span data-stu-id="a148b-236">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="a148b-237">Da benannte Semaphoren im gesamten Betriebssystem sichtbar sind, können Sie verwendet werden, um die Ressourcenverwendung über Prozess Grenzen hinweg zu koordinieren.</span><span class="sxs-lookup"><span data-stu-id="a148b-237">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a148b-238">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Semaphors mit Zugriffs Steuerungs Sicherheit veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="a148b-238">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="a148b-239">Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Semaphor vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-239">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span> <span data-ttu-id="a148b-240">Wenn das Semaphor nicht vorhanden ist, wird es mit einer maximalen Anzahl von zwei und mit Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Semaphor zu verwenden, aber das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor gewährt.</span><span class="sxs-lookup"><span data-stu-id="a148b-240">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span> <span data-ttu-id="a148b-241">Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie eine Zugriffs Verletzungs Ausnahme beim Aufrufen der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methode aus.</span><span class="sxs-lookup"><span data-stu-id="a148b-241">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="a148b-242">Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>-Methoden Überladung, um das Semaphor mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="a148b-242">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="a148b-243">Nachdem die Berechtigungen geändert wurden, wird das Semaphor mit den Rechten geöffnet, die für die Eingabe und Freigabe erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="a148b-243">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="a148b-244">Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="a148b-244">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a148b-245"><paramref name="initialCount" /> ist größer als <paramref name="maximumCount" />.</span><span class="sxs-lookup"><span data-stu-id="a148b-245"><paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span></span>  
  
<span data-ttu-id="a148b-246">Oder</span><span class="sxs-lookup"><span data-stu-id="a148b-246">-or-</span></span> 
 <span data-ttu-id="a148b-247"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="a148b-247"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a148b-248"><paramref name="maximumCount" /> ist kleiner als 1.</span><span class="sxs-lookup"><span data-stu-id="a148b-248"><paramref name="maximumCount" /> is less than 1.</span></span>  
  
<span data-ttu-id="a148b-249">Oder</span><span class="sxs-lookup"><span data-stu-id="a148b-249">-or-</span></span> 
 <span data-ttu-id="a148b-250"><paramref name="initialCount" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="a148b-250"><paramref name="initialCount" /> is less than 0.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a148b-251">Der benannte Semaphor ist vorhanden und verfügt über Zugriffssteuerungssicherheit, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="a148b-251">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a148b-252">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="a148b-252">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="a148b-253">Der benannte Semaphor kann nicht erstellt werden, möglicherweise, weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</span><span class="sxs-lookup"><span data-stu-id="a148b-253">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="a148b-254">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="a148b-254">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="a148b-255">Semaphore</span><span class="sxs-lookup"><span data-stu-id="a148b-255">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a148b-256">Ruft die Zugriffssteuerungssicherheit für ein benanntes Systemsemaphor ab.</span><span class="sxs-lookup"><span data-stu-id="a148b-256">Gets the access control security for a named system semaphore.</span></span></summary>
        <returns><span data-ttu-id="a148b-257">Ein <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />-Objekt, das die Zugriffssteuerungssicherheit für das benannte Systemsemaphor darstellt.</span><span class="sxs-lookup"><span data-stu-id="a148b-257">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security for the named system semaphore.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a148b-258">Die <xref:System.Threading.Semaphore.GetAccessControl%2A>-Methode verwendet die folgende Kombination von-Flags (kombiniert mithilfe des bitweisen OR-Vorgangs), um nach Berechtigungen zu suchen: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>und <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a148b-258">The <xref:System.Threading.Semaphore.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a148b-259">Der Benutzer muss über <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> Rechte verfügen, um diese Methode aufzurufen, und das Semaphor muss mit <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> Rechten geöffnet worden sein.</span><span class="sxs-lookup"><span data-stu-id="a148b-259">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights.</span></span>  
  
 <span data-ttu-id="a148b-260">Bei einem lokalen Semaphor ist die Zugriffs Steuerungs Sicherheit irrelevant.</span><span class="sxs-lookup"><span data-stu-id="a148b-260">On a local semaphore, access control security is irrelevant.</span></span> <span data-ttu-id="a148b-261">Wenn das <xref:System.Threading.Semaphore>-Objekt kein benanntes System Semaphor darstellt, gibt diese Methode ein <xref:System.Security.AccessControl.SemaphoreSecurity>-Objekt zurück, das allen Benutzern alle Rechte gewährt.</span><span class="sxs-lookup"><span data-stu-id="a148b-261">If the <xref:System.Threading.Semaphore> object does not represent a named system semaphore, this method returns a <xref:System.Security.AccessControl.SemaphoreSecurity> object that grants all rights to any user.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a148b-262">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Semaphors mit Zugriffs Steuerungs Sicherheit veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="a148b-262">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="a148b-263">Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Semaphor vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-263">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="a148b-264">Wenn das Semaphor nicht vorhanden ist, wird es mit einer maximalen Anzahl von zwei und mit Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Semaphor zu verwenden, aber das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor gewährt.</span><span class="sxs-lookup"><span data-stu-id="a148b-264">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="a148b-265">Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie eine Zugriffs Verletzungs Ausnahme beim Aufrufen der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methode aus.</span><span class="sxs-lookup"><span data-stu-id="a148b-265">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="a148b-266">Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>-Methoden Überladung, um das Semaphor mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="a148b-266">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span> <span data-ttu-id="a148b-267">Die Zugriffs Steuerungs Sicherheit für das System Semaphor wird mithilfe der <xref:System.Threading.Semaphore.GetAccessControl%2A>-Methode abgerufen.</span><span class="sxs-lookup"><span data-stu-id="a148b-267">The access control security for the system semaphore is obtained using the <xref:System.Threading.Semaphore.GetAccessControl%2A> method.</span></span>  
  
 <span data-ttu-id="a148b-268">Nachdem die Berechtigungen geändert wurden, wird das Semaphor mit den Rechten geöffnet, die für die Eingabe und Freigabe erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="a148b-268">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="a148b-269">Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="a148b-269">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a148b-270">Das aktuelle <see cref="T:System.Threading.Semaphore" />-Objekt stellt einen benannten Systemsemaphor dar, und der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />-Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="a148b-270">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span></span>  
  
<span data-ttu-id="a148b-271">Oder</span><span class="sxs-lookup"><span data-stu-id="a148b-271">-or-</span></span> 
<span data-ttu-id="a148b-272">Das aktuelle <see cref="T:System.Threading.Semaphore" />-Objekt stellt einen benannten Systemsemaphor dar und wurde nicht mit <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />-Berechtigung geöffnet.</span><span class="sxs-lookup"><span data-stu-id="a148b-272">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore and was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a148b-273">Wird nicht für Windows 98 oder Windows Millennium Edition unterstützt.</span><span class="sxs-lookup"><span data-stu-id="a148b-273">Not supported for Windows 98 or Windows Millennium Edition.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="a148b-274">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="a148b-274">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="a148b-275">Semaphore</span><span class="sxs-lookup"><span data-stu-id="a148b-275">Semaphore</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a148b-276">Öffnet ein angegebenes benanntes Semaphor, wenn es bereits vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-276">Opens a specified named semaphore, if it already exists.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="a148b-277">Der Name des zu öffnenden Systemsemaphors.</span><span class="sxs-lookup"><span data-stu-id="a148b-277">The name of the system semaphore to open.</span></span></param>
        <summary><span data-ttu-id="a148b-278">Öffnet das angegebene benannte Semaphor, wenn es bereits vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-278">Opens the specified named semaphore, if it already exists.</span></span></summary>
        <returns><span data-ttu-id="a148b-279">Ein Objekt, das das benannte Systemsemaphor darstellt.</span><span class="sxs-lookup"><span data-stu-id="a148b-279">An object that represents the named system semaphore.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a148b-280">Die <xref:System.Threading.Semaphore.OpenExisting%2A>-Methode versucht, die angegebene benannte Semaphore zu öffnen.</span><span class="sxs-lookup"><span data-stu-id="a148b-280">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open the specified named semaphore.</span></span> <span data-ttu-id="a148b-281">Wenn das System Semaphor nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das System Semaphor zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="a148b-281">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="a148b-282">Um das System Semaphor zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie einen der <xref:System.Threading.Semaphore.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="a148b-282">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="a148b-283">Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.Semaphore> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Semaphor darstellen.</span><span class="sxs-lookup"><span data-stu-id="a148b-283">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="a148b-284">Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.Semaphore.OpenExisting%2A>-Methoden Überladung und der Angabe von <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rechten, kombiniert mithilfe des bitweisen OR-Vorgangs.</span><span class="sxs-lookup"><span data-stu-id="a148b-284">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.OpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="a148b-285">Wenn Sie das <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>-Flag angeben, kann ein Thread in das Semaphor eintreten, und die Angabe des <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Flags ermöglicht einem Thread, die <xref:System.Threading.Semaphore.Release%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="a148b-285">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a148b-286">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Semaphors mit Zugriffs Steuerungs Sicherheit veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="a148b-286">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="a148b-287">Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Semaphor vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-287">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="a148b-288">Wenn das Semaphor nicht vorhanden ist, wird es mit einer maximalen Anzahl von zwei und mit der Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Semaphor zu verwenden, das jedoch dem Recht gewährt, Lese-und Änderungs Berechtigungen für das Semaphor zu erteilen.</span><span class="sxs-lookup"><span data-stu-id="a148b-288">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="a148b-289">Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie beim Aufrufen der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methoden Überladung eine Zugriffs Verletzungs Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="a148b-289">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload.</span></span> <span data-ttu-id="a148b-290">Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>-Methoden Überladung, um das Semaphor mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="a148b-290">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="a148b-291">Nachdem die Berechtigungen geändert wurden, wird das Semaphor mit den zum eingeben und Freigeben erforderlichen Rechten geöffnet.</span><span class="sxs-lookup"><span data-stu-id="a148b-291">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="a148b-292">Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="a148b-292">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a148b-293"><paramref name="name" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a148b-293"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="a148b-294">Oder</span><span class="sxs-lookup"><span data-stu-id="a148b-294">-or-</span></span> 
 <span data-ttu-id="a148b-295"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="a148b-295"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a148b-296"><paramref name="name" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="a148b-296"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="a148b-297">Das benannte Semaphor ist nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="a148b-297">The named semaphore does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a148b-298">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="a148b-298">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a148b-299">Der benannte Semaphor ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-299">The named semaphore exists, but the user does not have the security access required to use it.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="a148b-300">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="a148b-300">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="a148b-301">Semaphore</span><span class="sxs-lookup"><span data-stu-id="a148b-301">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="a148b-302">Der Name des zu öffnenden Systemsemaphors.</span><span class="sxs-lookup"><span data-stu-id="a148b-302">The name of the system semaphore to open.</span></span></param>
        <param name="rights"><span data-ttu-id="a148b-303">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</span><span class="sxs-lookup"><span data-stu-id="a148b-303">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <summary><span data-ttu-id="a148b-304">Öffnet das angegebene benannte Semaphor, wenn es bereits vorhanden ist, mit dem gewünschten Sicherheitszugriff.</span><span class="sxs-lookup"><span data-stu-id="a148b-304">Opens the specified named semaphore, if it already exists, with the desired security access.</span></span></summary>
        <returns><span data-ttu-id="a148b-305">Ein Objekt, das das benannte Systemsemaphor darstellt.</span><span class="sxs-lookup"><span data-stu-id="a148b-305">An object that represents the named system semaphore.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a148b-306">Der `rights`-Parameter muss das <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>-Flag enthalten, damit Threads in das Semaphor eintreten können, und das <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>-Flag, damit Threads die <xref:System.Threading.Semaphore.Release%2A>-Methode aufrufen können.</span><span class="sxs-lookup"><span data-stu-id="a148b-306">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="a148b-307">Die <xref:System.Threading.Semaphore.OpenExisting%2A>-Methode versucht, eine vorhandene benannte Semaphore zu öffnen.</span><span class="sxs-lookup"><span data-stu-id="a148b-307">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open an existing named semaphore.</span></span> <span data-ttu-id="a148b-308">Wenn das System Semaphor nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das System Semaphor zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="a148b-308">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="a148b-309">Um das System Semaphor zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie einen der <xref:System.Threading.Semaphore.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="a148b-309">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="a148b-310">Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.Semaphore> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Semaphor darstellen.</span><span class="sxs-lookup"><span data-stu-id="a148b-310">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a148b-311">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Semaphors mit Zugriffs Steuerungs Sicherheit veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="a148b-311">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="a148b-312">Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Semaphor vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-312">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="a148b-313">Wenn das Semaphor nicht vorhanden ist, wird es mit einer maximalen Anzahl von zwei und mit Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Semaphor zu verwenden, aber das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor gewährt.</span><span class="sxs-lookup"><span data-stu-id="a148b-313">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="a148b-314">Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie eine Zugriffs Verletzungs Ausnahme beim Aufrufen der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methode aus.</span><span class="sxs-lookup"><span data-stu-id="a148b-314">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="a148b-315">Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>-Methoden Überladung, um das Semaphor mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="a148b-315">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="a148b-316">Nachdem die Berechtigungen geändert wurden, wird das Semaphor mit den zum eingeben und Freigeben erforderlichen Rechten geöffnet.</span><span class="sxs-lookup"><span data-stu-id="a148b-316">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="a148b-317">Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="a148b-317">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a148b-318"><paramref name="name" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a148b-318"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="a148b-319">Oder</span><span class="sxs-lookup"><span data-stu-id="a148b-319">-or-</span></span> 
 <span data-ttu-id="a148b-320"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="a148b-320"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a148b-321"><paramref name="name" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="a148b-321"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="a148b-322">Das benannte Semaphor ist nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="a148b-322">The named semaphore does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a148b-323">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="a148b-323">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a148b-324">Das benannte Semaphor ist vorhanden, der Benutzer verfügt jedoch nicht über die gewünschten Sicherheitszugriffsrechte.</span><span class="sxs-lookup"><span data-stu-id="a148b-324">The named semaphore exists, but the user does not have the desired security access rights.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="a148b-325">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="a148b-325">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="a148b-326">Semaphore</span><span class="sxs-lookup"><span data-stu-id="a148b-326">Semaphore</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a148b-327">Beendet das Semaphor.</span><span class="sxs-lookup"><span data-stu-id="a148b-327">Exits the semaphore.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a148b-328">Beendet das Semaphor und gibt die vorherige Anzahl zurück.</span><span class="sxs-lookup"><span data-stu-id="a148b-328">Exits the semaphore and returns the previous count.</span></span></summary>
        <returns><span data-ttu-id="a148b-329">Die Anzahl für das Semaphor vor dem Aufruf der <see cref="Overload:System.Threading.Semaphore.Release" />-Methode.</span><span class="sxs-lookup"><span data-stu-id="a148b-329">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a148b-330">Threads verwenden in der Regel die <xref:System.Threading.WaitHandle.WaitOne%2A>-Methode, um das Semaphor einzugeben, und verwenden diese Methoden Überladung normalerweise zum Beenden.</span><span class="sxs-lookup"><span data-stu-id="a148b-330">Threads typically use the <xref:System.Threading.WaitHandle.WaitOne%2A> method to enter the semaphore, and they typically use this method overload to exit.</span></span>  
  
 <span data-ttu-id="a148b-331">Wenn ein <xref:System.Threading.SemaphoreFullException> von der <xref:System.Threading.Semaphore.Release%2A>-Methode ausgelöst wird, weist dies nicht unbedingt auf ein Problem mit dem aufrufenden Thread hin.</span><span class="sxs-lookup"><span data-stu-id="a148b-331">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="a148b-332">Ein Programmierfehler in einem anderen Thread hat möglicherweise bewirkt, dass dieser Thread das Semaphor mehrmals beendet hat, als er eingegeben hat.</span><span class="sxs-lookup"><span data-stu-id="a148b-332">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="a148b-333">Wenn das aktuelle <xref:System.Threading.Semaphore>-Objekt ein benanntes System Semaphor darstellt, muss der Benutzer über <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechte verfügen, und das Semaphor muss mit <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechten geöffnet worden sein.</span><span class="sxs-lookup"><span data-stu-id="a148b-333">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a148b-334">Im folgenden Codebeispiel wird ein Semaphor mit einer maximalen Anzahl von drei und einer anfänglichen Anzahl von 0 (null) erstellt.</span><span class="sxs-lookup"><span data-stu-id="a148b-334">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="a148b-335">Im Beispiel werden fünf Threads gestartet, die blockieren, um auf das Semaphor zu warten.</span><span class="sxs-lookup"><span data-stu-id="a148b-335">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="a148b-336">Der Haupt Thread verwendet die <xref:System.Threading.Semaphore.Release%28System.Int32%29>-Methoden Überladung, um die Anzahl der Semaphor auf den maximalen Wert zu erhöhen, sodass drei Threads in das Semaphor gelangen können.</span><span class="sxs-lookup"><span data-stu-id="a148b-336">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="a148b-337">Jeder Thread verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>-Methode, um eine Sekunde zu warten, um die Arbeit zu simulieren, und ruft dann die <xref:System.Threading.Semaphore.Release>-Methoden Überladung auf, um das Semaphor freizugeben.</span><span class="sxs-lookup"><span data-stu-id="a148b-337">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="a148b-338">Jedes Mal, wenn das Semaphor freigegeben wird, wird die vorherige Semaphor-Anzahl angezeigt.</span><span class="sxs-lookup"><span data-stu-id="a148b-338">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="a148b-339">Konsolen Meldungen verfolgen die Verwendung von Semaphor.</span><span class="sxs-lookup"><span data-stu-id="a148b-339">Console messages track semaphore use.</span></span> <span data-ttu-id="a148b-340">Das simulierte Arbeitsintervall wird für jeden Thread geringfügig angehoben, damit die Ausgabe leichter lesbar ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-340">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException"><span data-ttu-id="a148b-341">Die Anzahl für das Semaphor weist bereits den maximalen Wert auf.</span><span class="sxs-lookup"><span data-stu-id="a148b-341">The semaphore count is already at the maximum value.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a148b-342">Bei einem benannten Semaphor ist ein Win32-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="a148b-342">A Win32 error occurred with a named semaphore.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a148b-343">Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar. Der Benutzer verfügt jedoch nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span><span class="sxs-lookup"><span data-stu-id="a148b-343">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span></span>  
  
<span data-ttu-id="a148b-344">Oder</span><span class="sxs-lookup"><span data-stu-id="a148b-344">-or-</span></span> 
<span data-ttu-id="a148b-345">Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar, es wurde jedoch nicht mit <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> geöffnet.</span><span class="sxs-lookup"><span data-stu-id="a148b-345">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="a148b-346">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="a148b-346">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="a148b-347">Semaphore</span><span class="sxs-lookup"><span data-stu-id="a148b-347">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount"><span data-ttu-id="a148b-348">Die Anzahl von Malen, die das Semaphor freigegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="a148b-348">The number of times to exit the semaphore.</span></span></param>
        <summary><span data-ttu-id="a148b-349">Gibt das Semaphor eine festgelegte Anzahl von Malen frei und gibt die vorherige Anzahl zurück.</span><span class="sxs-lookup"><span data-stu-id="a148b-349">Exits the semaphore a specified number of times and returns the previous count.</span></span></summary>
        <returns><span data-ttu-id="a148b-350">Die Anzahl für das Semaphor vor dem Aufruf der <see cref="Overload:System.Threading.Semaphore.Release" />-Methode.</span><span class="sxs-lookup"><span data-stu-id="a148b-350">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a148b-351">Wenn ein Thread mehrmals in das Semaphor gelangt ist, lässt diese Methoden Überladung zu, dass die gesamte Semaphor-Anzahl mit einem-Befehl wieder hergestellt wird.</span><span class="sxs-lookup"><span data-stu-id="a148b-351">If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.</span></span>  
  
 <span data-ttu-id="a148b-352">Wenn ein <xref:System.Threading.SemaphoreFullException> von der <xref:System.Threading.Semaphore.Release%2A>-Methode ausgelöst wird, weist dies nicht unbedingt auf ein Problem mit dem aufrufenden Thread hin.</span><span class="sxs-lookup"><span data-stu-id="a148b-352">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="a148b-353">Ein Programmierfehler in einem anderen Thread hat möglicherweise bewirkt, dass dieser Thread das Semaphor mehrmals beendet hat, als er eingegeben hat.</span><span class="sxs-lookup"><span data-stu-id="a148b-353">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="a148b-354">Wenn das aktuelle <xref:System.Threading.Semaphore>-Objekt ein benanntes System Semaphor darstellt, muss der Benutzer über <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechte verfügen, und das Semaphor muss mit <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechten geöffnet worden sein.</span><span class="sxs-lookup"><span data-stu-id="a148b-354">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a148b-355">Im folgenden Codebeispiel wird ein Semaphor mit einer maximalen Anzahl von drei und einer anfänglichen Anzahl von 0 (null) erstellt.</span><span class="sxs-lookup"><span data-stu-id="a148b-355">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="a148b-356">Im Beispiel werden fünf Threads gestartet, die blockieren, um auf das Semaphor zu warten.</span><span class="sxs-lookup"><span data-stu-id="a148b-356">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="a148b-357">Der Haupt Thread verwendet die <xref:System.Threading.Semaphore.Release%28System.Int32%29>-Methoden Überladung, um die Anzahl der Semaphor auf den maximalen Wert zu erhöhen, sodass drei Threads in das Semaphor gelangen können.</span><span class="sxs-lookup"><span data-stu-id="a148b-357">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="a148b-358">Jeder Thread verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>-Methode, um eine Sekunde zu warten, um die Arbeit zu simulieren, und ruft dann die <xref:System.Threading.Semaphore.Release>-Methoden Überladung auf, um das Semaphor freizugeben.</span><span class="sxs-lookup"><span data-stu-id="a148b-358">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="a148b-359">Jedes Mal, wenn das Semaphor freigegeben wird, wird die vorherige Semaphor-Anzahl angezeigt.</span><span class="sxs-lookup"><span data-stu-id="a148b-359">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="a148b-360">Konsolen Meldungen verfolgen die Verwendung von Semaphor.</span><span class="sxs-lookup"><span data-stu-id="a148b-360">Console messages track semaphore use.</span></span> <span data-ttu-id="a148b-361">Das simulierte Arbeitsintervall wird für jeden Thread geringfügig angehoben, damit die Ausgabe leichter lesbar ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-361">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a148b-362"><paramref name="releaseCount" /> ist kleiner als 1.</span><span class="sxs-lookup"><span data-stu-id="a148b-362"><paramref name="releaseCount" /> is less than 1.</span></span></exception>
        <exception cref="T:System.Threading.SemaphoreFullException"><span data-ttu-id="a148b-363">Die Anzahl für das Semaphor weist bereits den maximalen Wert auf.</span><span class="sxs-lookup"><span data-stu-id="a148b-363">The semaphore count is already at the maximum value.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a148b-364">Bei einem benannten Semaphor ist ein Win32-Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="a148b-364">A Win32 error occurred with a named semaphore.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a148b-365">Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar. Der Benutzer verfügt jedoch nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />-Rechte.</span><span class="sxs-lookup"><span data-stu-id="a148b-365">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span></span>  
  
<span data-ttu-id="a148b-366">Oder</span><span class="sxs-lookup"><span data-stu-id="a148b-366">-or-</span></span> 
<span data-ttu-id="a148b-367">Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar, es wurde jedoch nicht mit <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />-Rechten geöffnet.</span><span class="sxs-lookup"><span data-stu-id="a148b-367">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="a148b-368">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="a148b-368">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="a148b-369">Semaphore</span><span class="sxs-lookup"><span data-stu-id="a148b-369">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (semaphoreSecurity As SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity"><span data-ttu-id="a148b-370">Ein <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf das benannte Systemsemaphor angewendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="a148b-370">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span></span></param>
        <summary><span data-ttu-id="a148b-371">Legt die Zugriffssteuerungssicherheit für ein benanntes Systemsemaphor fest.</span><span class="sxs-lookup"><span data-stu-id="a148b-371">Sets the access control security for a named system semaphore.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a148b-372">Sie können die Zugriffs Steuerungs Sicherheit nur für <xref:System.Threading.Semaphore> Objekte festlegen, die benannte System Semaphoren darstellen.</span><span class="sxs-lookup"><span data-stu-id="a148b-372">You can set access control security only on <xref:System.Threading.Semaphore> objects that represent named system semaphores.</span></span>  
  
 <span data-ttu-id="a148b-373">Der Benutzer muss über <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> Rechte verfügen, um diese Methode aufzurufen, und das Semaphor muss mit <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> Rechten geöffnet worden sein.</span><span class="sxs-lookup"><span data-stu-id="a148b-373">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a148b-374">Im folgenden Codebeispiel wird das prozessübergreifende Verhalten eines benannten Semaphors mit Zugriffs Steuerungs Sicherheit veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="a148b-374">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="a148b-375">Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methoden Überladung verwendet, um zu testen, ob ein benanntes Semaphor vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-375">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="a148b-376">Wenn das Semaphor nicht vorhanden ist, wird es mit einer maximalen Anzahl von zwei und mit Zugriffs Steuerungs Sicherheit erstellt, die dem aktuellen Benutzer das Recht verweigert, das Semaphor zu verwenden, aber das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor gewährt.</span><span class="sxs-lookup"><span data-stu-id="a148b-376">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="a148b-377">Wenn Sie das kompilierte Beispiel aus zwei Befehls Fenstern ausführen, löst die zweite Kopie eine Zugriffs Verletzungs Ausnahme beim Aufrufen der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methode aus.</span><span class="sxs-lookup"><span data-stu-id="a148b-377">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="a148b-378">Die Ausnahme wird abgefangen, und das Beispiel verwendet die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>-Methoden Überladung, um das Semaphor mit den rechten zu öffnen, die zum Lesen und Ändern der Berechtigungen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="a148b-378">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="a148b-379">Nachdem die Berechtigungen mithilfe der <xref:System.Threading.Semaphore.SetAccessControl%2A>-Methode geändert wurden, wird das Semaphor mit den Rechten geöffnet, die für die Eingabe und Freigabe erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="a148b-379">After the permissions are changed, using the <xref:System.Threading.Semaphore.SetAccessControl%2A> method, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="a148b-380">Wenn Sie das kompilierte Beispiel aus einem dritten Befehlsfenster ausführen, wird es mithilfe der neuen Berechtigungen ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="a148b-380">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a148b-381"><paramref name="semaphoreSecurity" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="a148b-381"><paramref name="semaphoreSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a148b-382">Der Benutzer verfügt nicht über <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />-Rechte.</span><span class="sxs-lookup"><span data-stu-id="a148b-382">The user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span></span>  
  
<span data-ttu-id="a148b-383">Oder</span><span class="sxs-lookup"><span data-stu-id="a148b-383">-or-</span></span> 
<span data-ttu-id="a148b-384">Das Semaphor wurde nicht mit <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />-Rechten geöffnet.</span><span class="sxs-lookup"><span data-stu-id="a148b-384">The semaphore was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a148b-385">Das aktuelle <see cref="T:System.Threading.Semaphore" />-Objekt stellt kein benanntes Systemsemaphor dar.</span><span class="sxs-lookup"><span data-stu-id="a148b-385">The current <see cref="T:System.Threading.Semaphore" /> object does not represent a named system semaphore.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="a148b-386">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="a148b-386">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="a148b-387">Semaphore</span><span class="sxs-lookup"><span data-stu-id="a148b-387">Semaphore</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a148b-388">Öffnet ein angegebenes benanntes Semaphor, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a148b-388">Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * Semaphore -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="a148b-389">Der Name des zu öffnenden Systemsemaphors.</span><span class="sxs-lookup"><span data-stu-id="a148b-389">The name of the system semaphore to open.</span></span></param>
        <param name="result"><span data-ttu-id="a148b-390">Enthält nach Beenden der Methode ein <see cref="T:System.Threading.Semaphore" />-Objekt, das das benannte Semaphor darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn der Aufruf fehlgeschlagen ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-390">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="a148b-391">Dieser Parameter wird als nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="a148b-391">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="a148b-392">Öffnet das angegebene benannte Semaphor, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a148b-392">Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="a148b-393"><see langword="true" />, wenn das benannte Semaphor erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a148b-393"><see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a148b-394">Wenn das benannte Semaphor nicht vorhanden ist, wird es von dieser Methode nicht erstellt.</span><span class="sxs-lookup"><span data-stu-id="a148b-394">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="a148b-395">Um das System Semaphor zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie einen der <xref:System.Threading.Semaphore.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="a148b-395">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="a148b-396">Wenn Sie unsicher sind, ob ein benanntes Semaphor vorhanden ist, verwenden Sie diese Methoden Überladung anstelle der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>-Methoden Überladung, die eine Ausnahme auslöst, wenn das Semaphor nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-396">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="a148b-397">Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Threading.Semaphore.TryOpenExisting%2A>-Methoden Überladung und der Angabe von <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rechten, kombiniert mithilfe des bitweisen OR-Vorgangs.</span><span class="sxs-lookup"><span data-stu-id="a148b-397">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.TryOpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="a148b-398">Wenn Sie das <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>-Flag angeben, kann ein Thread in das Semaphor eintreten, und die Angabe des <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Flags ermöglicht einem Thread, die <xref:System.Threading.Semaphore.Release%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="a148b-398">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the   <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a148b-399"><paramref name="name" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a148b-399"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="a148b-400">Oder</span><span class="sxs-lookup"><span data-stu-id="a148b-400">-or-</span></span> 
 <span data-ttu-id="a148b-401"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="a148b-401"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a148b-402"><paramref name="name" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="a148b-402"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a148b-403">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="a148b-403">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a148b-404">Der benannte Semaphor ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-404">The named semaphore exists, but the user does not have the security access required to use it.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights * Semaphore -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="a148b-405">Der Name des zu öffnenden Systemsemaphors.</span><span class="sxs-lookup"><span data-stu-id="a148b-405">The name of the system semaphore to open.</span></span></param>
        <param name="rights"><span data-ttu-id="a148b-406">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</span><span class="sxs-lookup"><span data-stu-id="a148b-406">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <param name="result"><span data-ttu-id="a148b-407">Enthält nach Beenden der Methode ein <see cref="T:System.Threading.Semaphore" />-Objekt, das das benannte Semaphor darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <see langword="null" />, wenn der Aufruf fehlgeschlagen ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-407">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="a148b-408">Dieser Parameter wird als nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="a148b-408">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="a148b-409">Öffnet das angegebene benannte Semaphor, wenn es bereits mit dem gewünschten Sicherheitszugriff vorhanden ist und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a148b-409">Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="a148b-410"><see langword="true" />, wenn das benannte Semaphor erfolgreich geöffnet wurde; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a148b-410"><see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a148b-411">Wenn das benannte Semaphor nicht vorhanden ist, wird es von dieser Methode nicht erstellt.</span><span class="sxs-lookup"><span data-stu-id="a148b-411">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="a148b-412">Um das System Semaphor zu erstellen, wenn es nicht bereits vorhanden ist, verwenden Sie einen der <xref:System.Threading.Semaphore.%23ctor%2A> Konstruktoren mit einem `name`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="a148b-412">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="a148b-413">Wenn Sie unsicher sind, ob ein benanntes Semaphor vorhanden ist, verwenden Sie diese Methoden Überladung anstelle der <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>-Methoden Überladung, die eine Ausnahme auslöst, wenn das Semaphor nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-413">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="a148b-414">Der `rights`-Parameter muss das <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>-Flag enthalten, damit Threads in das Semaphor eintreten können, und das <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>-Flag, damit Threads die <xref:System.Threading.Semaphore.Release%2A>-Methode aufrufen können.</span><span class="sxs-lookup"><span data-stu-id="a148b-414">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="a148b-415">Mehrere Aufrufe dieser Methode, die denselben Wert für `name` verwenden, geben nicht notwendigerweise dasselbe <xref:System.Threading.Semaphore> Objekt zurück, auch wenn die zurückgegebenen Objekte dasselbe benannte System Semaphor darstellen.</span><span class="sxs-lookup"><span data-stu-id="a148b-415">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a148b-416"><paramref name="name" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a148b-416"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="a148b-417">Oder</span><span class="sxs-lookup"><span data-stu-id="a148b-417">-or-</span></span> 
 <span data-ttu-id="a148b-418"><paramref name="name" /> ist länger als 260 Zeichen.</span><span class="sxs-lookup"><span data-stu-id="a148b-418"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a148b-419"><paramref name="name" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="a148b-419"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a148b-420">Win32-Fehler.</span><span class="sxs-lookup"><span data-stu-id="a148b-420">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a148b-421">Der benannte Semaphor ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="a148b-421">The named semaphore exists, but the user does not have the security access required to use it.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
