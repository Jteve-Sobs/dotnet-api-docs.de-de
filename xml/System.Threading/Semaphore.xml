<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Semaphore.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5589fcf34edfc4ff1eb1c243acad8b5ad0d3cd911.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">589fcf34edfc4ff1eb1c243acad8b5ad0d3cd911</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Limits the number of threads that can access a resource or pool of resources concurrently.</source>
          <target state="translated">Schränkt die Anzahl von Threads ein, die gleichzeitig auf eine Ressource oder einen Pool von Ressourcen zugreifen können.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class to control access to a pool of resources.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> Klasse zum Steuern des Zugriffs auf einen Pool von Ressourcen.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Threads enter the semaphore by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method, which is inherited from the <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> class, and release the semaphore by calling the <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">Threads das Semaphor durch Aufrufen der <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> -Methode, die von geerbt wird die <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> Klasse, und geben Sie das Semaphor durch Aufrufen der <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore.</source>
          <target state="translated">Anzahl die für einen Semaphore wird wieder um eins erniedrigt jedes Mal ein Thread das Semaphor eingibt, und inkrementiert, wenn ein Thread das Semaphor freigibt.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>When the count is zero, subsequent requests block until other threads release the semaphore.</source>
          <target state="translated">Wenn die Anzahl 0 (null) ist, blockieren nachfolgende Anforderungen, bis andere Threads das Semaphor freizugeben.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.</source>
          <target state="translated">Wenn alle Threads das Semaphor freigegeben haben, wird die Anzahl der zulässige Höchstwert angegeben, wenn das Semaphor erstellt wurde.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.</source>
          <target state="translated">Es gibt keine festgelegte Reihenfolge, z. B. FIFO oder LIFO, in denen blockierte Threads das Semaphor.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>A thread can enter the semaphore multiple times, by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method repeatedly.</source>
          <target state="translated">Ein Thread kann das Semaphor mehrfach durch Aufrufen der <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> Methode wiederholt.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>To release some or all of these entries, the thread can call the parameterless <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload multiple times, or it can call the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload that specifies the number of entries to be released.</source>
          <target state="translated">Um einige oder alle diese Einträge freizugeben, kann der Thread die parameterlose Aufrufen <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> methodenüberladung, die mehrere Male, oder es kann Aufrufen der <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> methodenüberladung, die die Anzahl der freizugebenden Einträge angibt.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class does not enforce thread identity on calls to <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> Klasse erzwingt keine Threadidentität für Aufrufe von <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>It is the programmer's responsibility to ensure that threads do not release the semaphore too many times.</source>
          <target state="translated">Es ist der Verantwortung des Programmierers, stellen Sie sicher, dass Threads das Semaphor nicht zu oft freigeben.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</source>
          <target state="translated">Angenommen, ein Semaphor hat einen maximalen Zähler von zwei und Thread A sowie Thread B wechseln beide in das Semaphor.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>If a programming error in thread B causes it to call <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> twice, both calls succeed.</source>
          <target state="translated">Wenn ein Programmierfehler in Thread B aufrufen verursacht <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> zweimal, beide Aufrufe erfolgreich.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The count on the semaphore is full, and when thread A eventually calls <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>, a <ph id="ph2">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown.</source>
          <target state="translated">Der Zähler des Semaphors ist voll, und wenn Thread A schließlich <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> aufruft, wird eine <ph id="ph2">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> ausgelöst.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Semaphores are of two types: local semaphores and named system semaphores.</source>
          <target state="translated">Semaphoren sind zwei Typen: lokale Semaphore und benanntes Semaphore.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>If you create a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name.</source>
          <target state="translated">Bei Erstellung einer <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> -Objekt mithilfe eines Konstruktors, der einen Namen akzeptiert ein Betriebssystem-Semaphor mit diesem Namen zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes.</source>
          <target state="translated">Benannte Semaphoren sind im gesamten Betriebssystem sichtbar und können verwendet werden, um die Aktivitäten von Prozessen zu synchronisieren.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore, and you can use the <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method to open an existing named system semaphore.</source>
          <target state="translated">Sie können mehrere erstellen <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> benannte Systemsemaphor Objekte, die die gleiche darstellen, und Sie können die <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> Methode zum Öffnen einer vorhandenen benannte Systemsemaphor.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>A local semaphore exists only within your process.</source>
          <target state="translated">Ein lokales Semaphor ist nur innerhalb des Prozesses vorhanden.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>It can be used by any thread in your process that has a reference to the local <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object.</source>
          <target state="translated">Er kann von jedem Thread in einem Prozess verwendet werden, der einen Verweis auf das lokale <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph>-Objekt enthält.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Each <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object is a separate local semaphore.</source>
          <target state="translated">Jede <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> Objekt ist ein separates lokales Semaphor.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The following code example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">Das folgende Codebeispiel erstellt eine Semaphore mit einen maximalen Zähler von drei und eine anfängliche Anzahl von 0 (null).</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">Das Beispiel beginnt fünf Threads das Semaphor warten zu blockieren.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">Der Hauptthread verwendet die <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> -methodenüberladung, um den Zähler des Semaphors auf seinen Maximalwert, sodass drei Threads in das Semaphor zu erhöhen.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">Jeder Thread verwendet die <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> Methode, um eine Sekunde warten, bis zum Simulieren von Arbeit und ruft dann die <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> -methodenüberladung, um das Semaphor freizugeben.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">Jedes Mal, wenn das Semaphor freigegeben wird, wird die vorherige Anzahl des Semaphors angezeigt.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Console messages track semaphore use.</source>
          <target state="translated">Konsole Nachrichten nachverfolgen Semaphore verwenden.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">Das simulierte Intervall wird für jeden Thread, um die Ausgabe leichter lesbar zu machen etwas erhöht.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>This type is thread safe.</source>
          <target state="translated">Dieser Typ ist threadsicher.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The initial number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">Die anfängliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The maximum number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>-Klasse und gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen an.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>This constructor initializes an unnamed semaphore.</source>
          <target state="translated">Dieser Konstruktor initialisiert ein unbenanntes Semaphor.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>All threads that use an instance of such a semaphore must have references to the instance.</source>
          <target state="translated">Alle Threads, die eine Instanz eines solchen Semaphors verwenden, müssen Verweise auf die Instanz haben.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, the effect is the same as if the current thread had called <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> minus <ph id="ph5">`initialCount`</ph>) times.</source>
          <target state="translated">Wenn <ph id="ph1">`initialCount`</ph> ist kleiner als <ph id="ph2">`maximumCount`</ph>, der Effekt ist derselbe, als ob der aktuelle Thread aufgerufen hätten <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> minus <ph id="ph5">`initialCount`</ph>) Zeiten.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for <ph id="ph1">`maximumCount`</ph> and <ph id="ph2">`initialCount`</ph>.</source>
          <target state="translated">Wenn keine Einträge für den Thread zu reservieren, die das Semaphor erstellt werden soll, verwenden Sie die gleiche Anzahl für <ph id="ph1">`maximumCount`</ph> und <ph id="ph2">`initialCount`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The following example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">Das folgende Beispiel erstellt eine Semaphore mit einer maximalen Anzahl von drei und eine anfängliche Anzahl von 0 (null).</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">Das Beispiel beginnt fünf Threads das Semaphor warten zu blockieren.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">Der Hauptthread verwendet die <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> -methodenüberladung, um den Zähler des Semaphors auf seinen Maximalwert, sodass drei Threads in das Semaphor zu erhöhen.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">Jeder Thread verwendet die <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> Methode, um eine Sekunde warten, bis zum Simulieren von Arbeit und ruft dann die <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> -methodenüberladung, um das Semaphor freizugeben.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">Jedes Mal, wenn das Semaphor freigegeben wird, wird die vorherige Anzahl des Semaphors angezeigt.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Console messages track semaphore use.</source>
          <target state="translated">Konsole Nachrichten nachverfolgen Semaphore verwenden.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">Das simulierte Intervall wird für jeden Thread, um die Ausgabe leichter lesbar zu machen etwas erhöht.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> ist kleiner als 1.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The initial number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">Die anfängliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The maximum number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig gewährt werden können.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The name of a named system semaphore object.</source>
          <target state="translated">Der Name eines benannten Systemsemaphorobjekts.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>-Klasse, gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen sowie optional den Namen eines Systemsemaphorobjekts an.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.</source>
          <target state="translated">Dieser Konstruktor initialisiert ein <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> Objekt, das ein benanntes Systemsemaphor darstellt.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.</source>
          <target state="translated">Sie können mehrere erstellen <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> benannte Systemsemaphor Objekte, die die gleiche darstellen.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">Wenn das benannte Systemsemaphor nicht vorhanden ist, wird Sie mit dem anfänglichen Zähler und die maximale Anzahl von angegebenen erstellt <ph id="ph1">`initialCount`</ph> und <ph id="ph2">`maximumCount`</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If the named system semaphore already exists, <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph> are not used, although invalid values still cause exceptions.</source>
          <target state="translated">Wenn das benannte Systemsemaphor bereits vorhanden ist, <ph id="ph1">`initialCount`</ph> und <ph id="ph2">`maximumCount`</ph> nicht verwendet, obwohl ungültige Werte immer noch Ausnahmen auslösen.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If you need to determine whether or not a named system semaphore was created, use the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor overload instead.</source>
          <target state="translated">Wenn Sie bestimmen müssen, und zwar unabhängig davon, ob ein benanntes Systemsemaphor erstellt wurde, verwenden Sie die <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> Konstruktor überladen stattdessen.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>When you use this constructor overload, the recommended practice is to specify the same number for <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">Wenn Sie diese Konstruktorüberladung verwenden, ist die empfohlene Vorgehensweise für die gleiche Anzahl an <ph id="ph1">`initialCount`</ph> und <ph id="ph2">`maximumCount`</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, and a named system semaphore is created, the effect is the same as if the current thread had called <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> minus <ph id="ph5">`initialCount`</ph>) times.</source>
          <target state="translated">Wenn <ph id="ph1">`initialCount`</ph> ist kleiner als <ph id="ph2">`maximumCount`</ph>, und ein benanntes Systemsemaphor erstellt wird, der Effekt ist derselbe, als ob der aktuelle Thread aufgerufen hätten <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> minus <ph id="ph5">`initialCount`</ph>) Zeiten.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>However, with this constructor overload there is no way to determine whether a named system semaphore was created.</source>
          <target state="translated">Mit dieser Konstruktorüberladung ist jedoch keine Möglichkeit zu bestimmen, ob ein benanntes Systemsemaphor erstellt wurde.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local semaphore is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.</source>
          <target state="translated">Bei Angabe von <ph id="ph1">`null`</ph> oder eine leere Zeichenfolge für <ph id="ph2">`name`</ph>, ein lokales Semaphor erstellt, wie bei einem Aufruf der <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> Überladung des Konstruktors.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Da benannte Semaphoren im gesamten Betriebssystem sichtbar sind, können sie verwendet werden, um Ressourcen über Prozessgrenzen hinweg koordinieren.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If you want to find out whether a named system semaphore exists, use the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie herausfinden, ob ein benanntes Systemsemaphor vorhanden ist, verwenden Sie möchten die <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> Methode versucht, ein vorhandenes benanntes Semaphor zu öffnen, und löst eine Ausnahme aus, wenn das Systemsemaphor nicht vorhanden ist.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, das Verhalten prozessübergreifend ein benanntes Semaphor.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The example creates a named semaphore with a maximum count of five and an initial count of five.</source>
          <target state="translated">Das Beispiel erstellt ein benanntes Semaphor mit einen maximalen Zähler von fünf und eine anfängliche Anzahl von fünf.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The program makes three calls to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">Das Programm sendet drei Aufrufe, die <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</source>
          <target state="translated">Daher, wenn Sie das kompilierte Beispiel über zwei Befehlsfenstern ausgeführt, beim zweiten Kopiervorgang blockiert der dritte Aufruf von <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Release one or more entries in the first copy of the program to unblock the second.</source>
          <target state="translated">Lassen Sie eine oder mehrere Einträge in der ersten Kopie des Programms für die zweite aufheben.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist länger als 260 Zeichen.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> ist kleiner als 1.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32-Fehler.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The named semaphore exists and has access control security, and the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">Der benannte Semaphor ist vorhanden und verfügt über Zugriffssteuerungssicherheit, und der Benutzer verfügt nicht über <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Der benannte Semaphor kann nicht erstellt werden, möglicherweise, weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">zum Aufrufen von nicht verwaltetem Code, um ein benanntes Systemsemaphor zu erstellen.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Sicherheitsaktion: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The initial number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">Die ursprüngliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The maximum number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The name of a named system semaphore object.</source>
          <target state="translated">Der Name eines benannten Systemsemaphorobjekts.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local semaphore was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system semaphore was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system semaphore already existed.</source>
          <target state="translated">Enthält nach dem Beenden dieser Methode den Wert <ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn ein lokales Semaphor erstellt wurde (d. h., wenn <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> gleich <ph id="ph2">&lt;see langword="null" /&gt;</ph> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemsemaphor erstellt wurde. Der Wert ist <ph id="ph3">&lt;see langword="false" /&gt;</ph>, wenn das angegebene benannte Systemsemaphor bereits vorhanden war.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Dieser Parameter wird nicht initialisiert übergeben.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>-Klasse, gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen sowie optional den Namen eines Systemsemaphorobjekts an, gibt eine Variable an, die einen Wert empfängt, der angibt, ob ein neues Systemsemaphor erstellt wurde.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.</source>
          <target state="translated">Dieser Konstruktor initialisiert ein <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> Objekt, das ein benanntes Systemsemaphor darstellt.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.</source>
          <target state="translated">Sie können mehrere erstellen <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> benannte Systemsemaphor Objekte, die die gleiche darstellen.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">Wenn das benannte Systemsemaphor nicht vorhanden ist, wird Sie mit dem anfänglichen Zähler und die maximale Anzahl von angegebenen erstellt <ph id="ph1">`initialCount`</ph> und <ph id="ph2">`maximumCount`</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If the named system semaphore already exists, <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph> are not used, although invalid values still cause exceptions.</source>
          <target state="translated">Wenn das benannte Systemsemaphor bereits vorhanden ist, <ph id="ph1">`initialCount`</ph> und <ph id="ph2">`maximumCount`</ph> nicht verwendet, obwohl ungültige Werte immer noch Ausnahmen auslösen.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Use <ph id="ph1">`createdNew`</ph> to determine whether the system semaphore was created.</source>
          <target state="translated">Verwendung <ph id="ph1">`createdNew`</ph> um zu bestimmen, ob das Systemsemaphor erstellt wurde.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, and <ph id="ph3">`createdNew`</ph> is <ph id="ph4">`true`</ph>, the effect is the same as if the current thread had called <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> minus <ph id="ph7">`initialCount`</ph>) times.</source>
          <target state="translated">Wenn <ph id="ph1">`initialCount`</ph> ist kleiner als <ph id="ph2">`maximumCount`</ph>, und <ph id="ph3">`createdNew`</ph> ist <ph id="ph4">`true`</ph>, der Effekt ist derselbe, als ob der aktuelle Thread aufgerufen hätten <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> minus <ph id="ph7">`initialCount`</ph>) Zeiten.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local semaphore is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.</source>
          <target state="translated">Bei Angabe von <ph id="ph1">`null`</ph> oder eine leere Zeichenfolge für <ph id="ph2">`name`</ph>, ein lokales Semaphor erstellt, wie bei einem Aufruf der <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> Überladung des Konstruktors.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">In diesem Fall <ph id="ph1">`createdNew`</ph> ist immer <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Da benannte Semaphoren im gesamten Betriebssystem sichtbar sind, können sie verwendet werden, um Ressourcen über Prozessgrenzen hinweg koordinieren.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, das Verhalten prozessübergreifend ein benanntes Semaphor.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The example creates a named semaphore with a maximum count of five and an initial count of two.</source>
          <target state="translated">Das Beispiel erstellt ein benanntes Semaphor mit einen maximalen Zähler von fünf und einem anfänglichen Zähler von zwei.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>That is, it reserves three entries for the thread that calls the constructor.</source>
          <target state="translated">D. h., sie behält sich vor drei Einträge für den Thread, der den Konstruktor aufruft.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If <ph id="ph1">`createNew`</ph> is <ph id="ph2">`false`</ph>, the program makes three calls to the <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">Wenn <ph id="ph1">`createNew`</ph> ist <ph id="ph2">`false`</ph>, das Programm sendet drei Aufrufe, die <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</source>
          <target state="translated">Daher, wenn Sie das kompilierte Beispiel über zwei Befehlsfenstern ausgeführt, beim zweiten Kopiervorgang blockiert der dritte Aufruf von <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Release one or more entries in the first copy of the program to unblock the second.</source>
          <target state="translated">Lassen Sie eine oder mehrere Einträge in der ersten Kopie des Programms für die zweite aufheben.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist länger als 260 Zeichen.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> ist kleiner als 1.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32-Fehler.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The named semaphore exists and has access control security, and the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">Der benannte Semaphor ist vorhanden und verfügt über Zugriffssteuerungssicherheit, und der Benutzer verfügt nicht über <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Der benannte Semaphor kann nicht erstellt werden, möglicherweise, weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">zum Aufrufen von nicht verwaltetem Code, um ein benanntes Systemsemaphor zu erstellen.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Sicherheitsaktion: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The initial number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">Die ursprüngliche Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The maximum number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">Die maximale Anzahl von Anforderungen für das Semaphor, die gleichzeitig ausgeführt werden können.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The name of a named system semaphore object.</source>
          <target state="translated">Der Name eines benannten Systemsemaphorobjekts.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local semaphore was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system semaphore was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system semaphore already existed.</source>
          <target state="translated">Enthält nach dem Beenden dieser Methode den Wert <ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn ein lokales Semaphor erstellt wurde (d. h., wenn <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> gleich <ph id="ph2">&lt;see langword="null" /&gt;</ph> oder eine leere Zeichenfolge ist) oder wenn das angegebene benannte Systemsemaphor erstellt wurde. Der Wert ist <ph id="ph3">&lt;see langword="false" /&gt;</ph>, wenn das angegebene benannte Systemsemaphor bereits vorhanden war.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Dieser Parameter wird nicht initialisiert übergeben.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system semaphore.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph>-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf das benannte Systemsemaphor angewendet werden soll.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>-Klasse, gibt die ursprüngliche Anzahl von Einträgen und die maximale Anzahl von gleichzeitigen Einträgen an, gibt optional den Namen eines Systemsemaphorobjekts an, gibt eine Variable an, die einen Wert empfängt, der angibt, ob ein neues Systemsemaphor erstellt wurde, und gibt die Sicherheitszugriffssteuerung für das Systemsemaphor an.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.</source>
          <target state="translated">Verwenden Sie diesen Konstruktor zur Steuerung des Zugriffs auf ein benanntes Systemsemaphor anzuwenden verhindert, dass anderer Code Kontrolle über das Semaphor erstellt wurde, ein.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.</source>
          <target state="translated">Dieser Konstruktor initialisiert ein <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> Objekt, das ein benanntes Systemsemaphor darstellt.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.</source>
          <target state="translated">Sie können mehrere erstellen <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> benannte Systemsemaphor Objekte, die die gleiche darstellen.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named system semaphore does not exist, it is created with the specified access control security.</source>
          <target state="translated">Wenn das benannte Systemsemaphor nicht vorhanden ist, wird er mit dem angegebenen zugriffssteuerungssicherheit erstellt.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named semaphore exists, the specified access control security is ignored.</source>
          <target state="translated">Wenn das benannte Semaphor vorhanden ist, wird die angegebene zugriffssteuerungssicherheit ignoriert.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The caller has full control over the newly created <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object even if <ph id="ph2">`semaphoreSecurity`</ph> denies or fails to grant some access rights to the current user.</source>
          <target state="translated">Der Aufrufer hat Vollzugriff auf das neu erstellte <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> Objekt erstellen, selbst wenn <ph id="ph2">`semaphoreSecurity`</ph> verweigert oder einige über die Zugriffsrechte für den aktuellen Benutzer zu erteilen.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>However, if the current user attempts to get another <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object to represent the same named semaphore, using either a constructor or the <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.</source>
          <target state="translated">Jedoch wenn der aktuelle Benutzer versucht, erhalten eine andere <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> Objekt zur Darstellung identisch benannte Semaphor, die entweder einen Konstruktor oder die <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> -Methode, Windows-zugriffssteuerungssicherheit angewendet wird.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">Wenn das benannte Systemsemaphor nicht vorhanden ist, wird Sie mit dem anfänglichen Zähler und die maximale Anzahl von angegebenen erstellt <ph id="ph1">`initialCount`</ph> und <ph id="ph2">`maximumCount`</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named system semaphore already exists, <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph> are not used, although invalid values still cause exceptions.</source>
          <target state="translated">Wenn das benannte Systemsemaphor bereits vorhanden ist, <ph id="ph1">`initialCount`</ph> und <ph id="ph2">`maximumCount`</ph> nicht verwendet, obwohl ungültige Werte immer noch Ausnahmen auslösen.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Use the <ph id="ph1">`createdNew`</ph> parameter to determine whether the system semaphore was created by this constructor.</source>
          <target state="translated">Verwenden der <ph id="ph1">`createdNew`</ph> Parameter, um zu bestimmen, ob von diesem Konstruktor die Systemsemaphor erstellt wurde.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, and <ph id="ph3">`createdNew`</ph> is <ph id="ph4">`true`</ph>, the effect is the same as if the current thread had called <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> minus <ph id="ph7">`initialCount`</ph>) times.</source>
          <target state="translated">Wenn <ph id="ph1">`initialCount`</ph> ist kleiner als <ph id="ph2">`maximumCount`</ph>, und <ph id="ph3">`createdNew`</ph> ist <ph id="ph4">`true`</ph>, der Effekt ist derselbe, als ob der aktuelle Thread aufgerufen hätten <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> minus <ph id="ph7">`initialCount`</ph>) Zeiten.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local semaphore is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.</source>
          <target state="translated">Bei Angabe von <ph id="ph1">`null`</ph> oder eine leere Zeichenfolge für <ph id="ph2">`name`</ph>, ein lokales Semaphor erstellt, wie bei einem Aufruf der <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> Überladung des Konstruktors.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">In diesem Fall <ph id="ph1">`createdNew`</ph> ist immer <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Da benannte Semaphoren im gesamten Betriebssystem sichtbar sind, können sie verwendet werden, um Ressourcen über Prozessgrenzen hinweg koordinieren.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">Im folgenden Codebeispiel wird das Verhalten prozessübergreifend ein benanntes Semaphor mit zugriffssteuerungssicherheit veranschaulicht.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> -methodenüberladung, um das Vorhandensein des ein benanntes Semaphor testen.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">Wenn das Semaphor nicht vorhanden ist, wird es erstellt, mit einer maximalen Zähler von zwei und zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Semaphor verwenden, aber das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor gewährt.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel aus zwei Befehlsfenstern ausführen, löst die zweite Kopie eine Zugriffsverletzungsausnahme beim Aufruf von der <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">Die Ausnahme abgefangen wird, und im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> -methodenüberladung, um das Semaphor mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen zu öffnen.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release.</source>
          <target state="translated">Nachdem die Berechtigungen geändert werden, wird das Semaphor geöffnet, mit den erforderlichen Benutzerrechten zum eingeben und freigeben.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird die Verwendung der neuen Berechtigungen ausgeführt.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist länger als 260 Zeichen.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> ist kleiner als 1.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The named semaphore exists and has access control security, and the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">Der benannte Semaphor ist vorhanden und verfügt über Zugriffssteuerungssicherheit, und der Benutzer verfügt nicht über <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32-Fehler.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Der benannte Semaphor kann nicht erstellt werden, möglicherweise, weil ein Wait-Handle eines anderen Typs den gleichen Namen hat.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">zum Aufrufen von nicht verwaltetem Code, um ein benanntes Systemsemaphor zu erstellen.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Sicherheitsaktion: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>Gets the access control security for a named system semaphore.</source>
          <target state="translated">Ruft die Zugriffssteuerungssicherheit für ein benanntes Systemsemaphor ab.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> object that represents the access control security for the named system semaphore.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph>-Objekt, das die Zugriffssteuerungssicherheit für das benannte Systemsemaphor darstellt.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> Methode verwendet die folgende Kombination von Flags, die (mit dem bitweisen OR-Operation kombiniert) zu suchende Berechtigungen: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, und <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the semaphore must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">Der Benutzer benötigt <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> Rechte für diese Methode aufzurufen, und das Semaphor müssen mit geöffnet wurden <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> Rechte.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>On a local semaphore, access control security is irrelevant.</source>
          <target state="translated">Auf ein lokales Semaphor ist zugriffssteuerungssicherheit spielt keine Rolle.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object does not represent a named system semaphore, this method returns a <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object that grants all rights to any user.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> Objekt stellt kein benanntes Systemsemaphor dar, die diese Methode gibt ein <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> -Objekt, das für jeden Benutzer alle Rechte gewährt.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">Im folgenden Codebeispiel wird das Verhalten prozessübergreifend ein benanntes Semaphor mit zugriffssteuerungssicherheit veranschaulicht.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> -methodenüberladung, um das Vorhandensein des ein benanntes Semaphor testen.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">Wenn das Semaphor nicht vorhanden ist, wird es erstellt, mit einer maximalen Zähler von zwei und zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Semaphor verwenden, aber das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor gewährt.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel aus zwei Befehlsfenstern ausführen, löst die zweite Kopie eine Zugriffsverletzungsausnahme beim Aufruf von der <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">Die Ausnahme abgefangen wird, und im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> -methodenüberladung, um das Semaphor mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen zu öffnen.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The access control security for the system semaphore is obtained using the <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> method.</source>
          <target state="translated">Die zugriffssteuerungssicherheit für das Systemsemaphor abgerufen wird, mithilfe der <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release.</source>
          <target state="translated">Nachdem die Berechtigungen geändert werden, wird das Semaphor geöffnet, mit den erforderlichen Benutzerrechten zum eingeben und freigeben.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird die Verwendung der neuen Berechtigungen ausgeführt.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object represents a named system semaphore, and the user does not have <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph> rights.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>-Objekt stellt einen benannten Systemsemaphor dar, und der Benutzer verfügt nicht über <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph>-Berechtigung.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object represents a named system semaphore and was not opened with <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph> rights.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>-Objekt stellt einen benannten Systemsemaphor dar und wurde nicht mit <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph>-Berechtigung geöffnet.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>Not supported for Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Wird nicht für Windows 98 oder Windows Millennium Edition unterstützt.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Opens a specified named semaphore, if it already exists.</source>
          <target state="translated">Öffnet ein angegebenes benanntes Semaphor, wenn es bereits vorhanden ist.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">Der Name des zu öffnenden Systemsemaphors.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Opens the specified named semaphore, if it already exists.</source>
          <target state="translated">Öffnet das angegebene benannte Semaphor, wenn es bereits vorhanden ist.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>An object that represents the named system semaphore.</source>
          <target state="translated">Ein Objekt, das das benannte Systemsemaphor darstellt.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method tries to open the specified named semaphore.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> Methode versucht, das angegebene benannte Semaphor öffnen.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</source>
          <target state="translated">Wenn das Systemsemaphor nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das Systemsemaphor an.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Das Systemsemaphor erstellt, wenn sie nicht bereits vorhanden ist, gehen Sie die <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> Konstruktoren, die verfügt über eine <ph id="ph2">`name`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.</source>
          <target state="translated">Mehrere Aufrufe dieser Methode, die den gleichen Wert für <ph id="ph1">`name`</ph> nicht unbedingt zurück, die gleiche <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> -Objekt, auch wenn die Objekte, die zurückgegeben werden, stellen den gleichen Systemsemaphor Namen.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Überladung dieser Methode entspricht dem Aufrufen der <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> methodenüberladung und Angeben von <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> und <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> Rechte, die mit dem bitweisen OR-Operation kombiniert.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to enter the semaphore, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">Angeben der <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> Flag ermöglicht, dass einen Thread das Semaphor und Angeben der <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> Flag ermöglicht, dass einen Thread aufrufen, die <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">Im folgenden Codebeispiel wird das Verhalten prozessübergreifend ein benanntes Semaphor mit zugriffssteuerungssicherheit veranschaulicht.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> -methodenüberladung, um das Vorhandensein des ein benanntes Semaphor testen.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">Wenn das Semaphor nicht vorhanden ist, wird es erstellt, mit einer maximalen Zähler von zwei und zugriffssteuerungssicherheit, die dem aktuellen Benutzer das Recht, verwenden Sie das Semaphor verweigert, aber denen erteilt die Berechtigung zum Lesen und Ändern von Berechtigungen für das Semaphor.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel aus zwei Befehlsfenstern ausführen, löst die zweite Kopie eine Zugriffsverletzungsausnahme beim Aufruf von der <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">Die Ausnahme abgefangen wird, und im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> -methodenüberladung, um das Semaphor mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen zu öffnen.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</source>
          <target state="translated">Nachdem die Berechtigungen geändert werden, wird das Semaphor mit den erforderlichen Benutzerrechten zum eingeben und freigegeben werden, geöffnet.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird die Verwendung der neuen Berechtigungen ausgeführt.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist eine leere Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist länger als 260 Zeichen.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The named semaphore does not exist.</source>
          <target state="translated">Das benannte Semaphor ist nicht vorhanden.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32-Fehler.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The named semaphore exists, but the user does not have the security access required to use it.</source>
          <target state="translated">Der benannte Semaphor ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>for calling unmanaged code to open a named system semaphore.</source>
          <target state="translated">zum Aufrufen von nicht verwaltetem Code, um ein benanntes Systemsemaphor zu öffnen.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Sicherheitsaktion: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">Der Name des zu öffnenden Systemsemaphors.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Opens the specified named semaphore, if it already exists, with the desired security access.</source>
          <target state="translated">Öffnet das angegebene benannte Semaphor, wenn es bereits vorhanden ist, mit dem gewünschten Sicherheitszugriff.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>An object that represents the named system semaphore.</source>
          <target state="translated">Ein Objekt, das das benannte Systemsemaphor darstellt.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to enter the semaphore, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">`rights`</ph> Parameter umfasst die <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> Flag, um Threads das Semaphor ermöglichen und die <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> -Kennzeichen an die Threads ermöglichen, rufen Sie die <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method tries to open an existing named semaphore.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> Methode versucht, öffnen Sie eine vorhandene benannte Semaphor.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</source>
          <target state="translated">Wenn das Systemsemaphor nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das Systemsemaphor an.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Das Systemsemaphor erstellt, wenn sie nicht bereits vorhanden ist, gehen Sie die <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> Konstruktoren, die verfügt über eine <ph id="ph2">`name`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.</source>
          <target state="translated">Mehrere Aufrufe dieser Methode, die den gleichen Wert für <ph id="ph1">`name`</ph> nicht unbedingt zurück, die gleiche <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> -Objekt, auch wenn die Objekte, die zurückgegeben werden, stellen den gleichen Systemsemaphor Namen.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">Im folgenden Codebeispiel wird das Verhalten prozessübergreifend ein benanntes Semaphor mit zugriffssteuerungssicherheit veranschaulicht.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> -methodenüberladung, um das Vorhandensein des ein benanntes Semaphor testen.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">Wenn das Semaphor nicht vorhanden ist, wird es erstellt, mit einer maximalen Zähler von zwei und zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Semaphor verwenden, aber das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor gewährt.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel aus zwei Befehlsfenstern ausführen, löst die zweite Kopie eine Zugriffsverletzungsausnahme beim Aufruf von der <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">Die Ausnahme abgefangen wird, und im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> -methodenüberladung, um das Semaphor mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen zu öffnen.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</source>
          <target state="translated">Nachdem die Berechtigungen geändert werden, wird das Semaphor mit den erforderlichen Benutzerrechten zum eingeben und freigegeben werden, geöffnet.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird die Verwendung der neuen Berechtigungen ausgeführt.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist eine leere Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist länger als 260 Zeichen.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The named semaphore does not exist.</source>
          <target state="translated">Das benannte Semaphor ist nicht vorhanden.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32-Fehler.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The named semaphore exists, but the user does not have the desired security access rights.</source>
          <target state="translated">Das benannte Semaphor ist vorhanden, der Benutzer verfügt jedoch nicht über die gewünschten Sicherheitszugriffsrechte.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">zum Aufrufen von nicht verwaltetem Code, um ein benanntes Systemsemaphor zu erstellen.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Sicherheitsaktion: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Exits the semaphore.</source>
          <target state="translated">Beendet das Semaphor.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>Exits the semaphore and returns the previous count.</source>
          <target state="translated">Beendet das Semaphor und gibt die vorherige Anzahl zurück.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The count on the semaphore before the <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph> method was called.</source>
          <target state="translated">Die Anzahl für das Semaphor vor dem Aufruf der <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Threads typically use the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method to enter the semaphore, and they typically use this method overload to exit.</source>
          <target state="translated">Verwenden von Threads in der Regel die <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> Methode, um in der Regel geben das Semaphor, und sie verwenden eine Überladung dieser Methode um zu beenden.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown by the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method, it does not necessarily indicate a problem with the calling thread.</source>
          <target state="translated">Wenn eine <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> wird ausgelöst, durch die <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> -Methode, ein Problem mit dem aufrufenden Thread nicht notwendigerweise.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</source>
          <target state="translated">Ein Programmierfehler in einem anderen Thread möglicherweise Thread das Semaphor mehrfach als er vorliegt.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>If the current <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object represents a named system semaphore, the user must have <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights and the semaphore must have been opened with <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> -Objekt stellt ein benanntes Systemsemaphor dar, die der Benutzer benötigt <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> Rechte und das Semaphor müssen geöffnet wurden mit <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> Rechte.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The following code example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">Das folgende Codebeispiel erstellt eine Semaphore mit einen maximalen Zähler von drei und eine anfängliche Anzahl von 0 (null).</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">Das Beispiel beginnt fünf Threads das Semaphor warten zu blockieren.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">Der Hauptthread verwendet die <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> -methodenüberladung, um den Zähler des Semaphors auf seinen Maximalwert, sodass drei Threads in das Semaphor zu erhöhen.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">Jeder Thread verwendet die <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> Methode, um eine Sekunde warten, bis zum Simulieren von Arbeit und ruft dann die <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> -methodenüberladung, um das Semaphor freizugeben.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">Jedes Mal, wenn das Semaphor freigegeben wird, wird die vorherige Anzahl des Semaphors angezeigt.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Console messages track semaphore use.</source>
          <target state="translated">Konsole Nachrichten nachverfolgen Semaphore verwenden.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">Das simulierte Intervall wird für jeden Thread, um die Ausgabe leichter lesbar zu machen etwas erhöht.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The semaphore count is already at the maximum value.</source>
          <target state="translated">Die Anzahl für das Semaphor weist bereits den maximalen Wert auf.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>A Win32 error occurred with a named semaphore.</source>
          <target state="translated">Bei einem benannten Semaphor ist ein Win32-Fehler aufgetreten.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The current semaphore represents a named system semaphore, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</source>
          <target state="translated">Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar. Der Benutzer verfügt jedoch nicht über <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The current semaphore represents a named system semaphore, but it was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</source>
          <target state="translated">Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar, es wurde jedoch nicht mit <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph> geöffnet.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The number of times to exit the semaphore.</source>
          <target state="translated">Die Anzahl von Malen, die das Semaphor freigegeben werden soll.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Exits the semaphore a specified number of times and returns the previous count.</source>
          <target state="translated">Gibt das Semaphor eine festgelegte Anzahl von Malen frei und gibt die vorherige Anzahl zurück.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The count on the semaphore before the <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph> method was called.</source>
          <target state="translated">Die Anzahl für das Semaphor vor dem Aufruf der <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.</source>
          <target state="translated">Wenn ein Thread das Semaphor mehrfach eingegeben hat, kann Überladung dieser Methode die gesamte Semaphorenanzahl mit einem Aufruf wiederhergestellt werden.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown by the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method, it does not necessarily indicate a problem with the calling thread.</source>
          <target state="translated">Wenn eine <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> wird ausgelöst, durch die <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> -Methode, ein Problem mit dem aufrufenden Thread nicht notwendigerweise.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</source>
          <target state="translated">Ein Programmierfehler in einem anderen Thread möglicherweise Thread das Semaphor mehrfach als er vorliegt.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>If the current <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object represents a named system semaphore, the user must have <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights and the semaphore must have been opened with <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> -Objekt stellt ein benanntes Systemsemaphor dar, die der Benutzer benötigt <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> Rechte und das Semaphor müssen geöffnet wurden mit <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> Rechte.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The following code example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">Das folgende Codebeispiel erstellt eine Semaphore mit einen maximalen Zähler von drei und eine anfängliche Anzahl von 0 (null).</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">Das Beispiel beginnt fünf Threads das Semaphor warten zu blockieren.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">Der Hauptthread verwendet die <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> -methodenüberladung, um den Zähler des Semaphors auf seinen Maximalwert, sodass drei Threads in das Semaphor zu erhöhen.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">Jeder Thread verwendet die <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> Methode, um eine Sekunde warten, bis zum Simulieren von Arbeit und ruft dann die <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> -methodenüberladung, um das Semaphor freizugeben.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">Jedes Mal, wenn das Semaphor freigegeben wird, wird die vorherige Anzahl des Semaphors angezeigt.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Console messages track semaphore use.</source>
          <target state="translated">Konsole Nachrichten nachverfolgen Semaphore verwenden.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">Das simulierte Intervall wird für jeden Thread, um die Ausgabe leichter lesbar zu machen etwas erhöht.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="releaseCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="releaseCount" /&gt;</ph> ist kleiner als 1.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The semaphore count is already at the maximum value.</source>
          <target state="translated">Die Anzahl für das Semaphor weist bereits den maximalen Wert auf.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>A Win32 error occurred with a named semaphore.</source>
          <target state="translated">Bei einem benannten Semaphor ist ein Win32-Fehler aufgetreten.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The current semaphore represents a named system semaphore, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph> rights.</source>
          <target state="translated">Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar. Der Benutzer verfügt jedoch nicht über <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>-Rechte.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The current semaphore represents a named system semaphore, but it was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph> rights.</source>
          <target state="translated">Das aktuelle Semaphor stellt ein benanntes Systemsemaphor dar, es wurde jedoch nicht mit <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>-Rechten geöffnet.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system semaphore.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph>-Objekt, das die Zugriffssteuerungssicherheit darstellt, die auf das benannte Systemsemaphor angewendet werden soll.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>Sets the access control security for a named system semaphore.</source>
          <target state="translated">Legt die Zugriffssteuerungssicherheit für ein benanntes Systemsemaphor fest.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>You can set access control security only on <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent named system semaphores.</source>
          <target state="translated">Sie können die zugriffssteuerungssicherheit festlegen, nur auf <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> Objekte, die benanntes Semaphore darstellen.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the semaphore must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">Der Benutzer benötigt <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> Rechte für diese Methode aufzurufen, und das Semaphor müssen mit geöffnet wurden <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> Rechte.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">Im folgenden Codebeispiel wird das Verhalten prozessübergreifend ein benanntes Semaphor mit zugriffssteuerungssicherheit veranschaulicht.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> -methodenüberladung, um das Vorhandensein des ein benanntes Semaphor testen.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">Wenn das Semaphor nicht vorhanden ist, wird es erstellt, mit einer maximalen Zähler von zwei und zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Semaphor verwenden, aber das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor gewährt.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel aus zwei Befehlsfenstern ausführen, löst die zweite Kopie eine Zugriffsverletzungsausnahme beim Aufruf von der <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">Die Ausnahme abgefangen wird, und im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> -methodenüberladung, um das Semaphor mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen zu öffnen.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>After the permissions are changed, using the <ph id="ph1">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A&gt;</ph> method, the semaphore is opened with the rights required to enter and release.</source>
          <target state="translated">Nach dem Ändern der Berechtigungen mithilfe der <ph id="ph1">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A&gt;</ph> mit den erforderlichen Benutzerrechten zum eingeben und release-Methode, das Semaphor geöffnet wird.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird die Verwendung der neuen Berechtigungen ausgeführt.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="semaphoreSecurity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="semaphoreSecurity" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph> rights.</source>
          <target state="translated">Der Benutzer verfügt nicht über <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph>-Rechte.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The semaphore was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph> rights.</source>
          <target state="translated">Das Semaphor wurde nicht mit <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph>-Rechten geöffnet.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object does not represent a named system semaphore.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>-Objekt stellt kein benanntes Systemsemaphor dar.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Öffnet ein angegebenes benanntes Semaphor, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">Der Name des zu öffnenden Systemsemaphors.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object that represents the named semaphore if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">Enthält nach Beenden der Methode ein <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>-Objekt, das das benannte Semaphor darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn der Aufruf fehlgeschlagen ist.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Dieser Parameter wird nicht initialisiert behandelt.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Öffnet das angegebene benannte Semaphor, wenn es bereits vorhanden ist, und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named semaphore was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das benannte Semaphor erfolgreich geöffnet wurde; andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>If the named semaphore does not exist, this method does not create it.</source>
          <target state="translated">Wenn das benannte Semaphor nicht vorhanden ist, wird es von dieser Methode nicht erstellt.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Das Systemsemaphor erstellt, wenn sie nicht bereits vorhanden ist, gehen Sie die <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> Konstruktoren, die verfügt über eine <ph id="ph2">`name`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>If you are uncertain whether a named semaphore exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the semaphore does not exist.</source>
          <target state="translated">Wenn Sie unsicher sind, ob ein benanntes Semaphor vorhanden ist, verwenden Sie die Überladung dieser Methode anstelle des dem <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> methodenüberladung, die eine Ausnahme auslöst, wenn das Semaphor nicht vorhanden ist.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Semaphore.TryOpenExisting%2A&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Überladung dieser Methode entspricht dem Aufrufen der <ph id="ph1">&lt;xref:System.Threading.Semaphore.TryOpenExisting%2A&gt;</ph> methodenüberladung und Angeben von <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> und <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> Rechte, die mit dem bitweisen OR-Operation kombiniert.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to enter the semaphore, and specifying the   <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">Angeben der <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> Flag ermöglicht, dass einen Thread das Semaphor und Angeben der <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> Flag ermöglicht, dass einen Thread aufrufen, die <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist eine leere Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist länger als 260 Zeichen.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32-Fehler.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>The named semaphore exists, but the user does not have the security access required to use it.</source>
          <target state="translated">Der benannte Semaphor ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">Der Name des zu öffnenden Systemsemaphors.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Eine bitweise Kombination von Enumerationswerten, die die gewünschten Sicherheitszugriffsrechte darstellen.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object that represents the named semaphore if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">Enthält nach Beenden der Methode ein <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>-Objekt, das das benannte Semaphor darstellt, wenn der Aufruf erfolgreich ausgeführt wurde, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn der Aufruf fehlgeschlagen ist.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Dieser Parameter wird nicht initialisiert behandelt.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Öffnet das angegebene benannte Semaphor, wenn es bereits mit dem gewünschten Sicherheitszugriff vorhanden ist und gibt einen Wert zurück, der angibt, ob der Vorgang erfolgreich war.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named semaphore was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das benannte Semaphor erfolgreich geöffnet wurde; andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>If the named semaphore does not exist, this method does not create it.</source>
          <target state="translated">Wenn das benannte Semaphor nicht vorhanden ist, wird es von dieser Methode nicht erstellt.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Das Systemsemaphor erstellt, wenn sie nicht bereits vorhanden ist, gehen Sie die <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> Konstruktoren, die verfügt über eine <ph id="ph2">`name`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>If you are uncertain whether a named semaphore exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload, which throws an exception if the semaphore does not exist.</source>
          <target state="translated">Wenn Sie unsicher sind, ob ein benanntes Semaphor vorhanden ist, verwenden Sie die Überladung dieser Methode anstelle des dem <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> methodenüberladung, die eine Ausnahme auslöst, wenn das Semaphor nicht vorhanden ist.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to enter the semaphore, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">`rights`</ph> Parameter umfasst die <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> Flag, um Threads das Semaphor ermöglichen und die <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> -Kennzeichen an die Threads ermöglichen, rufen Sie die <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.</source>
          <target state="translated">Mehrere Aufrufe dieser Methode, die den gleichen Wert für <ph id="ph1">`name`</ph> nicht unbedingt zurück, die gleiche <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> -Objekt, auch wenn die Objekte, die zurückgegeben werden, stellen den gleichen Systemsemaphor Namen.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist eine leere Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist länger als 260 Zeichen.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Win32-Fehler.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>The named semaphore exists, but the user does not have the security access required to use it.</source>
          <target state="translated">Der benannte Semaphor ist vorhanden, aber der Benutzer verfügt nicht über den Sicherheitszugriff, der für die Verwendung erforderlich ist.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>