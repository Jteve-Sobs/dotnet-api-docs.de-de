<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="47dc3c315c3032983e55c27b5310ada10bd2501f" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36406830" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Limits the number of threads that can access a resource or pool of resources concurrently.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Threading.Semaphore> Klasse zum Steuern des Zugriffs auf einen Pool von Ressourcen. Threads das Semaphor durch Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%2A> -Methode, die von geerbt wird die <xref:System.Threading.WaitHandle> Klasse, und geben Sie das Semaphor durch Aufrufen der <xref:System.Threading.Semaphore.Release%2A> Methode.  
  
 Anzahl die für einen Semaphore wird wieder um eins erniedrigt jedes Mal ein Thread das Semaphor eingibt, und inkrementiert, wenn ein Thread das Semaphor freigibt. Wenn die Anzahl 0 (null) ist, blockieren nachfolgende Anforderungen, bis andere Threads das Semaphor freizugeben. Wenn alle Threads das Semaphor freigegeben haben, wird die Anzahl der zulässige Höchstwert angegeben, wenn das Semaphor erstellt wurde.  
  
 Es gibt keine festgelegte Reihenfolge, z. B. FIFO oder LIFO, in denen blockierte Threads das Semaphor.  
  
 Ein Thread kann das Semaphor mehrfach durch Aufrufen der <xref:System.Threading.WaitHandle.WaitOne%2A> Methode wiederholt. Um einige oder alle diese Einträge freizugeben, kann der Thread die parameterlose Aufrufen <xref:System.Threading.Semaphore.Release> methodenüberladung, die mehrere Male, oder es kann Aufrufen der <xref:System.Threading.Semaphore.Release%28System.Int32%29> methodenüberladung, die die Anzahl der freizugebenden Einträge angibt.  
  
 Die <xref:System.Threading.Semaphore> Klasse erzwingt keine Threadidentität für Aufrufe von <xref:System.Threading.WaitHandle.WaitOne%2A> oder <xref:System.Threading.Semaphore.Release%2A>. Es ist der Verantwortung des Programmierers, stellen Sie sicher, dass Threads das Semaphor nicht zu oft freigeben. Angenommen, ein Semaphor hat einen maximalen Zähler von zwei und Thread A sowie Thread B wechseln beide in das Semaphor. Wenn ein Programmierfehler in Thread B aufrufen verursacht <xref:System.Threading.Semaphore.Release%2A> zweimal, beide Aufrufe erfolgreich. Der Zähler des Semaphors ist voll, und wenn Thread A schließlich <xref:System.Threading.Semaphore.Release%2A> aufruft, wird eine <xref:System.Threading.SemaphoreFullException> ausgelöst.  
  
 Semaphoren sind zwei Typen: lokale Semaphore und benanntes Semaphore. Bei Erstellung einer <xref:System.Threading.Semaphore> -Objekt mithilfe eines Konstruktors, der einen Namen akzeptiert ein Betriebssystem-Semaphor mit diesem Namen zugeordnet ist. Benannte Semaphoren sind im gesamten Betriebssystem sichtbar und können verwendet werden, um die Aktivitäten von Prozessen zu synchronisieren. Sie können mehrere erstellen <xref:System.Threading.Semaphore> benannte Systemsemaphor Objekte, die die gleiche darstellen, und Sie können die <xref:System.Threading.Semaphore.OpenExisting%2A> Methode zum Öffnen einer vorhandenen benannte Systemsemaphor.  
  
 Ein lokales Semaphor ist nur innerhalb des Prozesses vorhanden. Er kann von jedem Thread in einem Prozess verwendet werden, der einen Verweis auf das lokale <xref:System.Threading.Semaphore>-Objekt enthält. Jede <xref:System.Threading.Semaphore> Objekt ist ein separates lokales Semaphor.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine Semaphore mit einen maximalen Zähler von drei und eine anfängliche Anzahl von 0 (null). Das Beispiel beginnt fünf Threads das Semaphor warten zu blockieren. Der Hauptthread verwendet die <xref:System.Threading.Semaphore.Release%28System.Int32%29> -methodenüberladung, um den Zähler des Semaphors auf seinen Maximalwert, sodass drei Threads in das Semaphor zu erhöhen. Jeder Thread verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode, um eine Sekunde warten, bis zum Simulieren von Arbeit und ruft dann die <xref:System.Threading.Semaphore.Release> -methodenüberladung, um das Semaphor freizugeben. Jedes Mal, wenn das Semaphor freigegeben wird, wird die vorherige Anzahl des Semaphors angezeigt. Konsole Nachrichten nachverfolgen Semaphore verwenden. Das simulierte Intervall wird für jeden Thread, um die Ausgabe leichter lesbar zu machen etwas erhöht.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
        <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert ein unbenanntes Semaphor. Alle Threads, die eine Instanz eines solchen Semaphors verwenden, müssen Verweise auf die Instanz haben.  
  
 Wenn `initialCount` ist kleiner als `maximumCount`, der Effekt ist derselbe, als ob der aktuelle Thread aufgerufen hätten <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) Zeiten. Wenn keine Einträge für den Thread zu reservieren, die das Semaphor erstellt werden soll, verwenden Sie die gleiche Anzahl für `maximumCount` und `initialCount`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Semaphore mit einer maximalen Anzahl von drei und eine anfängliche Anzahl von 0 (null). Das Beispiel beginnt fünf Threads das Semaphor warten zu blockieren. Der Hauptthread verwendet die <xref:System.Threading.Semaphore.Release%28System.Int32%29> -methodenüberladung, um den Zähler des Semaphors auf seinen Maximalwert, sodass drei Threads in das Semaphor zu erhöhen. Jeder Thread verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode, um eine Sekunde warten, bis zum Simulieren von Arbeit und ruft dann die <xref:System.Threading.Semaphore.Release> -methodenüberladung, um das Semaphor freizugeben. Jedes Mal, wenn das Semaphor freigegeben wird, wird die vorherige Anzahl des Semaphors angezeigt. Konsole Nachrichten nachverfolgen Semaphore verwenden. Das simulierte Intervall wird für jeden Thread, um die Ausgabe leichter lesbar zu machen etwas erhöht.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> is less than 1.  -or-  <paramref name="initialCount" /> is less than 0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
        <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
        <param name="name">The name of a named system semaphore object.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.Semaphore> Objekt, das ein benanntes Systemsemaphor darstellt. Sie können mehrere erstellen <xref:System.Threading.Semaphore> benannte Systemsemaphor Objekte, die die gleiche darstellen.  
  
 Wenn das benannte Systemsemaphor nicht vorhanden ist, wird Sie mit dem anfänglichen Zähler und die maximale Anzahl von angegebenen erstellt `initialCount` und `maximumCount`. Wenn das benannte Systemsemaphor bereits vorhanden ist, `initialCount` und `maximumCount` nicht verwendet, obwohl ungültige Werte immer noch Ausnahmen auslösen. Wenn Sie bestimmen müssen, und zwar unabhängig davon, ob ein benanntes Systemsemaphor erstellt wurde, verwenden Sie die <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> Konstruktor überladen stattdessen.  
  
> [!IMPORTANT]
>  Wenn Sie diese Konstruktorüberladung verwenden, ist die empfohlene Vorgehensweise für die gleiche Anzahl an `initialCount` und `maximumCount`. Wenn `initialCount` ist kleiner als `maximumCount`, und ein benanntes Systemsemaphor erstellt wird, der Effekt ist derselbe, als ob der aktuelle Thread aufgerufen hätten <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) Zeiten. Mit dieser Konstruktorüberladung ist jedoch keine Möglichkeit zu bestimmen, ob ein benanntes Systemsemaphor erstellt wurde.  
  
 Bei Angabe von `null` oder eine leere Zeichenfolge für `name`, ein lokales Semaphor erstellt, wie bei einem Aufruf der <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> Überladung des Konstruktors.  
  
 Da benannte Semaphoren im gesamten Betriebssystem sichtbar sind, können sie verwendet werden, um Ressourcen über Prozessgrenzen hinweg koordinieren.  
  
 Wenn Sie herausfinden, ob ein benanntes Systemsemaphor vorhanden ist, verwenden Sie möchten die <xref:System.Threading.Semaphore.OpenExisting%2A> Methode. Die <xref:System.Threading.Semaphore.OpenExisting%2A> Methode versucht, ein vorhandenes benanntes Semaphor zu öffnen, und löst eine Ausnahme aus, wenn das Systemsemaphor nicht vorhanden ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Verhalten prozessübergreifend ein benanntes Semaphor. Das Beispiel erstellt ein benanntes Semaphor mit einen maximalen Zähler von fünf und eine anfängliche Anzahl von fünf. Das Programm sendet drei Aufrufe, die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode. Daher, wenn Sie das kompilierte Beispiel über zwei Befehlsfenstern ausgeführt, beim zweiten Kopiervorgang blockiert der dritte Aufruf von <xref:System.Threading.WaitHandle.WaitOne%2A>. Lassen Sie eine oder mehrere Einträge in der ersten Kopie des Programms für die zweite aufheben.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> is less than 1.  -or-  <paramref name="initialCount" /> is less than 0.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code, um ein benanntes Systemsemaphor zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">The initial number of requests for the semaphore that can be satisfied concurrently.</param>
        <param name="maximumCount">The maximum number of requests for the semaphore that can be satisfied concurrently.</param>
        <param name="name">The name of a named system semaphore object.</param>
        <param name="createdNew">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed. This parameter is passed uninitialized.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.Semaphore> Objekt, das ein benanntes Systemsemaphor darstellt. Sie können mehrere erstellen <xref:System.Threading.Semaphore> benannte Systemsemaphor Objekte, die die gleiche darstellen.  
  
 Wenn das benannte Systemsemaphor nicht vorhanden ist, wird Sie mit dem anfänglichen Zähler und die maximale Anzahl von angegebenen erstellt `initialCount` und `maximumCount`. Wenn das benannte Systemsemaphor bereits vorhanden ist, `initialCount` und `maximumCount` nicht verwendet, obwohl ungültige Werte immer noch Ausnahmen auslösen. Verwendung `createdNew` um zu bestimmen, ob das Systemsemaphor erstellt wurde.  
  
 Wenn `initialCount` ist kleiner als `maximumCount`, und `createdNew` ist `true`, der Effekt ist derselbe, als ob der aktuelle Thread aufgerufen hätten <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) Zeiten.  
  
 Bei Angabe von `null` oder eine leere Zeichenfolge für `name`, ein lokales Semaphor erstellt, wie bei einem Aufruf der <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> Überladung des Konstruktors. In diesem Fall `createdNew` ist immer `true`.  
  
 Da benannte Semaphoren im gesamten Betriebssystem sichtbar sind, können sie verwendet werden, um Ressourcen über Prozessgrenzen hinweg koordinieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Verhalten prozessübergreifend ein benanntes Semaphor. Das Beispiel erstellt ein benanntes Semaphor mit einen maximalen Zähler von fünf und einem anfänglichen Zähler von zwei. D. h., sie behält sich vor drei Einträge für den Thread, der den Konstruktor aufruft. Wenn `createNew` ist `false`, das Programm sendet drei Aufrufe, die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode. Daher, wenn Sie das kompilierte Beispiel über zwei Befehlsfenstern ausgeführt, beim zweiten Kopiervorgang blockiert der dritte Aufruf von <xref:System.Threading.WaitHandle.WaitOne%2A>. Lassen Sie eine oder mehrere Einträge in der ersten Kopie des Programms für die zweite aufheben.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> is less than 1.  -or-  <paramref name="initialCount" /> is less than 0.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code, um ein benanntes Systemsemaphor zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">The initial number of requests for the semaphore that can be satisfied concurrently.</param>
        <param name="maximumCount">The maximum number of requests for the semaphore that can be satisfied concurrently.</param>
        <param name="name">The name of a named system semaphore object.</param>
        <param name="createdNew">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed. This parameter is passed uninitialized.</param>
        <param name="semaphoreSecurity">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor zur Steuerung des Zugriffs auf ein benanntes Systemsemaphor anzuwenden verhindert, dass anderer Code Kontrolle über das Semaphor erstellt wurde, ein.  
  
 Dieser Konstruktor initialisiert ein <xref:System.Threading.Semaphore> Objekt, das ein benanntes Systemsemaphor darstellt. Sie können mehrere erstellen <xref:System.Threading.Semaphore> benannte Systemsemaphor Objekte, die die gleiche darstellen.  
  
 Wenn das benannte Systemsemaphor nicht vorhanden ist, wird er mit dem angegebenen zugriffssteuerungssicherheit erstellt. Wenn das benannte Semaphor vorhanden ist, wird die angegebene zugriffssteuerungssicherheit ignoriert.  
  
> [!NOTE]
>  Der Aufrufer hat Vollzugriff auf das neu erstellte <xref:System.Threading.Semaphore> Objekt erstellen, selbst wenn `semaphoreSecurity` verweigert oder einige über die Zugriffsrechte für den aktuellen Benutzer zu erteilen. Jedoch wenn der aktuelle Benutzer versucht, erhalten eine andere <xref:System.Threading.Semaphore> Objekt zur Darstellung identisch benannte Semaphor, die entweder einen Konstruktor oder die <xref:System.Threading.Semaphore.OpenExisting%2A> -Methode, Windows-zugriffssteuerungssicherheit angewendet wird.  
  
 Wenn das benannte Systemsemaphor nicht vorhanden ist, wird Sie mit dem anfänglichen Zähler und die maximale Anzahl von angegebenen erstellt `initialCount` und `maximumCount`. Wenn das benannte Systemsemaphor bereits vorhanden ist, `initialCount` und `maximumCount` nicht verwendet, obwohl ungültige Werte immer noch Ausnahmen auslösen. Verwenden der `createdNew` Parameter, um zu bestimmen, ob von diesem Konstruktor die Systemsemaphor erstellt wurde.  
  
 Wenn `initialCount` ist kleiner als `maximumCount`, und `createdNew` ist `true`, der Effekt ist derselbe, als ob der aktuelle Thread aufgerufen hätten <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) Zeiten.  
  
 Bei Angabe von `null` oder eine leere Zeichenfolge für `name`, ein lokales Semaphor erstellt, wie bei einem Aufruf der <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> Überladung des Konstruktors. In diesem Fall `createdNew` ist immer `true`.  
  
 Da benannte Semaphoren im gesamten Betriebssystem sichtbar sind, können sie verwendet werden, um Ressourcen über Prozessgrenzen hinweg koordinieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Verhalten prozessübergreifend ein benanntes Semaphor mit zugriffssteuerungssicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein des ein benanntes Semaphor testen. Wenn das Semaphor nicht vorhanden ist, wird es erstellt, mit einer maximalen Zähler von zwei und zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Semaphor verwenden, aber das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor gewährt. Wenn Sie das kompilierte Beispiel aus zwei Befehlsfenstern ausführen, löst die zweite Kopie eine Zugriffsverletzungsausnahme beim Aufruf von der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> Methode. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> -methodenüberladung, um das Semaphor mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen zu öffnen.  
  
 Nachdem die Berechtigungen geändert werden, wird das Semaphor geöffnet, mit den erforderlichen Benutzerrechten zum eingeben und freigeben. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird die Verwendung der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> is less than 1.  -or-  <paramref name="initialCount" /> is less than 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code, um ein benanntes Systemsemaphor zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the access control security for a named system semaphore.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security for the named system semaphore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Semaphore.GetAccessControl%2A> Methode verwendet die folgende Kombination von Flags, die (mit dem bitweisen OR-Operation kombiniert) zu suchende Berechtigungen: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, und <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Der Benutzer benötigt <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> Rechte für diese Methode aufzurufen, und das Semaphor müssen mit geöffnet wurden <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> Rechte.  
  
 Auf ein lokales Semaphor ist zugriffssteuerungssicherheit spielt keine Rolle. Wenn die <xref:System.Threading.Semaphore> Objekt stellt kein benanntes Systemsemaphor dar, die diese Methode gibt ein <xref:System.Security.AccessControl.SemaphoreSecurity> -Objekt, das für jeden Benutzer alle Rechte gewährt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Verhalten prozessübergreifend ein benanntes Semaphor mit zugriffssteuerungssicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein des ein benanntes Semaphor testen.  
  
 Wenn das Semaphor nicht vorhanden ist, wird es erstellt, mit einer maximalen Zähler von zwei und zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Semaphor verwenden, aber das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor gewährt.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehlsfenstern ausführen, löst die zweite Kopie eine Zugriffsverletzungsausnahme beim Aufruf von der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> Methode. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> -methodenüberladung, um das Semaphor mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen zu öffnen. Die zugriffssteuerungssicherheit für das Systemsemaphor abgerufen wird, mithilfe der <xref:System.Threading.Semaphore.GetAccessControl%2A> Methode.  
  
 Nachdem die Berechtigungen geändert werden, wird das Semaphor geöffnet, mit den erforderlichen Benutzerrechten zum eingeben und freigeben. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird die Verwendung der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.  -or-  The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore and was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</exception>
        <exception cref="T:System.NotSupportedException">Not supported for Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named semaphore, if it already exists.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system semaphore to open.</param>
        <summary>Opens the specified named semaphore, if it already exists.</summary>
        <returns>An object that represents the named system semaphore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Semaphore.OpenExisting%2A> Methode versucht, das angegebene benannte Semaphor öffnen. Wenn das Systemsemaphor nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das Systemsemaphor an. Das Systemsemaphor erstellt, wenn sie nicht bereits vorhanden ist, gehen Sie die <xref:System.Threading.Semaphore.%23ctor%2A> Konstruktoren, die verfügt über eine `name` Parameter.  
  
 Mehrere Aufrufe dieser Methode, die den gleichen Wert für `name` nicht unbedingt zurück, die gleiche <xref:System.Threading.Semaphore> -Objekt, auch wenn die Objekte, die zurückgegeben werden, stellen den gleichen Systemsemaphor Namen.  
  
 Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.Semaphore.OpenExisting%2A> methodenüberladung und Angeben von <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechte, die mit dem bitweisen OR-Operation kombiniert.  
  
 Angeben der <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> Flag ermöglicht, dass einen Thread das Semaphor und Angeben der <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Flag ermöglicht, dass einen Thread aufrufen, die <xref:System.Threading.Semaphore.Release%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Verhalten prozessübergreifend ein benanntes Semaphor mit zugriffssteuerungssicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein des ein benanntes Semaphor testen.  
  
 Wenn das Semaphor nicht vorhanden ist, wird es erstellt, mit einer maximalen Zähler von zwei und zugriffssteuerungssicherheit, die dem aktuellen Benutzer das Recht, verwenden Sie das Semaphor verweigert, aber denen erteilt die Berechtigung zum Lesen und Ändern von Berechtigungen für das Semaphor.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehlsfenstern ausführen, löst die zweite Kopie eine Zugriffsverletzungsausnahme beim Aufruf von der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> -methodenüberladung. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> -methodenüberladung, um das Semaphor mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen zu öffnen.  
  
 Nachdem die Berechtigungen geändert werden, wird das Semaphor mit den erforderlichen Benutzerrechten zum eingeben und freigegeben werden, geöffnet. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird die Verwendung der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code, um ein benanntes Systemsemaphor zu öffnen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system semaphore to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <summary>Opens the specified named semaphore, if it already exists, with the desired security access.</summary>
        <returns>An object that represents the named system semaphore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `rights` Parameter umfasst die <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> Flag, um Threads das Semaphor ermöglichen und die <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> -Kennzeichen an die Threads ermöglichen, rufen Sie die <xref:System.Threading.Semaphore.Release%2A> Methode.  
  
 Die <xref:System.Threading.Semaphore.OpenExisting%2A> Methode versucht, öffnen Sie eine vorhandene benannte Semaphor. Wenn das Systemsemaphor nicht vorhanden ist, löst diese Methode eine Ausnahme aus, statt das Systemsemaphor an. Das Systemsemaphor erstellt, wenn sie nicht bereits vorhanden ist, gehen Sie die <xref:System.Threading.Semaphore.%23ctor%2A> Konstruktoren, die verfügt über eine `name` Parameter.  
  
 Mehrere Aufrufe dieser Methode, die den gleichen Wert für `name` nicht unbedingt zurück, die gleiche <xref:System.Threading.Semaphore> -Objekt, auch wenn die Objekte, die zurückgegeben werden, stellen den gleichen Systemsemaphor Namen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Verhalten prozessübergreifend ein benanntes Semaphor mit zugriffssteuerungssicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein des ein benanntes Semaphor testen.  
  
 Wenn das Semaphor nicht vorhanden ist, wird es erstellt, mit einer maximalen Zähler von zwei und zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Semaphor verwenden, aber das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor gewährt.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehlsfenstern ausführen, löst die zweite Kopie eine Zugriffsverletzungsausnahme beim Aufruf von der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> Methode. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> -methodenüberladung, um das Semaphor mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen zu öffnen.  
  
 Nachdem die Berechtigungen geändert werden, wird das Semaphor mit den erforderlichen Benutzerrechten zum eingeben und freigegeben werden, geöffnet. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird die Verwendung der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the desired security access rights.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code, um ein benanntes Systemsemaphor zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exits the semaphore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exits the semaphore and returns the previous count.</summary>
        <returns>The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden von Threads in der Regel die <xref:System.Threading.WaitHandle.WaitOne%2A> Methode, um in der Regel geben das Semaphor, und sie verwenden eine Überladung dieser Methode um zu beenden.  
  
 Wenn eine <xref:System.Threading.SemaphoreFullException> wird ausgelöst, durch die <xref:System.Threading.Semaphore.Release%2A> -Methode, ein Problem mit dem aufrufenden Thread nicht notwendigerweise. Ein Programmierfehler in einem anderen Thread möglicherweise Thread das Semaphor mehrfach als er vorliegt.  
  
 Wenn die aktuelle <xref:System.Threading.Semaphore> -Objekt stellt ein benanntes Systemsemaphor dar, die der Benutzer benötigt <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechte und das Semaphor müssen geöffnet wurden mit <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechte.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine Semaphore mit einen maximalen Zähler von drei und eine anfängliche Anzahl von 0 (null). Das Beispiel beginnt fünf Threads das Semaphor warten zu blockieren. Der Hauptthread verwendet die <xref:System.Threading.Semaphore.Release%28System.Int32%29> -methodenüberladung, um den Zähler des Semaphors auf seinen Maximalwert, sodass drei Threads in das Semaphor zu erhöhen. Jeder Thread verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode, um eine Sekunde warten, bis zum Simulieren von Arbeit und ruft dann die <xref:System.Threading.Semaphore.Release> -methodenüberladung, um das Semaphor freizugeben.  
  
 Jedes Mal, wenn das Semaphor freigegeben wird, wird die vorherige Anzahl des Semaphors angezeigt. Konsole Nachrichten nachverfolgen Semaphore verwenden. Das simulierte Intervall wird für jeden Thread, um die Ausgabe leichter lesbar zu machen etwas erhöht.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">The semaphore count is already at the maximum value.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred with a named semaphore.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  -or-  The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">The number of times to exit the semaphore.</param>
        <summary>Exits the semaphore a specified number of times and returns the previous count.</summary>
        <returns>The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Thread das Semaphor mehrfach eingegeben hat, kann Überladung dieser Methode die gesamte Semaphorenanzahl mit einem Aufruf wiederhergestellt werden.  
  
 Wenn eine <xref:System.Threading.SemaphoreFullException> wird ausgelöst, durch die <xref:System.Threading.Semaphore.Release%2A> -Methode, ein Problem mit dem aufrufenden Thread nicht notwendigerweise. Ein Programmierfehler in einem anderen Thread möglicherweise Thread das Semaphor mehrfach als er vorliegt.  
  
 Wenn die aktuelle <xref:System.Threading.Semaphore> -Objekt stellt ein benanntes Systemsemaphor dar, die der Benutzer benötigt <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechte und das Semaphor müssen geöffnet wurden mit <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechte.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine Semaphore mit einen maximalen Zähler von drei und eine anfängliche Anzahl von 0 (null). Das Beispiel beginnt fünf Threads das Semaphor warten zu blockieren. Der Hauptthread verwendet die <xref:System.Threading.Semaphore.Release%28System.Int32%29> -methodenüberladung, um den Zähler des Semaphors auf seinen Maximalwert, sodass drei Threads in das Semaphor zu erhöhen. Jeder Thread verwendet die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode, um eine Sekunde warten, bis zum Simulieren von Arbeit und ruft dann die <xref:System.Threading.Semaphore.Release> -methodenüberladung, um das Semaphor freizugeben.  
  
 Jedes Mal, wenn das Semaphor freigegeben wird, wird die vorherige Anzahl des Semaphors angezeigt. Konsole Nachrichten nachverfolgen Semaphore verwenden. Das simulierte Intervall wird für jeden Thread, um die Ausgabe leichter lesbar zu machen etwas erhöht.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="releaseCount" /> is less than 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">The semaphore count is already at the maximum value.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred with a named semaphore.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.  -or-  The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</param>
        <summary>Sets the access control security for a named system semaphore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die zugriffssteuerungssicherheit festlegen, nur auf <xref:System.Threading.Semaphore> Objekte, die benanntes Semaphore darstellen.  
  
 Der Benutzer benötigt <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> Rechte für diese Methode aufzurufen, und das Semaphor müssen mit geöffnet wurden <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> Rechte.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Verhalten prozessübergreifend ein benanntes Semaphor mit zugriffssteuerungssicherheit veranschaulicht. Im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> -methodenüberladung, um das Vorhandensein des ein benanntes Semaphor testen.  
  
 Wenn das Semaphor nicht vorhanden ist, wird es erstellt, mit einer maximalen Zähler von zwei und zugriffssteuerungssicherheit, die verweigert des aktuellen Benutzers des rechts, das Semaphor verwenden, aber das Recht zum Lesen und Ändern von Berechtigungen für das Semaphor gewährt.  
  
 Wenn Sie das kompilierte Beispiel aus zwei Befehlsfenstern ausführen, löst die zweite Kopie eine Zugriffsverletzungsausnahme beim Aufruf von der <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> Methode. Die Ausnahme abgefangen wird, und im Beispiel wird die <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> -methodenüberladung, um das Semaphor mit den Berechtigungen zum Lesen und ändern Sie die Berechtigungen zu öffnen.  
  
 Nach dem Ändern der Berechtigungen mithilfe der <xref:System.Threading.Semaphore.SetAccessControl%2A> mit den erforderlichen Benutzerrechten zum eingeben und release-Methode, das Semaphor geöffnet wird. Wenn Sie das kompilierte Beispiel in einem dritten Befehlsfenster ausführen, wird die Verwendung der neuen Berechtigungen ausgeführt.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="semaphoreSecurity" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.  -or-  The semaphore was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</exception>
        <exception cref="T:System.NotSupportedException">The current <see cref="T:System.Threading.Semaphore" /> object does not represent a named system semaphore.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system semaphore to open.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das benannte Semaphor nicht vorhanden ist, wird es von dieser Methode nicht erstellt. Das Systemsemaphor erstellt, wenn sie nicht bereits vorhanden ist, gehen Sie die <xref:System.Threading.Semaphore.%23ctor%2A> Konstruktoren, die verfügt über eine `name` Parameter.  
  
 Wenn Sie unsicher sind, ob ein benanntes Semaphor vorhanden ist, verwenden Sie die Überladung dieser Methode anstelle des dem <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> methodenüberladung, die eine Ausnahme auslöst, wenn das Semaphor nicht vorhanden ist.  
  
 Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Threading.Semaphore.TryOpenExisting%2A> methodenüberladung und Angeben von <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> und <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Rechte, die mit dem bitweisen OR-Operation kombiniert. Angeben der <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> Flag ermöglicht, dass einen Thread das Semaphor und Angeben der <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> Flag ermöglicht, dass einen Thread aufrufen, die <xref:System.Threading.Semaphore.Release%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the security access required to use it.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system semaphore to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das benannte Semaphor nicht vorhanden ist, wird es von dieser Methode nicht erstellt. Das Systemsemaphor erstellt, wenn sie nicht bereits vorhanden ist, gehen Sie die <xref:System.Threading.Semaphore.%23ctor%2A> Konstruktoren, die verfügt über eine `name` Parameter.  
  
 Wenn Sie unsicher sind, ob ein benanntes Semaphor vorhanden ist, verwenden Sie die Überladung dieser Methode anstelle des dem <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> methodenüberladung, die eine Ausnahme auslöst, wenn das Semaphor nicht vorhanden ist.  
  
 Die `rights` Parameter umfasst die <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> Flag, um Threads das Semaphor ermöglichen und die <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> -Kennzeichen an die Threads ermöglichen, rufen Sie die <xref:System.Threading.Semaphore.Release%2A> Methode.  
  
 Mehrere Aufrufe dieser Methode, die den gleichen Wert für `name` nicht unbedingt zurück, die gleiche <xref:System.Threading.Semaphore> -Objekt, auch wenn die Objekte, die zurückgegeben werden, stellen den gleichen Systemsemaphor Namen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the security access required to use it.</exception>
      </Docs>
    </Member>
  </Members>
</Type>