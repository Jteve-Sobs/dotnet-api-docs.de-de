<Type Name="Interlocked" FullName="System.Threading.Interlocked">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d6ce8b1f7570e481cceac6397e202ec9df286b51" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70362978" /></Metadata><TypeSignature Language="C#" Value="public static class Interlocked" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Interlocked extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Interlocked" />
  <TypeSignature Language="VB.NET" Value="Public Class Interlocked" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interlocked abstract sealed" />
  <TypeSignature Language="F#" Value="type Interlocked = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0">
      <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="add9a-101">Stellt atomare Operationen für Variablen bereit, die von mehreren Threads gemeinsam genutzt werden.</span><span class="sxs-lookup"><span data-stu-id="add9a-101">Provides atomic operations for variables that are shared by multiple threads.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="add9a-102">Die Methoden dieser Klasse helfen beim Schutz vor Fehlern, die auftreten können, wenn der Planer einen Kontext wechselt, während ein Thread eine Variable aktualisiert, auf die von anderen Threads zugegriffen werden kann, oder wenn zwei Threads gleichzeitig auf separaten Prozessoren ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="add9a-102">The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors.</span></span> <span data-ttu-id="add9a-103">Die Member dieser Klasse lösen keine Ausnahmen aus.</span><span class="sxs-lookup"><span data-stu-id="add9a-103">The members of this class do not throw exceptions.</span></span>  
  
 <span data-ttu-id="add9a-104">Die <xref:System.Threading.Interlocked.Increment%2A> - <xref:System.Threading.Interlocked.Decrement%2A> Methode und die-Methode erhöhen oder verringern eine Variable und speichern den resultierenden Wert in einem einzelnen Vorgang.</span><span class="sxs-lookup"><span data-stu-id="add9a-104">The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and store the resulting value in a single operation.</span></span> <span data-ttu-id="add9a-105">Auf den meisten Computern ist das Inkrementieren einer Variablen kein atomarer Vorgang, bei dem die folgenden Schritte erforderlich sind:</span><span class="sxs-lookup"><span data-stu-id="add9a-105">On most computers, incrementing a variable is not an atomic operation, requiring the following steps:</span></span>  
  
1.  <span data-ttu-id="add9a-106">Lädt einen Wert aus einer Instanzvariablen in ein Register.</span><span class="sxs-lookup"><span data-stu-id="add9a-106">Load a value from an instance variable into a register.</span></span>  
  
2.  <span data-ttu-id="add9a-107">Erhöhen oder verringern Sie den Wert.</span><span class="sxs-lookup"><span data-stu-id="add9a-107">Increment or decrement the value.</span></span>  
  
3.  <span data-ttu-id="add9a-108">Speichern Sie den Wert in der Instanzvariablen.</span><span class="sxs-lookup"><span data-stu-id="add9a-108">Store the value in the instance variable.</span></span>  
  
 <span data-ttu-id="add9a-109">Wenn Sie und <xref:System.Threading.Interlocked.Decrement%2A>nicht verwenden <xref:System.Threading.Interlocked.Increment%2A> , kann ein Thread nach dem Ausführen der ersten beiden Schritte vorzeitig entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="add9a-109">If you do not use <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A>, a thread can be preempted after executing the first two steps.</span></span> <span data-ttu-id="add9a-110">Ein anderer Thread kann dann alle drei Schritte ausführen.</span><span class="sxs-lookup"><span data-stu-id="add9a-110">Another thread can then execute all three steps.</span></span> <span data-ttu-id="add9a-111">Wenn der erste Thread die Ausführung fortsetzt, wird der Wert in der Instanzvariablen überschrieben, und die Auswirkung des Inkrement oder Dekrement, der durch den zweiten Thread durchgeführt wird, geht verloren.</span><span class="sxs-lookup"><span data-stu-id="add9a-111">When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.</span></span>  

 <span data-ttu-id="add9a-112">Die <xref:System.Threading.Interlocked.Add%2A> -Methode fügt einen ganzzahligen Wert atomisch zu einer ganzzahligen Variablen hinzu und gibt den neuen Wert der Variablen zurück.</span><span class="sxs-lookup"><span data-stu-id="add9a-112">The <xref:System.Threading.Interlocked.Add%2A> method atomically adds an integer value to an integer variable and returns the new value of the variable.</span></span>  
  
 <span data-ttu-id="add9a-113">Die <xref:System.Threading.Interlocked.Exchange%2A> -Methode tauscht den Wert der angegebenen Variablen atomisch aus.</span><span class="sxs-lookup"><span data-stu-id="add9a-113">The <xref:System.Threading.Interlocked.Exchange%2A> method atomically exchanges the values of the specified variables.</span></span> <span data-ttu-id="add9a-114">Die <xref:System.Threading.Interlocked.CompareExchange%2A> -Methode kombiniert zwei Vorgänge: Vergleichen von zwei Werten und Speichern eines dritten Werts in einer der Variablen, basierend auf dem Ergebnis des Vergleichs.</span><span class="sxs-lookup"><span data-stu-id="add9a-114">The <xref:System.Threading.Interlocked.CompareExchange%2A> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison.</span></span> <span data-ttu-id="add9a-115">Die Vergleichs-und Exchange-Vorgänge werden als atomarer Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="add9a-115">The compare and exchange operations are performed as an atomic operation.</span></span>  

 <span data-ttu-id="add9a-116">Stellen Sie sicher, dass jeder Schreib-oder Lesezugriff auf eine freigegebene Variable atomarisch ist.</span><span class="sxs-lookup"><span data-stu-id="add9a-116">Ensure that any write or read access to a shared variable is atomic.</span></span> <span data-ttu-id="add9a-117">Andernfalls sind die Daten möglicherweise beschädigt, oder der geladene Wert ist falsch.</span><span class="sxs-lookup"><span data-stu-id="add9a-117">Otherwise, the data might be corrupted or the loaded value might be incorrect.</span></span>    
   
  
## Examples  
 <span data-ttu-id="add9a-118">Das folgende Codebeispiel zeigt einen Thread sicheren Mechanismus zum Sperren von Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="add9a-118">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="add9a-119">Dieser Typ ist threadsicher.</span><span class="sxs-lookup"><span data-stu-id="add9a-119">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-120">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-120">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-121">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-121">Overview of synchronization primitives</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="add9a-122">Fügt in einer atomaren Operation zwei Ganzzahlen hinzu und ersetzt die erste Ganzzahl durch die Summe.</span><span class="sxs-lookup"><span data-stu-id="add9a-122">Adds two integers and replaces the first integer with the sum, as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Add(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Add(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Add : int * int -&gt; int" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="add9a-123">Eine Variable, die den ersten Wert enthält, der hinzugefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-123">A variable containing the first value to be added.</span></span> <span data-ttu-id="add9a-124">Die Summe der beiden Werte wird in <paramref name="location1" /> gespeichert.</span><span class="sxs-lookup"><span data-stu-id="add9a-124">The sum of the two values is stored in <paramref name="location1" />.</span></span></param>
        <param name="value"><span data-ttu-id="add9a-125">Der Wert, der der Ganzzahl in <paramref name="location1" /> hinzugefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-125">The value to be added to the integer at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="add9a-126">Fügt in einer atomaren Operation zwei 32-Bit-Ganzzahlen hinzu und ersetzt die erste Ganzzahl durch die Summe.</span><span class="sxs-lookup"><span data-stu-id="add9a-126">Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="add9a-127">Der unter <paramref name="location1" /> gespeicherte neue Wert.</span><span class="sxs-lookup"><span data-stu-id="add9a-127">The new value stored at <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="add9a-128">Diese Methode behandelt eine Überlauf Bedingung durch Umbrüchen: Wenn der Wert `location1` bei <xref:System.Int32.MaxValue?displayProperty=nameWithType> ist `value` und 1 ist, ist <xref:System.Int32.MinValue?displayProperty=nameWithType>das Ergebnis. `value` wenn 2 ist, ist das Ergebnis<xref:System.Int32.MinValue?displayProperty=nameWithType> (+ 1) usw.</span><span class="sxs-lookup"><span data-stu-id="add9a-128">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int32.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int32.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="add9a-129">Es werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="add9a-129">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="add9a-130">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-130">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-131">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-131">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-132">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-132">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Add(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Add(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Add : int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="add9a-133">Eine Variable, die den ersten Wert enthält, der hinzugefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-133">A variable containing the first value to be added.</span></span> <span data-ttu-id="add9a-134">Die Summe der beiden Werte wird in <paramref name="location1" /> gespeichert.</span><span class="sxs-lookup"><span data-stu-id="add9a-134">The sum of the two values is stored in <paramref name="location1" />.</span></span></param>
        <param name="value"><span data-ttu-id="add9a-135">Der Wert, der der Ganzzahl in <paramref name="location1" /> hinzugefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-135">The value to be added to the integer at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="add9a-136">Fügt in einer atomaren Operation zwei 64-Bit-Ganzzahlen hinzu und ersetzt die erste Ganzzahl durch die Summe.</span><span class="sxs-lookup"><span data-stu-id="add9a-136">Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="add9a-137">Der unter <paramref name="location1" /> gespeicherte neue Wert.</span><span class="sxs-lookup"><span data-stu-id="add9a-137">The new value stored at <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="add9a-138">Diese Methode behandelt eine Überlauf Bedingung durch Umbrüchen: Wenn der Wert `location1` bei <xref:System.Int64.MaxValue?displayProperty=nameWithType> ist `value` und 1 ist, ist <xref:System.Int64.MinValue?displayProperty=nameWithType>das Ergebnis. `value` wenn 2 ist, ist das Ergebnis<xref:System.Int64.MinValue?displayProperty=nameWithType> (+ 1) usw.</span><span class="sxs-lookup"><span data-stu-id="add9a-138">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int64.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int64.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="add9a-139">Es werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="add9a-139">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="add9a-140">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-140">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-141">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-141">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-142">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-142">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareExchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="add9a-143">Vergleicht zwei Werte hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</span><span class="sxs-lookup"><span data-stu-id="add9a-143">Compares two values for equality and, if they are equal, replaces the first value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CompareExchange(float64&amp; location1, float64 value, float64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Double, value As Double, comparand As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double CompareExchange(double % location1, double value, double comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : double * double * double -&gt; double" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="System.Double" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="add9a-144">Das Ziel, dessen Wert mit <paramref name="comparand" /> verglichen und möglicherweise ersetzt wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-144">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="add9a-145">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</span><span class="sxs-lookup"><span data-stu-id="add9a-145">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="add9a-146">Der Wert, der mit dem Wert bei <paramref name="location1" /> verglichen wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-146">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="add9a-147">Vergleicht zwei Gleitkommazahlen mit doppelter Genauigkeit hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</span><span class="sxs-lookup"><span data-stu-id="add9a-147">Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="add9a-148">Der ursprüngliche Wert in <paramref name="location1" />.</span><span class="sxs-lookup"><span data-stu-id="add9a-148">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="add9a-149">Wenn `comparand` und der Wert in `location1` gleich sind, `value` wird in `location1`gespeichert.</span><span class="sxs-lookup"><span data-stu-id="add9a-149">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="add9a-150">Andernfalls wird kein Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="add9a-150">Otherwise, no operation is performed.</span></span> <span data-ttu-id="add9a-151">Die Vergleichs-und Exchange-Vorgänge werden als atomarer Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="add9a-151">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="add9a-152">Der Rückgabewert von <xref:System.Threading.Interlocked.CompareExchange%2A> ist der ursprüngliche Wert in `location1`, unabhängig davon, ob der Exchange-Vorgang stattfindet.</span><span class="sxs-lookup"><span data-stu-id="add9a-152">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="add9a-153">Im folgenden Codebeispiel wird eine Thread sichere Methode veranschaulicht, die eine laufende Summe von <xref:System.Double> Werten akkumuliert.</span><span class="sxs-lookup"><span data-stu-id="add9a-153">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Double> values.</span></span> <span data-ttu-id="add9a-154">Zwei Threads fügen mithilfe der Thread <xref:System.Double> sicheren Methode und der normalen Addition eine Reihe von Werten hinzu, und nach Abschluss der Threads werden die Gesamtwerte verglichen.</span><span class="sxs-lookup"><span data-stu-id="add9a-154">Two threads add a series of <xref:System.Double> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="add9a-155">Auf einem Dual Prozessor Computer gibt es einen signifikanten Unterschied in den Gesamtwerten.</span><span class="sxs-lookup"><span data-stu-id="add9a-155">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="add9a-156">In der Thread sicheren Methode wird der Anfangswert der laufenden Summe gespeichert, und anschließend <xref:System.Threading.Interlocked.CompareExchange%2A> wird die-Methode verwendet, um die neu berechnete Summe mit der alten Summe auszutauschen.</span><span class="sxs-lookup"><span data-stu-id="add9a-156">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="add9a-157">Wenn der Rückgabewert nicht gleich dem gespeicherten Wert der laufenden Summe ist, hat ein anderer Thread die Summe in der Zwischenzeit aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="add9a-157">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="add9a-158">In diesem Fall muss der Versuch, die laufende Summe zu aktualisieren, wiederholt werden.</span><span class="sxs-lookup"><span data-stu-id="add9a-158">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="add9a-159">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-159">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-160">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-160">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-161">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-161">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareExchange(int32&amp; location1, int32 value, int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Integer, value As Integer, comparand As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareExchange(int % location1, int value, int comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : int * int * int -&gt; int" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="add9a-162">Das Ziel, dessen Wert mit <paramref name="comparand" /> verglichen und möglicherweise ersetzt wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-162">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="add9a-163">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</span><span class="sxs-lookup"><span data-stu-id="add9a-163">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="add9a-164">Der Wert, der mit dem Wert bei <paramref name="location1" /> verglichen wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-164">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="add9a-165">Vergleicht zwei 32-Bit-Ganzzahlen mit Vorzeichen hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</span><span class="sxs-lookup"><span data-stu-id="add9a-165">Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="add9a-166">Der ursprüngliche Wert in <paramref name="location1" />.</span><span class="sxs-lookup"><span data-stu-id="add9a-166">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="add9a-167">Wenn `comparand` und der Wert in `location1` gleich sind, `value` wird in `location1`gespeichert.</span><span class="sxs-lookup"><span data-stu-id="add9a-167">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="add9a-168">Andernfalls wird kein Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="add9a-168">Otherwise, no operation is performed.</span></span> <span data-ttu-id="add9a-169">Die Vergleichs-und Exchange-Vorgänge werden als atomarer Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="add9a-169">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="add9a-170">Der Rückgabewert von <xref:System.Threading.Interlocked.CompareExchange%2A> ist der ursprüngliche Wert in `location1`, unabhängig davon, ob der Exchange-Vorgang stattfindet.</span><span class="sxs-lookup"><span data-stu-id="add9a-170">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="add9a-171">Im folgenden Codebeispiel wird eine Thread sichere Methode veranschaulicht, die eine laufende Summe akkumuliert.</span><span class="sxs-lookup"><span data-stu-id="add9a-171">The following code example demonstrates a thread-safe method that accumulates a running total.</span></span> <span data-ttu-id="add9a-172">Der Anfangswert der laufenden Summe wird gespeichert, und anschließend <xref:System.Threading.Interlocked.CompareExchange%2A> wird die-Methode verwendet, um die neu berechnete Summe mit der alten Summe auszutauschen.</span><span class="sxs-lookup"><span data-stu-id="add9a-172">The initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="add9a-173">Wenn der Rückgabewert nicht gleich dem gespeicherten Wert der laufenden Summe ist, hat ein anderer Thread die Summe in der Zwischenzeit aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="add9a-173">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="add9a-174">In diesem Fall muss der Versuch, die laufende Summe zu aktualisieren, wiederholt werden.</span><span class="sxs-lookup"><span data-stu-id="add9a-174">In that case, the attempt to update the running total must be repeated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="add9a-175">Die <xref:System.Threading.Interlocked.Add%2A> in Version 2,0 des .NET Framework eingeführte-Methode bietet eine komfortablere Möglichkeit zum sammeln Thread sicherer laufender Summen für ganze Zahlen.</span><span class="sxs-lookup"><span data-stu-id="add9a-175">The <xref:System.Threading.Interlocked.Add%2A> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="add9a-176">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-176">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-177">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-177">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-178">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-178">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CompareExchange(int64&amp; location1, int64 value, int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Long, value As Long, comparand As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long CompareExchange(long % location1, long value, long comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : int64 * int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="System.Int64" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="add9a-179">Das Ziel, dessen Wert mit <paramref name="comparand" /> verglichen und möglicherweise ersetzt wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-179">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="add9a-180">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</span><span class="sxs-lookup"><span data-stu-id="add9a-180">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="add9a-181">Der Wert, der mit dem Wert bei <paramref name="location1" /> verglichen wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-181">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="add9a-182">Vergleicht zwei 64-Bit-Ganzzahlen mit Vorzeichen hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</span><span class="sxs-lookup"><span data-stu-id="add9a-182">Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="add9a-183">Der ursprüngliche Wert in <paramref name="location1" />.</span><span class="sxs-lookup"><span data-stu-id="add9a-183">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="add9a-184">Wenn `comparand` und der Wert in `location1` gleich sind, `value` wird in `location1`gespeichert.</span><span class="sxs-lookup"><span data-stu-id="add9a-184">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="add9a-185">Andernfalls wird kein Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="add9a-185">Otherwise, no operation is performed.</span></span> <span data-ttu-id="add9a-186">Die Vergleichs-und Exchange-Vorgänge werden als atomarer Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="add9a-186">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="add9a-187">Der Rückgabewert von <xref:System.Threading.Interlocked.CompareExchange%2A> ist der ursprüngliche Wert in `location1`, unabhängig davon, ob der Exchange-Vorgang stattfindet.</span><span class="sxs-lookup"><span data-stu-id="add9a-187">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="add9a-188">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-188">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-189">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-189">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-190">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-190">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CompareExchange(native int&amp; location1, native int value, native int comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As IntPtr, value As IntPtr, comparand As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CompareExchange(IntPtr % location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : nativeint * nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="System.IntPtr" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="add9a-191">Das Ziel <see cref="T:System.IntPtr" />, dessen Wert mit dem Wert von <paramref name="comparand" /> verglichen und möglicherweise durch <paramref name="value" /> ersetzt wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-191">The destination <see cref="T:System.IntPtr" />, whose value is compared with the value of <paramref name="comparand" /> and possibly replaced by <paramref name="value" />.</span></span></param>
        <param name="value"><span data-ttu-id="add9a-192">Der <see cref="T:System.IntPtr" />, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</span><span class="sxs-lookup"><span data-stu-id="add9a-192">The <see cref="T:System.IntPtr" /> that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="add9a-193">Der <see cref="T:System.IntPtr" />, der mit dem Wert in <paramref name="location1" /> verglichen wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-193">The <see cref="T:System.IntPtr" /> that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="add9a-194">Vergleicht zwei plattformspezifische Handles oder Zeiger hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten.</span><span class="sxs-lookup"><span data-stu-id="add9a-194">Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</span></span></summary>
        <returns><span data-ttu-id="add9a-195">Der ursprüngliche Wert in <paramref name="location1" />.</span><span class="sxs-lookup"><span data-stu-id="add9a-195">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="add9a-196">Wenn `comparand` und der Wert in `location1` gleich sind, `value` wird in `location1`gespeichert.</span><span class="sxs-lookup"><span data-stu-id="add9a-196">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="add9a-197">Andernfalls wird kein Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="add9a-197">Otherwise, no operation is performed.</span></span> <span data-ttu-id="add9a-198">Die Vergleichs-und Exchange-Vorgänge werden als atomarer Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="add9a-198">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="add9a-199">Der Rückgabewert dieser Methode ist der ursprüngliche Wert in `location1`, unabhängig davon, ob der Exchange-Vorgang stattfindet.</span><span class="sxs-lookup"><span data-stu-id="add9a-199">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="add9a-200"><xref:System.IntPtr>ist ein plattformspezifischer Typ.</span><span class="sxs-lookup"><span data-stu-id="add9a-200"><xref:System.IntPtr> is a platform-specific type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="add9a-201">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-201">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-202">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-202">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-203">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-203">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CompareExchange(object&amp; location1, object value, object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Object, value As Object, comparand As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CompareExchange(System::Object ^ % location1, System::Object ^ value, System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : obj * obj * obj -&gt; obj" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="add9a-204">Das Zielobjekt, das mit <paramref name="comparand" /> nach Verweis verglichen und möglicherweise ersetzt wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-204">The destination object that is compared by reference with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="add9a-205">Das Objekt, das das Zielobjekt ersetzt, wenn beim Verweisevergleich Gleichheit festgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-205">The object that replaces the destination object if the reference comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="add9a-206">Das Objekt, das nach Verweis mit dem Objekt bei <paramref name="location1" /> verglichen wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-206">The object that is compared by reference to the object at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="add9a-207">Vergleicht zwei Objekte hinsichtlich ihrer Verweisgleichheit und ersetzt bei vorliegender Gleichheit das erste Objekt.</span><span class="sxs-lookup"><span data-stu-id="add9a-207">Compares two objects for reference equality and, if they are equal, replaces the first object.</span></span></summary>
        <returns><span data-ttu-id="add9a-208">Der ursprüngliche Wert in <paramref name="location1" />.</span><span class="sxs-lookup"><span data-stu-id="add9a-208">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> <span data-ttu-id="add9a-209">Ab .NET Framework 2.0 bietet die Überladung der <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29>-Methoden eine typsichere Alternative für Verweistypen.</span><span class="sxs-lookup"><span data-stu-id="add9a-209">Beginning with .NET Framework 2.0, the <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span> <span data-ttu-id="add9a-210">Es wird empfohlen, dass Sie diese anstelle dieser Überladung aufrufen.</span><span class="sxs-lookup"><span data-stu-id="add9a-210">We recommend that you call it instead of this overload.</span></span>

<span data-ttu-id="add9a-211">Wenn `comparand` und das-Objekt `location1` in `value` gleich Verweis sind, wird in `location1`gespeichert.</span><span class="sxs-lookup"><span data-stu-id="add9a-211">If `comparand` and the object in `location1` are equal by reference, then `value` is stored in `location1`.</span></span> <span data-ttu-id="add9a-212">Andernfalls wird kein Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="add9a-212">Otherwise, no operation is performed.</span></span> <span data-ttu-id="add9a-213">Die Vergleichs-und Exchange-Vorgänge werden als atomarer Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="add9a-213">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="add9a-214">Der Rückgabewert von <xref:System.Threading.Interlocked.CompareExchange%2A> ist der ursprüngliche Wert in `location1`, unabhängig davon, ob der Exchange-Vorgang stattfindet.</span><span class="sxs-lookup"><span data-stu-id="add9a-214">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  

> [!NOTE]
>  <span data-ttu-id="add9a-215">Die Objekte werden auf Verweis Übereinstimmung anstatt auf Wert Gleichheit verglichen.</span><span class="sxs-lookup"><span data-stu-id="add9a-215">The objects are compared for reference equality rather than value equality.</span></span> <span data-ttu-id="add9a-216">Folglich scheinen zwei einfügende Instanzen desselben Werttyps (z. b. die ganze Zahl 3) immer ungleich zu sein, und es wird kein Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="add9a-216">As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal and no operation is performed.</span></span> <span data-ttu-id="add9a-217">Verwenden Sie diese Überladung nicht mit Werttypen.</span><span class="sxs-lookup"><span data-stu-id="add9a-217">Do not use this overload with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="add9a-218">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-218">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-219">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-219">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-220">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-220">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CompareExchange(float32&amp; location1, float32 value, float32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Single, value As Single, comparand As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CompareExchange(float % location1, float value, float comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : single * single * single -&gt; single" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="add9a-221">Das Ziel, dessen Wert mit <paramref name="comparand" /> verglichen und möglicherweise ersetzt wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-221">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="add9a-222">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</span><span class="sxs-lookup"><span data-stu-id="add9a-222">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="add9a-223">Der Wert, der mit dem Wert bei <paramref name="location1" /> verglichen wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-223">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="add9a-224">Vergleicht zwei Gleitkommazahlen mit einfacher Genauigkeit hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</span><span class="sxs-lookup"><span data-stu-id="add9a-224">Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="add9a-225">Der ursprüngliche Wert in <paramref name="location1" />.</span><span class="sxs-lookup"><span data-stu-id="add9a-225">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="add9a-226">Wenn `comparand` und der Wert in `location1` gleich sind, `value` wird in `location1`gespeichert.</span><span class="sxs-lookup"><span data-stu-id="add9a-226">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="add9a-227">Andernfalls wird kein Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="add9a-227">Otherwise, no operation is performed.</span></span> <span data-ttu-id="add9a-228">Die Vergleichs-und Exchange-Vorgänge werden als atomarer Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="add9a-228">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="add9a-229">Der Rückgabewert von <xref:System.Threading.Interlocked.CompareExchange%2A> ist der ursprüngliche Wert in `location1`, unabhängig davon, ob der Exchange-Vorgang stattfindet.</span><span class="sxs-lookup"><span data-stu-id="add9a-229">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="add9a-230">Im folgenden Codebeispiel wird eine Thread sichere Methode veranschaulicht, die eine laufende Summe von <xref:System.Single> Werten akkumuliert.</span><span class="sxs-lookup"><span data-stu-id="add9a-230">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Single> values.</span></span> <span data-ttu-id="add9a-231">Zwei Threads fügen mithilfe der Thread <xref:System.Single> sicheren Methode und der normalen Addition eine Reihe von Werten hinzu, und nach Abschluss der Threads werden die Gesamtwerte verglichen.</span><span class="sxs-lookup"><span data-stu-id="add9a-231">Two threads add a series of <xref:System.Single> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="add9a-232">Auf einem Dual Prozessor Computer gibt es einen signifikanten Unterschied in den Gesamtwerten.</span><span class="sxs-lookup"><span data-stu-id="add9a-232">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="add9a-233">In der Thread sicheren Methode wird der Anfangswert der laufenden Summe gespeichert, und anschließend <xref:System.Threading.Interlocked.CompareExchange%2A> wird die-Methode verwendet, um die neu berechnete Summe mit der alten Summe auszutauschen.</span><span class="sxs-lookup"><span data-stu-id="add9a-233">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="add9a-234">Wenn der Rückgabewert nicht gleich dem gespeicherten Wert der laufenden Summe ist, hat ein anderer Thread die Summe in der Zwischenzeit aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="add9a-234">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="add9a-235">In diesem Fall muss der Versuch, die laufende Summe zu aktualisieren, wiederholt werden.</span><span class="sxs-lookup"><span data-stu-id="add9a-235">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="add9a-236">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-236">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-237">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-237">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-238">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-238">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CompareExchange&lt;class T&gt;(!!T&amp; location1, !!T value, !!T comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange(Of T As Class) (ByRef location1 As T, value As T, comparand As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T CompareExchange(T % location1, T value, T comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : 'T * 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="T" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="add9a-239">Der Typ, der für <paramref name="location1" />, <paramref name="value" /> und <paramref name="comparand" /> verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-239">The type to be used for <paramref name="location1" />, <paramref name="value" />, and <paramref name="comparand" />.</span></span> <span data-ttu-id="add9a-240">Dieser Typ muss ein Referenztyp sein.</span><span class="sxs-lookup"><span data-stu-id="add9a-240">This type must be a reference type.</span></span></typeparam>
        <param name="location1"><span data-ttu-id="add9a-241">Das Ziel, dessen Wert mit <paramref name="comparand" /> nach Verweis verglichen und möglicherweise ersetzt wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-241">The destination, whose value is compared by reference with <paramref name="comparand" /> and possibly replaced.</span></span> <span data-ttu-id="add9a-242">Dies ist ein Verweisparameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="add9a-242">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span></span></param>
        <param name="value"><span data-ttu-id="add9a-243">Der Wert, der den Zielwert ersetzt, wenn der Vergleich nach Verweis Gleichheit ergibt.</span><span class="sxs-lookup"><span data-stu-id="add9a-243">The value that replaces the destination value if the comparison by reference results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="add9a-244">Der Wert, der nach Verweis mit dem Wert bei <paramref name="location1" /> verglichen wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-244">The value that is compared by reference to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="add9a-245">Vergleicht zwei Instanzen des angegebenen Referenztyps <paramref name="T" /> hinsichtlich ihrer Verweisgleichheit und ersetzt bei vorliegender Gleichheit den ersten.</span><span class="sxs-lookup"><span data-stu-id="add9a-245">Compares two instances of the specified reference type <paramref name="T" /> for reference equality and, if they are equal, replaces the first one.</span></span></summary>
        <returns><span data-ttu-id="add9a-246">Der ursprüngliche Wert in <paramref name="location1" />.</span><span class="sxs-lookup"><span data-stu-id="add9a-246">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="add9a-247">Wenn `comparand` und der Wert in `location1` `value` gleich der Verweis sind, wird in `location1`gespeichert.</span><span class="sxs-lookup"><span data-stu-id="add9a-247">If `comparand` and the value in `location1` are equal by reference, then `value` is stored in `location1`.</span></span> <span data-ttu-id="add9a-248">Andernfalls wird kein Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="add9a-248">Otherwise, no operation is performed.</span></span> <span data-ttu-id="add9a-249">Der Vergleich und der Austausch werden als atomarer Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="add9a-249">The comparison and the exchange are performed as an atomic operation.</span></span> <span data-ttu-id="add9a-250">Der Rückgabewert dieser Methode ist der ursprüngliche Wert in `location1`, unabhängig davon, ob der Exchange-Vorgang stattfindet.</span><span class="sxs-lookup"><span data-stu-id="add9a-250">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 <span data-ttu-id="add9a-251">Diese Methode unterstützt nur Verweis Typen.</span><span class="sxs-lookup"><span data-stu-id="add9a-251">This method only supports reference types.</span></span> <span data-ttu-id="add9a-252">Es <xref:System.Threading.Interlocked.CompareExchange%2A> gibt über Ladungen der-Methode für die <xref:System.Int64>Werttypen <xref:System.Single> <xref:System.Int32> <xref:System.IntPtr>,,, und <xref:System.Double>, aber es gibt keine Unterstützung für andere Werttypen.</span><span class="sxs-lookup"><span data-stu-id="add9a-252">There are overloads of the <xref:System.Threading.Interlocked.CompareExchange%2A> method for the value types <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double>, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="add9a-253">Diese Methoden Überladung ist der <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> -Methoden Überladung vorzuziehen, da Letztere erfordert, dass der Zugriff auf das Zielobjekt spät gebunden ist.</span><span class="sxs-lookup"><span data-stu-id="add9a-253">This method overload is preferable to the <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> method overload, because the latter requires the destination object to be accessed late-bound.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="add9a-254">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-254">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="add9a-255">Dekrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</span><span class="sxs-lookup"><span data-stu-id="add9a-255">Decrements a specified variable and stores the result, as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Decrement(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Decrement(int % location);" />
      <MemberSignature Language="F#" Value="static member Decrement : int -&gt; int" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="add9a-256">Die Variable, deren Wert dekrementiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-256">The variable whose value is to be decremented.</span></span></param>
        <summary><span data-ttu-id="add9a-257">Dekrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</span><span class="sxs-lookup"><span data-stu-id="add9a-257">Decrements a specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="add9a-258">Der dekrementierte Wert.</span><span class="sxs-lookup"><span data-stu-id="add9a-258">The decremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="add9a-259">Diese Methode behandelt eine Überlauf Bedingung, indem Sie Folgendes umwickelt: Wenn `location` , = -1 =<xref:System.Int32.MaxValue?displayProperty=nameWithType>. <xref:System.Int32.MinValue?displayProperty=nameWithType> `location`</span><span class="sxs-lookup"><span data-stu-id="add9a-259">This method handles an overflow condition by wrapping: If `location` = <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="add9a-260">Es werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="add9a-260">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="add9a-261">Im folgenden Beispiel wird bestimmt, wie viele Zufallszahlen zwischen 0 und 1.000 erforderlich sind, um 1.000 Zufallszahlen mit einem Mittelpunkt Wert zu generieren.</span><span class="sxs-lookup"><span data-stu-id="add9a-261">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="add9a-262">Um die Anzahl der Mittelpunkt Werte nachzuverfolgen, wird eine Variable `midpointCount`,, auf 1.000 festgelegt und dekrementiert, wenn der Zufallszahlengenerator einen Mittelpunkt Wert zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="add9a-262">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value.</span></span> <span data-ttu-id="add9a-263">Da drei Threads die Zufallszahlen generieren, wird <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> die-Methode aufgerufen, um sicherzustellen, dass `midpointCount` mehrere Threads nicht gleichzeitig aktualisiert werden.</span><span class="sxs-lookup"><span data-stu-id="add9a-263">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="add9a-264">Beachten Sie, dass eine Sperre auch verwendet wird, um den Zufallszahlengenerator zu schützen <xref:System.Threading.CountdownEvent> , und dass ein-Objekt verwendet `Main` wird, um sicherzustellen, dass die-Methode die Ausführung vor den drei Threads nicht beendet.</span><span class="sxs-lookup"><span data-stu-id="add9a-264">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Decrement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  
  
 <span data-ttu-id="add9a-265">Das folgende Beispiel ähnelt dem vorherigen, mit der Ausnahme, dass es die <xref:System.Threading.Tasks.Task> -Klasse anstelle einer Thread Prozedur verwendet, um 50.000 zufällige Mittelpunkt-Ganzzahlen zu generieren.</span><span class="sxs-lookup"><span data-stu-id="add9a-265">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="add9a-266">In diesem Beispiel wird durch einen Lambda-Ausdruck `GenerateNumbers` die Thread Prozedur ersetzt, und durch den <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> -Aufrufvorgang entfällt die <xref:System.Threading.CountdownEvent> Notwendigkeit des-Objekts.</span><span class="sxs-lookup"><span data-stu-id="add9a-266">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]
 [!code-vb[System.Threading.Interlocked.Decrement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="add9a-267">Die Adresse von <paramref name="location" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-267">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-268">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-268">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-269">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-269">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Decrement(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Decrement(long % location);" />
      <MemberSignature Language="F#" Value="static member Decrement : int64 -&gt; int64" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="add9a-270">Die Variable, deren Wert dekrementiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-270">The variable whose value is to be decremented.</span></span></param>
        <summary><span data-ttu-id="add9a-271">Dekrementiert den Wert der angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</span><span class="sxs-lookup"><span data-stu-id="add9a-271">Decrements the specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="add9a-272">Der dekrementierte Wert.</span><span class="sxs-lookup"><span data-stu-id="add9a-272">The decremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="add9a-273">Diese Methode behandelt eine Überlauf Bedingung durch Wrapping: If `location`  =  <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` -1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="add9a-273">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="add9a-274">Es werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="add9a-274">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="add9a-275">Die Adresse von <paramref name="location" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-275">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-276">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-276">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-277">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-277">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="add9a-278">Legt eine Variable in einer atomaren Operation auf einen angegebenen Wert fest.</span><span class="sxs-lookup"><span data-stu-id="add9a-278">Sets a variable to a specified value as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exchange(float64&amp; location1, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Double, value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exchange(double % location1, double value);" />
      <MemberSignature Language="F#" Value="static member Exchange : double * double -&gt; double" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="add9a-279">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-279">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="add9a-280">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="add9a-280">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="add9a-281">Legt in einer atomaren Operation eine Gleitkommazahl mit doppelter Genauigkeit auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="add9a-281">Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="add9a-282">Der ursprüngliche Wert von <paramref name="location1" />.</span><span class="sxs-lookup"><span data-stu-id="add9a-282">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="add9a-283">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-283">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-284">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-284">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-285">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-285">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Exchange(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Exchange(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Exchange : int * int -&gt; int" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="add9a-286">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-286">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="add9a-287">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="add9a-287">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="add9a-288">Legt eine 32-Bit-Ganzzahl mit Vorzeichen in einer atomaren Operation auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="add9a-288">Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="add9a-289">Der ursprüngliche Wert von <paramref name="location1" />.</span><span class="sxs-lookup"><span data-stu-id="add9a-289">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="add9a-290">Das folgende Codebeispiel zeigt einen Thread sicheren Mechanismus zum Sperren von Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="add9a-290">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="add9a-291">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-291">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-292">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-292">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-293">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-293">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Exchange(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Exchange(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Exchange : int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="add9a-294">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-294">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="add9a-295">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="add9a-295">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="add9a-296">Legt eine 64-Bit-Ganzzahl mit Vorzeichen in einer atomaren Operation auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="add9a-296">Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="add9a-297">Der ursprüngliche Wert von <paramref name="location1" />.</span><span class="sxs-lookup"><span data-stu-id="add9a-297">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="add9a-298">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-298">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-299">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-299">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-300">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-300">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Exchange(native int&amp; location1, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As IntPtr, value As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Exchange(IntPtr % location1, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member Exchange : nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="add9a-301">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-301">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="add9a-302">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="add9a-302">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="add9a-303">Legt in einer atomaren Operation ein plattformspezifisches Handle bzw. einen plattformspezifischen Zeiger auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="add9a-303">Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="add9a-304">Der ursprüngliche Wert von <paramref name="location1" />.</span><span class="sxs-lookup"><span data-stu-id="add9a-304">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="add9a-305">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-305">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-306">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-306">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-307">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-307">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Exchange(object&amp; location1, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Object, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Exchange(System::Object ^ % location1, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Exchange : obj * obj -&gt; obj" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="add9a-308">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-308">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="add9a-309">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="add9a-309">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="add9a-310">Legt in einer atomaren Operation ein Objekt auf einen angegebenen Wert fest und gibt einen Verweis auf das ursprüngliche Objekt zurück.</span><span class="sxs-lookup"><span data-stu-id="add9a-310">Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="add9a-311">Der ursprüngliche Wert von <paramref name="location1" />.</span><span class="sxs-lookup"><span data-stu-id="add9a-311">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> <span data-ttu-id="add9a-312">Ab .NET Framework 2.0 bietet die Überladung der <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29>-Methoden eine typsichere Alternative für Verweistypen.</span><span class="sxs-lookup"><span data-stu-id="add9a-312">Beginning with .NET Framework 2.0, the <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span> <span data-ttu-id="add9a-313">Es wird empfohlen, dass Sie diese anstelle dieser Überladung aufrufen.</span><span class="sxs-lookup"><span data-stu-id="add9a-313">We recommend that you call it instead of this overload.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="add9a-314">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-314">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-315">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-315">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-316">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-316">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exchange(float32&amp; location1, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Single, value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exchange(float % location1, float value);" />
      <MemberSignature Language="F#" Value="static member Exchange : single * single -&gt; single" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="add9a-317">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-317">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="add9a-318">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="add9a-318">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="add9a-319">Legt in einer atomaren Operation eine Gleitkommazahl mit einfacher Genauigkeit auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="add9a-319">Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="add9a-320">Der ursprüngliche Wert von <paramref name="location1" />.</span><span class="sxs-lookup"><span data-stu-id="add9a-320">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="add9a-321">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-321">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-322">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-322">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-323">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-323">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Exchange&lt;class T&gt;(!!T&amp; location1, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange``1(``0@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange(Of T As Class) (ByRef location1 As T, value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T Exchange(T % location1, T value);" />
      <MemberSignature Language="F#" Value="static member Exchange : 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="add9a-324">Der Typ, der für <paramref name="location1" /> und <paramref name="value" /> verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-324">The type to be used for <paramref name="location1" /> and <paramref name="value" />.</span></span> <span data-ttu-id="add9a-325">Dieser Typ muss ein Referenztyp sein.</span><span class="sxs-lookup"><span data-stu-id="add9a-325">This type must be a reference type.</span></span></typeparam>
        <param name="location1"><span data-ttu-id="add9a-326">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-326">The variable to set to the specified value.</span></span> <span data-ttu-id="add9a-327">Dies ist ein Verweisparameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="add9a-327">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span></span></param>
        <param name="value"><span data-ttu-id="add9a-328">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="add9a-328">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="add9a-329">Legt eine Variable vom angegebenen Typ <paramref name="T" /> in einer atomaren Operation auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="add9a-329">Sets a variable of the specified type <paramref name="T" /> to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="add9a-330">Der ursprüngliche Wert von <paramref name="location1" />.</span><span class="sxs-lookup"><span data-stu-id="add9a-330">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="add9a-331">Diese Methode unterstützt nur Verweis Typen.</span><span class="sxs-lookup"><span data-stu-id="add9a-331">This method only supports reference types.</span></span> <span data-ttu-id="add9a-332">Es gibt über Ladungen <xref:System.Threading.Interlocked.Exchange%2A> der-Methode für die <xref:System.Int32>Werttypen, <xref:System.Int64>, <xref:System.Double> <xref:System.IntPtr>, <xref:System.Single>und, aber es gibt keine Unterstützung für andere Werttypen.</span><span class="sxs-lookup"><span data-stu-id="add9a-332">There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="add9a-333">Diese Methoden Überladung ist der <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> -Methoden Überladung vorzuziehen, da letztere den spät gebundenen Zugriff auf das Zielobjekt erfordert.</span><span class="sxs-lookup"><span data-stu-id="add9a-333">This method overload is preferable to the <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> method overload, because the latter requires late-bound access to the destination object .</span></span>  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="add9a-334">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-334">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="add9a-335">Inkrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</span><span class="sxs-lookup"><span data-stu-id="add9a-335">Increments a specified variable and stores the result, as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Increment(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Increment(int % location);" />
      <MemberSignature Language="F#" Value="static member Increment : int -&gt; int" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="add9a-336">Die Variable, deren Wert inkrementiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-336">The variable whose value is to be incremented.</span></span></param>
        <summary><span data-ttu-id="add9a-337">Inkrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</span><span class="sxs-lookup"><span data-stu-id="add9a-337">Increments a specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="add9a-338">Der inkrementierte Wert.</span><span class="sxs-lookup"><span data-stu-id="add9a-338">The incremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="add9a-339">Diese Methode behandelt eine Überlauf Bedingung durch Umbrüchen: `location`if `location`  =  <xref:System.Int32.MaxValue?displayProperty=nameWithType>, + 1 <xref:System.Int32.MinValue?displayProperty=nameWithType>=.</span><span class="sxs-lookup"><span data-stu-id="add9a-339">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="add9a-340">Es werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="add9a-340">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="add9a-341">Im folgenden Beispiel wird bestimmt, wie viele Zufallszahlen zwischen 0 und 1.000 erforderlich sind, um 1.000 Zufallszahlen mit einem Mittelpunkt Wert zu generieren.</span><span class="sxs-lookup"><span data-stu-id="add9a-341">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="add9a-342">Um die Anzahl der Mittelpunkt Werte nachzuverfolgen, wird eine Variable `midpointCount`,, auf 0 festgelegt und jedes Mal erhöht, wenn der Zufallszahlen-Generator einen Mittelpunkt Wert zurückgibt, bis 10.000 erreicht wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-342">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000.</span></span> <span data-ttu-id="add9a-343">Da drei Threads die Zufallszahlen generieren, wird <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> die-Methode aufgerufen, um sicherzustellen, dass `midpointCount` mehrere Threads nicht gleichzeitig aktualisiert werden.</span><span class="sxs-lookup"><span data-stu-id="add9a-343">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="add9a-344">Beachten Sie, dass eine Sperre auch verwendet wird, um den Zufallszahlengenerator zu schützen <xref:System.Threading.CountdownEvent> , und dass ein-Objekt verwendet `Main` wird, um sicherzustellen, dass die-Methode die Ausführung vor den drei Threads nicht beendet.</span><span class="sxs-lookup"><span data-stu-id="add9a-344">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]
 [!code-vb[System.Threading.Interlocked.Increment2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  
  
 <span data-ttu-id="add9a-345">Das folgende Beispiel ähnelt dem vorherigen, mit der Ausnahme, dass es die <xref:System.Threading.Tasks.Task> -Klasse anstelle einer Thread Prozedur verwendet, um 50.000 zufällige Mittelpunkt-Ganzzahlen zu generieren.</span><span class="sxs-lookup"><span data-stu-id="add9a-345">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="add9a-346">In diesem Beispiel wird durch einen Lambda-Ausdruck `GenerateNumbers` die Thread Prozedur ersetzt, und durch den <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> -Aufrufvorgang entfällt die <xref:System.Threading.CountdownEvent> Notwendigkeit des-Objekts.</span><span class="sxs-lookup"><span data-stu-id="add9a-346">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]
 [!code-vb[System.Threading.Interlocked.Increment2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="add9a-347">Die Adresse von <paramref name="location" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-347">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-348">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-348">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-349">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-349">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Increment(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Increment(long % location);" />
      <MemberSignature Language="F#" Value="static member Increment : int64 -&gt; int64" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="add9a-350">Die Variable, deren Wert inkrementiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="add9a-350">The variable whose value is to be incremented.</span></span></param>
        <summary><span data-ttu-id="add9a-351">Inkrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</span><span class="sxs-lookup"><span data-stu-id="add9a-351">Increments a specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="add9a-352">Der inkrementierte Wert.</span><span class="sxs-lookup"><span data-stu-id="add9a-352">The incremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="add9a-353">Diese Methode behandelt eine Überlauf Bedingung durch Umbrüchen: `location`if `location`  =  <xref:System.Int64.MaxValue?displayProperty=nameWithType>, + 1 <xref:System.Int64.MinValue?displayProperty=nameWithType>=.</span><span class="sxs-lookup"><span data-stu-id="add9a-353">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="add9a-354">Es werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="add9a-354">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="add9a-355">Die Adresse von <paramref name="location" /> ist ein NULL-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="add9a-355">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-356">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-356">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-357">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-357">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="add9a-358">Synchronisiert den Arbeitsspeicherzugriff wie folgt: Der Prozessor, der den aktuellen Thread ausführt, kann Anweisungen nicht so neu anordnen, dass Speicherzugriffe vor dem Aufruf von <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> nach Speicherzugriffen ausgeführt werden, die nach dem Aufruf von <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> erfolgen.</span><span class="sxs-lookup"><span data-stu-id="add9a-358">Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="add9a-359">Diese Methode wurde der <xref:System.Threading.Interlocked> -Klasse in der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] -Klasse hinzugefügt. es handelt sich um einen Wrapper <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> für die-Methode.</span><span class="sxs-lookup"><span data-stu-id="add9a-359">This method was added to the <xref:System.Threading.Interlocked> class in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] as a convenience; it's a wrapper for the <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="add9a-360"><xref:System.Threading.Interlocked.MemoryBarrier%2A>ist nur auf Multiprozessorsystemen erforderlich, die eine schwache Arbeitsspeicher Anordnung aufweisen (z. b. ein System, das mehrere Intel Itanium-Prozessoren verwendet).</span><span class="sxs-lookup"><span data-stu-id="add9a-360"><xref:System.Threading.Interlocked.MemoryBarrier%2A> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="add9a-361">In den meisten Fällen stellt C# `lock` die-Anweisung, `SyncLock` die Visual Basic-Anweisung <xref:System.Threading.Monitor> oder die-Klasse einfachere Möglichkeiten zum Synchronisieren von Daten bereit.</span><span class="sxs-lookup"><span data-stu-id="add9a-361">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrierProcessWide">
      <MemberSignature Language="C#" Value="public static void MemoryBarrierProcessWide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrierProcessWide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrierProcessWide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrierProcessWide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrierProcessWide();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrierProcessWide : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrierProcessWide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="add9a-362">Bietet eine prozessübergreifende Arbeitsspeicherbarriere, die verhindert, dass Lese- und Schreibvorgänge von CPUs über die Barriere hinaus verschoben werden.</span><span class="sxs-lookup"><span data-stu-id="add9a-362">Provides a process-wide memory barrier that ensures that reads and writes from any CPU cannot move across the barrier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="add9a-363">Die `MemoryBarrierProcessWide` -Methode unterscheidet sich von der <xref:System.Threading.Interlocked.MemoryBarrier%2A> "normalen" Methode wie folgt:</span><span class="sxs-lookup"><span data-stu-id="add9a-363">The `MemoryBarrierProcessWide` method differs from the "normal" <xref:System.Threading.Interlocked.MemoryBarrier%2A> method as follows:</span></span>

- <span data-ttu-id="add9a-364">Die normale Speicherbarriere stellt sicher, dass die Lese-und Schreibvorgänge von der aktuellen CPU nicht über die Barriere hinaus verschoben werden können.</span><span class="sxs-lookup"><span data-stu-id="add9a-364">The normal memory barrier ensures that the reads and writes from the current CPU can't move across the barrier.</span></span> <span data-ttu-id="add9a-365">Die Prozess weite Speicherbarriere stellt sicher, dass alle Lese-und Schreibvorgänge aus beliebigen CPU, die im Prozess verwendet werden, nicht über die Barriere verschoben werden können.</span><span class="sxs-lookup"><span data-stu-id="add9a-365">The process-wide memory barrier ensures that any read or write from any CPU being used in the process can't move across the barrier.</span></span>

- <span data-ttu-id="add9a-366">Die normale Speicherbarriere ermöglicht einen angemessenen freigegebenen Zugriff, wenn *jeder* Thread, der auf die Daten zugreift, Barrieren verwendet</span><span class="sxs-lookup"><span data-stu-id="add9a-366">The normal memory barrier allows reasonable shared access if *every* thread accessing the data uses barriers.</span></span> <span data-ttu-id="add9a-367">Die Prozess weite Speicherbarriere zwingt die Synchronisierung *anderer CPUs* mit dem Prozess Speicher (z. b. zum leeren von Schreib Puffern und Synchronisieren von Lese Puffern).</span><span class="sxs-lookup"><span data-stu-id="add9a-367">The process-wide memory barrier forces *other CPUs* to synchronize with process memory (for example, to flush write buffers and synchronize read buffers).</span></span> <span data-ttu-id="add9a-368">Dies ermöglicht nicht Interlocked-Vorgänge für einige Threads und hat dennoch einen angemessenen gemeinsamen Zugriff.</span><span class="sxs-lookup"><span data-stu-id="add9a-368">This allows for non-interlocked operations on some threads and still have reasonable shared access.</span></span> 

- <span data-ttu-id="add9a-369">Die normale Speicherbarriere zwingt sehr wenig mehr Aufwand. normale Interlocked-Vorgänge Kosten wahrscheinlich weniger als hundert Zyklen.</span><span class="sxs-lookup"><span data-stu-id="add9a-369">The normal memory barrier imposes very little overhead; normal interlocked operations probably cost fewer than a hundred cycles.</span></span> <span data-ttu-id="add9a-370">Die Prozess weite Speicherbarriere ist sehr aufwendig.</span><span class="sxs-lookup"><span data-stu-id="add9a-370">The process-wide memory barrier is very expensive.</span></span> <span data-ttu-id="add9a-371">Es muss jede CPU im Prozess mit einer wahrscheinlichen Kosten Anzahl von Tausenden von Zyklen erzwingen.</span><span class="sxs-lookup"><span data-stu-id="add9a-371">It has to force every CPU in the process do to something, at a probable cost of thousands of cycles.</span></span> 

<span data-ttu-id="add9a-372">Die `MemoryBarrierProcessWide` -Methode wird auch von allen Feinheiten der sperrenlosen Programmierung unterschieden.</span><span class="sxs-lookup"><span data-stu-id="add9a-372">The `MemoryBarrierProcessWide` method also suffers from all the subtleties of lock-free programming.</span></span> <span data-ttu-id="add9a-373">Dennoch kann diese Methode äußerst nützlich sein, wenn Sie Sie tatsächlich anrufen müssen, was selten vorkommen sollte.</span><span class="sxs-lookup"><span data-stu-id="add9a-373">Nevertheless, this method can be extremely useful when you actually need to call it, which should be rare.</span></span>

<span data-ttu-id="add9a-374">Diese Methode umschließt einen Aufrufen von [flushprocesswrite tebuffers](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-flushprocesswritebuffers) unter Windows und [sys_membarrier](https://lore.kernel.org/patchwork/patch/188708/) unter Linux.</span><span class="sxs-lookup"><span data-stu-id="add9a-374">This method wraps a call to [FlushProcessWriteBuffers](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-flushprocesswritebuffers) on Windows and [sys_membarrier](https://lore.kernel.org/patchwork/patch/188708/) on Linux.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Read(long % location);" />
      <MemberSignature Language="F#" Value="static member Read : int64 -&gt; int64" Usage="System.Threading.Interlocked.Read location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="add9a-375">Der zu ladende 64-Bit-Wert.</span><span class="sxs-lookup"><span data-stu-id="add9a-375">The 64-bit value to be loaded.</span></span></param>
        <summary><span data-ttu-id="add9a-376">Gibt einen 64-Bit-Wert zurück, der in einer atomaren Operation geladen wird.</span><span class="sxs-lookup"><span data-stu-id="add9a-376">Returns a 64-bit value, loaded as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="add9a-377">Der geladene Wert.</span><span class="sxs-lookup"><span data-stu-id="add9a-377">The loaded value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="add9a-378">Die <xref:System.Threading.Interlocked.Read%2A> -Methode ist auf 64-Bit-Systemen nicht erforderlich, da 64-Bit-Lesevorgänge bereits atomarisch sind.</span><span class="sxs-lookup"><span data-stu-id="add9a-378">The <xref:System.Threading.Interlocked.Read%2A> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic.</span></span> <span data-ttu-id="add9a-379">Auf 32-Bit-Systemen sind 64-Bit-Lesevorgänge nicht atomarisch, <xref:System.Threading.Interlocked.Read%2A>es sei denn, Sie werden mit ausgeführt</span><span class="sxs-lookup"><span data-stu-id="add9a-379">On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref:System.Threading.Interlocked.Read%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="add9a-380">Verwaltetes Threading</span><span class="sxs-lookup"><span data-stu-id="add9a-380">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="add9a-381">Übersicht über Synchronisierungsprimitive</span><span class="sxs-lookup"><span data-stu-id="add9a-381">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SpeculationBarrier">
      <MemberSignature Language="C#" Value="public static void SpeculationBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpeculationBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.SpeculationBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpeculationBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpeculationBarrier();" />
      <MemberSignature Language="F#" Value="static member SpeculationBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.SpeculationBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="add9a-382">Definiert einen Arbeitsspeicher-Fence, der eine spekulative Ausführung über diesen Punkt hinaus blockiert, bis ausstehende Lese- und Schreibvorgänge abgeschlossen sind.</span><span class="sxs-lookup"><span data-stu-id="add9a-382">Defines a memory fence that blocks speculative execution past this point until pending reads and writes are complete.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="add9a-383">Die `SpeculationBarrier` -Methode definiert einen speicherfence ( `mfence` eine-Anweisung für x86-und AMD64-Prozessoren), die die *spekulative* Ausführung bis zu diesem Zeitpunkt blockiert, bis ausstehende Lese-und Schreibvorgänge abgeschlossen sind.</span><span class="sxs-lookup"><span data-stu-id="add9a-383">The `SpeculationBarrier` method defines a memory fence (an `mfence` instruction on x86 and amd64 processors) that blocks *speculative* execution past this point until pending reads and writes are complete.</span></span> 

 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
