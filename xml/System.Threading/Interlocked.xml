<Type Name="Interlocked" FullName="System.Threading.Interlocked">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f8323bee2d10de4d0d6fe2f4d3f64f4e9c289672" /><Meta Name="ms.sourcegitcommit" Value="6fca7f55940a389853cc2d183619073ce0d69092" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/26/2020" /><Meta Name="ms.locfileid" Value="88868471" /></Metadata><TypeSignature Language="C#" Value="public static class Interlocked" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Interlocked extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Interlocked" />
  <TypeSignature Language="VB.NET" Value="Public Class Interlocked" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interlocked abstract sealed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Interlocked = class" />
  <TypeSignature Language="C#" Value="public sealed class Interlocked" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Interlocked extends System.Object" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Interlocked" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interlocked sealed" FrameworkAlternate="netframework-1.1" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0">
      <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt atomare Vorgänge für Variablen bereit, die von mehreren Threads gemeinsam genutzt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden dieser Klasse helfen beim Schutz vor Fehlern, die auftreten können, wenn der Planer einen Kontext wechselt, während ein Thread eine Variable aktualisiert, auf die von anderen Threads zugegriffen werden kann, oder wenn zwei Threads gleichzeitig auf separaten Prozessoren ausgeführt werden. Die Member dieser Klasse lösen keine Ausnahmen aus.  
  
 Die <xref:System.Threading.Interlocked.Increment%2A> -Methode und die- <xref:System.Threading.Interlocked.Decrement%2A> Methode erhöhen oder verringern eine Variable und speichern den resultierenden Wert in einem einzelnen Vorgang. Auf den meisten Computern ist das Inkrementieren einer Variablen kein atomarer Vorgang, bei dem die folgenden Schritte erforderlich sind:  
  
1.  Lädt einen Wert aus einer Instanzvariablen in ein Register.  
  
2.  Erhöhen oder verringern Sie den Wert.  
  
3.  Speichern Sie den Wert in der Instanzvariablen.  
  
 Wenn Sie und nicht verwenden <xref:System.Threading.Interlocked.Increment%2A> <xref:System.Threading.Interlocked.Decrement%2A> , kann ein Thread nach dem Ausführen der ersten beiden Schritte vorzeitig entfernt werden. Ein anderer Thread kann dann alle drei Schritte ausführen. Wenn der erste Thread die Ausführung fortsetzt, wird der Wert in der Instanzvariablen überschrieben, und die Auswirkung des Inkrement oder Dekrement, der durch den zweiten Thread durchgeführt wird, geht verloren.  

 Die <xref:System.Threading.Interlocked.Add%2A> -Methode fügt einen ganzzahligen Wert atomisch zu einer ganzzahligen Variablen hinzu und gibt den neuen Wert der Variablen zurück.  
  
 Die- <xref:System.Threading.Interlocked.Exchange%2A> Methode tauscht den Wert der angegebenen Variablen atomisch aus. Die- <xref:System.Threading.Interlocked.CompareExchange%2A> Methode kombiniert zwei Vorgänge: Vergleichen von zwei Werten und Speichern eines dritten Werts in einer der Variablen, basierend auf dem Ergebnis des Vergleichs. Die Vergleichs-und Exchange-Vorgänge werden als atomarer Vorgang ausgeführt.  

 Stellen Sie sicher, dass jeder Schreib-oder Lesezugriff auf eine freigegebene Variable atomarisch ist. Andernfalls sind die Daten möglicherweise beschädigt, oder der geladene Wert ist falsch.    
   
  
## Examples  
 Das folgende Codebeispiel zeigt einen Thread sicheren Mechanismus zum Sperren von Ressourcen.  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
    <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt in einer atomaren Operation zwei Ganzzahlen hinzu und ersetzt die erste Ganzzahl durch die Summe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Add(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Add(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Add : int * int -&gt; int" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1">Eine Variable, die den ersten Wert enthält, der hinzugefügt werden soll. Die Summe der beiden Werte wird in <paramref name="location1" /> gespeichert.</param>
        <param name="value">Der Wert, der der Ganzzahl in <paramref name="location1" /> hinzugefügt werden soll.</param>
        <summary>Fügt in einer atomaren Operation zwei 32-Bit-Ganzzahlen hinzu und ersetzt die erste Ganzzahl durch die Summe.</summary>
        <returns>Der unter <paramref name="location1" /> gespeicherte neue Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode behandelt eine Überlauf Bedingung durch Umbrüchen: Wenn der Wert bei `location1` ist <xref:System.Int32.MaxValue?displayProperty=nameWithType> und `value` 1 ist, ist das Ergebnis <xref:System.Int32.MinValue?displayProperty=nameWithType> . Wenn `value` 2 ist, ist das Ergebnis ( <xref:System.Int32.MinValue?displayProperty=nameWithType> + 1) usw. Es werden keine Ausnahmen ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Add(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Add(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Add : int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1">Eine Variable, die den ersten Wert enthält, der hinzugefügt werden soll. Die Summe der beiden Werte wird in <paramref name="location1" /> gespeichert.</param>
        <param name="value">Der Wert, der der Ganzzahl in <paramref name="location1" /> hinzugefügt werden soll.</param>
        <summary>Fügt in einer atomaren Operation zwei 64-Bit-Ganzzahlen hinzu und ersetzt die erste Ganzzahl durch die Summe.</summary>
        <returns>Der unter <paramref name="location1" /> gespeicherte neue Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode behandelt eine Überlauf Bedingung durch Umbrüchen: Wenn der Wert bei `location1` ist <xref:System.Int64.MaxValue?displayProperty=nameWithType> und `value` 1 ist, ist das Ergebnis <xref:System.Int64.MinValue?displayProperty=nameWithType> . Wenn `value` 2 ist, ist das Ergebnis ( <xref:System.Int64.MinValue?displayProperty=nameWithType> + 1) usw. Es werden keine Ausnahmen ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static uint Add (ref uint location1, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Add(unsigned int32&amp; location1, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As UInteger, value As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Add(System::UInt32 % location1, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member Add : uint32 * uint32 -&gt; uint32" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">Eine Variable, die den ersten Wert enthält, der hinzugefügt werden soll. Die Summe der beiden Werte wird in <paramref name="location1" /> gespeichert.</param>
        <param name="value">Der Wert, der der Ganzzahl in <paramref name="location1" /> hinzugefügt werden soll.</param>
        <summary>Fügt zwei 32-Bit-Ganzzahlen ohne Vorzeichen hinzu und ersetzt die erste Ganzzahl durch die Summe als atomare Operation.</summary>
        <returns>Der unter <paramref name="location1" /> gespeicherte neue Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static ulong Add (ref ulong location1, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Add(unsigned int64&amp; location1, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As ULong, value As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Add(System::UInt64 % location1, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member Add : uint64 * uint64 -&gt; uint64" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">Eine Variable, die den ersten Wert enthält, der hinzugefügt werden soll. Die Summe der beiden Werte wird in <paramref name="location1" /> gespeichert.</param>
        <param name="value">Der Wert, der der Ganzzahl in <paramref name="location1" /> hinzugefügt werden soll.</param>
        <summary>Fügt zwei 64-Bit-Ganzzahlen ohne Vorzeichen hinzu und ersetzt die erste Ganzzahl durch die Summe als atomare Operation.</summary>
        <returns>Der unter <paramref name="location1" /> gespeicherte neue Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static int And (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 And(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.And(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int And(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member And : int * int -&gt; int" Usage="System.Threading.Interlocked.And (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">Eine Variable, die den ersten Wert enthält, der kombiniert werden soll. Das Ergebnis wird in <paramref name="location1" /> gespeichert.</param>
        <param name="value">Der Wert, der an <paramref name="location1" /> mit der Ganzzahl kombiniert werden soll.</param>
        <summary>Wendet „and“ bitweise auf zwei 32-Bit-Ganzzahlen mit Vorzeichen an und ersetzt die erste Ganzzahl durch das Ergebnis als atomare Operation.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static long And (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 And(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.And(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long And(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member And : int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.And (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">Eine Variable, die den ersten Wert enthält, der kombiniert werden soll. Das Ergebnis wird in <paramref name="location1" /> gespeichert.</param>
        <param name="value">Der Wert, der an <paramref name="location1" /> mit der Ganzzahl kombiniert werden soll.</param>
        <summary>Wendet „and“ bitweise auf zwei 64-Bit-Ganzzahlen mit Vorzeichen an und ersetzt die erste Ganzzahl durch das Ergebnis als atomare Operation.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static uint And (ref uint location1, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 And(unsigned int32&amp; location1, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.And(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (ByRef location1 As UInteger, value As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 And(System::UInt32 % location1, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member And : uint32 * uint32 -&gt; uint32" Usage="System.Threading.Interlocked.And (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">Eine Variable, die den ersten Wert enthält, der kombiniert werden soll. Das Ergebnis wird in <paramref name="location1" /> gespeichert.</param>
        <param name="value">Der Wert, der an <paramref name="location1" /> mit der Ganzzahl kombiniert werden soll.</param>
        <summary>Wendet „and“ bitweise auf zwei 32-Bit-Ganzzahlen ohne Vorzeichen an und ersetzt die erste Ganzzahl durch das Ergebnis als atomare Operation.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static ulong And (ref ulong location1, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 And(unsigned int64&amp; location1, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.And(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (ByRef location1 As ULong, value As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 And(System::UInt64 % location1, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member And : uint64 * uint64 -&gt; uint64" Usage="System.Threading.Interlocked.And (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">Eine Variable, die den ersten Wert enthält, der kombiniert werden soll. Das Ergebnis wird in <paramref name="location1" /> gespeichert.</param>
        <param name="value">Der Wert, der an <paramref name="location1" /> mit der Ganzzahl kombiniert werden soll.</param>
        <summary>Wendet „and“ bitweise auf zwei 64-Bit-Ganzzahlen ohne Vorzeichen an und ersetzt die erste Ganzzahl durch das Ergebnis als atomare Operation.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareExchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht zwei Werte hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CompareExchange(float64&amp; location1, float64 value, float64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Double, value As Double, comparand As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double CompareExchange(double % location1, double value, double comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : double * double * double -&gt; double" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="System.Double" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1">Das Ziel, dessen Wert mit <paramref name="comparand" /> verglichen und möglicherweise ersetzt wird.</param>
        <param name="value">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
        <param name="comparand">Der Wert, der mit dem Wert bei <paramref name="location1" /> verglichen wird.</param>
        <summary>Vergleicht zwei Gleitkommazahlen mit doppelter Genauigkeit hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparand` und der Wert in `location1` gleich sind, `value` wird in gespeichert `location1` . Andernfalls wird kein Vorgang ausgeführt. Die Vergleichs-und Exchange-Vorgänge werden als atomarer Vorgang ausgeführt. Der Rückgabewert von <xref:System.Threading.Interlocked.CompareExchange%2A> ist der ursprüngliche Wert in `location1` , unabhängig davon, ob der Exchange-Vorgang stattfindet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Thread sichere Methode veranschaulicht, die eine laufende Summe von Werten akkumuliert <xref:System.Double> . Zwei Threads fügen <xref:System.Double> mithilfe der Thread sicheren Methode und der normalen Addition eine Reihe von Werten hinzu, und nach Abschluss der Threads werden die Gesamtwerte verglichen. Auf einem Dual Prozessor Computer gibt es einen signifikanten Unterschied in den Gesamtwerten.  
  
 In der Thread sicheren Methode wird der Anfangswert der laufenden Summe gespeichert, und anschließend wird die- <xref:System.Threading.Interlocked.CompareExchange%2A> Methode verwendet, um die neu berechnete Summe mit der alten Summe auszutauschen. Wenn der Rückgabewert nicht gleich dem gespeicherten Wert der laufenden Summe ist, hat ein anderer Thread die Summe in der Zwischenzeit aktualisiert. In diesem Fall muss der Versuch, die laufende Summe zu aktualisieren, wiederholt werden.  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareExchange(int32&amp; location1, int32 value, int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Integer, value As Integer, comparand As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareExchange(int % location1, int value, int comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : int * int * int -&gt; int" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">Das Ziel, dessen Wert mit <paramref name="comparand" /> verglichen und möglicherweise ersetzt wird.</param>
        <param name="value">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
        <param name="comparand">Der Wert, der mit dem Wert bei <paramref name="location1" /> verglichen wird.</param>
        <summary>Vergleicht zwei 32-Bit-Ganzzahlen mit Vorzeichen hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparand` und der Wert in `location1` gleich sind, `value` wird in gespeichert `location1` . Andernfalls wird kein Vorgang ausgeführt. Die Vergleichs-und Exchange-Vorgänge werden als atomarer Vorgang ausgeführt. Der Rückgabewert von <xref:System.Threading.Interlocked.CompareExchange%2A> ist der ursprüngliche Wert in `location1` , unabhängig davon, ob der Exchange-Vorgang stattfindet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Thread sichere Methode veranschaulicht, die eine laufende Summe akkumuliert. Der Anfangswert der laufenden Summe wird gespeichert, und anschließend wird die- <xref:System.Threading.Interlocked.CompareExchange%2A> Methode verwendet, um die neu berechnete Summe mit der alten Summe auszutauschen. Wenn der Rückgabewert nicht gleich dem gespeicherten Wert der laufenden Summe ist, hat ein anderer Thread die Summe in der Zwischenzeit aktualisiert. In diesem Fall muss der Versuch, die laufende Summe zu aktualisieren, wiederholt werden.  
  
> [!NOTE]
>  Die <xref:System.Threading.Interlocked.Add%2A> in Version 2,0 des .NET Framework eingeführte-Methode bietet eine komfortablere Möglichkeit zum sammeln Thread sicherer laufender Summen für ganze Zahlen.  
  
 [!code-cpp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CompareExchange(int64&amp; location1, int64 value, int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Long, value As Long, comparand As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long CompareExchange(long % location1, long value, long comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : int64 * int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="System.Int64" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1">Das Ziel, dessen Wert mit <paramref name="comparand" /> verglichen und möglicherweise ersetzt wird.</param>
        <param name="value">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
        <param name="comparand">Der Wert, der mit dem Wert bei <paramref name="location1" /> verglichen wird.</param>
        <summary>Vergleicht zwei 64-Bit-Ganzzahlen mit Vorzeichen hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparand` und der Wert in `location1` gleich sind, `value` wird in gespeichert `location1` . Andernfalls wird kein Vorgang ausgeführt. Die Vergleichs-und Exchange-Vorgänge werden als atomarer Vorgang ausgeführt. Der Rückgabewert von <xref:System.Threading.Interlocked.CompareExchange%2A> ist der ursprüngliche Wert in `location1` , unabhängig davon, ob der Exchange-Vorgang stattfindet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CompareExchange(native int&amp; location1, native int value, native int comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As IntPtr, value As IntPtr, comparand As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CompareExchange(IntPtr % location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : nativeint * nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="System.IntPtr" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1">Das Ziel <see cref="T:System.IntPtr" />, dessen Wert mit dem Wert von <paramref name="comparand" /> verglichen und möglicherweise durch <paramref name="value" /> ersetzt wird.</param>
        <param name="value">Der <see cref="T:System.IntPtr" />, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
        <param name="comparand">Der <see cref="T:System.IntPtr" />, der mit dem Wert in <paramref name="location1" /> verglichen wird.</param>
        <summary>Vergleicht zwei plattformspezifische Handles oder Zeiger hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparand` und der Wert in `location1` gleich sind, `value` wird in gespeichert `location1` . Andernfalls wird kein Vorgang ausgeführt. Die Vergleichs-und Exchange-Vorgänge werden als atomarer Vorgang ausgeführt. Der Rückgabewert dieser Methode ist der ursprüngliche Wert in, unabhängig davon `location1` , ob der Exchange-Vorgang stattfindet.  
  
> [!NOTE]
>  <xref:System.IntPtr> ist ein plattformspezifischer Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CompareExchange(object&amp; location1, object value, object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Object, value As Object, comparand As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CompareExchange(System::Object ^ % location1, System::Object ^ value, System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : obj * obj * obj -&gt; obj" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">Das Zielobjekt, das mit <paramref name="comparand" /> nach Verweis verglichen und möglicherweise ersetzt wird.</param>
        <param name="value">Das Objekt, das das Zielobjekt ersetzt, wenn beim Verweisevergleich Gleichheit festgestellt wird.</param>
        <param name="comparand">Das Objekt, das nach Verweis mit dem Objekt bei <paramref name="location1" /> verglichen wird.</param>
        <summary>Vergleicht zwei Objekte hinsichtlich ihrer Verweisgleichheit und ersetzt bei vorliegender Gleichheit das erste Objekt.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> Ab .NET Framework 2.0 bietet die Überladung der <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29>-Methoden eine typsichere Alternative für Verweistypen. Es wird empfohlen, dass Sie diese anstelle dieser Überladung aufrufen.

Wenn `comparand` und das-Objekt in `location1` gleich Verweis sind, `value` wird in gespeichert `location1` . Andernfalls wird kein Vorgang ausgeführt. Die Vergleichs-und Exchange-Vorgänge werden als atomarer Vorgang ausgeführt. Der Rückgabewert von <xref:System.Threading.Interlocked.CompareExchange%2A> ist der ursprüngliche Wert in `location1` , unabhängig davon, ob der Exchange-Vorgang stattfindet.  

> [!NOTE]
>  Die Objekte werden auf Verweis Übereinstimmung anstatt auf Wert Gleichheit verglichen. Folglich scheinen zwei einfügende Instanzen desselben Werttyps (z. b. die ganze Zahl 3) immer ungleich zu sein, und es wird kein Vorgang ausgeführt. Verwenden Sie diese Überladung nicht mit Werttypen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CompareExchange(float32&amp; location1, float32 value, float32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Single, value As Single, comparand As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CompareExchange(float % location1, float value, float comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : single * single * single -&gt; single" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">Das Ziel, dessen Wert mit <paramref name="comparand" /> verglichen und möglicherweise ersetzt wird.</param>
        <param name="value">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
        <param name="comparand">Der Wert, der mit dem Wert bei <paramref name="location1" /> verglichen wird.</param>
        <summary>Vergleicht zwei Gleitkommazahlen mit einfacher Genauigkeit hinsichtlich ihrer Gleichheit und ersetzt bei vorliegender Gleichheit den ersten Wert.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparand` und der Wert in `location1` gleich sind, `value` wird in gespeichert `location1` . Andernfalls wird kein Vorgang ausgeführt. Die Vergleichs-und Exchange-Vorgänge werden als atomarer Vorgang ausgeführt. Der Rückgabewert von <xref:System.Threading.Interlocked.CompareExchange%2A> ist der ursprüngliche Wert in `location1` , unabhängig davon, ob der Exchange-Vorgang stattfindet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Thread sichere Methode veranschaulicht, die eine laufende Summe von Werten akkumuliert <xref:System.Single> . Zwei Threads fügen <xref:System.Single> mithilfe der Thread sicheren Methode und der normalen Addition eine Reihe von Werten hinzu, und nach Abschluss der Threads werden die Gesamtwerte verglichen. Auf einem Dual Prozessor Computer gibt es einen signifikanten Unterschied in den Gesamtwerten.  
  
 In der Thread sicheren Methode wird der Anfangswert der laufenden Summe gespeichert, und anschließend wird die- <xref:System.Threading.Interlocked.CompareExchange%2A> Methode verwendet, um die neu berechnete Summe mit der alten Summe auszutauschen. Wenn der Rückgabewert nicht gleich dem gespeicherten Wert der laufenden Summe ist, hat ein anderer Thread die Summe in der Zwischenzeit aktualisiert. In diesem Fall muss der Versuch, die laufende Summe zu aktualisieren, wiederholt werden.  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static uint CompareExchange (ref uint location1, uint value, uint comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 CompareExchange(unsigned int32&amp; location1, unsigned int32 value, unsigned int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.UInt32@,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As UInteger, value As UInteger, comparand As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 CompareExchange(System::UInt32 % location1, System::UInt32 value, System::UInt32 comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : uint32 * uint32 * uint32 -&gt; uint32" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="comparand" Type="System.UInt32" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">Das Ziel, dessen Wert mit <paramref name="comparand" /> verglichen und möglicherweise ersetzt wird.</param>
        <param name="value">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
        <param name="comparand">Der Wert, der mit dem Wert bei <paramref name="location1" /> verglichen wird.</param>
        <summary>Vergleicht zwei 32-Bit-Ganzzahlen ohne Vorzeichen auf Gleichheit und ersetzt den ersten Wert, wenn sie gleich sind.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static ulong CompareExchange (ref ulong location1, ulong value, ulong comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 CompareExchange(unsigned int64&amp; location1, unsigned int64 value, unsigned int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.UInt64@,System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As ULong, value As ULong, comparand As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 CompareExchange(System::UInt64 % location1, System::UInt64 value, System::UInt64 comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : uint64 * uint64 * uint64 -&gt; uint64" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="comparand" Type="System.UInt64" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">Das Ziel, dessen Wert mit <paramref name="comparand" /> verglichen und möglicherweise ersetzt wird.</param>
        <param name="value">Der Wert, der den Zielwert ersetzt, wenn der Vergleich Gleichheit ergibt.</param>
        <param name="comparand">Der Wert, der mit dem Wert bei <paramref name="location1" /> verglichen wird.</param>
        <summary>Vergleicht zwei 64-Bit-Ganzzahlen ohne Vorzeichen auf Gleichheit und ersetzt den ersten Wert, wenn sie gleich sind.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CompareExchange&lt;class T&gt;(!!T&amp; location1, !!T value, !!T comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange(Of T As Class) (ByRef location1 As T, value As T, comparand As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T CompareExchange(T % location1, T value, T comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : 'T * 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="T" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ, der für <paramref name="location1" />, <paramref name="value" /> und <paramref name="comparand" /> verwendet werden soll. Dieser Typ muss ein Referenztyp sein.</typeparam>
        <param name="location1">Das Ziel, dessen Wert mit <paramref name="comparand" /> nach Verweis verglichen und möglicherweise ersetzt wird. Dies ist ein Verweisparameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</param>
        <param name="value">Der Wert, der den Zielwert ersetzt, wenn der Vergleich nach Verweis Gleichheit ergibt.</param>
        <param name="comparand">Der Wert, der nach Verweis mit dem Wert bei <paramref name="location1" /> verglichen wird.</param>
        <summary>Vergleicht zwei Instanzen des angegebenen Referenztyps <paramref name="T" /> hinsichtlich ihrer Verweisgleichheit und ersetzt bei vorliegender Gleichheit den ersten.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparand` und der Wert in `location1` gleich der Verweis sind, `value` wird in gespeichert `location1` . Andernfalls wird kein Vorgang ausgeführt. Der Vergleich und der Austausch werden als atomarer Vorgang ausgeführt. Der Rückgabewert dieser Methode ist der ursprüngliche Wert in, unabhängig davon `location1` , ob der Exchange-Vorgang stattfindet.  
  
 Diese Methode unterstützt nur Verweis Typen. Es gibt über Ladungen der <xref:System.Threading.Interlocked.CompareExchange%2A> -Methode für die Werttypen,,, <xref:System.Int32> <xref:System.Int64> <xref:System.IntPtr> <xref:System.Single> und <xref:System.Double> , aber es gibt keine Unterstützung für andere Werttypen.  
  
> [!NOTE]
>  Diese Methoden Überladung ist der- <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> Methoden Überladung vorzuziehen, da Letztere erfordert, dass der Zugriff auf das Zielobjekt spät gebunden ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein NULL-Zeiger.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dekrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Decrement(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Decrement(int % location);" />
      <MemberSignature Language="F#" Value="static member Decrement : int -&gt; int" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Die Variable, deren Wert dekrementiert werden soll.</param>
        <summary>Dekrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
        <returns>Der dekrementierte Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode behandelt eine Überlauf Bedingung durch Wrapping: If `location`  =  <xref:System.Int32.MinValue?displayProperty=nameWithType> , `location` -1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType> . Es werden keine Ausnahmen ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, wie viele Zufallszahlen zwischen 0 und 1.000 erforderlich sind, um 1.000 Zufallszahlen mit einem Mittelpunkt Wert zu generieren. Um die Anzahl der Mittelpunkt Werte nachzuverfolgen, wird eine Variable, `midpointCount` , auf 1.000 festgelegt und dekrementiert, wenn der Zufallszahlengenerator einen Mittelpunkt Wert zurückgibt. Da drei Threads die Zufallszahlen generieren, wird die- <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> Methode aufgerufen, um sicherzustellen, dass mehrere Threads nicht `midpointCount` gleichzeitig aktualisiert werden. Beachten Sie, dass eine Sperre auch verwendet wird, um den Zufallszahlengenerator zu schützen, und dass ein- <xref:System.Threading.CountdownEvent> Objekt verwendet wird, um sicherzustellen, dass die- `Main` Methode die Ausführung vor den drei Threads nicht beendet.  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Decrement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  
  
 Das folgende Beispiel ähnelt dem vorherigen, mit der Ausnahme, dass es die- <xref:System.Threading.Tasks.Task> Klasse anstelle einer Thread Prozedur verwendet, um 50.000 zufällige Mittelpunkt-Ganzzahlen zu generieren. In diesem Beispiel wird durch einen Lambda-Ausdruck die `GenerateNumbers` Thread Prozedur ersetzt, und durch den-Aufrufvorgang <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> entfällt die Notwendigkeit des- <xref:System.Threading.CountdownEvent> Objekts.  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]
 [!code-vb[System.Threading.Interlocked.Decrement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Adresse von <paramref name="location" /> ist ein <see langword="null" />-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Decrement(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Decrement(long % location);" />
      <MemberSignature Language="F#" Value="static member Decrement : int64 -&gt; int64" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Die Variable, deren Wert dekrementiert werden soll.</param>
        <summary>Dekrementiert den Wert der angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
        <returns>Der dekrementierte Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode behandelt eine Überlauf Bedingung durch Wrapping: If `location`  =  <xref:System.Int64.MinValue?displayProperty=nameWithType> , `location` -1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType> . Es werden keine Ausnahmen ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Adresse von <paramref name="location" /> ist ein <see langword="null" />-Zeiger.</exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static uint Decrement (ref uint location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Decrement(unsigned int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Decrement(System::UInt32 % location);" />
      <MemberSignature Language="F#" Value="static member Decrement : uint32 -&gt; uint32" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location">Die Variable, deren Wert dekrementiert werden soll.</param>
        <summary>Dekrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
        <returns>Der dekrementierte Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static ulong Decrement (ref ulong location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Decrement(unsigned int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Decrement(System::UInt64 % location);" />
      <MemberSignature Language="F#" Value="static member Decrement : uint64 -&gt; uint64" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location">Die Variable, deren Wert dekrementiert werden soll.</param>
        <summary>Dekrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
        <returns>Der dekrementierte Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt eine Variable in einer atomaren Operation auf einen angegebenen Wert fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exchange(float64&amp; location1, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Double, value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exchange(double % location1, double value);" />
      <MemberSignature Language="F#" Value="static member Exchange : double * double -&gt; double" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
        <param name="value">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</param>
        <summary>Legt in einer atomaren Operation eine Gleitkommazahl mit doppelter Genauigkeit auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
        <returns>Der ursprüngliche Wert von <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Exchange(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Exchange(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Exchange : int * int -&gt; int" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
        <param name="value">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</param>
        <summary>Legt eine 32-Bit-Ganzzahl mit Vorzeichen in einer atomaren Operation auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
        <returns>Der ursprüngliche Wert von <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel zeigt einen Thread sicheren Mechanismus zum Sperren von Ressourcen.  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Exchange(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Exchange(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Exchange : int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
        <param name="value">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</param>
        <summary>Legt eine 64-Bit-Ganzzahl mit Vorzeichen in einer atomaren Operation auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
        <returns>Der ursprüngliche Wert von <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Exchange(native int&amp; location1, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As IntPtr, value As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Exchange(IntPtr % location1, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member Exchange : nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
        <param name="value">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</param>
        <summary>Legt in einer atomaren Operation ein plattformspezifisches Handle bzw. einen plattformspezifischen Zeiger auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
        <returns>Der ursprüngliche Wert von <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Exchange(object&amp; location1, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Object, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Exchange(System::Object ^ % location1, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Exchange : obj * obj -&gt; obj" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
        <param name="value">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</param>
        <summary>Legt in einer atomaren Operation ein Objekt auf einen angegebenen Wert fest und gibt einen Verweis auf das ursprüngliche Objekt zurück.</summary>
        <returns>Der ursprüngliche Wert von <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> Ab .NET Framework 2.0 bietet die Überladung der <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29>-Methoden eine typsichere Alternative für Verweistypen. Es wird empfohlen, dass Sie diese anstelle dieser Überladung aufrufen.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exchange(float32&amp; location1, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Single, value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exchange(float % location1, float value);" />
      <MemberSignature Language="F#" Value="static member Exchange : single * single -&gt; single" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
        <param name="value">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</param>
        <summary>Legt in einer atomaren Operation eine Gleitkommazahl mit einfacher Genauigkeit auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
        <returns>Der ursprüngliche Wert von <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static uint Exchange (ref uint location1, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Exchange(unsigned int32&amp; location1, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As UInteger, value As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Exchange(System::UInt32 % location1, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member Exchange : uint32 * uint32 -&gt; uint32" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
        <param name="value">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</param>
        <summary>Legt eine 32-Bit-Ganzzahl ohne Vorzeichen auf einen angegebenen Wert fest und gibt den ursprünglichen Wert als atomare Operation zurück.</summary>
        <returns>Der ursprüngliche Wert von <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static ulong Exchange (ref ulong location1, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Exchange(unsigned int64&amp; location1, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As ULong, value As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Exchange(System::UInt64 % location1, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member Exchange : uint64 * uint64 -&gt; uint64" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">Die Variable, die auf den angegebenen Wert festgelegt werden soll.</param>
        <param name="value">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</param>
        <summary>Legt eine 64-Bit-Ganzzahl ohne Vorzeichen auf einen angegebenen Wert fest und gibt den ursprünglichen Wert als atomare Operation zurück.</summary>
        <returns>Der ursprüngliche Wert von <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Exchange&lt;class T&gt;(!!T&amp; location1, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange``1(``0@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange(Of T As Class) (ByRef location1 As T, value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T Exchange(T % location1, T value);" />
      <MemberSignature Language="F#" Value="static member Exchange : 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ, der für <paramref name="location1" /> und <paramref name="value" /> verwendet werden soll. Dieser Typ muss ein Referenztyp sein.</typeparam>
        <param name="location1">Die Variable, die auf den angegebenen Wert festgelegt werden soll. Dies ist ein Verweisparameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</param>
        <param name="value">Der Wert, auf den der <paramref name="location1" />-Parameter festgelegt ist.</param>
        <summary>Legt eine Variable vom angegebenen Typ <paramref name="T" /> in einer atomaren Operation auf einen angegebenen Wert fest und gibt den ursprünglichen Wert zurück.</summary>
        <returns>Der ursprüngliche Wert von <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nur Verweis Typen. Es gibt über Ladungen der <xref:System.Threading.Interlocked.Exchange%2A> -Methode für die <xref:System.Int32> <xref:System.Int64> <xref:System.IntPtr> <xref:System.Single> Werttypen,,, und <xref:System.Double> , aber es gibt keine Unterstützung für andere Werttypen.  
  
> [!NOTE]
>  Diese Methoden Überladung ist der- <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> Methoden Überladung vorzuziehen, da letztere den spät gebundenen Zugriff auf das Zielobjekt erfordert.  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inkrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Increment(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Increment(int % location);" />
      <MemberSignature Language="F#" Value="static member Increment : int -&gt; int" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Die Variable, deren Wert inkrementiert werden soll.</param>
        <summary>Inkrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
        <returns>Der inkrementierte Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode behandelt eine Überlauf Bedingung durch Umbrüchen: If `location`  =  <xref:System.Int32.MaxValue?displayProperty=nameWithType> , `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType> . Es werden keine Ausnahmen ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, wie viele Zufallszahlen zwischen 0 und 1.000 erforderlich sind, um 1.000 Zufallszahlen mit einem Mittelpunkt Wert zu generieren. Um die Anzahl der Mittelpunkt Werte nachzuverfolgen, wird eine Variable, `midpointCount` , auf 0 festgelegt und jedes Mal erhöht, wenn der Zufallszahlen-Generator einen Mittelpunkt Wert zurückgibt, bis 10.000 erreicht wird. Da drei Threads die Zufallszahlen generieren, wird die- <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> Methode aufgerufen, um sicherzustellen, dass mehrere Threads nicht `midpointCount` gleichzeitig aktualisiert werden. Beachten Sie, dass eine Sperre auch verwendet wird, um den Zufallszahlengenerator zu schützen, und dass ein- <xref:System.Threading.CountdownEvent> Objekt verwendet wird, um sicherzustellen, dass die- `Main` Methode die Ausführung vor den drei Threads nicht beendet.  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]
 [!code-vb[System.Threading.Interlocked.Increment2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  
  
 Das folgende Beispiel ähnelt dem vorherigen, mit der Ausnahme, dass es die- <xref:System.Threading.Tasks.Task> Klasse anstelle einer Thread Prozedur verwendet, um 50.000 zufällige Mittelpunkt-Ganzzahlen zu generieren. In diesem Beispiel wird durch einen Lambda-Ausdruck die `GenerateNumbers` Thread Prozedur ersetzt, und durch den-Aufrufvorgang <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> entfällt die Notwendigkeit des- <xref:System.Threading.CountdownEvent> Objekts.  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]
 [!code-vb[System.Threading.Interlocked.Increment2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location" /> ist ein <see langword="null" />-Zeiger.</exception>
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Increment(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Increment(long % location);" />
      <MemberSignature Language="F#" Value="static member Increment : int64 -&gt; int64" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Die Variable, deren Wert inkrementiert werden soll.</param>
        <summary>Inkrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
        <returns>Der inkrementierte Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode behandelt eine Überlauf Bedingung durch Umbrüchen: If `location`  =  <xref:System.Int64.MaxValue?displayProperty=nameWithType> , `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType> . Es werden keine Ausnahmen ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location" /> ist ein <see langword="null" />-Zeiger.</exception>
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static uint Increment (ref uint location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Increment(unsigned int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Increment(System::UInt32 % location);" />
      <MemberSignature Language="F#" Value="static member Increment : uint32 -&gt; uint32" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location">Die Variable, deren Wert inkrementiert werden soll.</param>
        <summary>Inkrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
        <returns>Der inkrementierte Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static ulong Increment (ref ulong location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Increment(unsigned int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Increment(System::UInt64 % location);" />
      <MemberSignature Language="F#" Value="static member Increment : uint64 -&gt; uint64" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location">Die Variable, deren Wert inkrementiert werden soll.</param>
        <summary>Inkrementiert den Wert einer angegebenen Variablen und speichert das Ergebnis in einer atomaren Operation.</summary>
        <returns>Der inkrementierte Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Synchronisiert den Speicherzugriff wie folgt: Der Prozessor, der den aktuellen Thread ausführt, kann Anweisungen nicht so neu anordnen, dass Speicherzugriffe vor dem Aufruf von <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> nach Speicherzugriffen ausgeführt werden, die nach dem Aufruf <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> erfolgen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wurde der <xref:System.Threading.Interlocked> -Klasse in der-Klasse hinzugefügt [!INCLUDE[net_v45](~/includes/net-v45-md.md)] . es handelt sich um einen Wrapper für die- <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> Methode.  
  
 In den meisten Fällen bietet die c#- `lock` Anweisung, die Visual Basic- `SyncLock` Anweisung oder die- <xref:System.Threading.Monitor> Klasse einfachere Möglichkeiten zum Synchronisieren von Daten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrierProcessWide">
      <MemberSignature Language="C#" Value="public static void MemoryBarrierProcessWide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrierProcessWide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrierProcessWide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrierProcessWide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrierProcessWide();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrierProcessWide : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrierProcessWide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bietet eine prozessübergreifende Arbeitsspeicherbarriere, die verhindert, dass Lese- und Schreibvorgänge von CPUs über die Barriere hinaus verschoben werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Die- `MemoryBarrierProcessWide` Methode unterscheidet sich von der "normalen" <xref:System.Threading.Interlocked.MemoryBarrier%2A> Methode wie folgt:

- Die normale Speicherbarriere stellt sicher, dass die Lese-und Schreibvorgänge von der aktuellen CPU nicht über die Barriere hinaus verschoben werden können. Die Prozess weite Speicherbarriere stellt sicher, dass alle Lese-und Schreibvorgänge aus beliebigen CPU, die im Prozess verwendet werden, nicht über die Barriere verschoben werden können.

- Die normale Speicherbarriere ermöglicht einen angemessenen freigegebenen Zugriff, wenn *jeder* Thread, der auf die Daten zugreift, Barrieren verwendet Die Prozess weite Speicherbarriere zwingt die Synchronisierung *anderer CPUs* mit dem Prozess Speicher (z. b. zum leeren von Schreib Puffern und Synchronisieren von Lese Puffern). Dies ermöglicht nicht Interlocked-Vorgänge für einige Threads und hat dennoch einen angemessenen gemeinsamen Zugriff. 

- Die normale Speicherbarriere zwingt sehr wenig mehr Aufwand. normale Interlocked-Vorgänge Kosten wahrscheinlich weniger als hundert Zyklen. Die Prozess weite Speicherbarriere ist sehr aufwendig. Es muss jede CPU im Prozess mit einer wahrscheinlichen Kosten Anzahl von Tausenden von Zyklen erzwingen. 

Die- `MemoryBarrierProcessWide` Methode wird auch von allen Feinheiten der sperrenlosen Programmierung unterschieden. Dennoch kann diese Methode äußerst nützlich sein, wenn Sie Sie tatsächlich anrufen müssen, was selten vorkommen sollte.

Diese Methode umschließt einen Aufrufen von [flushprocesswrite tebuffers](/windows/win32/api/processthreadsapi/nf-processthreadsapi-flushprocesswritebuffers) unter Windows und [sys_membarrier](https://lore.kernel.org/patchwork/patch/188708/) unter Linux.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static int Or (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Or(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Or(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Or(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Or : int * int -&gt; int" Usage="System.Threading.Interlocked.Or (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">Eine Variable, die den ersten Wert enthält, der kombiniert werden soll. Das Ergebnis wird in <paramref name="location1" /> gespeichert.</param>
        <param name="value">Der Wert, der an <paramref name="location1" /> mit der Ganzzahl kombiniert werden soll.</param>
        <summary>Wendet „or“ bitweise auf zwei 32-Bit-Ganzzahlen mit Vorzeichen an und ersetzt die erste Ganzzahl durch das Ergebnis als atomarer Vorgang.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static long Or (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Or(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Or(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Or(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Or : int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.Or (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">Eine Variable, die den ersten Wert enthält, der kombiniert werden soll. Das Ergebnis wird in <paramref name="location1" /> gespeichert.</param>
        <param name="value">Der Wert, der an <paramref name="location1" /> mit der Ganzzahl kombiniert werden soll.</param>
        <summary>Wendet „or“ bitweise auf zwei 64-Bit-Ganzzahlen mit Vorzeichen an und ersetzt die erste Ganzzahl durch das Ergebnis als atomare Operation.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static uint Or (ref uint location1, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Or(unsigned int32&amp; location1, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Or(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (ByRef location1 As UInteger, value As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Or(System::UInt32 % location1, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member Or : uint32 * uint32 -&gt; uint32" Usage="System.Threading.Interlocked.Or (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">Eine Variable, die den ersten Wert enthält, der kombiniert werden soll. Das Ergebnis wird in <paramref name="location1" /> gespeichert.</param>
        <param name="value">Der Wert, der an <paramref name="location1" /> mit der Ganzzahl kombiniert werden soll.</param>
        <summary>Wendet „or“ bitweise auf zwei 32-Bit-Ganzzahlen ohne Vorzeichen an und ersetzt die erste Ganzzahl durch das Ergebnis als atomare Operation.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static ulong Or (ref ulong location1, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Or(unsigned int64&amp; location1, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Or(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (ByRef location1 As ULong, value As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Or(System::UInt64 % location1, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member Or : uint64 * uint64 -&gt; uint64" Usage="System.Threading.Interlocked.Or (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location1">Eine Variable, die den ersten Wert enthält, der kombiniert werden soll. Das Ergebnis wird in <paramref name="location1" /> gespeichert.</param>
        <param name="value">Der Wert, der an <paramref name="location1" /> mit der Ganzzahl kombiniert werden soll.</param>
        <summary>Wendet „or“ bitweise auf zwei 64-Bit-Ganzzahlen ohne Vorzeichen an und ersetzt die erste Ganzzahl durch das Ergebnis als atomare Operation.</summary>
        <returns>Der ursprüngliche Wert in <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Die Adresse von <paramref name="location1" /> ist ein <see langword="null" />-Zeiger.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Read(long % location);" />
      <MemberSignature Language="F#" Value="static member Read : int64 -&gt; int64" Usage="System.Threading.Interlocked.Read location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location">Der zu ladende 64-Bit-Wert.</param>
        <summary>Gibt einen 64-Bit-Wert zurück, der in einer atomaren Operation geladen wird.</summary>
        <returns>Der geladene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Interlocked.Read%2A> -Methode ist auf 64-Bit-Systemen nicht erforderlich, da 64-Bit-Lesevorgänge bereits atomarisch sind. Auf 32-Bit-Systemen sind 64-Bit-Lesevorgänge nicht atomarisch, es sei denn <xref:System.Threading.Interlocked.Read%2A> , Sie werden mit ausgeführt  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <related type="Article" href="/dotnet/standard/threading/">Verwaltetes Threading</related>
        <related type="Article" href="/dotnet/standard/threading/overview-of-synchronization-primitives">Übersicht über Synchronisierungsprimitive</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static ulong Read (ref ulong location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Read(unsigned int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (ByRef location As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Read(System::UInt64 % location);" />
      <MemberSignature Language="F#" Value="static member Read : uint64 -&gt; uint64" Usage="System.Threading.Interlocked.Read location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="location">Der zu ladende 64-Bit-Wert.</param>
        <summary>Gibt einen 64-Bit-Wert ohne Vorzeichen zurück, der als atomare Operation geladen wurde.</summary>
        <returns>Der geladene Wert.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeculationBarrier">
      <MemberSignature Language="C#" Value="public static void SpeculationBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpeculationBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.SpeculationBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpeculationBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpeculationBarrier();" />
      <MemberSignature Language="F#" Value="static member SpeculationBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.SpeculationBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Definiert einen Arbeitsspeicher-Fence, der eine spekulative Ausführung über diesen Punkt hinaus blockiert, bis ausstehende Lese- und Schreibvorgänge abgeschlossen sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Die- `SpeculationBarrier` Methode definiert einen speicherfence (eine `mfence` -Anweisung für x86-und AMD64-Prozessoren), die die *spekulative* Ausführung bis zu diesem Zeitpunkt blockiert, bis ausstehende Lese-und Schreibvorgänge abgeschlossen sind. 

 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
