<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Interlocked.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5883047e940a7b189bf8c52c13e9ba85d0fb9bf82.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">883047e940a7b189bf8c52c13e9ba85d0fb9bf82</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Provides atomic operations for variables that are shared by multiple threads.</source>
          
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors.</source>
          <target state="translated">Die Methoden dieser Klasse schützen vor Fehlern, die auftreten können, wenn das Zeitplanungsmodul Kontexten wechselt, während ein Thread eine Variable aktualisiert, die von anderen Threads zugegriffen werden kann, oder wenn zwei Threads gleichzeitig auf separaten Prozessoren ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The members of this class do not throw exceptions.</source>
          <target state="translated">Die Member dieser Klasse lösen keine Ausnahmen.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph> methods increment or decrement a variable and store the resulting value in a single operation.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph> Methoden erhöhen oder verringern Sie eine Variable und den resultierenden Wert in einem einzigen Vorgang zu speichern.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>On most computers, incrementing a variable is not an atomic operation, requiring the following steps:</source>
          <target state="translated">Bei den meisten Computern ist das Inkrementieren einer Variablen nicht atomare Operation unter erfordern die folgenden Schritte aus:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>Load a value from an instance variable into a register.</source>
          <target state="translated">Laden Sie einen Wert aus einer Instanzvariablen in ein Register.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>Increment or decrement the value.</source>
          <target state="translated">Erhöhen Sie oder verringern Sie den Wert.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>Store the value in the instance variable.</source>
          <target state="translated">Speichern Sie den Wert in der Instanzvariablen.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>If you do not use <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, a thread can be preempted after executing the first two steps.</source>
          <target state="translated">Wenn Sie nicht verwenden <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, kann ein Thread unterbrochen werden, nach der ersten beiden Schritte ausführen.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>Another thread can then execute all three steps.</source>
          <target state="translated">Ein anderer Thread kann dann alle drei Schritte ausführen.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.</source>
          <target state="translated">Wenn der erste Thread die Ausführung fortsetzt, wird den Wert in der Instanzvariablen überschrieben und geht verloren, die Auswirkungen der das Inkrement oder Dekrement vom zweiten Thread ausgeführt.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> method atomically exchanges the values of the specified variables.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> Methode atomar tauscht die Werte der angegebenen Variablen.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> -Methode kombiniert zwei Operationen: Vergleichen von zwei Werten, und speichern eine dritte in eine der Variablen, abhängig vom Ergebnis des Vergleichs Wert.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">Die Vergleichs- und Austausch-Vorgänge werden als atomarer Vorgang ausgeführt.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The following code example shows a thread-safe resource locking mechanism.</source>
          <target state="translated">Das folgende Codebeispiel zeigt einen Thread-sichere Ressource Sperrmechanismus.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>This type is thread safe.</source>
          <target state="translated">Dieser Typ ist threadsicher.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Adds two integers and replaces the first integer with the sum, as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>A variable containing the first value to be added.</source>
          
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>The sum of the two values is stored in <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>The value to be added to the integer at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>The new value stored at <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>This method handles an overflow condition by wrapping: if the value at <ph id="ph1">`location1`</ph> is <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`value`</ph> is 1, the result is <ph id="ph4">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>; if <ph id="ph5">`value`</ph> is 2, the result is (<ph id="ph6">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> + 1); and so on.</source>
          <target state="translated">Diese Methode behandelt einen Überlauf durch wrapping: Wenn der Wert an <ph id="ph1">`location1`</ph> ist <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> und <ph id="ph3">`value`</ph> 1 ist, ist das Ergebnis <ph id="ph4">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>; Wenn <ph id="ph5">`value`</ph> gleich 2 ist, ist das Ergebnis (<ph id="ph6">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> + 1); und so weiter.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">Es werden keine Ausnahmen ausgelöst.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>A variable containing the first value to be added.</source>
          
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>The sum of the two values is stored in <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>The value to be added to the integer at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>The new value stored at <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>This method handles an overflow condition by wrapping: if the value at <ph id="ph1">`location1`</ph> is <ph id="ph2">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`value`</ph> is 1, the result is <ph id="ph4">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>; if <ph id="ph5">`value`</ph> is 2, the result is (<ph id="ph6">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph> + 1); and so on.</source>
          <target state="translated">Diese Methode behandelt einen Überlauf durch wrapping: Wenn der Wert an <ph id="ph1">`location1`</ph> ist <ph id="ph2">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph> und <ph id="ph3">`value`</ph> 1 ist, ist das Ergebnis <ph id="ph4">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>; Wenn <ph id="ph5">`value`</ph> gleich 2 ist, ist das Ergebnis (<ph id="ph6">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph> + 1); und so weiter.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>No exception is thrown.</source>
          <target state="translated">Es werden keine Ausnahmen ausgelöst.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method and the 64-bit overloads of the <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> methods are truly atomic only on systems where a <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> is 64 bits long.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> -Methode und die 64-Bit-Überladungen der <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, und <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> Methoden sind tatsächlich atomar nur auf Systemen, in denen eine <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> 64 Bit lang ist.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</source>
          <target state="translated">Auf anderen Systemen werden diese Methoden atomic in Bezug zu anderen, jedoch nicht in Bezug auf andere Weise den Zugriff auf die Daten.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class.</source>
          <target state="translated">Folglich um Threadsicherheit auf 32-Bit-Systemen zu sein, Zugriff auf einen 64-Bit-Wert muss erfolgen, durch die Mitglieder der <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Compares two values for equality and, if they are equal, replaces the first value.</source>
          
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The destination, whose value is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The value that replaces the destination value if the comparison results in equality.</source>
          
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The value that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</source>
          
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`comparand`</ph> und der Wert im <ph id="ph2">`location1`</ph> gleich sind, klicken Sie dann <ph id="ph3">`value`</ph> befindet sich in <ph id="ph4">`location1`</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">Andernfalls wird kein Vorgang ausgeführt.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">Die Vergleichs- und Austausch-Vorgänge werden als atomarer Vorgang ausgeführt.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The return value of <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id="ph2">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">Der Rückgabewert der <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> ist der ursprüngliche Wert in <ph id="ph2">`location1`</ph>, unabhängig davon, ob der Exchange-stattfindet.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The following code example demonstrates a thread-safe method that accumulates a running total of <ph id="ph1">&lt;xref:System.Double&gt;</ph> values.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, eine threadsichere-Methode, die eine laufende Summe akkumuliert <ph id="ph1">&lt;xref:System.Double&gt;</ph> Werte.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>Two threads add a series of <ph id="ph1">&lt;xref:System.Double&gt;</ph> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</source>
          <target state="translated">Zwei Threads hinzufügen, eine Reihe von <ph id="ph1">&lt;xref:System.Double&gt;</ph> Werte mit der Thread-sichere Methode und dem normalen hinzufügen und beim Beenden der Threads die Ergebnisse werden verglichen.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>On a dual-processor computer, there is a significant difference in the totals.</source>
          <target state="translated">Auf einem Computer mit Dual-Prozessor ist es ein signifikanter Unterschied bei den Gesamtergebnissen.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>In the thread-safe method, the initial value of the running total is saved, and then the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method is used to exchange the newly computed total with the old total.</source>
          <target state="translated">In der Thread-sichere Methode, der anfängliche Wert des der laufenden Summe gespeichert wird, und klicken Sie dann die <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> Methode wird verwendet, um die neu berechneten insgesamt mit den alten Gesamtwert austauschen.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</source>
          <target state="translated">Ist der Rückgabewert nicht gleich dem gespeicherten Wert für die laufende Summe, hat dann einen anderen Thread die Summe in der Zwischenzeit aktualisiert.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>In that case, the attempt to update the running total must be repeated.</source>
          <target state="translated">In diesem Fall muss der Versuch, die laufende Summe aktualisieren wiederholt werden.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The destination, whose value is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The value that replaces the destination value if the comparison results in equality.</source>
          
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The value that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</source>
          
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`comparand`</ph> und der Wert im <ph id="ph2">`location1`</ph> gleich sind, klicken Sie dann <ph id="ph3">`value`</ph> befindet sich in <ph id="ph4">`location1`</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">Andernfalls wird kein Vorgang ausgeführt.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">Die Vergleichs- und Austausch-Vorgänge werden als atomarer Vorgang ausgeführt.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The return value of <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id="ph2">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">Der Rückgabewert der <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> ist der ursprüngliche Wert in <ph id="ph2">`location1`</ph>, unabhängig davon, ob der Exchange-stattfindet.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The following code example demonstrates a thread-safe method that accumulates a running total.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, eine threadsichere-Methode, die einen laufenden Gesamtbetrag ansammelt.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The initial value of the running total is saved, and then the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method is used to exchange the newly computed total with the old total.</source>
          <target state="translated">Der Anfangswert von der laufenden Summe gespeichert wird, und klicken Sie dann die <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> Methode wird verwendet, um die neu berechneten insgesamt mit den alten Gesamtwert austauschen.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</source>
          <target state="translated">Ist der Rückgabewert nicht gleich dem gespeicherten Wert für die laufende Summe, hat dann einen anderen Thread die Summe in der Zwischenzeit aktualisiert.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>In that case, the attempt to update the running total must be repeated.</source>
          <target state="translated">In diesem Fall muss der Versuch, die laufende Summe aktualisieren wiederholt werden.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> -Methode, eingeführt in Version 2.0 von .NET Framework bietet einen Bequemerer Weg, Thread-sichere laufende Summen für ganze Zahlen zu sammeln.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The destination, whose value is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The value that replaces the destination value if the comparison results in equality.</source>
          
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The value that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</source>
          
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`comparand`</ph> und der Wert im <ph id="ph2">`location1`</ph> gleich sind, klicken Sie dann <ph id="ph3">`value`</ph> befindet sich in <ph id="ph4">`location1`</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">Andernfalls wird kein Vorgang ausgeführt.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">Die Vergleichs- und Austausch-Vorgänge werden als atomarer Vorgang ausgeführt.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The return value of <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id="ph2">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">Der Rückgabewert der <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> ist der ursprüngliche Wert in <ph id="ph2">`location1`</ph>, unabhängig davon, ob der Exchange-stattfindet.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The destination <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>, whose value is compared with the value of <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced by <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept>.</source>
          
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> that replaces the destination value if the comparison results in equality.</source>
          
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</source>
          
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`comparand`</ph> und der Wert im <ph id="ph2">`location1`</ph> gleich sind, klicken Sie dann <ph id="ph3">`value`</ph> befindet sich in <ph id="ph4">`location1`</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">Andernfalls wird kein Vorgang ausgeführt.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">Die Vergleichs- und Austausch-Vorgänge werden als atomarer Vorgang ausgeführt.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The return value of this method is the original value in <ph id="ph1">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">Der Rückgabewert dieser Methode wird der ursprüngliche Wert in <ph id="ph1">`location1`</ph>, unabhängig davon, ob der Exchange-stattfindet.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> is a platform-specific type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> ist ein Plattformspezifischer Typ.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The destination object that is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The object that replaces the destination object if the comparison results in equality.</source>
          
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The object that is compared to the object at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>Compares two objects for reference equality and, if they are equal, replaces the first object.</source>
          
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>If <ph id="ph1">`comparand`</ph> and the object in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`comparand`</ph> und das Objekt im <ph id="ph2">`location1`</ph> gleich sind, klicken Sie dann <ph id="ph3">`value`</ph> befindet sich in <ph id="ph4">`location1`</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">Andernfalls wird kein Vorgang ausgeführt.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">Die Vergleichs- und Austausch-Vorgänge werden als atomarer Vorgang ausgeführt.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The return value of <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id="ph2">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">Der Rückgabewert der <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> ist der ursprüngliche Wert in <ph id="ph2">`location1`</ph>, unabhängig davon, ob der Exchange-stattfindet.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>Beginning with .NET Framework version 2.0, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29&gt;</ph> method overload provides a type-safe alternative for reference types.</source>
          <target state="translated">Ab .NET Framework, Version 2.0, die <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29&gt;</ph> methodenüberladung bietet eine typsichere Alternative für Verweistypen.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The objects are compared for reference equality, rather than <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Die Objekte für vergleichsgleichheit, verglichen werden und nicht als <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal, and no operation is performed.</source>
          <target state="translated">Daher zwei geschachtelte Instanzen des gleichen Werttyp (z. B. die ganze Zahl 3) immer angezeigt werden, und es wird kein Vorgang ausgeführt.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>Do not use this overload with value types.</source>
          <target state="translated">Verwenden Sie diese Überladung nicht mit Werttypen.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The destination, whose value is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The value that replaces the destination value if the comparison results in equality.</source>
          
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The value that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</source>
          
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`comparand`</ph> und der Wert im <ph id="ph2">`location1`</ph> gleich sind, klicken Sie dann <ph id="ph3">`value`</ph> befindet sich in <ph id="ph4">`location1`</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">Andernfalls wird kein Vorgang ausgeführt.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">Die Vergleichs- und Austausch-Vorgänge werden als atomarer Vorgang ausgeführt.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The return value of <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id="ph2">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">Der Rückgabewert der <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> ist der ursprüngliche Wert in <ph id="ph2">`location1`</ph>, unabhängig davon, ob der Exchange-stattfindet.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The following code example demonstrates a thread-safe method that accumulates a running total of <ph id="ph1">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, eine threadsichere-Methode, die eine laufende Summe akkumuliert <ph id="ph1">&lt;xref:System.Single&gt;</ph> Werte.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>Two threads add a series of <ph id="ph1">&lt;xref:System.Single&gt;</ph> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</source>
          <target state="translated">Zwei Threads hinzufügen, eine Reihe von <ph id="ph1">&lt;xref:System.Single&gt;</ph> Werte mit der Thread-sichere Methode und dem normalen hinzufügen und beim Beenden der Threads die Ergebnisse werden verglichen.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>On a dual-processor computer, there is a significant difference in the totals.</source>
          <target state="translated">Auf einem Computer mit Dual-Prozessor ist es ein signifikanter Unterschied bei den Gesamtergebnissen.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>In the thread-safe method, the initial value of the running total is saved, and then the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method is used to exchange the newly computed total with the old total.</source>
          <target state="translated">In der Thread-sichere Methode, der anfängliche Wert des der laufenden Summe gespeichert wird, und klicken Sie dann die <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> Methode wird verwendet, um die neu berechneten insgesamt mit den alten Gesamtwert austauschen.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</source>
          <target state="translated">Ist der Rückgabewert nicht gleich dem gespeicherten Wert für die laufende Summe, hat dann einen anderen Thread die Summe in der Zwischenzeit aktualisiert.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>In that case, the attempt to update the running total must be repeated.</source>
          <target state="translated">In diesem Fall muss der Versuch, die laufende Summe aktualisieren wiederholt werden.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The type to be used for <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>, <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept>, and <bpt id="p3">&lt;c&gt;</bpt>comparand<ept id="p3">&lt;/c&gt;</ept>.</source>
          <target state="translated">Der Typ, für die zu verwendende <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>, <bpt id="p2">&lt;c&gt;</bpt>Wert<ept id="p2">&lt;/c&gt;</ept>, und <bpt id="p3">&lt;c&gt;</bpt>Comparand<ept id="p3">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>This type must be a reference type.</source>
          <target state="translated">Dieser Typ muss ein Referenztyp sein.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The destination, whose value is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>This is a reference parameter (<ph id="ph1">&lt;see langword="ref" /&gt;</ph> in C#, <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</source>
          
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The value that replaces the destination value if the comparison results in equality.</source>
          
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The value that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>Compares two instances of the specified reference type <ph id="ph1">&lt;paramref name="T" /&gt;</ph> for equality and, if they are equal, replaces the first one.</source>
          
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`comparand`</ph> und der Wert im <ph id="ph2">`location1`</ph> gleich sind, klicken Sie dann <ph id="ph3">`value`</ph> befindet sich in <ph id="ph4">`location1`</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">Andernfalls wird kein Vorgang ausgeführt.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The comparison and the exchange are performed as an atomic operation.</source>
          <target state="translated">Der Vergleich und die Exchange werden als atomarer Vorgang ausgeführt.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The return value of this method is the original value in <ph id="ph1">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">Der Rückgabewert dieser Methode wird der ursprüngliche Wert in <ph id="ph1">`location1`</ph>, unabhängig davon, ob der Exchange-stattfindet.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>This method only supports reference types.</source>
          <target state="translated">Diese Methode unterstützt nur Verweistypen.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>There are overloads of the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method for the value types <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, <ph id="ph3">&lt;xref:System.Int64&gt;</ph>, <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph5">&lt;xref:System.Single&gt;</ph>, and <ph id="ph6">&lt;xref:System.Double&gt;</ph>, but there is no support for other value types.</source>
          <target state="translated">Es gibt Überladungen der der <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> Methode für die Werttypen <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, <ph id="ph3">&lt;xref:System.Int64&gt;</ph>, <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph5">&lt;xref:System.Single&gt;</ph>, und <ph id="ph6">&lt;xref:System.Double&gt;</ph>, aber es gibt keine Unterstützung für andere Werttypen.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>This method overload is preferable to the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29&gt;</ph> method overload, because the latter requires the destination object to be accessed late-bound.</source>
          <target state="translated">Diese methodenüberladung ist zu bevorzugen die <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29&gt;</ph> Methode zu überladen, da letztere spät gebundener Zugriff auf das Zielobjekt ist erforderlich.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Decrements a specified variable and stores the result, as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>The variable whose value is to be decremented.</source>
          
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>Decrements a specified variable and stores the result, as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>The decremented value.</source>
          
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>This method handles an overflow condition by wrapping: If <ph id="ph1">`location`</ph><ph id="ph2"> = </ph><ph id="ph3">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> - 1 = <ph id="ph5">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Diese Methode behandelt einen Überlauf durch wrapping: Wenn <ph id="ph1">`location`</ph> <ph id="ph2"> = </ph> <ph id="ph3">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> - 1 = <ph id="ph5">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>No exception is thrown.</source>
          <target state="translated">Es werden keine Ausnahmen ausgelöst.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</source>
          <target state="translated">Im folgende Beispiel wird bestimmt, wie viele Zufallszahlen, die zwischen 0 und 1000 liegen 1.000 Zufallszahlen mit einem Wert für den Mittelpunkt erforderlich sind.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>To keep track of the number of midpoint values, a variable, <ph id="ph1">`midpointCount`</ph>, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value.</source>
          <target state="translated">Die Anzahl der Werte für Mittelpunkt, eine Variable des <ph id="ph1">`midpointCount`</ph>, ist gleich 1.000 und dekrementiert jedes Mal der Zufallszahlen-Generator einen Wert für den Mittelpunkt gibt.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>Because three threads generate the random numbers, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29&gt;</ph> method is called to ensure that multiple threads don't update <ph id="ph2">`midpointCount`</ph> concurrently.</source>
          <target state="translated">Da drei Threads, die Zufallszahlen generieren die <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29&gt;</ph> Methode wird aufgerufen, um sicherzustellen, dass mehrere Threads nicht aktualisieren <ph id="ph2">`midpointCount`</ph> gleichzeitig.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>Note that a lock is also used to protect the random number generator, and that a <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object is used to ensure that the <ph id="ph2">`Main`</ph> method doesn't finish execution before the three threads.</source>
          <target state="translated">Beachten Sie, dass eine Sperre auch verwendet wird, schützen Sie den Zufallszahlen-Generator und, ein <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> Objekt wird verwendet, um sicherzustellen, dass die <ph id="ph2">`Main`</ph> Methode nicht ausführen, bevor der drei Threads abgeschlossen.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers.</source>
          <target state="translated">Im folgende Beispiel ähnelt der vorherigen Ansicht identisch, jedoch verwendet die anstelle einer Threadprozedur 50.000 Mittelpunkt zufällige ganze Zahlen zu generieren.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>In this example, a lambda expression replaces the <ph id="ph1">`GenerateNumbers`</ph> thread procedure, and the call to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method eliminates the need for the <ph id="ph3">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object.</source>
          <target state="translated">In diesem Beispiel wird ein Lambda-Ausdruck ersetzt die <ph id="ph1">`GenerateNumbers`</ph> Threadprozedur und der Aufruf an die <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> Methode entfällt die Notwendigkeit für die <ph id="ph3">&lt;xref:System.Threading.CountdownEvent&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>The address of <ph id="ph1">&lt;paramref name="location" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>The variable whose value is to be decremented.</source>
          
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>Decrements the specified variable and stores the result, as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>The decremented value.</source>
          
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>This method handles an overflow condition by wrapping: if <ph id="ph1">`location`</ph><ph id="ph2"> = </ph><ph id="ph3">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> - 1 = <ph id="ph5">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Diese Methode behandelt einen Überlauf durch wrapping: Wenn <ph id="ph1">`location`</ph> <ph id="ph2"> = </ph> <ph id="ph3">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> - 1 = <ph id="ph5">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>No exception is thrown.</source>
          <target state="translated">Es werden keine Ausnahmen ausgelöst.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method and the 64-bit overloads of the <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> methods are truly atomic only on systems where a <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> is 64 bits long.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> -Methode und die 64-Bit-Überladungen der <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, und <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> Methoden sind tatsächlich atomar nur auf Systemen, in denen eine <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> 64 Bit lang ist.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</source>
          <target state="translated">Auf anderen Systemen werden diese Methoden atomic in Bezug zu anderen, jedoch nicht in Bezug auf andere Weise den Zugriff auf die Daten.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class.</source>
          <target state="translated">Folglich um Threadsicherheit auf 32-Bit-Systemen zu sein, Zugriff auf einen 64-Bit-Wert muss erfolgen, durch die Mitglieder der <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>The address of <ph id="ph1">&lt;paramref name="location" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Sets a variable to a specified value as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
          <source>The variable to set to the specified value.</source>
          
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
          <source>Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>The variable to set to the specified value.</source>
          
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>The following code example shows a thread-safe resource locking mechanism.</source>
          <target state="translated">Das folgende Codebeispiel zeigt einen Thread-sichere Ressource Sperrmechanismus.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
          <source>The variable to set to the specified value.</source>
          
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
          <source>Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
          <source>The variable to set to the specified value.</source>
          
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
          <source>Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>The variable to set to the specified value.</source>
          
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>Beginning with .NET Framework version 2.0, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29&gt;</ph> method overload provides a type-safe alternative for reference types.</source>
          <target state="translated">Ab .NET Framework, Version 2.0, die <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29&gt;</ph> methodenüberladung bietet eine typsichere Alternative für Verweistypen.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>The following code example shows the syntax for using <ph id="ph1">`Exchange`</ph> with any reference type object.</source>
          <target state="translated">Das folgende Codebeispiel zeigt die Syntax für die Verwendung von <ph id="ph1">`Exchange`</ph> bei jedem Verweis Typ-Objekt.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
          <source>The variable to set to the specified value.</source>
          
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
          <source>Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The type to be used for <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> and <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Der Typ, für die zu verwendende <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> und <bpt id="p2">&lt;c&gt;</bpt>Wert<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>This type must be a reference type.</source>
          <target state="translated">Dieser Typ muss ein Referenztyp sein.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The variable to set to the specified value.</source>
          
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>This is a reference parameter (<ph id="ph1">&lt;see langword="ref" /&gt;</ph> in C#, <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</source>
          
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>Sets a variable of the specified type <ph id="ph1">&lt;paramref name="T" /&gt;</ph> to a specified value and returns the original value, as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>This method only supports reference types.</source>
          <target state="translated">Diese Methode unterstützt nur Verweistypen.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>There are overloads of the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> method for the <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, <ph id="ph3">&lt;xref:System.Int64&gt;</ph>, <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph5">&lt;xref:System.Single&gt;</ph>, and <ph id="ph6">&lt;xref:System.Double&gt;</ph> value types, but there is no support for other value types.</source>
          <target state="translated">Es gibt Überladungen der der <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> Methode für die <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, <ph id="ph3">&lt;xref:System.Int64&gt;</ph>, <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph5">&lt;xref:System.Single&gt;</ph>, und <ph id="ph6">&lt;xref:System.Double&gt;</ph> Werttypen, aber es gibt keine Unterstützung für andere Werttypen.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>This method overload is preferable to the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29&gt;</ph> method overload, because the latter requires late-bound access to the destination object .</source>
          <target state="translated">Diese methodenüberladung ist zu bevorzugen die <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29&gt;</ph> Methode zu überladen, da letztere spät gebundener Zugriff auf das Zielobjekt ist erforderlich.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The following example launches ten tasks, each of which generates  100 ten-character part numbers.</source>
          <target state="translated">Im folgende Beispiel werden zehn Aufgaben, von die jede 100 zehn Zeichen Teilenummern generiert gestartet.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>It then the part number that is first alphabetically.</source>
          <target state="translated">Es wird dann die Teilenummer, das zuerst in alphabetischer Reihenfolge.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The example uses the <ph id="ph1">`firstWidget`</ph> variable to store the ID that occurs first in the sort order.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">`firstWidget`</ph> Variable zum Speichern der ID, die zuerst erreicht wird, in der Sortierreihenfolge.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>It compares each ID that it generates with the <ph id="ph1">`firstWidget`</ph> value.</source>
          <target state="translated">Es vergleicht jede ID, die sie mit generiert die <ph id="ph1">`firstWidget`</ph> Wert.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>If the new value precedes the current value of <ph id="ph1">`firstWidget`</ph> in the sort order, the example calls the <ph id="ph2">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> method to assign the new value to <ph id="ph3">`firstWidget`</ph>.</source>
          <target state="translated">Wenn der neue Wert den aktuellen Wert der voransteht <ph id="ph1">`firstWidget`</ph> in der Sortierreihenfolge im Beispiel wird die <ph id="ph2">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> Methode, um den neuen Wert zuzuweisen <ph id="ph3">`firstWidget`</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Increments a specified variable and stores the result, as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>The variable whose value is to be incremented.</source>
          
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>Increments a specified variable and stores the result, as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>The incremented value.</source>
          
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>This method handles an overflow condition by wrapping: if <ph id="ph1">`location`</ph><ph id="ph2"> = </ph><ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> + 1 = <ph id="ph5">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Diese Methode behandelt einen Überlauf durch wrapping: Wenn <ph id="ph1">`location`</ph> <ph id="ph2"> = </ph> <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> + 1 = <ph id="ph5">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>No exception is thrown.</source>
          <target state="translated">Es werden keine Ausnahmen ausgelöst.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</source>
          <target state="translated">Im folgende Beispiel wird bestimmt, wie viele Zufallszahlen, die zwischen 0 und 1000 liegen 1.000 Zufallszahlen mit einem Wert für den Mittelpunkt erforderlich sind.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>To keep track of the number of midpoint values, a variable, <ph id="ph1">`midpointCount`</ph>, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000.</source>
          <target state="translated">Die Anzahl der Werte für Mittelpunkt, eine Variable des <ph id="ph1">`midpointCount`</ph>, gleich 0 festgelegt und inkrementiert jedes Mal der Zufallszahlen-Generator einen Wert für den Mittelpunkt gibt bis 10.000 erreicht ist.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>Because three threads generate the random numbers, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%28System.Int32%40%29&gt;</ph> method is called to ensure that multiple threads don't update <ph id="ph2">`midpointCount`</ph> concurrently.</source>
          <target state="translated">Da drei Threads, die Zufallszahlen generieren die <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%28System.Int32%40%29&gt;</ph> Methode wird aufgerufen, um sicherzustellen, dass mehrere Threads nicht aktualisieren <ph id="ph2">`midpointCount`</ph> gleichzeitig.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>Note that a lock is also used to protect the random number generator, and that a <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object is used to ensure that the <ph id="ph2">`Main`</ph> method doesn't finish execution before the three threads.</source>
          <target state="translated">Beachten Sie, dass eine Sperre auch verwendet wird, schützen Sie den Zufallszahlen-Generator und, ein <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> Objekt wird verwendet, um sicherzustellen, dass die <ph id="ph2">`Main`</ph> Methode nicht ausführen, bevor der drei Threads abgeschlossen.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers.</source>
          <target state="translated">Im folgende Beispiel ähnelt der vorherigen Ansicht identisch, jedoch verwendet die anstelle einer Threadprozedur 50.000 Mittelpunkt zufällige ganze Zahlen zu generieren.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>In this example, a lambda expression replaces the <ph id="ph1">`GenerateNumbers`</ph> thread procedure, and the call to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method eliminates the need for the <ph id="ph3">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object.</source>
          <target state="translated">In diesem Beispiel wird ein Lambda-Ausdruck ersetzt die <ph id="ph1">`GenerateNumbers`</ph> Threadprozedur und der Aufruf an die <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> Methode entfällt die Notwendigkeit für die <ph id="ph3">&lt;xref:System.Threading.CountdownEvent&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>The address of <ph id="ph1">&lt;paramref name="location" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>The variable whose value is to be incremented.</source>
          
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>Increments a specified variable and stores the result, as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>The incremented value.</source>
          
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>This method handles an overflow condition by wrapping: if <ph id="ph1">`location`</ph><ph id="ph2"> = </ph><ph id="ph3">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> + 1 = <ph id="ph5">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Diese Methode behandelt einen Überlauf durch wrapping: Wenn <ph id="ph1">`location`</ph> <ph id="ph2"> = </ph> <ph id="ph3">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> + 1 = <ph id="ph5">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>No exception is thrown.</source>
          <target state="translated">Es werden keine Ausnahmen ausgelöst.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method and the 64-bit overloads of the <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> methods are truly atomic only on systems where a <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> is 64 bits long.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> -Methode und die 64-Bit-Überladungen der <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, und <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> Methoden sind tatsächlich atomar nur auf Systemen, in denen eine <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> 64 Bit lang ist.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</source>
          <target state="translated">Auf anderen Systemen werden diese Methoden atomic in Bezug zu anderen, jedoch nicht in Bezug auf andere Weise den Zugriff auf die Daten.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class.</source>
          <target state="translated">Folglich um Threadsicherheit auf 32-Bit-Systemen zu sein, Zugriff auf einen 64-Bit-Wert muss erfolgen, durch die Mitglieder der <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>The address of <ph id="ph1">&lt;paramref name="location" /&gt;</ph> is a null pointer.</source>
          
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.MemoryBarrier">
          <source>Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <ph id="ph1">&lt;see cref="M:System.Threading.Interlocked.MemoryBarrier" /&gt;</ph> execute after memory accesses that follow the call to <ph id="ph2">&lt;see cref="M:System.Threading.Interlocked.MemoryBarrier" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.MemoryBarrier">
          <source>This method was added to the <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class in the <ph id="ph2">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> as a convenience; it's a wrapper for the <ph id="ph3">&lt;xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Diese Methode wurde hinzugefügt, um die <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> -Klasse in der <ph id="ph2">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> einen Schlüsselverweis; es ist ein Wrapper für die <ph id="ph3">&lt;xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.MemoryBarrier">
          <source><ph id="ph1">&lt;xref:System.Threading.Interlocked.MemoryBarrier%2A&gt;</ph> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Interlocked.MemoryBarrier%2A&gt;</ph> ist nur auf Systemen mit mehreren Prozessoren erforderlich, die über unsichere Arbeitsspeicher Reihenfolge (z. B. ein System, das verwendet wird. mehrere Intel Itanium-Prozessoren).</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.MemoryBarrier">
          <source>For most purposes, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, or the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier ways to synchronize data.</source>
          <target state="translated">Für die Mehrzahl der Fälle, die C#- <ph id="ph1">`lock`</ph> -Anweisung, die Visual Basic <ph id="ph2">`SyncLock`</ph> -Anweisung oder der <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> Klasse bereitstellen einfachere Möglichkeiten zur Synchronisierung von Daten.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>The 64-bit value to be loaded.</source>
          
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>Returns a 64-bit value, loaded as an atomic operation.</source>
          
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>The loaded value.</source>
          
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> Methode ist nicht auf 64-Bit-Systemen erforderlich, da 64-Bit-Lesevorgänge bereits atomar sind.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>On 32-bit systems, 64-bit read operations are not atomic unless performed using <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph>.</source>
          <target state="translated">Auf 32-Bit-Systemen, 64-Bit-Lesevorgänge sind nicht atomaren, es sei denn, die mit ausgeführt <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method and the 64-bit overloads of the <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> methods are truly atomic only on systems where a <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> is 64 bits long.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> -Methode und die 64-Bit-Überladungen der <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, und <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> Methoden sind tatsächlich atomar nur auf Systemen, in denen eine <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> 64 Bit lang ist.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</source>
          <target state="translated">Auf anderen Systemen werden diese Methoden atomic in Bezug zu anderen, jedoch nicht in Bezug auf andere Weise den Zugriff auf die Daten.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class.</source>
          <target state="translated">Folglich um Threadsicherheit auf 32-Bit-Systemen zu sein, Zugriff auf einen 64-Bit-Wert muss erfolgen, durch die Mitglieder der <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source><ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> is a platform-specific type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> ist ein Plattformspezifischer Typ.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>