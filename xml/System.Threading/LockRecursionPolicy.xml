<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="LockRecursionPolicy.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac52aaae222fcf2f023007bf6b87e2bf7c7bb83adaa.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2aaae222fcf2f023007bf6b87e2bf7c7bb83adaa</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.LockRecursionPolicy">
          <source>Specifies whether a lock can be entered multiple times by the same thread.</source>
          <target state="translated">Gibt an, ob eine Sperre mehrmals dem gleichen Thread zugewiesen werden kann.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>The default recursion policy depends on the type of lock.</source>
          <target state="translated">Die Standardrichtlinie für die Rekursion hängt vom Typ der Sperre.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>For the default policy and the precise behavior of lock recursion for any given lock type, see the documentation for the type.</source>
          <target state="translated">Die Standardrichtlinie und das genaue Verhalten der Sperre Rekursion für alle angegebenen Sperrtyp finden Sie in der Dokumentation für den Typ.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>For example, the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class does not allow a thread to enter the lock in write mode if it already entered the lock in read mode, regardless of the lock policy setting, in order to reduce the chance of deadlocks.</source>
          <target state="translated">Z. B. die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> Klasse lässt sich nicht auf einen Thread die Sperre im Schreibmodus, wenn er die Sperre im Lesemodus, unabhängig von der Einstellung bereits zugewiesen, um die Wahrscheinlichkeit von Deadlocks zu reduzieren.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>Currently only one lock uses this enumeration:</source>
          <target state="translated">Derzeit nur eine Sperre diese Enumeration wird verwendet:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph></target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> property.</source>
          <target state="translated">Weitere Informationen finden Sie in den Ausführungen zur <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph>-Eigenschaft.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>The following example shows two exception scenarios, one that depends on the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> setting and one that does not.</source>
          <target state="translated">Das folgende Beispiel zeigt zwei Ausnahme Szenarien, die von abhängig ist die <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> festlegen und eine, die nicht der Fall ist.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>In the first scenario, the thread enters the lock in read mode and then tries to enter read mode recursively.</source>
          <target state="translated">Im ersten Szenario wird der Thread die Sperre im Lesemodus und versucht dann Lesemodus rekursiv eingeben.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is created by using the default constructor, which sets recursion policy to NoRecursion, an exception is thrown.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> wird erstellt, mit dem Standardkonstruktor, der Rekursionsrichtlinie für die NoRecursion festgelegt ist, wird eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>If SupportsRecursion is used to create the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Wenn SupportsRecursion, zum Erstellen verwendet wird der <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, wird keine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>In the second scenario, the thread enters the lock in read mode and then tries to enter the lock in write mode.</source>
          <target state="translated">Im zweiten Szenario wird der Thread die Sperre im Lesemodus und versucht dann, die Sperre im Schreibmodus.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown regardless of the lock recursion policy.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> unabhängig von der Rekursionsrichtlinie der Sperre ausgelöst.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.NoRecursion">
          <source>If a thread tries to enter a lock recursively, an exception is thrown.</source>
          <target state="translated">Wenn ein Thread rekursiv versucht, eine Sperre zu erhalten, wird eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.NoRecursion">
          <source>Some classes may allow certain recursions when this setting is in effect.</source>
          <target state="translated">Einige Klassen gestatten gewisse Rekursionen, wenn diese Einstellung aktiv ist.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
          <source>A thread can enter a lock recursively.</source>
          <target state="translated">Ein Thread kann rekursiv eine Sperre erhalten.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
          <source>Some classes may restrict this capability.</source>
          <target state="translated">Einige Klassen beschränken diese Möglichkeit einer rekursiven Zuweisung.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>