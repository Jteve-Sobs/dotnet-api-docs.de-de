<Type Name="LockRecursionPolicy" FullName="System.Threading.LockRecursionPolicy">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8537d427d3e90bd7e5ce3217ad42326fe49300a8" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83522870" /></Metadata><TypeSignature Language="C#" Value="public enum LockRecursionPolicy" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed LockRecursionPolicy extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Threading.LockRecursionPolicy" />
  <TypeSignature Language="VB.NET" Value="Public Enum LockRecursionPolicy" />
  <TypeSignature Language="C++ CLI" Value="public enum class LockRecursionPolicy" />
  <TypeSignature Language="F#" Value="type LockRecursionPolicy = " />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Core" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary><span data-ttu-id="3b2af-101">Gibt an, ob eine Sperre mehrmals dem gleichen Thread zugewiesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="3b2af-101">Specifies whether a lock can be entered multiple times by the same thread.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3b2af-102">Die Standard-Rekursions Richtlinie hängt vom Typ der Sperre ab.</span><span class="sxs-lookup"><span data-stu-id="3b2af-102">The default recursion policy depends on the type of lock.</span></span> <span data-ttu-id="3b2af-103">Die Standard Richtlinie und das genaue Verhalten der Sperr Rekursion für einen beliebigen Sperrentyp finden Sie in der Dokumentation für den-Typ.</span><span class="sxs-lookup"><span data-stu-id="3b2af-103">For the default policy and the precise behavior of lock recursion for any given lock type, see the documentation for the type.</span></span> <span data-ttu-id="3b2af-104">Beispielsweise lässt die <xref:System.Threading.ReaderWriterLockSlim>-Klasse nicht zu, dass ein Thread die Sperre im Schreibmodus eingibt, wenn die Sperre bereits in den Lesemodus eingetreten ist, und zwar unabhängig von der Einstellung der Sperr Richtlinie, um die Wahrscheinlichkeit von Deadlocks zu verringern.</span><span class="sxs-lookup"><span data-stu-id="3b2af-104">For example, the <xref:System.Threading.ReaderWriterLockSlim> class does not allow a thread to enter the lock in write mode if it already entered the lock in read mode, regardless of the lock policy setting, in order to reduce the chance of deadlocks.</span></span>  
  
 <span data-ttu-id="3b2af-105">Zurzeit verwendet nur eine Sperre diese Enumeration:</span><span class="sxs-lookup"><span data-stu-id="3b2af-105">Currently only one lock uses this enumeration:</span></span>  
  
-   <span data-ttu-id="3b2af-106">[https://login.microsoftonline.com/consumers/](<xref:System.Threading.ReaderWriterLockSlim>).</span><span class="sxs-lookup"><span data-stu-id="3b2af-106"><xref:System.Threading.ReaderWriterLockSlim>.</span></span> <span data-ttu-id="3b2af-107">Weitere Informationen finden Sie unter den Ausführungen zur Eigenschaft <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A>.</span><span class="sxs-lookup"><span data-stu-id="3b2af-107">For more information, see the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3b2af-108">Das folgende Beispiel zeigt zwei Ausnahme Szenarios, eine, die von der <xref:System.Threading.LockRecursionPolicy> Einstellung abhängt, und eine, die nicht ist.</span><span class="sxs-lookup"><span data-stu-id="3b2af-108">The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.</span></span>  
  
 <span data-ttu-id="3b2af-109">Im ersten Szenario wechselt der Thread in die Sperre im Lesemodus und versucht dann rekursiv in den Lesemodus zu wechseln.</span><span class="sxs-lookup"><span data-stu-id="3b2af-109">In the first scenario, the thread enters the lock in read mode and then tries to enter read mode recursively.</span></span> <span data-ttu-id="3b2af-110">Wenn die <xref:System.Threading.ReaderWriterLockSlim> mit dem Parameter losen Konstruktor erstellt wird, mit dem die Rekursions Richtlinie auf NoRecursion festgelegt wird, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3b2af-110">If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the parameterless constructor, which sets recursion policy to NoRecursion, an exception is thrown.</span></span> <span data-ttu-id="3b2af-111">Wenn SupportsRecursion verwendet wird, um den <xref:System.Threading.ReaderWriterLockSlim>zu erstellen, wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3b2af-111">If SupportsRecursion is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="3b2af-112">Im zweiten Szenario wechselt der Thread in den Lesemodus und versucht dann, die Sperre im Schreibmodus einzugeben.</span><span class="sxs-lookup"><span data-stu-id="3b2af-112">In the second scenario, the thread enters the lock in read mode and then tries to enter the lock in write mode.</span></span> <span data-ttu-id="3b2af-113"><xref:System.Threading.LockRecursionException> wird unabhängig von der sperrrekursions Richtlinie ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3b2af-113"><xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.</span></span>  
  
 [!code-csharp[System.Threading.LockRecursionPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/example1.cs#1)]
 [!code-vb[System.Threading.LockRecursionPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="NoRecursion">
      <MemberSignature Language="C#" Value="NoRecursion" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.LockRecursionPolicy NoRecursion = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.LockRecursionPolicy.NoRecursion" />
      <MemberSignature Language="VB.NET" Value="NoRecursion" />
      <MemberSignature Language="C++ CLI" Value="NoRecursion" />
      <MemberSignature Language="F#" Value="NoRecursion = 0" Usage="System.Threading.LockRecursionPolicy.NoRecursion" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary><span data-ttu-id="3b2af-114">Wenn ein Thread rekursiv versucht, eine Sperre zu erhalten, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3b2af-114">If a thread tries to enter a lock recursively, an exception is thrown.</span></span> <span data-ttu-id="3b2af-115">Einige Klassen gestatten gewisse Rekursionen, wenn diese Einstellung aktiv ist.</span><span class="sxs-lookup"><span data-stu-id="3b2af-115">Some classes may allow certain recursions when this setting is in effect.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="SupportsRecursion">
      <MemberSignature Language="C#" Value="SupportsRecursion" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.LockRecursionPolicy SupportsRecursion = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.LockRecursionPolicy.SupportsRecursion" />
      <MemberSignature Language="VB.NET" Value="SupportsRecursion" />
      <MemberSignature Language="C++ CLI" Value="SupportsRecursion" />
      <MemberSignature Language="F#" Value="SupportsRecursion = 1" Usage="System.Threading.LockRecursionPolicy.SupportsRecursion" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary><span data-ttu-id="3b2af-116">Ein Thread kann rekursiv eine Sperre erhalten.</span><span class="sxs-lookup"><span data-stu-id="3b2af-116">A thread can enter a lock recursively.</span></span> <span data-ttu-id="3b2af-117">Einige Klassen beschränken diese Möglichkeit einer rekursiven Zuweisung.</span><span class="sxs-lookup"><span data-stu-id="3b2af-117">Some classes may restrict this capability.</span></span></summary>
      </Docs>
    </Member>
  </Members>
</Type>
