<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="LazyInitializer.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac57ae28946e3c3f6b03b2cc6e3fd75b033dbd5575b.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7ae28946e3c3f6b03b2cc6e3fd75b033dbd5575b</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.LazyInitializer">
          <source>Provides lazy initialization routines.</source>
          <target state="translated">Stellt verzögerte Initialisierungsroutinen bereit.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LazyInitializer">
          <source>These routines avoid needing to allocate a dedicated, lazy-initialization instance, instead using references to ensure targets have been initialized as they are accessed.</source>
          <target state="translated">Diese Routinen umgehen, reservieren eine dedizierte, verzögerte Initialisierung Instanz, die stattdessen Verweise verwenden, um sicherzustellen, dass Ziele initialisiert wurden, wie darauf zugegriffen wird.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LazyInitializer">
          <source>The following example demonstrates how to use EnsureInitialized to lazily initialize a value using a Boolean value to track whether initialization has already happened and an object to use as the mutual exclusion lock.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie Sie EnsureInitialized verzögert initialisiert werden, einen Wert mit einem booleschen Wert zum Nachverfolgen, ob die Initialisierung bereits geschehen ist und ein Objekt, das als die gegenseitigen Ausschlusssperre verwendet wird.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LazyInitializer">
          <source>The methods of <ph id="ph1">&lt;see cref="T:System.Threading.LazyInitializer" /&gt;</ph> are thread-safe and may be called from multiple threads concurrently.</source>
          <target state="translated">Die Methoden der <ph id="ph1">&lt;see cref="T:System.Threading.LazyInitializer" /&gt;</ph> sind threadsicher und können von mehreren Threads gleichzeitig aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="T:System.Threading.LazyInitializer">
          <source>Initializes a target type if it hasn't already been initialized.</source>
          <target state="translated">Initialisiert einen Zieltyp, wenn der noch nicht initialisiert wurde.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
          <source>The type of the reference to be initialized.</source>
          <target state="translated">Der Typ des zu initialisierenden Verweises.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
          <source>A reference of type <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> to initialize if it has not already been initialized.</source>
          <target state="translated">Ein Verweis des Typs <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept>, der initialisiert werden soll, wenn er noch nicht initialisiert wurde.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
          <source>Initializes a target reference type with the type's default constructor if it hasn't already been initialized.</source>
          <target state="translated">Initialisiert einen Zielverweistyp mit seinem Standardkonstruktor, wenn er noch nicht initialisiert wurde.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
          <source>The initialized reference of type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">Der initialisierte Verweis vom Typ <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
          <source>This method may only be used on reference types.</source>
          <target state="translated">Diese Methode kann nur für Verweistypen verwendet werden.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
          <source>To ensure initialization of value types, see other overloads of EnsureInitialized.</source>
          <target state="translated">Um sicherzustellen, dass die Initialisierung von Werttypen, finden Sie unter anderen Überladungen der EnsureInitialized.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
          <source>This method may be used concurrently by multiple threads to initialize <ph id="ph1">`target`</ph>.</source>
          <target state="translated">Diese Methode kann verwendet werden gleichzeitig durch mehrere Threads initialisieren <ph id="ph1">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
          <source>In the event that multiple threads access this method concurrently, multiple instances of <ph id="ph1">`T`</ph> may be created, but only one will be stored into <ph id="ph2">`target`</ph>.</source>
          <target state="translated">Wenn mehrere Threads gleichzeitig auf diese Methode, mehrere Instanzen von Zugriff auf <ph id="ph1">`T`</ph> erstellt werden kann, aber nur eine wird in gespeichert werden <ph id="ph2">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
          <source>In such an occurrence, this method will not dispose of the objects that were not stored.</source>
          <target state="translated">In solch einem Vorkommen wird diese Methode nicht die Objekte freizugeben, die nicht gespeichert wurden.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
          <source>If such objects must be disposed, it is up to the caller to determine if an object was not used and to then dispose of the object appropriately.</source>
          <target state="translated">Wenn solche Objekte freigegeben werden müssen, ist es Aufgabe des Aufrufers, um zu bestimmen, ob ein Objekt nicht verwendet wurde und dann Verwerfen des Objekts entsprechend.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
          <source>Permissions to access the constructor of type <ph id="ph1">&lt;paramref name="T" /&gt;</ph> were missing.</source>
          <target state="translated">Berechtigungen, auf den Konstruktor des Typs <ph id="ph1">&lt;paramref name="T" /&gt;</ph> zuzugreifen, haben gefehlt.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
          <source>Type <ph id="ph1">&lt;paramref name="T" /&gt;</ph> does not have a default constructor.</source>
          <target state="translated">Der Typ <ph id="ph1">&lt;paramref name="T" /&gt;</ph> besitzt keinen Standardkonstruktor.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
          <source>The reference type of the reference to be initialized.</source>
          <target state="translated">Der Verweistyp des zu initialisierenden Verweises.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
          <source>The reference of type <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> to initialize if it hasn't already been initialized.</source>
          <target state="translated">Der Verweis des Typs <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept>, der initialisiert werden soll, wenn er noch nicht initialisiert wurde.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
          <source>The function that is called to initialize the reference.</source>
          <target state="translated">Die Funktion, die aufgerufen wird, um den Verweis zu initialisieren.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
          <source>Initializes a target reference type by using a specified function if it hasn't already been initialized.</source>
          <target state="translated">Initialisiert einen Zielverweistyp mit einer angegebenen Funktion, wenn er noch nicht initialisiert wurde.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
          <source>The initialized value of type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">Der initialisierte Wert vom Typ <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
          <source>This method may only be used on reference types, and <ph id="ph1">`valueFactory`</ph> may not return a null reference (Nothing in Visual Basic).</source>
          <target state="translated">Diese Methode kann nur verwendet werden, bei Verweistypen, und <ph id="ph1">`valueFactory`</ph> kann einen null-Verweis (Nothing in Visual Basic) zurückgibt.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
          <source>To ensure initialization of value types or to allow null reference types, see other overloads of EnsureInitialized.</source>
          <target state="translated">Um sicherzustellen, dass die Initialisierung von Werttypen oder null-Verweis-Typen zu ermöglichen, finden Sie unter "andere Überladungen der EnsureInitialized".</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
          <source>This method may be used concurrently by multiple threads to initialize <ph id="ph1">`target`</ph>.</source>
          <target state="translated">Diese Methode kann verwendet werden gleichzeitig durch mehrere Threads initialisieren <ph id="ph1">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
          <source>In the event that multiple threads access this method concurrently, multiple instances of <ph id="ph1">`T`</ph> may be created, but only one will be stored into <ph id="ph2">`target`</ph>.</source>
          <target state="translated">Wenn mehrere Threads gleichzeitig auf diese Methode, mehrere Instanzen von Zugriff auf <ph id="ph1">`T`</ph> erstellt werden kann, aber nur eine wird in gespeichert werden <ph id="ph2">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
          <source>In such an occurrence, this method will not dispose of the objects that were not stored.</source>
          <target state="translated">In solch einem Vorkommen wird diese Methode nicht die Objekte freizugeben, die nicht gespeichert wurden.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
          <source>If such objects must be disposed, it is up to the caller to determine if an object was not used and to then dispose of the object appropriately.</source>
          <target state="translated">Wenn solche Objekte freigegeben werden müssen, ist es Aufgabe des Aufrufers, um zu bestimmen, ob ein Objekt nicht verwendet wurde und dann Verwerfen des Objekts entsprechend.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
          <source>Type <ph id="ph1">&lt;paramref name="T" /&gt;</ph> does not have a default constructor.</source>
          <target state="translated">Der Typ <ph id="ph1">&lt;paramref name="T" /&gt;</ph> besitzt keinen Standardkonstruktor.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
          <source><ph id="ph1">&lt;paramref name="valueFactory" /&gt;</ph> returned null (Nothing in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="valueFactory" /&gt;</ph> gibt null (Nothing in Visual Basic) zurück.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
          <source>The type of the reference to be initialized.</source>
          <target state="translated">Der Typ des zu initialisierenden Verweises.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
          <source>A reference or value of type <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> to initialize if it hasn't already been initialized.</source>
          <target state="translated">Ein Verweis oder Wert des Typs <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept>, der initialisiert werden soll, wenn er noch nicht initialisiert wurde.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
          <source>A reference to a Boolean value that determines whether the target has already been initialized.</source>
          <target state="translated">Ein Verweis auf einen booleschen Wert, der bestimmt, ob das Ziel bereits initialisiert wurde.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
          <source>A reference to an object used as the mutually exclusive lock for initializing <bpt id="p1">&lt;c&gt;</bpt>target<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Ein Verweis auf ein Objekt, das für die Initialisierung von <bpt id="p1">&lt;c&gt;</bpt>target<ept id="p1">&lt;/c&gt;</ept> als sich gegenseitig ausschließende Sperre verwendet wird.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>syncLock<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, a new object will be instantiated.</source>
          <target state="translated">Wenn <bpt id="p1">&lt;c&gt;</bpt>syncLock<ept id="p1">&lt;/c&gt;</ept> <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist, wird ein neues Objekt instanziiert.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
          <source>Initializes a target reference or value type with its default constructor if it hasn't already been initialized.</source>
          <target state="translated">Initialisiert einen Zielverweis- oder Werttyp mit seinem Standardkonstruktor, wenn er noch nicht initialisiert wurde.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
          <source>The initialized value of type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">Der initialisierte Wert vom Typ <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
          <source>If <ph id="ph1">`intialized`</ph> is specified as true, then no further initialization occurs.</source>
          <target state="translated">Wenn <ph id="ph1">`intialized`</ph> als "true", angegeben ist, dann keine weiteren Initialisierung erfolgt.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
          <source>Permissions to access the constructor of type <ph id="ph1">&lt;paramref name="T" /&gt;</ph> were missing.</source>
          <target state="translated">Berechtigungen, auf den Konstruktor des Typs <ph id="ph1">&lt;paramref name="T" /&gt;</ph> zuzugreifen, haben gefehlt.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
          <source>Type <ph id="ph1">&lt;paramref name="T" /&gt;</ph> does not have a default constructor.</source>
          <target state="translated">Der Typ <ph id="ph1">&lt;paramref name="T" /&gt;</ph> besitzt keinen Standardkonstruktor.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
          <source>The type of the reference to be initialized.</source>
          <target state="translated">Der Typ des zu initialisierenden Verweises.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
          <source>A reference or value of type <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> to initialize if it hasn't already been initialized.</source>
          <target state="translated">Ein Verweis oder Wert des Typs <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept>, der initialisiert werden soll, wenn er noch nicht initialisiert wurde.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
          <source>A reference to a Boolean value that determines whether the target has already been initialized.</source>
          <target state="translated">Ein Verweis auf einen booleschen Wert, der bestimmt, ob das Ziel bereits initialisiert wurde.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
          <source>A reference to an object used as the mutually exclusive lock for initializing <bpt id="p1">&lt;c&gt;</bpt>target<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Ein Verweis auf ein Objekt, das für die Initialisierung von <bpt id="p1">&lt;c&gt;</bpt>target<ept id="p1">&lt;/c&gt;</ept> als sich gegenseitig ausschließende Sperre verwendet wird.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>syncLock<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, a new object will be instantiated.</source>
          <target state="translated">Wenn <bpt id="p1">&lt;c&gt;</bpt>syncLock<ept id="p1">&lt;/c&gt;</ept> <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist, wird ein neues Objekt instanziiert.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
          <source>The function that is called to initialize the reference or value.</source>
          <target state="translated">Die Funktion, die aufgerufen wird, um den Verweis oder den Wert zu initialisieren.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
          <source>Initializes a target reference or value type by using a specified function if it hasn't already been initialized.</source>
          <target state="translated">Initialisiert einen Zielverweis- oder Werttyp mit einer angegebenen Funktion, wenn er noch nicht initialisiert wurde.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
          <source>The initialized value of type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">Der initialisierte Wert vom Typ <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
          <source>If <ph id="ph1">`intialized`</ph> is specified as true, then no further initialization occurs.</source>
          <target state="translated">Wenn <ph id="ph1">`intialized`</ph> als "true", angegeben ist, dann keine weiteren Initialisierung erfolgt.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
          <source>Permissions to access the constructor of type <ph id="ph1">&lt;paramref name="T" /&gt;</ph> were missing.</source>
          <target state="translated">Berechtigungen, auf den Konstruktor des Typs <ph id="ph1">&lt;paramref name="T" /&gt;</ph> zuzugreifen, haben gefehlt.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
          <source>Type <ph id="ph1">&lt;paramref name="T" /&gt;</ph> does not have a default constructor.</source>
          <target state="translated">Der Typ <ph id="ph1">&lt;paramref name="T" /&gt;</ph> besitzt keinen Standardkonstruktor.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>