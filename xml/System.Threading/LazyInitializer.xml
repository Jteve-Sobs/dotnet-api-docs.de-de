<Type Name="LazyInitializer" FullName="System.Threading.LazyInitializer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="19a9cea9a7caa1bb7e43249d9fcee2f86c4d25d8" /><Meta Name="ms.sourcegitcommit" Value="385ff23cc00fe9aa1c93460c62603b45c2041d0b" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/22/2019" /><Meta Name="ms.locfileid" Value="74387982" /></Metadata><TypeSignature Language="C#" Value="public static class LazyInitializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit LazyInitializer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.LazyInitializer" />
  <TypeSignature Language="VB.NET" Value="Public Class LazyInitializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class LazyInitializer abstract sealed" />
  <TypeSignature Language="F#" Value="type LazyInitializer = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides lazy initialization routines.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Routinen vermeiden es, eine dedizierte Instanz mit verzögerter Initialisierung zuzuordnen, indem Sie stattdessen Verweise verwenden, um sicherzustellen, dass Ziele beim Zugriff initialisiert wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie mithilfe von EnsureInitialized einen Wert verzögert mit einem booleschen Wert initialisieren können, um zu verfolgen, ob die Initialisierung bereits stattgefunden hat, und ein Objekt, das als gegenseitige Ausschluss Sperre verwendet werden soll.  
  
```vb  
Dim _data As ExpensiveData = Nothing  
Dim _dataInitialized As Boolean = False  
Dim _dataLock As Object = Nothing  
'    ...  
Dim name = LazyInitializer.EnsureInitialized(_data, _dataInitialized, _dataLock)  
```  
  
```csharp  
ExpensiveData _data = null;  
bool _dataInitialized = false;  
object _dataLock = new object();  

//  ...  
  
ExpensiveData dataToUse = LazyInitializer.EnsureInitialized(ref _data, ref _dataInitialized, ref _dataLock);  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Die Methoden von <see cref="T:System.Threading.LazyInitializer" /> sind Thread sicher und können von mehreren Threads gleichzeitig aufgerufen werden.</threadsafe>
    <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="EnsureInitialized&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a target type if it hasn't already been initialized.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;class T&gt;(!!T&amp; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T As Class) (ByRef target As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T EnsureInitialized(T % target);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized : 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.LazyInitializer.EnsureInitialized target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des zu initialisierenden Verweises.</typeparam>
        <param name="target">A reference to initialize if it has not already been initialized.</param>
        <summary>Initializes a target reference type with the type's parameterless constructor if it hasn't already been initialized.</summary>
        <returns>The initialized object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann nur für Verweis Typen verwendet werden. Um die Initialisierung von Werttypen sicherzustellen, sehen Sie sich andere über Ladungen von `EnsureInitialized`an.  
  
 Diese Methode kann gleichzeitig von mehreren Threads verwendet werden, um `target`zu initialisieren.  
  
 Wenn mehrere Threads gleichzeitig auf diese Methode zugreifen, werden möglicherweise mehrere Instanzen von `T` erstellt, aber nur eine wird in `target` gespeichert und zurückgegeben. In solch einem Vorkommen werden die Objekte, die nicht gespeichert wurden, von dieser Methode nicht verworfen. Wenn solche Objekte verworfen werden müssen, verwenden Sie eine Überladung, die eine `valueFactory` annimmt, und löschen Sie das Objekt, wenn es nicht auf dasselbe gespeicherte Objekt verweist.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Permissions to access the constructor of type <paramref name="T" /> were missing.</exception>
        <exception cref="T:System.MissingMemberException">Type <paramref name="T" /> does not have a parameterless constructor.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target, Func&lt;T&gt; valueFactory) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;class T&gt;(!!T&amp; target, class System.Func`1&lt;!!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T As Class) (ByRef target As T, valueFactory As Func(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T EnsureInitialized(T % target, Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized : 'T * Func&lt;'T (requires 'T : null)&gt; -&gt; 'T (requires 'T : null)" Usage="System.Threading.LazyInitializer.EnsureInitialized (target, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des zu initialisierenden Verweises.</typeparam>
        <param name="target">The reference to initialize if it hasn't already been initialized.</param>
        <param name="valueFactory">The function that is called to initialize the reference.</param>
        <summary>Initializes a target reference type by using a specified function if it hasn't already been initialized.</summary>
        <returns>The initialized object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann nur für Verweis Typen verwendet werden, und `valueFactory` darf keinen NULL-Verweis zurückgeben (Nothing in Visual Basic). Um die Initialisierung von Werttypen zu gewährleisten oder NULL-Verweis Typen zuzulassen, finden Sie weitere Informationen unter andere über Ladungen von EnsureInitialized.  
  
 Diese Methode kann gleichzeitig von mehreren Threads verwendet werden, um `target`zu initialisieren.  
  
 Wenn mehrere Threads gleichzeitig auf diese Methode zugreifen, werden möglicherweise mehrere Instanzen von `T` erstellt, aber nur eine wird in `target`gespeichert. In solch einem Vorkommen werden die Objekte, die nicht gespeichert wurden, von dieser Methode nicht verworfen. Wenn solche Objekte verworfen werden müssen, liegt es an dem Aufrufer, zu bestimmen, ob ein Objekt nicht verwendet wurde, und das Objekt entsprechend zu verwerfen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MissingMemberException">Type <paramref name="T" /> does not have a parameterless constructor.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="valueFactory" /> returned null (Nothing in Visual Basic).</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target, ref bool initialized, ref object syncLock);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;T&gt;(!!T&amp; target, bool&amp; initialized, object&amp; syncLock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T) (ByRef target As T, ByRef initialized As Boolean, ByRef syncLock As Object) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T EnsureInitialized(T % target, bool % initialized, System::Object ^ % syncLock);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized : 'T * bool * obj -&gt; 'T" Usage="System.Threading.LazyInitializer.EnsureInitialized (target, initialized, syncLock)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
        <Parameter Name="initialized" Type="System.Boolean" RefType="ref" />
        <Parameter Name="syncLock" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des zu initialisierenden Verweises.</typeparam>
        <param name="target">A reference or value of type <c>T</c> to initialize if it hasn't already been initialized.</param>
        <param name="initialized">A reference to a Boolean value that determines whether the target has already been initialized.</param>
        <param name="syncLock">A reference to an object used as the mutually exclusive lock for initializing <paramref name="target" />. If <paramref name="syncLock" /> is <see langword="null" />, a new object will be instantiated.</param>
        <summary>Initializes a target reference or value type with its parameterless constructor if it hasn't already been initialized.</summary>
        <returns>The initialized object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `initialized` als true angegeben wird, erfolgt keine weitere Initialisierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Permissions to access the constructor of type <paramref name="T" /> were missing.</exception>
        <exception cref="T:System.MissingMemberException">Type <paramref name="T" /> does not have a parameterless constructor.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target, ref object syncLock, Func&lt;T&gt; valueFactory) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;class T&gt;(!!T&amp; target, object&amp; syncLock, class System.Func`1&lt;!!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T As Class) (ByRef target As T, ByRef syncLock As Object, valueFactory As Func(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T EnsureInitialized(T % target, System::Object ^ % syncLock, Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized : 'T * obj * Func&lt;'T (requires 'T : null)&gt; -&gt; 'T (requires 'T : null)" Usage="System.Threading.LazyInitializer.EnsureInitialized (target, syncLock, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="syncLock" Type="System.Object" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des zu initialisierenden Verweises.</typeparam>
        <param name="target">A reference to initialize if it has not already been initialized.</param>
        <param name="syncLock">A reference to an object used as the mutually exclusive lock for initializing <paramref name="target" />. If <paramref name="syncLock" /> is <see langword="null" />, a new object will be instantiated.</param>
        <param name="valueFactory">The method to invoke to initialize <paramref name="target" />.</param>
        <summary>Initializes a target reference type with a specified function if it has not already been initialized.</summary>
        <returns>The initialized object.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target, ref bool initialized, ref object syncLock, Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;T&gt;(!!T&amp; target, bool&amp; initialized, object&amp; syncLock, class System.Func`1&lt;!!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T) (ByRef target As T, ByRef initialized As Boolean, ByRef syncLock As Object, valueFactory As Func(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T EnsureInitialized(T % target, bool % initialized, System::Object ^ % syncLock, Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized : 'T * bool * obj * Func&lt;'T&gt; -&gt; 'T" Usage="System.Threading.LazyInitializer.EnsureInitialized (target, initialized, syncLock, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
        <Parameter Name="initialized" Type="System.Boolean" RefType="ref" />
        <Parameter Name="syncLock" Type="System.Object" RefType="ref" />
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des zu initialisierenden Verweises.</typeparam>
        <param name="target">A reference or value of type <c>T</c> to initialize if it hasn't already been initialized.</param>
        <param name="initialized">A reference to a Boolean value that determines whether the target has already been initialized.</param>
        <param name="syncLock">A reference to an object used as the mutually exclusive lock for initializing <paramref name="target" />. If <paramref name="syncLock" /> is <see langword="null" />, a new object will be instantiated.</param>
        <param name="valueFactory">The function that is called to initialize the reference or value.</param>
        <summary>Initializes a target reference or value type by using a specified function if it hasn't already been initialized.</summary>
        <returns>The initialized object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `initialized` als true angegeben wird, erfolgt keine weitere Initialisierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Permissions to access the constructor of type <paramref name="T" /> were missing.</exception>
        <exception cref="T:System.MissingMemberException">Type <paramref name="T" /> does not have a parameterless constructor.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
  </Members>
</Type>
