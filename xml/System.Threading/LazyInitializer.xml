<Type Name="LazyInitializer" FullName="System.Threading.LazyInitializer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2637ee45bf5183878b44c878203a0a6a55dde4f2" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83530228" /></Metadata><TypeSignature Language="C#" Value="public static class LazyInitializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit LazyInitializer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.LazyInitializer" />
  <TypeSignature Language="VB.NET" Value="Public Class LazyInitializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class LazyInitializer abstract sealed" />
  <TypeSignature Language="F#" Value="type LazyInitializer = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Threading" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="17af0-101">Stellt verzögerte Initialisierungsroutinen bereit.</span><span class="sxs-lookup"><span data-stu-id="17af0-101">Provides lazy initialization routines.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17af0-102">Diese Routinen vermeiden es, eine dedizierte Instanz mit verzögerter Initialisierung zuzuordnen, indem Sie stattdessen Verweise verwenden, um sicherzustellen, dass Ziele beim Zugriff initialisiert wurden.</span><span class="sxs-lookup"><span data-stu-id="17af0-102">These routines avoid needing to allocate a dedicated, lazy-initialization instance, instead using references to ensure targets have been initialized as they are accessed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17af0-103">Im folgenden Beispiel wird veranschaulicht, wie Sie mithilfe von EnsureInitialized einen Wert verzögert mit einem booleschen Wert initialisieren können, um zu verfolgen, ob die Initialisierung bereits stattgefunden hat, und ein Objekt, das als gegenseitige Ausschluss Sperre verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="17af0-103">The following example demonstrates how to use EnsureInitialized to lazily initialize a value using a Boolean value to track whether initialization has already happened and an object to use as the mutual exclusion lock.</span></span>  
  
```vb  
Dim _data As ExpensiveData = Nothing  
Dim _dataInitialized As Boolean = False  
Dim _dataLock As Object = Nothing  
'    ...  
Dim name = LazyInitializer.EnsureInitialized(_data, _dataInitialized, _dataLock)  
```  
  
```csharp  
ExpensiveData _data = null;  
bool _dataInitialized = false;  
object _dataLock = new object();  

//  ...  
  
ExpensiveData dataToUse = LazyInitializer.EnsureInitialized(ref _data, ref _dataInitialized, ref _dataLock);  
```  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="17af0-104">Die Methoden von <see cref="T:System.Threading.LazyInitializer" /> sind Thread sicher und können von mehreren Threads gleichzeitig aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="17af0-104">The methods of <see cref="T:System.Threading.LazyInitializer" /> are thread-safe and may be called from multiple threads concurrently.</span></span></threadsafe>
    <related type="Article" href="~/docs/framework/performance/lazy-initialization.md"><span data-ttu-id="17af0-105">Verzögerte Initialisierung</span><span class="sxs-lookup"><span data-stu-id="17af0-105">Lazy Initialization</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="EnsureInitialized&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="17af0-106">Initialisiert einen Zieltyp, wenn der noch nicht initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="17af0-106">Initializes a target type if it hasn't already been initialized.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;class T&gt;(!!T&amp; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T As Class) (ByRef target As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T EnsureInitialized(T % target);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized : 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.LazyInitializer.EnsureInitialized target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="17af0-107">Der Typ des zu initialisierenden Verweises.</span><span class="sxs-lookup"><span data-stu-id="17af0-107">The type of the reference to be initialized.</span></span></typeparam>
        <param name="target"><span data-ttu-id="17af0-108">Ein Verweis, der initialisiert werden soll, wenn er noch nicht initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="17af0-108">A reference to initialize if it has not already been initialized.</span></span> <span data-ttu-id="17af0-109">Bei <see langword="null" /> wird er als nicht initialisiert betrachtet, andernfalls gilt er als initialisiert.</span><span class="sxs-lookup"><span data-stu-id="17af0-109">If it is <see langword="null" />, it is considered not initialized; otherwise, it's considered initialized.</span></span></param>
        <summary><span data-ttu-id="17af0-110">Initialisiert einen Zielverweistyp mit seinem parameterlosen Konstruktor, wenn er noch nicht initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="17af0-110">Initializes a target reference type with the type's parameterless constructor if it hasn't already been initialized.</span></span></summary>
        <returns><span data-ttu-id="17af0-111">Das initialisierte Objekt.</span><span class="sxs-lookup"><span data-stu-id="17af0-111">The initialized object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17af0-112">Diese Methode kann nur für Verweis Typen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="17af0-112">This method may only be used on reference types.</span></span> <span data-ttu-id="17af0-113">Um die Initialisierung von Werttypen sicherzustellen, sehen Sie sich andere über Ladungen von `EnsureInitialized`an.</span><span class="sxs-lookup"><span data-stu-id="17af0-113">To ensure initialization of value types, see other overloads of `EnsureInitialized`.</span></span>  
  
 <span data-ttu-id="17af0-114">Diese Methode kann gleichzeitig von mehreren Threads verwendet werden, um `target`zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="17af0-114">This method may be used concurrently by multiple threads to initialize `target`.</span></span>  
  
 <span data-ttu-id="17af0-115">Wenn mehrere Threads gleichzeitig auf diese Methode zugreifen, werden möglicherweise mehrere Instanzen von `T` erstellt, aber nur eine wird in `target` gespeichert und zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="17af0-115">In the event that multiple threads access this method concurrently, multiple instances of `T` may be created, but only one will be stored into `target` and returned.</span></span> <span data-ttu-id="17af0-116">In solch einem Vorkommen werden die Objekte, die nicht gespeichert wurden, von dieser Methode nicht verworfen.</span><span class="sxs-lookup"><span data-stu-id="17af0-116">In such an occurrence, this method will not dispose of the objects that were not stored.</span></span> <span data-ttu-id="17af0-117">Wenn solche Objekte verworfen werden müssen, verwenden Sie eine Überladung, die eine `valueFactory` annimmt, und löschen Sie das Objekt, wenn es nicht auf dasselbe gespeicherte Objekt verweist.</span><span class="sxs-lookup"><span data-stu-id="17af0-117">If such objects must be disposed, use an overload that takes a `valueFactory` and dispose of the object if it does not reference the same stored object.</span></span>
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="17af0-118">Berechtigungen, auf den Konstruktor des Typs <paramref name="T" /> zuzugreifen, haben gefehlt.</span><span class="sxs-lookup"><span data-stu-id="17af0-118">Permissions to access the constructor of type <paramref name="T" /> were missing.</span></span></exception>
        <exception cref="T:System.MissingMemberException"><span data-ttu-id="17af0-119">Der Typ <paramref name="T" /> hat keinen parameterlosen Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="17af0-119">Type <paramref name="T" /> does not have a parameterless constructor.</span></span></exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md"><span data-ttu-id="17af0-120">Verzögerte Initialisierung</span><span class="sxs-lookup"><span data-stu-id="17af0-120">Lazy Initialization</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target, Func&lt;T&gt; valueFactory) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;class T&gt;(!!T&amp; target, class System.Func`1&lt;!!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T As Class) (ByRef target As T, valueFactory As Func(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T EnsureInitialized(T % target, Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized : 'T * Func&lt;'T (requires 'T : null)&gt; -&gt; 'T (requires 'T : null)" Usage="System.Threading.LazyInitializer.EnsureInitialized (target, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="17af0-121">Der Typ des zu initialisierenden Verweises.</span><span class="sxs-lookup"><span data-stu-id="17af0-121">The type of the reference to be initialized.</span></span></typeparam>
        <param name="target"><span data-ttu-id="17af0-122">Der Verweis, der initialisiert werden soll, wenn er noch nicht initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="17af0-122">The reference to initialize if it hasn't already been initialized.</span></span></param>
        <param name="valueFactory"><span data-ttu-id="17af0-123">Die Funktion, die aufgerufen wird, um den Verweis zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="17af0-123">The function that is called to initialize the reference.</span></span></param>
        <summary><span data-ttu-id="17af0-124">Initialisiert einen Zielverweistyp mit einer angegebenen Funktion, wenn er noch nicht initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="17af0-124">Initializes a target reference type by using a specified function if it hasn't already been initialized.</span></span></summary>
        <returns><span data-ttu-id="17af0-125">Das initialisierte Objekt.</span><span class="sxs-lookup"><span data-stu-id="17af0-125">The initialized object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17af0-126">Diese Methode kann nur für Verweis Typen verwendet werden, und `valueFactory` darf keinen NULL-Verweis zurückgeben (Nothing in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="17af0-126">This method may only be used on reference types, and `valueFactory` may not return a null reference (Nothing in Visual Basic).</span></span> <span data-ttu-id="17af0-127">Um die Initialisierung von Werttypen zu gewährleisten oder NULL-Verweis Typen zuzulassen, finden Sie weitere Informationen unter andere über Ladungen von EnsureInitialized.</span><span class="sxs-lookup"><span data-stu-id="17af0-127">To ensure initialization of value types or to allow null reference types, see other overloads of EnsureInitialized.</span></span>  
  
 <span data-ttu-id="17af0-128">Diese Methode kann gleichzeitig von mehreren Threads verwendet werden, um `target`zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="17af0-128">This method may be used concurrently by multiple threads to initialize `target`.</span></span>  
  
 <span data-ttu-id="17af0-129">Wenn mehrere Threads gleichzeitig auf diese Methode zugreifen, werden möglicherweise mehrere Instanzen von `T` erstellt, aber nur eine wird in `target`gespeichert.</span><span class="sxs-lookup"><span data-stu-id="17af0-129">In the event that multiple threads access this method concurrently, multiple instances of `T` may be created, but only one will be stored into `target`.</span></span> <span data-ttu-id="17af0-130">In solch einem Vorkommen werden die Objekte, die nicht gespeichert wurden, von dieser Methode nicht verworfen.</span><span class="sxs-lookup"><span data-stu-id="17af0-130">In such an occurrence, this method will not dispose of the objects that were not stored.</span></span> <span data-ttu-id="17af0-131">Wenn solche Objekte verworfen werden müssen, liegt es an dem Aufrufer, zu bestimmen, ob ein Objekt nicht verwendet wurde, und das Objekt entsprechend zu verwerfen.</span><span class="sxs-lookup"><span data-stu-id="17af0-131">If such objects must be disposed, it is up to the caller to determine if an object was not used and to then dispose of the object appropriately.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MissingMemberException"><span data-ttu-id="17af0-132">Der Typ <paramref name="T" /> hat keinen parameterlosen Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="17af0-132">Type <paramref name="T" /> does not have a parameterless constructor.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="17af0-133"><paramref name="valueFactory" /> gibt null (Nothing in Visual Basic) zurück.</span><span class="sxs-lookup"><span data-stu-id="17af0-133"><paramref name="valueFactory" /> returned null (Nothing in Visual Basic).</span></span></exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md"><span data-ttu-id="17af0-134">Verzögerte Initialisierung</span><span class="sxs-lookup"><span data-stu-id="17af0-134">Lazy Initialization</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target, ref bool initialized, ref object syncLock);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;T&gt;(!!T&amp; target, bool&amp; initialized, object&amp; syncLock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T) (ByRef target As T, ByRef initialized As Boolean, ByRef syncLock As Object) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T EnsureInitialized(T % target, bool % initialized, System::Object ^ % syncLock);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized : 'T * bool * obj -&gt; 'T" Usage="System.Threading.LazyInitializer.EnsureInitialized (target, initialized, syncLock)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
        <Parameter Name="initialized" Type="System.Boolean" RefType="ref" />
        <Parameter Name="syncLock" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="17af0-135">Der Typ des zu initialisierenden Verweises.</span><span class="sxs-lookup"><span data-stu-id="17af0-135">The type of the reference to be initialized.</span></span></typeparam>
        <param name="target"><span data-ttu-id="17af0-136">Ein Verweis oder Wert des Typs <c>T</c>, der initialisiert werden soll, wenn er noch nicht initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="17af0-136">A reference or value of type <c>T</c> to initialize if it hasn't already been initialized.</span></span></param>
        <param name="initialized"><span data-ttu-id="17af0-137">Ein Verweis auf einen booleschen Wert, der bestimmt, ob das Ziel bereits initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="17af0-137">A reference to a Boolean value that determines whether the target has already been initialized.</span></span></param>
        <param name="syncLock"><span data-ttu-id="17af0-138">Ein Verweis auf ein Objekt, das für die Initialisierung von <paramref name="target" /> als sich gegenseitig ausschließende Sperre verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="17af0-138">A reference to an object used as the mutually exclusive lock for initializing <paramref name="target" />.</span></span> <span data-ttu-id="17af0-139">Wenn <paramref name="syncLock" /><see langword="null" /> ist, wird ein neues Objekt instanziiert.</span><span class="sxs-lookup"><span data-stu-id="17af0-139">If <paramref name="syncLock" /> is <see langword="null" />, a new object will be instantiated.</span></span></param>
        <summary><span data-ttu-id="17af0-140">Initialisiert einen Zielverweis- oder Werttyp mit seinem parameterlosen Konstruktor, wenn er noch nicht initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="17af0-140">Initializes a target reference or value type with its parameterless constructor if it hasn't already been initialized.</span></span></summary>
        <returns><span data-ttu-id="17af0-141">Das initialisierte Objekt.</span><span class="sxs-lookup"><span data-stu-id="17af0-141">The initialized object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17af0-142">Wenn `initialized` als true angegeben wird, erfolgt keine weitere Initialisierung.</span><span class="sxs-lookup"><span data-stu-id="17af0-142">If `initialized` is specified as true, then no further initialization occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="17af0-143">Berechtigungen, auf den Konstruktor des Typs <paramref name="T" /> zuzugreifen, haben gefehlt.</span><span class="sxs-lookup"><span data-stu-id="17af0-143">Permissions to access the constructor of type <paramref name="T" /> were missing.</span></span></exception>
        <exception cref="T:System.MissingMemberException"><span data-ttu-id="17af0-144">Der Typ <paramref name="T" /> hat keinen parameterlosen Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="17af0-144">Type <paramref name="T" /> does not have a parameterless constructor.</span></span></exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md"><span data-ttu-id="17af0-145">Verzögerte Initialisierung</span><span class="sxs-lookup"><span data-stu-id="17af0-145">Lazy Initialization</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target, ref object syncLock, Func&lt;T&gt; valueFactory) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;class T&gt;(!!T&amp; target, object&amp; syncLock, class System.Func`1&lt;!!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T As Class) (ByRef target As T, ByRef syncLock As Object, valueFactory As Func(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T EnsureInitialized(T % target, System::Object ^ % syncLock, Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized : 'T * obj * Func&lt;'T (requires 'T : null)&gt; -&gt; 'T (requires 'T : null)" Usage="System.Threading.LazyInitializer.EnsureInitialized (target, syncLock, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="syncLock" Type="System.Object" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="17af0-146">Der Typ des zu initialisierenden Verweises.</span><span class="sxs-lookup"><span data-stu-id="17af0-146">The type of the reference to be initialized.</span></span></typeparam>
        <param name="target"><span data-ttu-id="17af0-147">Ein Verweis, der initialisiert werden soll, wenn er noch nicht initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="17af0-147">A reference to initialize if it has not already been initialized.</span></span> <span data-ttu-id="17af0-148">Bei <see langword="null" /> wird er als nicht initialisiert betrachtet, andernfalls gilt er als initialisiert.</span><span class="sxs-lookup"><span data-stu-id="17af0-148">If it is <see langword="null" />, it is considered not initialized; otherwise, it's considered initialized.</span></span></param>
        <param name="syncLock"><span data-ttu-id="17af0-149">Ein Verweis auf ein Objekt, das für die Initialisierung von <paramref name="target" /> als sich gegenseitig ausschließende Sperre verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="17af0-149">A reference to an object used as the mutually exclusive lock for initializing <paramref name="target" />.</span></span> <span data-ttu-id="17af0-150">Wenn <paramref name="syncLock" /><see langword="null" /> ist, wird ein neues Objekt instanziiert.</span><span class="sxs-lookup"><span data-stu-id="17af0-150">If <paramref name="syncLock" /> is <see langword="null" />, a new object will be instantiated.</span></span></param>
        <param name="valueFactory"><span data-ttu-id="17af0-151">Die Methode, die zum Initialisieren von <paramref name="target" /> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="17af0-151">The method to invoke to initialize <paramref name="target" />.</span></span></param>
        <summary><span data-ttu-id="17af0-152">Initialisiert einen Zielverweistyp mit einer angegebenen Funktion, wenn er noch nicht initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="17af0-152">Initializes a target reference type with a specified function if it has not already been initialized.</span></span></summary>
        <returns><span data-ttu-id="17af0-153">Das initialisierte Objekt.</span><span class="sxs-lookup"><span data-stu-id="17af0-153">The initialized object.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target, ref bool initialized, ref object syncLock, Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;T&gt;(!!T&amp; target, bool&amp; initialized, object&amp; syncLock, class System.Func`1&lt;!!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T) (ByRef target As T, ByRef initialized As Boolean, ByRef syncLock As Object, valueFactory As Func(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T EnsureInitialized(T % target, bool % initialized, System::Object ^ % syncLock, Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized : 'T * bool * obj * Func&lt;'T&gt; -&gt; 'T" Usage="System.Threading.LazyInitializer.EnsureInitialized (target, initialized, syncLock, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
        <Parameter Name="initialized" Type="System.Boolean" RefType="ref" />
        <Parameter Name="syncLock" Type="System.Object" RefType="ref" />
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="17af0-154">Der Typ des zu initialisierenden Verweises.</span><span class="sxs-lookup"><span data-stu-id="17af0-154">The type of the reference to be initialized.</span></span></typeparam>
        <param name="target"><span data-ttu-id="17af0-155">Ein Verweis oder Wert des Typs <c>T</c>, der initialisiert werden soll, wenn er noch nicht initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="17af0-155">A reference or value of type <c>T</c> to initialize if it hasn't already been initialized.</span></span></param>
        <param name="initialized"><span data-ttu-id="17af0-156">Ein Verweis auf einen booleschen Wert, der bestimmt, ob das Ziel bereits initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="17af0-156">A reference to a Boolean value that determines whether the target has already been initialized.</span></span></param>
        <param name="syncLock"><span data-ttu-id="17af0-157">Ein Verweis auf ein Objekt, das für die Initialisierung von <paramref name="target" /> als sich gegenseitig ausschließende Sperre verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="17af0-157">A reference to an object used as the mutually exclusive lock for initializing <paramref name="target" />.</span></span> <span data-ttu-id="17af0-158">Wenn <paramref name="syncLock" /><see langword="null" /> ist, wird ein neues Objekt instanziiert.</span><span class="sxs-lookup"><span data-stu-id="17af0-158">If <paramref name="syncLock" /> is <see langword="null" />, a new object will be instantiated.</span></span></param>
        <param name="valueFactory"><span data-ttu-id="17af0-159">Die Funktion, die aufgerufen wird, um den Verweis oder den Wert zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="17af0-159">The function that is called to initialize the reference or value.</span></span></param>
        <summary><span data-ttu-id="17af0-160">Initialisiert einen Zielverweis- oder Werttyp mit einer angegebenen Funktion, wenn er noch nicht initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="17af0-160">Initializes a target reference or value type by using a specified function if it hasn't already been initialized.</span></span></summary>
        <returns><span data-ttu-id="17af0-161">Das initialisierte Objekt.</span><span class="sxs-lookup"><span data-stu-id="17af0-161">The initialized object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17af0-162">Wenn `initialized` als true angegeben wird, erfolgt keine weitere Initialisierung.</span><span class="sxs-lookup"><span data-stu-id="17af0-162">If `initialized` is specified as true, then no further initialization occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="17af0-163">Berechtigungen, auf den Konstruktor des Typs <paramref name="T" /> zuzugreifen, haben gefehlt.</span><span class="sxs-lookup"><span data-stu-id="17af0-163">Permissions to access the constructor of type <paramref name="T" /> were missing.</span></span></exception>
        <exception cref="T:System.MissingMemberException"><span data-ttu-id="17af0-164">Der Typ <paramref name="T" /> hat keinen parameterlosen Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="17af0-164">Type <paramref name="T" /> does not have a parameterless constructor.</span></span></exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md"><span data-ttu-id="17af0-165">Verzögerte Initialisierung</span><span class="sxs-lookup"><span data-stu-id="17af0-165">Lazy Initialization</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
