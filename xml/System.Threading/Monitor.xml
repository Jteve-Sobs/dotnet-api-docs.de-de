<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3bfaa4f0ca1c607a6d8ac9414307092efd5b281a" /><Meta Name="ms.sourcegitcommit" Value="bc24a3ba616ee1df8b858f9400cae4f058ea3a7e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="06/19/2019" /><Meta Name="ms.locfileid" Value="67243380" /></Metadata><TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Mechanismus bereit, der den Zugriff auf Objekte synchronisiert.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Monitor> Klasse können Sie den Zugriff auf einen Codebereich synchronisieren, indem eine Sperre für ein bestimmtes Objekt durch Aufrufen der <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, und <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> Methoden. Objektsperren bieten die Möglichkeit, den Zugriff auf einen Codeblock, im Allgemeinen bezeichnet einen kritischen Abschnitt beschränken. Während ein Thread die Sperre für ein Objekt besitzt, kann kein anderer Thread diese Sperre abrufen. Sie können auch die <xref:System.Threading.Monitor> Klasse, um sicherzustellen, dass kein anderer Thread zulässig ist, eine Anwendung Zugriff auf code von der Besitzer der Sperre ausgeführt wird, es sei denn, der andere Thread den Code mithilfe eines anderen gesperrten Objekts ausgeführt wird.  
  
 In diesem Artikel:  
  
 [Die Monitor-Klasse: Eine Übersicht über die](#Overview)   
 [Das Sperrobjekt](#Lock)   
 [Der kritische Abschnitt](#CriticalSection)   
 [Pulse "," PulseAll ", und warten](#Pulse)   
 [Monitore und Wait-handles](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>Die Monitor-Klasse: Eine Übersicht über die  
 <xref:System.Threading.Monitor> bietet die folgenden Features:  
  
-   Es ist ein Objekt nach Bedarf zugeordnet.  
  
-   Es wird aufgehoben, was bedeutet, dass direkt aus einem beliebigen Kontext aufgerufen werden kann.  
  
-   Eine Instanz von der <xref:System.Threading.Monitor> Klasse kann nicht erstellt werden; die Methoden der <xref:System.Threading.Monitor> Klasse sind alle statisch. Jede Methode übergeben wird das synchronisierte Objekt, das steuert den Zugriff auf den kritischen Abschnitt.  
  
> [!NOTE]
>  Verwenden der <xref:System.Threading.Monitor> Klasse, um Objekte als Zeichenfolgen sperren (d. h. Referenztypen außer <xref:System.String>), nicht Werttypen. Ausführliche Informationen finden Sie die Überladungen der <xref:System.Threading.Monitor.Enter%2A> Methode und [das Sperrobjekt](#Lock) weiter unten in diesem Artikel.  
  
 Die folgende Tabelle beschreibt die Aktionen, die von Threads ausgeführt werden können, die synchronisierte Objekte zugreifen:  
  
|Aktion|Beschreibung|  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>|Ruft eine Sperre für ein Objekt ab. Diese Aktion werden auch den Anfang eines kritischen Abschnitts. Kein anderer Thread kann den kritischen Abschnitt eingeben, es sei denn, sie die Anweisungen in den kritischen Abschnitt, der mithilfe eines anderen gesperrten Objekts ausgeführt wird.|  
|<xref:System.Threading.Monitor.Wait%2A>|Gibt die Sperre für ein Objekt zum Zulassen von anderen Threads zu sperren, und greifen auf das Objekt frei. Der aufrufende Thread wartet, während ein anderer Thread auf das Objekt zugreift. Pulse-Signale werden verwendet, um wartende Threads über Änderungen des Zustands eines Objekts zu benachrichtigen.|  
|<xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A>|Sendet ein Signal an einem oder mehreren wartenden Threads. Das Signal benachrichtigt einen wartenden Thread, den der Zustand des gesperrten Objekts geändert wurde, und der Besitzer der Sperre ist bereit, um die Sperre aufzuheben. Der wartende Thread befindet sich in der Warteschlange des Objekts, damit er die Sperre für das Objekt schließlich empfangen kann. Sobald der Thread die Sperre verfügt, kann es durch überprüfen den neuen Status des Objekts, um festzustellen, ob es sich bei der erforderliche Zustand erreicht wurde.|  
|<xref:System.Threading.Monitor.Exit%2A>|Hebt die Sperre für ein Objekt. Diese Aktion werden auch das Ende eines kritischen Abschnitts von gesperrten Objekts geschützt werden.|  
  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], es gibt zwei Sätze von Überladungen für die <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.TryEnter%2A> Methoden. Hat eine Reihe von Überladungen einer `ref` (in c#) oder `ByRef` (in Visual Basic) <xref:System.Boolean> Parameter, die atomar, um festgelegt wird `true` , wenn die Sperre abgerufen wurde, auch wenn eine Ausnahme ausgelöst wird, wenn die Sperre abrufen,. Verwenden Sie diese Überladungen, wenn es wichtig ist, die Sperre in allen Fällen auch, wenn die Ressourcen, die die Sperre zu schützen, ist möglicherweise nicht in einem konsistenten Zustand.  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>Das Sperrobjekt  
 Die Monitor-Klasse besteht aus `static` (in c#) oder `Shared` (in Visual Basic) Methoden für ein Objekt, das Zugriff auf den kritischen Abschnitt steuert.  Die folgende Informationen werden für jedes synchronisierte Objekt verwaltet:  
  
-   Ein Verweis auf den Thread, der derzeit die Sperre enthält.  
  
-   Ein Verweis auf eine Warteschlange enthält die Threads, die die Sperre erhalten können.  
  
-   Ein Verweis auf einer Warteschlange, die die Threads enthält, die für die Benachrichtigung über eine Änderung in den Zustand des gesperrten Objekts warten.  
  
 <xref:System.Threading.Monitor> sperrt Objekte (d. h. Referenztypen), nicht Werttypen. Sie können einen Werttyp an <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> übergeben. Dieser wird jedoch für jeden Aufruf separat geschachtelt. Da jeder Aufruf ein separates Objekt erstellt, bedingt <xref:System.Threading.Monitor.Enter%2A> nie eine Blockierung, und der Code, den die Methode eigentlich schützen soll, wird nicht wirklich synchronisiert. Darüber hinaus unterscheiden sich das an <xref:System.Threading.Monitor.Exit%2A> und das an <xref:System.Threading.Monitor.Enter%2A> übergebene Objekt, sodass <xref:System.Threading.Monitor> eine <xref:System.Threading.SynchronizationLockException> mit der folgenden Meldung auslöst: "Die Objektsynchronisationsmethode wurde von einem nicht synchronisierten Codeblock aufgerufen."  
  
 Dieses Problem wird anhand des folgenden Beispiels veranschaulicht. Im Beispiel werden zehn Aufgaben gestartet, wobei jede lediglich 250 Millisekunden inaktiv ist. Anschließend aktualisiert jede Aufgabe eine Zählervariable, `nTasks`, die dazu vorgesehen ist, die Anzahl von Aufgaben zu zählen, die tatsächlich gestartet wurden und ausgeführt werden. Weil `nTasks` eine globale Variable ist, die von mehreren Aufgaben gleichzeitig aktualisiert werden kann, wird ein Monitor verwendet, um zu verhindern, dass die Variable gleichzeitig von mehreren Aufgaben geändert wird. Wie die Ausgabe des Beispiels zeigt, löst jede dieser Aufgaben jedoch eine <xref:System.Threading.SynchronizationLockException>-Ausnahme aus.  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 Jede Aufgabe löst eine <xref:System.Threading.SynchronizationLockException>-Ausnahme aus, weil die Variable `nTasks` gekapselt wird, bevor in jeder Aufgabe die <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>-Methode aufgerufen wird. Anders formuliert heißt das, bei jedem Methodenaufruf wird eine separate Variable übergeben, die unabhängig von den anderen ist. `nTasks` wird im Aufruf der <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>-Methode erneut gekapselt. Dadurch werden wiederum zehn neue gekapselte `nTasks`-Variablen erstellt, die unabhängig voneinander sind. Hinzu kommen die zehn gekapselten Variablen, die im Aufruf der <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>-Methode erstellt wurden. Die Ausnahme wird dann ausgelöst, weil im Code versucht wird, eine Sperre für eine neu erstellte Variable freizugeben, die zuvor nicht gesperrt wurde.  
  
 Wie das folgende Beispiel zeigt, können Sie eine Werttypvariable zwar vor dem Aufruf von <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> kapseln und dasselbe gekapselte Objekt an beide Methoden übergeben, diese Vorgehensweise bietet jedoch keinerlei Vorteile. Änderungen an der nicht gekapselten Variablen wirken sich nicht auf die gekapselte Kopie aus, und es ist nicht möglich, den Wert der gekapselten Kopie zu ändern.  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 Wenn Sie ein Objekt auf die Synchronisierung auswählen zu können, sollten Sie nur auf private oder interne Objekte sperren. Sperren auf externe Objekte möglicherweise in Deadlocks führen, da es sich bei nicht verknüpfte Code So sperren Sie für unterschiedliche Zwecke auf dieselben Objekte auswählen kann.  
  
 Beachten Sie, die Sie für ein Objekt in mehreren Anwendungsdomänen synchronisieren können, wenn das für die Sperre verwendete Objekt abgeleitet <xref:System.MarshalByRefObject>.  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>Der kritische Abschnitt  
 Verwenden der <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> Methoden, um den Anfang und Ende eines kritischen Abschnitts zu markieren.  
  
> [!NOTE]
>  Die Funktionalität von der <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> Methoden ist identisch mit derjenigen der [Sperre](~/docs/csharp/language-reference/keywords/lock-statement.md) -Anweisung in c# und die [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) -Anweisung in Visual Basic, außer dass die Sprachkonstrukte Wrap der <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> -methodenüberladung, und die <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> -Methode in einer `try`...`finally` Block, um sicherzustellen, dass der Monitor freigegeben wird.  
  
 Der kritische Abschnitt ist eine Reihe von zusammenhängenden Anweisungen, und klicken Sie dann auf Sperre, die von der <xref:System.Threading.Monitor.Enter%2A> Methode stellt sicher, dass nur ein einzelner Thread des eingeschlossenen Codes mit gesperrten Objekts ausführen kann. In diesem Fall wird empfohlen, dass Sie diesen Code in platzieren eine `try` blockieren, und platzieren Sie den Aufruf der <xref:System.Threading.Monitor.Exit%2A> -Methode in der ein `finally` Block. Dadurch ist sichergestellt, dass die Sperre aufgehoben wird, selbst wenn eine Ausnahme auftritt. Das folgende Codefragment veranschaulicht dieses Muster.  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 Diese Funktion wird normalerweise verwendet, um den Zugriff auf eine statische Methode oder Instanzmethode einer Klasse zu synchronisieren.  
  
 Ein kritischen Abschnitt eine gesamte Methode umfasst, kann das Sperre Gebäude erreicht werden, indem Sie platzieren die <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> für die Methode, und geben Sie die <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> Wert im Konstruktor der <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>. Wenn Sie dieses Attribut verwenden die <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> Methodenaufrufe sind nicht erforderlich. Das folgende Codefragment veranschaulicht dieses Muster:  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 Beachten Sie, dass das Attribut der aktuelle Thread die Sperre wird, bis die Methode zurückgibt. Wenn die Sperre früher aufgehoben werden kann, verwenden Sie die <xref:System.Threading.Monitor> Klasse, die C#- [Sperre](~/docs/csharp/language-reference/keywords/lock-statement.md) -Anweisung oder in der Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) Anweisung innerhalb der Methode anstatt des Attributs.  
  
 Es ist zwar möglich, für die <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> Anweisungen, die Sperren und ein bestimmtes Objekt Cross-Element und/oder release, dies wird nicht empfohlen.  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>Pulse "," PulseAll ", und warten  
 Sobald ein Thread die Sperre besitzt und hat den kritischen Abschnitt, die die Sperre geschützt, können sie Aufrufen der <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, und <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> Methoden.  
  
 Wenn der Thread, enthält die Sperraufrufe <xref:System.Threading.Monitor.Wait%2A>, die Sperre wird aufgehoben, und der Thread wird aus der Warteschlange über das synchronisierte Objekt hinzugefügt. Der erste Thread in die Warteschlange gegebenenfalls erfolgreich sperren, und gibt den kritischen Abschnitt. Der Thread wird von der Warteschlange verschoben, in die Warteschlange Wenn entweder die <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> (um verschoben zu werden, muss der Thread am Anfang der Warteschlange wird) oder die <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> Methode wird aufgerufen, durch den Thread, der die Sperre aufrechterhält. Die <xref:System.Threading.Monitor.Wait%2A> Methode gibt zurück, wenn der aufrufende Thread die Sperre erneut erhält.  
  
 Wenn der Thread, enthält die Sperraufrufe <xref:System.Threading.Monitor.Pulse%2A>, der Thread am Anfang der Warteschlange in die Warteschlange verschoben. Der Aufruf der <xref:System.Threading.Monitor.PulseAll%2A> Methode verschiebt alle Threads aus der Warteschlange, in die Warteschlange.  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>Monitore und Wait-handles  
 Es ist wichtig, beachten Sie den Unterschied zwischen der Verwendung von der <xref:System.Threading.Monitor> Klasse und <xref:System.Threading.WaitHandle> Objekte.  
  
-   Die <xref:System.Threading.Monitor> Klasse ist rein verwaltete, vollständig übertragbar und kann in Bezug auf die Anforderungen an die Betriebssystem-Ressourcen effizienter sein.  
  
-   <xref:System.Threading.WaitHandle>-Objekte repräsentieren Objekte des Betriebssystems, die in der Lage sind, ihre Ausführung zu unterbrechen und zu warten. Sie sind für die Synchronisierung zwischen verwaltetem und nicht verwaltetem Code von Nutzen und machen einige höhere Betriebssystemfunktionen verfügbar, z. B. die Fähigkeit, auf viele Objekte gleichzeitig zu warten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Monitor> Klasse zum Synchronisieren des Zugriffs auf eine einzelne Instanz von einem Zufallszahlengenerator, dargestellt durch die <xref:System.Random> Klasse. Das Beispiel erstellt die zehn Aufgaben, von die jede auf einem Threadpool-Thread asynchron ausgeführt wird. Jede Aufgabe 10.000 Zufallszahlen generiert, deren Durchschnitt berechnet und aktualisiert zwei auf Prozedurebene-Variablen, die eine laufende Summe der Anzahl von Zufallszahlen generiert und deren Summe zu gewährleisten. Nachdem alle Aufgaben ausgeführt haben, werden diese beiden Werte zum Berechnen des gesamtmittelwerts verwendet.  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 Da sie von jeder Aufgabe, die auf einem Threadpoolthread ausgeführt zugegriffen werden kann, der Zugriff auf die Variablen `total` und `n` muss ebenfalls synchronisiert werden. Die <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> Methode für diesen Zweck verwendet wird.  
  
 Das folgende Beispiel zeigt die kombinierte Verwendung der <xref:System.Threading.Monitor> Klasse (mit implementiert die `lock` oder `SyncLock` Sprachkonstrukt), wird die <xref:System.Threading.Interlocked> -Klasse, und die <xref:System.Threading.AutoResetEvent> Klasse. Im Beispiel werden zwei `internal`- (in C#) oder `Friend`-Klassen (in Visual Basic), `SyncResource` und `UnSyncResource`, definiert, die entsprechend synchronisierten und nicht synchronisierten Zugriff auf eine Ressource bereitstellen. Damit sichergestellt ist, dass der Unterschied zwischen dem synchronisierten und dem nicht synchronisierten Zugriff im Beispiel deutlich wird (was der Fall sein kann, wenn jeder Methodenaufruf schnell abgeschlossen wird), enthält die Methode eine zufällige Verzögerung: Für Threads, deren <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>-Eigenschaft einen geraden Wert hat, ruft die Methode die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>-Methode auf, um eine Verzögerung von 2.000 Millisekunden einzuführen. Weil die `SyncResource`-Klasse nicht öffentlich ist, löst keiner der Clientcodes eine Sperre für die synchronisierte Ressource aus, sondern die Sperre wird von der internen Klasse selbst ausgelöst. Dadurch wird verhindert, dass bösartiger Code eine Sperre für ein öffentliches Objekt auslöst.  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 Im Beispiel wird eine Variable, `numOps`, definiert, mit der die Anzahl von Threads festgelegt wird, die versuchen, auf die Ressource zuzugreifen. Der Anwendungsthread ruft die <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType>-Methode jeweils fünf Mal für synchronisierten und nicht synchronisierten Zugriff auf. Die <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType>-Methode hat einen einzigen Parameter: ein Delegat, der keine Parameter akzeptiert und keinen Wert zurückgibt. Für synchronisierten Zugriff und ruft die Methode die `SyncUpdateResource`Methode auf, für nicht synchronisierten Zugriff ruft sie die `UnSyncUpdateResource`-Methode auf. Nach jedem Satz von Methodenaufrufen, ruft der Anwendungsthread die [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) Methode, sodass, bis blockiert die <xref:System.Threading.AutoResetEvent> -Instanz signalisiert wird.  
  
 Bei jedem Aufruf der `SyncUpdateResource`-Methode wird die interne `SyncResource.Access`-Methode und dann die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>-Methode aufgerufen, um den `numOps`-Zähler zu dekrementieren. Die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Methode wird verwendet, um den Zähler verringert, da andernfalls Sie bestimmte nicht sein können, dass ein zweiter Thread den Wert zugreift, bevor Sie ein ersten Thread der dekrementierte Wert in der Variablen gespeichert wurde. Wenn die letzte Worker dekrementiert den Zähler auf 0 (null) synchronisiert, gibt an, dass alle synchronisierten Threads haben Zugriff auf die Ressource, die `SyncUpdateResource` Methodenaufrufe der <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> -Methode, die signalisiert den Hauptthread, um den Vorgang fortzusetzen die Ausführung.  
  
 Bei jedem Aufruf der `UnSyncUpdateResource`-Methode wird die interne `UnSyncResource.Access`-Methode und dann die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>-Methode aufgerufen, um den `numOps`-Zähler zu dekrementieren. Auch hier die <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> Methode wird verwendet, um die verringert des Zähler, um sicherzustellen, dass ein zweiter Thread nicht den Wert zugreift, bevor der dekrementierte Wert des ersten Threads auf die Variable zugewiesen wurde. Bei der letzten dekrementiert Worker nicht den Zähler auf 0 (null) synchronisierte, gibt an, dass keine weiteren synchronisierten Threads Zugriff auf die Ressource, müssen die `UnSyncUpdateResource` Methodenaufrufe der <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> -Methode, die signalisiert den Hauptthread die Ausführung fortsetzen .  
  
 Wie die Ausgabe des Beispiels zeigt, wird mit synchronisiertem Zugriff sichergestellt, dass der aufrufende Thread die geschützte Ressource beendet, bevor ein anderer Thread auf sie zugreifen kann. Jeder Thread wartet auf seinen Vorgänger. Andererseits, ohne die Sperre, wird die `UnSyncResource.Access`-Methode in der Reihenfolge aufgerufen, in der sie von Threads erreicht wird.  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">Threadingobjekte und -funktionen</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erhält eine exklusive Sperre für ein angegebenes Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Monitorsperre erhalten werden soll.</param>
        <summary>Erhält eine exklusive Sperre für das angegebene Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung `Enter` zum Abrufen der <xref:System.Threading.Monitor> für das Objekt, das als Parameter übergeben. Wenn ein anderer Thread ausgeführt wurde ein `Enter` für das Objekt aber noch nicht die entsprechenden ausgeführt wurde <xref:System.Threading.Monitor.Exit%2A>, der aktuelle Thread blockiert, bis der andere Thread das Objekt freigegeben. Es ist zulässig, dass im gleichen Thread Aufrufen `Enter` mehr als einmal ohne diese Blockierung jedoch eine gleiche Anzahl von `Exit` Aufrufe aufgerufen werden müssen, bevor Sie andere Threads warten auf das Objekt aufgehoben wird.  
  
 Verwendung <xref:System.Threading.Monitor> Sperren von Objekten (d. h. Referenztypen), nicht Werttypen. Wenn Sie eine Werttypvariable zum übergeben `Enter`, wird Sie als ein Objekt geschachtelt. Wenn Sie die gleiche Variable übergeben `Enter` in diesem Fall wird als separates Objekt geschachtelt werden, und der Thread nicht blockiert. In diesem Fall ist der Code, `Monitor` ist die Methode eigentlich schützen ist nicht geschützt. Wenn Sie außerdem die Variable übergeben `Exit`, noch ein anderes Objekt erstellt. Da das Objekt an übergeben `Exit` unterscheidet sich von der an übergebene Objekt `Enter`, `Monitor` löst <xref:System.Threading.SynchronizationLockException>. Weitere Informationen finden Sie unter dem Thema [Monitore](xref:System.Threading.Monitor).  
  
 <xref:System.Threading.Thread.Interrupt%2A> unterbrechen, können Threads, die darauf warten, geben einen `Monitor` für ein Objekt. Ein <xref:System.Threading.ThreadInterruptedException> ausgelöst.  
  
 Verwenden Sie eine C#- `try`...`finally` Block (`Try`...`Finally` in Visual Basic) stellen Sie sicher, dass den Monitor freigegeben wird, oder verwenden Sie die C#- `lock` Anweisung (`SyncLock` -Anweisung in Visual Basic), welche umschließt die <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> Methoden in einer `try`...`finally` Block.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `Enter`-Methode veranschaulicht.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, auf das gewartet werden soll.</param>
        <param name="lockTaken">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis. Die Eingabe muss <see langword="false" /> sein. Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />. Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.  
  
Hinweis   Wenn keine Ausnahme auftritt, ist die Ausgabe dieser Methode immer <see langword="true" />.</param>
        <summary>Erhält eine exklusive Sperre für das angegebene Objekt und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden `Enter` zum Abrufen der <xref:System.Threading.Monitor> für das Objekt übergeben, als die `obj` Parameter. Wenn ein anderer Thread ausgeführt wurde ein `Enter` für das Objekt aber noch nicht die entsprechenden ausgeführt wurde <xref:System.Threading.Monitor.Exit%2A>, der aktuelle Thread blockiert, bis der andere Thread das Objekt freigegeben. Es ist zulässig, dass im gleichen Thread Aufrufen `Enter` mehr als einmal ohne diese Blockierung jedoch eine gleiche Anzahl von `Exit` Aufrufe aufgerufen werden müssen, bevor Sie andere Threads warten auf das Objekt aufgehoben wird.  
  
 Wenn die Sperre nicht erstellt wurde, da eine Ausnahme ausgelöst wurde, wird die Variable angegeben, für die `lockTaken` -Parameter ist `false` nach diese Methode beendet. Dadurch wird das Programm in allen Fällen, um zu bestimmen, ob es erforderlich, um die Sperre aufzuheben ist. Wenn diese Methode zurückgibt, ohne eine Ausnahme auszulösen, wird die Variable angegeben, für die `lockTaken` Parameter ist immer `true`, und es ist nicht erforderlich, um sie zu testen.  
  
 Verwendung <xref:System.Threading.Monitor> Sperren von Objekten (d. h. Referenztypen), nicht Werttypen. Wenn Sie eine Werttypvariable zum übergeben `Enter`, wird Sie als ein Objekt geschachtelt. Wenn Sie die gleiche Variable übergeben `Enter` in diesem Fall wird als separates Objekt geschachtelt werden, und der Thread nicht blockiert. In diesem Fall ist der Code, `Monitor` ist die Methode eigentlich schützen ist nicht geschützt. Wenn Sie außerdem die Variable übergeben `Exit`, einem anderen Objekt erstellt. Da das Objekt an übergeben `Exit` unterscheidet sich von der an übergebene Objekt `Enter`, `Monitor` löst <xref:System.Threading.SynchronizationLockException>. Weitere Informationen finden Sie unter dem Thema [Monitore](xref:System.Threading.Monitor).  
  
 <xref:System.Threading.Thread.Interrupt%2A> unterbrechen, können Threads, die darauf warten, geben einen `Monitor` für ein Objekt. Ein <xref:System.Threading.ThreadInterruptedException> ausgelöst.  
  
   
  
## Examples  
 Der folgende Code zeigt das grundlegende Muster für die Verwendung der <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> -methodenüberladung. Diese Überladung legt immer den Wert der Variablen, die an die `ref` Parameter (`ByRef` in Visual Basic) `lockTaken`, auch wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Möglichkeit zum Testen ist, ob die Sperre sein veröffentlicht.  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, dessen Sperre aufgehoben werden soll.</param>
        <summary>Hebt eine exklusive Sperre für das angegebene Objekt auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der aufrufende Thread die Sperre besitzen muss, auf die `obj` Parameter. Wenn der aufrufende Thread die Sperre für das angegebene Objekt besitzt, hat eine gleiche Anzahl von `Exit` und <xref:System.Threading.Monitor.Enter%2A> für das Objekt aufgerufen wird, und klicken Sie dann die Sperre aufgehoben wird. Wenn der aufrufende Thread nicht aufgerufen hat `Exit` so oft wie `Enter`, die Sperre wird nicht aufgehoben.  
  
 Wenn die Sperre wird aufgehoben, und andere Threads befinden sich in die Warteschlange für das Objekt, ruft einer der Threads die Sperre. Wenn andere Threads in der Warteschlange darauf warten, der eine Sperre sind, sie werden nicht automatisch verschoben in die Warteschlange, wenn der Besitzer der Sperre ruft `Exit`. Aufrufen, um eine oder mehrere wartende Threads in die Warteschlange zu verschieben, <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> vor dem Aufrufen `Exit`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `Exit`-Methode veranschaulicht.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Der aktuelle Thread besitzt die Sperre für das angegebene Objekt nicht.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Das zu überprüfende Objekt.</param>
        <summary>Bestimmt, ob der aktuelle Thread die Sperre für das angegebene Objekt enthält.</summary>
        <returns><see langword="true" />, wenn der aktuelle Thread die Schreibsperre für <paramref name="obj" /> enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode funktioniert nur für Sperren, die aktiviert werden, mithilfe der Methoden von der <xref:System.Threading.Monitor> -Klasse oder durch die Verwendung der C#- `lock` -Anweisung oder die Visual Basic `SyncLock` -Anweisung, die mit implementiert werden <xref:System.Threading.Monitor>.  
  
 Verwenden Sie diese Methode mit den Diagnosetools, z. B. die <xref:System.Diagnostics.Debug.Assert%2A> Methode und die <xref:System.Diagnostics.Contracts.Contract> -Klasse, um Probleme mit Datenbanksperren zu debuggen, bei denen die <xref:System.Threading.Monitor> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LockContentionCount">
      <MemberSignature Language="C#" Value="public static long LockContentionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 LockContentionCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Monitor.LockContentionCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LockContentionCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long LockContentionCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LockContentionCount : int64" Usage="System.Threading.Monitor.LockContentionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, auf das ein Thread wartet.</param>
        <summary>Benachrichtigt einen Thread in der Warteschlange für abzuarbeitende Threads über eine Änderung am Zustand des gesperrten Objekts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur der aktuelle Besitzer der Sperre ein warten mit signalisieren kann `Pulse`.  
  
 Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um die nächsten Threads in der Zeile, für die Sperre zu signalisieren. Nach dem Empfang des Schritts, wird der wartende Thread in die Warteschlange verschoben. Wenn der Thread aufgerufen, die `Pulse` hebt die Sperre der nächste Thread in die Warteschlange (dies nicht unbedingt der Thread, der Impuls empfangen hat), ruft die Sperre.  
  
> [!IMPORTANT]
>  Die <xref:System.Threading.Monitor> -Klasse verwaltet nicht den Status Gibt an, dass die <xref:System.Threading.Monitor.Pulse%2A> -Methode aufgerufen wurde. Daher Aufrufen <xref:System.Threading.Monitor.Pulse%2A> Wenn keine Threads warten, den aufrufende Thread nächsten <xref:System.Threading.Monitor.Wait%2A> Blöcke wie <xref:System.Threading.Monitor.Pulse%2A> noch nicht aufgerufen wurde. Wenn zwei Threads verwenden <xref:System.Threading.Monitor.Pulse%2A> und <xref:System.Threading.Monitor.Wait%2A> interagieren, könnte dies zu einem Deadlock. Vergleichen Sie dies mit dem Verhalten von der <xref:System.Threading.AutoResetEvent> Klasse: Wenn Sie darauf hinweisen ein <xref:System.Threading.AutoResetEvent> durch Aufrufen der <xref:System.Threading.EventWaitHandle.Set%2A> -Methode, und es sind keine Threads warten, die <xref:System.Threading.AutoResetEvent> bleibt in einem signalisierten Zustand, bis ein Thread ruft <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, oder <xref:System.Threading.WaitHandle.WaitAll%2A>. Die <xref:System.Threading.AutoResetEvent> gibt den Thread frei, und in den nicht signalisierten Zustand zurück.  
  
 Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise, die einen Verweis auf den Thread, der derzeit enthält, die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält enthält, und einen Verweis auf die Warteschlange für abzuarbeitende, einschließlich der enthält die Threads, die für die Benachrichtigung über eine Änderung in den Zustand des Objekts darauf warten.  
  
 Die `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, und <xref:System.Threading.Monitor.Wait%2A> Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.  
  
 Mehrere Threads signalisiert werden, verwenden Sie die <xref:System.Threading.Monitor.PulseAll%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das den Impuls sendet.</param>
        <summary>Benachrichtigt alle wartenden Threads über eine Änderung am Zustand des Objekts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um alle Threads, die darauf warten, die Sperre für das Objekt zu signalisieren. Wenn das Signal gesendet wurde, werden den wartenden Threads in die Warteschlange verschoben. Wenn der Thread aufgerufen, die `PulseAll` hebt die Sperre der nächste Thread in die Warteschlange erfolgreich sperren.  
  
 Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise, die einen Verweis auf den Thread, der derzeit enthält, die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält enthält, und einen Verweis auf die Warteschlange für abzuarbeitende, einschließlich der enthält die Threads, die für die Benachrichtigung über eine Änderung in den Zustand des Objekts darauf warten.  
  
 Die <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, und <xref:System.Threading.Monitor.Wait%2A> Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.  
  
 Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode erklären, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.  
  
 Verwenden Sie einen einzelnen Thread signalisiert werden, die `Pulse` Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Sperre erhalten werden soll.</param>
        <summary>Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten.</summary>
        <returns><see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn erfolgreich, diese Methode eine exklusive Sperre für Ruft die `obj` Parameter. Diese Methode gibt sofort zurück, ob die Sperre verfügbar ist.  
  
 Diese Methode ähnelt <xref:System.Threading.Monitor.Enter%2A>, aber es wird nie blockiert den aktuellen Thread. Wenn der Thread kann nicht ohne Blockierung eingegeben haben, gibt die Methode `false,`.  
  
> [!NOTE]
>  Verwendung <xref:System.Threading.Monitor> Sperren von Objekten (d. h. Referenztypen), nicht Werttypen. Weitere Informationen finden Sie unter den <xref:System.Threading.Monitor> Artikel.  
  
 Um sicherzustellen, dass der Thread nicht auf den kritischen Abschnitt, sollten Sie untersuchen der Rückgabewert der Methode und führen Sie Code in einem kritischen Abschnitt nur, wenn der Rückgabewert ist `true`. Das folgende Codefragment zeigt das Muster zum Aufrufen dieser Methode verwendet wird. Beachten Sie, die Sie aufrufen sollten <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt frei, wenn eine Ausnahme auftritt.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die `TryEnter`-Methode verwenden.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Sperre erhalten werden soll.</param>
        <param name="lockTaken">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis. Die Eingabe muss <see langword="false" /> sein. Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />. Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</param>
        <summary>Versucht, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn erfolgreich, diese Methode eine exklusive Sperre für Ruft die `obj` Parameter. Diese Methode gibt sofort zurück, ob die Sperre verfügbar ist.  
  
 Wenn die Sperre nicht erstellt wurde, da eine Ausnahme ausgelöst wurde, wird die Variable angegeben, für die `lockTaken` -Parameter ist `false` nach diese Methode beendet. Dadurch wird das Programm in allen Fällen, um zu bestimmen, ob es erforderlich, um die Sperre aufzuheben ist.  
  
 Diese Methode ähnelt <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, aber es wird nie blockiert den aktuellen Thread. Wenn der Thread ohne Blockierung, eingeben kann nicht die `lockTaken` Argument nastaven NA hodnotu `false` bei Rückgabe der Methode.  
  
> [!NOTE]
>  Verwendung <xref:System.Threading.Monitor> Sperren von Objekten (d. h. Referenztypen), nicht Werttypen. Weitere Informationen finden Sie im Artikel <xref:System.Threading.Monitor>.  
  
 Um sicherzustellen, dass der Thread wird nicht den kritischen Abschnitt eingeben, sollten Sie untersuchen, den Wert der `lockTaken` und Ausführen von Code in einem kritischen Abschnitt nur, wenn der Wert ist `true`. Das folgende Codefragment zeigt das Muster zum Aufrufen dieser Methode verwendet wird. Beachten Sie, die Sie aufrufen sollten <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt frei, wenn eine Ausnahme auftritt.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 Der folgende Code zeigt das grundlegende Muster für die Verwendung der <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> -methodenüberladung. Diese Überladung legt immer den Wert der Variablen, die an die `ref` Parameter (`ByRef` in Visual Basic) `lockTaken`, auch wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Möglichkeit zum Testen ist, ob die Sperre sein veröffentlicht.  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Sperre erhalten werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl der Millisekunden, für die auf die Sperre gewartet werden soll.</param>
        <summary>Versucht über eine angegebene Anzahl von Millisekunden hinweg, eine exklusive Sperre für das angegebene Objekt zu erhalten.</summary>
        <returns><see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `millisecondsTimeout` entspricht <xref:System.Threading.Timeout.Infinite>, diese Methode entspricht dem <xref:System.Threading.Monitor.Enter%2A>. Wenn `millisecondsTimeout` gleich 0 ist, diese Methode entspricht <xref:System.Threading.Monitor.TryEnter%2A>.  
  
> [!NOTE]
>  Verwendung <xref:System.Threading.Monitor> Sperren von Objekten (d. h. Referenztypen), nicht Werttypen. Weitere Informationen finden Sie unter den <xref:System.Threading.Monitor> Artikel.  
  
 Um sicherzustellen, dass der Thread nicht auf den kritischen Abschnitt, sollten Sie untersuchen der Rückgabewert der Methode und führen Sie Code in einem kritischen Abschnitt nur, wenn der Rückgabewert ist `true`. Das folgende Codefragment zeigt das Muster zum Aufrufen dieser Methode verwendet wird. Beachten Sie, die Sie aufrufen sollten <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt frei, wenn eine Ausnahme auftritt.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Sperre erhalten werden soll.</param>
        <param name="timeout">Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne darstellt, für die auf die Sperre gewartet werden soll. Ein Wert von –1 Millisekunde gibt eine unbegrenzte Wartezeit an.</param>
        <summary>Versucht über einen angegebenen Zeitraum hinweg, eine exklusive Sperre für das angegebene Objekt zu erhalten.</summary>
        <returns><see langword="true" />, wenn der aktuelle Thread die Sperre erhält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert des der `timeout` Parameter, die in Millisekunden konvertiert gleich-1 ist, diese Methode entspricht dem <xref:System.Threading.Monitor.Enter%2A>. Wenn der Wert des `timeout` gleich 0 ist, diese Methode entspricht <xref:System.Threading.Monitor.TryEnter%2A>.  
  
> [!NOTE]
>  Verwendung <xref:System.Threading.Monitor> Sperren von Objekten (d. h. Referenztypen), nicht Werttypen. Weitere Informationen finden Sie unter den <xref:System.Threading.Monitor> Thema-Klasse.  
  
 Um sicherzustellen, dass der Thread nicht auf den kritischen Abschnitt, sollten Sie untersuchen der Rückgabewert der Methode und führen Sie Code in einem kritischen Abschnitt nur, wenn der Rückgabewert ist `true`. Das folgende Codefragment zeigt das Muster zum Aufrufen dieser Methode verwendet wird. Beachten Sie, die Sie aufrufen sollten <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt frei, wenn eine Ausnahme auftritt.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="timeout" /> in Millisekunden ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> (–1 Millisekunde) oder ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Sperre erhalten werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl der Millisekunden, für die auf die Sperre gewartet werden soll.</param>
        <param name="lockTaken">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis. Die Eingabe muss <see langword="false" /> sein. Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />. Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</param>
        <summary>Versucht für die angegebene Anzahl von Millisekunden, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `millisecondsTimeout` entspricht <xref:System.Threading.Timeout.Infinite>, diese Methode entspricht dem <xref:System.Threading.Monitor.Enter%28System.Object%29>. Wenn `millisecondsTimeout` gleich 0 ist, diese Methode entspricht <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  
  
 Wenn die Sperre nicht erstellt wurde, da eine Ausnahme ausgelöst wurde, wird die Variable angegeben, für die `lockTaken` -Parameter ist `false` nach diese Methode beendet. Dadurch wird das Programm in allen Fällen, um zu bestimmen, ob es erforderlich, um die Sperre aufzuheben ist.  
  
> [!NOTE]
>  Verwendung <xref:System.Threading.Monitor> Sperren von Objekten (d. h. Referenztypen), nicht Werttypen. Weitere Informationen finden Sie unter den <xref:System.Threading.Monitor> Thema-Klasse.  
  
 Um sicherzustellen, dass der Thread wird nicht den kritischen Abschnitt eingeben, sollten Sie untersuchen, den Wert der `lockTaken` und Ausführen von Code in einem kritischen Abschnitt nur, wenn der Wert ist `true`. Das folgende Codefragment zeigt das Muster zum Aufrufen dieser Methode verwendet wird. Beachten Sie, die Sie aufrufen sollten <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt frei, wenn eine Ausnahme auftritt.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 Der folgende Code zeigt das grundlegende Muster für die Verwendung der <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> -methodenüberladung. Diese Überladung legt immer den Wert der Variablen, die an die `ref` Parameter (`ByRef` in Visual Basic) `lockTaken`, auch wenn die Methode eine Ausnahme auslöst, sodass der Wert der Variablen eine zuverlässige Möglichkeit zum Testen ist, ob die Sperre sein veröffentlicht.  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das die Sperre erhalten werden soll.</param>
        <param name="timeout">Die Zeitspanne, für die auf die Sperre gewartet werden soll. Ein Wert von –1 Millisekunde gibt eine unbegrenzte Wartezeit an.</param>
        <param name="lockTaken">Das Ergebnis des Versuchs, die Sperre abzurufen, übergeben als Verweis. Die Eingabe muss <see langword="false" /> sein. Die Ausgabe ist <see langword="true" />, wenn die Sperre abgerufen wurde. Andernfalls ist die Ausgabe <see langword="false" />. Die Ausgabe wird auch dann festgelegt, wenn eine Ausnahme bei dem Versuch auftritt, die Sperre abzurufen.</param>
        <summary>Versucht für die angegebene Dauer, eine exklusive Sperre für das angegebene Objekt zu erhalten, und legt atomar einen Wert fest, der angibt, ob die Sperre angenommen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert des der `timeout` Parameter, die in Millisekunden konvertiert gleich-1 ist, diese Methode entspricht dem <xref:System.Threading.Monitor.Enter%28System.Object%29>. Wenn der Wert des `timeout` gleich 0 ist, diese Methode entspricht <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  
  
 Wenn die Sperre nicht erstellt wurde, da eine Ausnahme ausgelöst wurde, wird die Variable angegeben, für die `lockTaken` -Parameter ist `false` nach diese Methode beendet. Dadurch wird das Programm in allen Fällen, um zu bestimmen, ob es erforderlich, um die Sperre aufzuheben ist.  
  
> [!NOTE]
>  Verwendung <xref:System.Threading.Monitor> Sperren von Objekten (d. h. Referenztypen), nicht Werttypen. Weitere Informationen finden Sie unter den <xref:System.Threading.Monitor> Thema-Klasse.  
  
 Um sicherzustellen, dass der Thread wird nicht den kritischen Abschnitt eingeben, sollten Sie untersuchen, den Wert der `lockTaken` und Ausführen von Code in einem kritischen Abschnitt nur, wenn der Wert ist `true`. Das folgende Codefragment zeigt das Muster zum Aufrufen dieser Methode verwendet wird. Beachten Sie, die Sie aufrufen sollten <xref:System.Threading.Monitor.Exit%2A> in einer `finally` Block, um sicherzustellen, dass der aufrufende Thread die Sperre für den kritischen Abschnitt frei, wenn eine Ausnahme auftritt.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Eingabe für <paramref name="lockTaken" /> ist <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="timeout" /> in Millisekunden ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> (–1 Millisekunde) oder ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, auf das gewartet werden soll.</param>
        <summary>Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält.</summary>
        <returns><see langword="true" />, wenn der Aufruf beendet wurde, weil der Aufrufer die Sperre für das angegebene Objekt erneut erhalten hat. Diese Methode wird nicht beendet, wenn die Sperre nicht erneut erhalten wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freigeben, sodass ein anderer Thread darauf zugreifen kann. Der Aufrufer gesperrt, beim Warten auf die Sperre erneut abzurufen. Diese Methode wird aufgerufen, wenn der Aufrufer muss auf eine Zustandsänderung warten, die aufgrund von einem anderen Thread ausgeführt wird.  
  
 Wenn ein Thread ruft `Wait`, es hebt die Sperre für das Objekt und gibt das Objekt in der Warteschlange. Der nächste Thread in die Warteschlange des Objekts (sofern vorhanden), ruft Sie die Sperre und verfügt über die exklusive Verwendung des Objekts. Alle Threads, die aufgerufen werden `Wait` in der Warteschlange verbleiben, bis sie ein Signal von empfangen <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>, durch den Besitzer der Sperre gesendet. Wenn `Pulse` gesendet wird, wird nur der Thread am Anfang der Warteschlange für abzuarbeitende betroffen ist. Wenn `PulseAll` gesendet wird, werden alle Threads, die für das Objekt darauf warten, sind betroffen. Das Signal empfangen wird, ein oder mehrere Threads verlassen die Warteschlange und geben Sie die Warteschlange. Ein Thread in die Warteschlange ist zulässig, die Sperre erneut zu erhalten.  
  
 Diese Methode gibt zurück, wenn der aufrufende Thread die Sperre für das Objekt erneut erhält. Beachten Sie, die diese Methode wird auf unbestimmte Zeit blockiert, wenn der Besitzer der Sperre nicht aufruft `Pulse` oder `PulseAll`.  
  
 Der Aufrufer führt `Wait` , unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> wurde für das angegebene Objekt aufgerufen. Vom Konzept her der `Wait` Methode speichert die Anzahl der Aufrufe der Aufrufer `Enter` für das Objekt und ruft `Exit` so oft wie nötig, um vollständig gesperrten Objekts freizugeben. Der Aufrufer ist dann beim Warten auf das Objekt erneut blockiert. Wenn der Aufrufer die Sperre erneut erhält, das System ruft `Enter` so oft wie nötig, um die gespeicherten wiederherstellen `Enter` Anzahl für den Aufrufer. Aufrufen von `Wait` hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, diese Sperren werden nicht aufgehoben.  
  
 Beachten Sie, dass ein synchronisiertes Objekt mehrere Verweise, die einen Verweis auf den Thread, der derzeit enthält, die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält enthält, und einen Verweis auf die Warteschlange für abzuarbeitende, einschließlich der enthält die Threads, die für die Benachrichtigung über eine Änderung in den Zustand des Objekts darauf warten.  
  
 Die <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, und `Wait` Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.  
  
 Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode erklären, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen. Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, auf das gewartet werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</param>
        <summary>Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält. Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</summary>
        <returns><see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist. Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird nicht zurückgegeben, bis er eine exklusive Sperre auf erneut erhält die `obj` Parameter.  
  
 Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freigeben, sodass ein anderer Thread darauf zugreifen kann. Der Aufrufer gesperrt, beim Warten auf die Sperre erneut abzurufen. Diese Methode wird aufgerufen, wenn der Aufrufer muss auf eine Zustandsänderung warten, die aufgrund von einem anderen Thread ausgeführt wird.  
  
 Das Timeout stellt sicher, dass der aktuelle Thread nicht auf unbestimmte Zeit gesperrt wird, wenn ein anderer Thread die Sperre erst nach Aufrufen von der <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode. Er verschiebt außerdem den Thread auf die Warteschlange für abgearbeitete Threads in der Warteschlange, so, dass er die Sperre früher erneut abrufen kann. Der Thread kann den Rückgabewert von Testen der <xref:System.Threading.Monitor.Wait%2A> Methode, um zu bestimmen, ob er vor dem Timeout der Sperre. Der Thread kann die Bedingungen, die die Wartezeit, geben verursacht hat auswerten und, wenn erforderlichen Aufruf der <xref:System.Threading.Monitor.Wait%2A> -Methode erneut auf.  
  
 Wenn ein Thread ruft `Wait`, es hebt die Sperre für das Objekt und gibt das Objekt in der Warteschlange. Der nächste Thread in die Warteschlange des Objekts (sofern vorhanden), ruft Sie die Sperre und verfügt über die exklusive Verwendung des Objekts. Der Thread, der aufgerufen `Wait` bleibt in der Warteschlange warten, bis ein Thread, der die Sperre aufrechterhält ruft <xref:System.Threading.Monitor.PulseAll%2A>, oder es ist die nächste in der Warteschlange und ruft Sie ein Thread, der die Sperre aufrechterhält <xref:System.Threading.Monitor.Pulse%2A>. Aber wenn `millisecondsTimeout` verstreicht, bevor ein anderer Thread auf dieses Objekts ruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> der ursprüngliche Thread-Methode wird in die Warteschlange verschoben, um die Sperre erneut erhalten.  
  
> [!NOTE]
>  Wenn <xref:System.Threading.Timeout.Infinite> angegeben ist, für die `millisecondsTimeout` Parameter dieser Methode blockiert unbegrenzt, es sei denn, der Besitzer der Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>. Wenn `millisecondsTimeout` gleich 0 ist, der aufrufende Thread `Wait` hebt die Sperre, und wird sofort in die Warteschlange um die Sperre erneut erhalten.  
  
 Der Aufrufer führt `Wait` , unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> wurde für das angegebene Objekt aufgerufen. Vom Konzept her der `Wait` Methode speichert die Anzahl der Aufrufe der Aufrufer <xref:System.Threading.Monitor.Enter%2A> für das Objekt und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig, um vollständig gesperrten Objekts freizugeben. Der Aufrufer ist dann beim Warten auf das Objekt erneut blockiert. Wenn der Aufrufer die Sperre erneut erhält, das System ruft <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig, um die gespeicherten wiederherstellen <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer. Aufrufen von `Wait` hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, diese Sperren werden nicht aufgehoben.  
  
> [!NOTE]
>  Ein synchronisiertes Objekt enthält mehrere Verweise, darunter einen Verweis auf den Thread, der derzeit enthält, die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf der Warteschlange, enthält die Threads, die für die Benachrichtigung über eine Änderung in den Zustand des Objekts warten.  
  
 Die <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, und `Wait` Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.  
  
 Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode erklären, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen. Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert des <paramref name="millisecondsTimeout" />-Parameters ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, auf das gewartet werden soll.</param>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" />, der die Zeit angibt, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</param>
        <summary>Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält. Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein.</summary>
        <returns><see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist. Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird nicht zurückgegeben, bis er eine exklusive Sperre auf erneut erhält die `obj` Parameter.  
  
 Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freigeben, sodass ein anderer Thread darauf zugreifen kann. Der Aufrufer gesperrt, beim Warten auf die Sperre erneut abzurufen. Diese Methode wird aufgerufen, wenn der Aufrufer muss auf eine Zustandsänderung warten, die aufgrund von einem anderen Thread ausgeführt wird.  
  
 Das Timeout stellt sicher, dass der aktuelle Thread nicht auf unbestimmte Zeit gesperrt wird, wenn ein anderer Thread die Sperre erst nach Aufrufen von der <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode. Er verschiebt außerdem den Thread auf die Warteschlange für abgearbeitete Threads in der Warteschlange, so, dass er die Sperre früher erneut abrufen kann. Der Thread kann den Rückgabewert von Testen der <xref:System.Threading.Monitor.Wait%2A> Methode, um zu bestimmen, ob er vor dem Timeout der Sperre. Der Thread kann die Bedingungen, die die Wartezeit, geben verursacht hat auswerten und, wenn erforderlichen Aufruf der <xref:System.Threading.Monitor.Wait%2A> -Methode erneut auf.  
  
 Wenn ein Thread ruft `Wait`, es hebt die Sperre für das Objekt und gibt das Objekt in der Warteschlange. Der nächste Thread in die Warteschlange des Objekts (sofern vorhanden), ruft Sie die Sperre und verfügt über die exklusive Verwendung des Objekts. Der Thread, der aufgerufen `Wait` bleibt in der Warteschlange warten, bis ein Thread, der die Sperre aufrechterhält ruft <xref:System.Threading.Monitor.PulseAll%2A>, oder es ist die nächste in der Warteschlange und ruft Sie ein Thread, der die Sperre aufrechterhält <xref:System.Threading.Monitor.Pulse%2A>. Aber wenn `timeout` verstreicht, bevor ein anderer Thread auf dieses Objekts ruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> der ursprüngliche Thread-Methode wird in die Warteschlange verschoben, um die Sperre erneut erhalten.  
  
> [!NOTE]
>  Wenn eine <xref:System.TimeSpan> -1 Millisekunde angegeben ist, für die `timeout` Parameter dieser Methode blockiert unbegrenzt, es sei denn, der Besitzer der Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>. Wenn `timeout` ist 0 Millisekunden, der aufrufende Thread `Wait` hebt die Sperre, und wird sofort in die Warteschlange um die Sperre erneut erhalten.  
  
 Der Aufrufer führt `Wait` , unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> wurde für das angegebene Objekt aufgerufen. Vom Konzept her der `Wait` Methode speichert die Anzahl der Aufrufe der Aufrufer <xref:System.Threading.Monitor.Enter%2A> für das Objekt und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig, um vollständig gesperrten Objekts freizugeben. Der Aufrufer ist dann beim Warten auf das Objekt erneut blockiert. Wenn der Aufrufer die Sperre erneut erhält, das System ruft <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig, um die gespeicherten wiederherstellen <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer. Aufrufen von `Wait` hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, diese Sperren werden nicht aufgehoben.  
  
> [!NOTE]
>  Ein synchronisiertes Objekt enthält mehrere Verweise, darunter einen Verweis auf den Thread, der derzeit enthält, die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf der Warteschlange, enthält die Threads, die für die Benachrichtigung über eine Änderung in den Zustand des Objekts warten.  
  
 Die <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, und `Wait` Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.  
  
 Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode erklären, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Der aufrufende Thread besitzt keine Sperre für das angegebene Objekt.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen. Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert des <paramref name="timeout" />-Parameters in Millisekunden ist negativ und stellt nicht <see cref="F:System.Threading.Timeout.Infinite" /> (–1 Millisekunde) dar, oder er ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, auf das gewartet werden soll.</param>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</param>
        <param name="exitContext"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext (sofern ein synchronisierter Kontext vorliegt) vor dem Wartevorgang zu beenden und erneut zu erhalten, andernfalls <see langword="false" />.</param>
        <summary>Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält. Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein. Diese Methode gibt außerdem an, ob die Synchronisierungsdomäne danach für den Kontext (wenn es sich um einen synchronisierten Kontext handelt) vor dem Warten und erneuten Erhalten verlassen wird.</summary>
        <returns><see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist. Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird nicht zurückgegeben, bis er eine exklusive Sperre auf erneut erhält die `obj` Parameter.  
  
 Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freigeben, sodass ein anderer Thread darauf zugreifen kann. Der Aufrufer gesperrt, beim Warten auf die Sperre erneut abzurufen. Diese Methode wird aufgerufen, wenn der Aufrufer muss auf eine Zustandsänderung warten, die aufgrund von einem anderen Thread ausgeführt wird.  
  
 Das Timeout stellt sicher, dass der aktuelle Thread nicht auf unbestimmte Zeit gesperrt wird, wenn ein anderer Thread die Sperre erst nach Aufrufen von der <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode. Er verschiebt außerdem den Thread auf die Warteschlange für abgearbeitete Threads in der Warteschlange, so, dass er die Sperre früher erneut abrufen kann. Der Thread kann den Rückgabewert von Testen der <xref:System.Threading.Monitor.Wait%2A> Methode, um zu bestimmen, ob er vor dem Timeout der Sperre. Der Thread kann die Bedingungen, die die Wartezeit, geben verursacht hat auswerten und, wenn erforderlichen Aufruf der <xref:System.Threading.Monitor.Wait%2A> -Methode erneut auf.  
  
 Wenn ein Thread ruft `Wait`, es hebt die Sperre und die Warteschlange für abzuarbeitende eingibt. An diesem Punkt ist der nächste Thread in die Warteschlange (sofern vorhanden) zulässig, die Kontrolle über die Sperre zu übernehmen. Der Thread, der aufgerufen `Wait` bleibt in der Warteschlange warten, bis ein Thread, der die Sperre aufrechterhält ruft <xref:System.Threading.Monitor.PulseAll%2A>, oder es ist die nächste in der Warteschlange und ruft Sie ein Thread, der die Sperre aufrechterhält <xref:System.Threading.Monitor.Pulse%2A>. Aber wenn `millisecondsTimeout` verstreicht, bevor ein anderer Thread auf dieses Objekts ruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> der ursprüngliche Thread-Methode wird in die Warteschlange verschoben, um die Sperre erneut erhalten.  
  
> [!NOTE]
>  Wenn <xref:System.Threading.Timeout.Infinite> angegeben ist, für die `millisecondsTimeout` Parameter dieser Methode blockiert unbegrenzt, es sei denn, der Besitzer der Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>. Wenn `millisecondsTimeout` gleich 0 ist, der aufrufende Thread `Wait` hebt die Sperre, und wird sofort in die Warteschlange um die Sperre erneut erhalten.  
  
 Der Aufrufer führt `Wait` , unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> wurde für das angegebene Objekt aufgerufen. Vom Konzept her der `Wait` Methode speichert die Anzahl der Aufrufe der Aufrufer <xref:System.Threading.Monitor.Enter%2A> für das Objekt und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig, um vollständig gesperrten Objekts freizugeben. Der Aufrufer ist dann beim Warten auf das Objekt erneut blockiert. Wenn der Aufrufer die Sperre erneut erhält, das System ruft <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig, um die gespeicherten wiederherstellen <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer. Aufrufen von `Wait` hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, diese Sperren werden nicht aufgehoben.  
  
> [!NOTE]
>  Ein synchronisiertes Objekt enthält mehrere Verweise, darunter einen Verweis auf den Thread, der derzeit enthält, die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf der Warteschlange, enthält die Threads, die für die Benachrichtigung über eine Änderung in den Zustand des Objekts warten.  
  
 Die <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, und `Wait` Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.  
  
 Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode erklären, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Die`exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.Monitor.Wait%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird. Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>. Selbst wenn derzeit eine Methode einer Klasse ausgeführt wird, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.  
  
 Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.Monitor.Wait%2A> Methode. Nach dem Aufruf des ursprünglichen Kontexts der vom Standard abweichenden gibt die <xref:System.Threading.Monitor.Wait%2A> Methode abgeschlossen wird.  
  
 Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über die <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> -Attribut. In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse. Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.Monitor.Wait%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird. Wenn die <xref:System.Threading.Monitor.Wait%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" /> wird nicht aus einem synchronisierten Codeblock aufgerufen.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Der Thread, der <see langword="Wait" /> aufruft, wird später im Wartezustand unterbrochen. Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert des <paramref name="millisecondsTimeout" />-Parameters ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, auf das gewartet werden soll.</param>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" />, der die Zeit angibt, die gewartet wird, bevor der Thread in die Warteschlange für abgearbeitete Threads eintritt.</param>
        <param name="exitContext"><see langword="true" />, um die Synchronisierungsdomäne für den Kontext (sofern ein synchronisierter Kontext vorliegt) vor dem Wartevorgang zu beenden und erneut zu erhalten, andernfalls <see langword="false" />.</param>
        <summary>Hebt die Sperre für ein Objekt auf und blockiert den aktuellen Thread, bis er die Sperre erneut erhält. Wenn das angegebene Timeoutintervall abläuft, tritt der Thread in die Warteschlange für abgearbeitete Threads ein. Beendet vor dem Warten optional auch die Synchronisierungsdomäne für den synchronisierten Kontext und erhält die Domäne anschließend wieder.</summary>
        <returns><see langword="true" />, wenn die Sperre erneut erhalten wurde, bevor die angegebene Zeitspanne verstrichen ist. <see langword="false" />, wenn die Sperre erneut erhalten wurde, nachdem die angegebene Zeitspanne verstrichen ist. Die Methode wird erst beendet, wenn die Sperre erneut erhalten wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird nicht zurückgegeben, bis er eine exklusive Sperre auf erneut erhält die `obj` Parameter.  
  
 Der Thread, der derzeit im Besitz der Sperre für das angegebene Objekt ruft diese Methode, um das Objekt freigeben, sodass ein anderer Thread darauf zugreifen kann. Der Aufrufer gesperrt, beim Warten auf die Sperre erneut abzurufen. Diese Methode wird aufgerufen, wenn der Aufrufer muss auf eine Zustandsänderung warten, die aufgrund von einem anderen Thread ausgeführt wird.  
  
 Das Timeout stellt sicher, dass der aktuelle Thread nicht auf unbestimmte Zeit gesperrt wird, wenn ein anderer Thread die Sperre erst nach Aufrufen von der <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> Methode. Er verschiebt außerdem den Thread auf die Warteschlange für abgearbeitete Threads in der Warteschlange, so, dass er die Sperre früher erneut abrufen kann. Der Thread kann den Rückgabewert von Testen der <xref:System.Threading.Monitor.Wait%2A> Methode, um zu bestimmen, ob er vor dem Timeout der Sperre. Der Thread kann die Bedingungen, die die Wartezeit, geben verursacht hat auswerten und, wenn erforderlichen Aufruf der <xref:System.Threading.Monitor.Wait%2A> -Methode erneut auf.  
  
 Wenn ein Thread ruft `Wait`, es hebt die Sperre und die Warteschlange für abzuarbeitende eingibt. An diesem Punkt ist der nächste Thread in die Warteschlange (sofern vorhanden) zulässig, die Kontrolle über die Sperre zu übernehmen. Der Thread, der aufgerufen `Wait` bleibt in der Warteschlange warten, bis ein Thread, der die Sperre aufrechterhält ruft <xref:System.Threading.Monitor.PulseAll%2A>, oder es ist die nächste in der Warteschlange und ruft Sie ein Thread, der die Sperre aufrechterhält <xref:System.Threading.Monitor.Pulse%2A>. Aber wenn `timeout` Millisekunden ablaufen, bevor ein anderer Thread auf dieses Objekts ruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A> der ursprüngliche Thread-Methode wird in die Warteschlange verschoben, um die Sperre erneut erhalten.  
  
> [!NOTE]
>  Wenn eine <xref:System.TimeSpan> -1 Millisekunde angegeben ist, für die `timeout` Parameter dieser Methode blockiert unbegrenzt, es sei denn, der Besitzer der Sperre aufruft <xref:System.Threading.Monitor.Pulse%2A> oder <xref:System.Threading.Monitor.PulseAll%2A>. Wenn `timeout` ist 0 Millisekunden, der aufrufende Thread `Wait` hebt die Sperre, und wird sofort in die Warteschlange um die Sperre erneut erhalten.  
  
 Der Aufrufer führt `Wait` , unabhängig davon, wie oft <xref:System.Threading.Monitor.Enter%2A> wurde für das angegebene Objekt aufgerufen. Vom Konzept her der `Wait` Methode speichert die Anzahl der Aufrufe der Aufrufer <xref:System.Threading.Monitor.Enter%2A> für das Objekt und ruft <xref:System.Threading.Monitor.Exit%2A> so oft wie nötig, um vollständig gesperrten Objekts freizugeben. Der Aufrufer ist dann beim Warten auf das Objekt erneut blockiert. Wenn der Aufrufer die Sperre erneut erhält, das System ruft <xref:System.Threading.Monitor.Enter%2A> so oft wie nötig, um die gespeicherten wiederherstellen <xref:System.Threading.Monitor.Enter%2A> Anzahl für den Aufrufer. Aufrufen von `Wait` hebt die Sperre für das angegebene Objekt nur, wenn der Aufrufer Besitzer von Sperren auf andere Objekte ist, diese Sperren werden nicht aufgehoben.  
  
> [!NOTE]
>  Ein synchronisiertes Objekt enthält mehrere Verweise, darunter einen Verweis auf den Thread, der derzeit enthält, die Sperre, die einen Verweis auf die Warteschlange, die die Threads, die die Sperre erhalten können enthält, und einen Verweis auf der Warteschlange, enthält die Threads, die für die Benachrichtigung über eine Änderung in den Zustand des Objekts warten.  
  
 Die <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, und `Wait` Methoden aus einem synchronisierten Codeblock aufgerufen werden müssen.  
  
 Die Hinweise für die <xref:System.Threading.Monitor.Pulse%2A> Methode erklären, was geschieht, wenn <xref:System.Threading.Monitor.Pulse%2A> wird aufgerufen, wenn keine Threads warten.  
  
## <a name="notes-on-exiting-the-context"></a>Hinweise zum Beenden des Kontexts  
 Die`exitContext` Parameter hat keine Auswirkungen, es sei denn, die <xref:System.Threading.Monitor.Wait%2A> Methode aus, in einem nicht standardmäßigen verwalteten Kontext aufgerufen wird. Dies kann auftreten, wenn der Thread in einem Aufruf an eine Instanz einer Klasse abgeleitet ist <xref:System.ContextBoundObject>. Selbst wenn derzeit eine Methode einer Klasse ausgeführt wird, die nicht von abgeleitet ist <xref:System.ContextBoundObject>, z. B. <xref:System.String>, werden in einem nicht standardmäßigen Kontext Wenn eine <xref:System.ContextBoundObject> ist auf dem Stapel in der aktuellen Anwendungsdomäne.  
  
 Angeben, wenn der Code in einem nicht standardmäßigen Kontext ausgeführt wird, `true` für `exitContext` bewirkt, dass den Thread, der vom Standard abweichenden verwalteten Kontext zu beenden (d. h. für den Übergang in den Standardkontext) vor dem Ausführen der <xref:System.Threading.Monitor.Wait%2A> Methode. Nach dem Aufruf des ursprünglichen Kontexts der vom Standard abweichenden gibt die <xref:System.Threading.Monitor.Wait%2A> Methode abgeschlossen wird.  
  
 Dies kann nützlich sein, wenn die kontextgebundene Klasse verfügt über die <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> -Attribut. In diesem Fall werden alle Aufrufe von Membern der Klasse werden automatisch synchronisiert, und die Synchronisierungsdomäne ist die Kernstruktur des Codes für die Klasse. Wenn Code in der Aufrufliste eines Elements aufgerufen der <xref:System.Threading.Monitor.Wait%2A> Methode und gibt `true` für `exitContext`, der Thread beendet wird, die Synchronisierungsdomäne, sodass einen Thread, der bei einem Aufruf auf einen Member des Objekts, um den Vorgang fortzusetzen, blockiert wird. Wenn die <xref:System.Threading.Monitor.Wait%2A> Methode zurückgegeben wird, der Thread, der der Aufruf erfolgt, muss mit dem die Synchronisierungsdomäne warten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="obj" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" /> wird nicht aus einem synchronisierten Codeblock aufgerufen.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Der Thread, der „Wait“ aufruft, wird später im Wartezustand unterbrochen. Dies geschieht, wenn ein anderer Thread die <see cref="M:System.Threading.Thread.Interrupt" />-Methode dieses Threads aufruft.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="timeout" />-Parameter ist negativ und stellt nicht <see cref="F:System.Threading.Timeout.Infinite" /> dar (–1 Millisekunde), oder er ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Verwaltetes Threading</related>
      </Docs>
    </Member>
  </Members>
</Type>